#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# GAMADV-XTD3
#
# Copyright 2020, All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""GAMADV-XTD3 is a command line tool which allows Administrators to control their G Suite domain and accounts.

For more information, see https://github.com/taers232c/GAMADV-XTD3
"""

__author__ = 'Ross Scroggs <ross.scroggs@gmail.com>'
__version__ = '5.12.06'
__license__ = 'Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)'

import base64
import calendar as calendarlib
import codecs
import collections
import configparser
import csv
import datetime
from email.charset import add_charset, QP
from email.generator import Generator
from email.header import decode_header, Header
from email.mime.application import MIMEApplication
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import formatdate
import hashlib
from html.entities import name2codepoint
from html.parser import HTMLParser
import http.client as http_client
import io
import json
import logging
import mimetypes
import multiprocessing
import os
import platform
import queue
import random
import re
from secrets import SystemRandom
import shlex
import signal
import smtplib
import ssl
import string
import struct
import subprocess
import sys
from tempfile import TemporaryFile
import threading
import time
from traceback import print_exc
from urllib.parse import quote, unquote, urlencode, urlparse
import uuid
import webbrowser
import zipfile

from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID

from filelock import FileLock

from gamlib import glaction
from gamlib import glapi as API
from gamlib import glcfg as GC
from gamlib import glclargs
from gamlib import glentity
from gamlib import glgapi as GAPI
from gamlib import glgcp as GCP
from gamlib import glgdata as GDATA
from gamlib import glglobals as GM
from gamlib import glindent
from gamlib import glmsgs as Msg
from gamlib import glskus as SKU
from gamlib import gluprop as UProp

import atom
import gdata.apps.audit.service
import gdata.apps.service
import gdata.apps.contacts
import gdata.apps.contacts.service
import gdata.apps.sites
import gdata.apps.sites.service
import googleapiclient
import googleapiclient.discovery
import googleapiclient.errors
import googleapiclient.http
import google.oauth2.credentials
import google.oauth2.id_token
import google.oauth2.service_account
import google_auth_oauthlib.flow
import google_auth_httplib2
import httplib2
from iso8601 import iso8601
if platform.system() == 'Windows':
  # No crypt module on Win, use passlib
  from passlib.hash import sha512_crypt
else:
  from crypt import crypt

if platform.system() == 'Linux':
  import distro

def ISOformatTimeStamp(timestamp):
  return timestamp.isoformat('T', 'seconds')

def currentISOformatTimeStamp(timespec='milliseconds'):
  return datetime.datetime.now(GC.Values[GC.TIMEZONE]).isoformat('T', timespec)

Act = glaction.GamAction()
Cmd = glclargs.GamCLArgs()
Ent = glentity.GamEntity()
Ind = glindent.GamIndent()

# Finding path method varies between Python source, PyInstaller and StaticX
if os.environ.get('STATICX_PROG_PATH', False):
  # StaticX static executable
  GM.Globals[GM.GAM_PATH] = os.path.dirname(os.environ['STATICX_PROG_PATH'])
  GM.Globals[GM.GAM_TYPE] = 'staticx'
elif getattr(sys, 'frozen', False):
  # Pyinstaller executable
  GM.Globals[GM.GAM_PATH] = os.path.dirname(sys.executable)
  GM.Globals[GM.GAM_TYPE] = 'pyinstaller'
else:
  # Source code
  GM.Globals[GM.GAM_PATH] = os.path.dirname(os.path.realpath(__file__))
  GM.Globals[GM.GAM_TYPE] = 'pythonsource'

GIT_USER = 'taers232c'
GAM = 'GAMADV-XTD3'
GAM_URL = f'https://github.com/{GIT_USER}/{GAM}'
GAM_USER_AGENT = (f'{GAM} {__version__} - {GAM_URL} / '
                  f'{__author__} / '
                  f'Python {sys.version_info[0]}.{sys.version_info[1]}.{sys.version_info[2]} {sys.version_info[3]} / '
                  f'{platform.platform()} {platform.machine()} /'
                  )
GAM_RELEASES = f'https://github.com/{GIT_USER}/{GAM}/releases'
GAM_WIKI = f'https://github.com/{GIT_USER}/{GAM}/wiki'
GAM_LATEST_RELEASE = f'https://api.github.com/repos/{GIT_USER}/{GAM}/releases/latest'

TRUE = 'true'
FALSE = 'false'
TRUE_VALUES = [TRUE, 'on', 'yes', 'enabled', '1']
FALSE_VALUES = [FALSE, 'off', 'no', 'disabled', '0']
TRUE_FALSE = [TRUE, FALSE]
ERROR = 'ERROR'
ERROR_PREFIX = ERROR+': '
WARNING = 'WARNING'
WARNING_PREFIX = WARNING+': '
ONE_KILO_10_BYTES = 1000
ONE_MEGA_10_BYTES = 1000000
ONE_GIGA_10_BYTES = 1000000000
ONE_KILO_BYTES = 1024
ONE_MEGA_BYTES = 1048576
ONE_GIGA_BYTES = 1073741824
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 3600
SECONDS_PER_DAY = 86400
SECONDS_PER_WEEK = 604800
MAX_GOOGLE_SHEET_CELLS = 5000000 # See https://support.google.com/drive/answer/37603
MAX_LOCAL_GOOGLE_TIME_OFFSET = 30
UTF8 = 'utf-8'
UTF8_SIG = 'utf-8-sig'
FN_GAM_CFG = 'gam.cfg'
FN_LAST_UPDATE_CHECK_TXT = 'lastupdatecheck.txt'
FN_GAMCOMMANDS_TXT = 'GamCommands.txt'
FN_GAM_OAUTH_URL_TXT = 'gamoauthurl.txt'
FN_GAM_SVCACCT_URL_TXT = 'gamsvcaccturl.txt'
MY_DRIVE = 'My Drive'
TEAM_DRIVE = 'Drive'
ROOT = 'root'
ORPHANS = 'Orphans'
SHARED_WITHME = 'SharedWithMe'
SHARED_DRIVES = 'SharedDrives'

LOWERNUMERIC_CHARS = string.ascii_lowercase+string.digits
ALPHANUMERIC_CHARS = LOWERNUMERIC_CHARS+string.ascii_uppercase
URL_SAFE_CHARS = ALPHANUMERIC_CHARS+'-._~'
PASSWORD_SAFE_CHARS = ALPHANUMERIC_CHARS+'!#$%&()* -./:;<=>?@[\\]^_{|}~'
FILENAME_SAFE_CHARS = ALPHANUMERIC_CHARS+'-_.() '
ADMIN_ACCESS_OPTIONS = {'adminaccess', 'asadmin'}

# Python 3 values
DEFAULT_CSV_READ_MODE = 'r'
DEFAULT_FILE_APPEND_MODE = 'a'
DEFAULT_FILE_READ_MODE = 'r'
DEFAULT_FILE_WRITE_MODE = 'w'

# Google API constants
APPLICATION_VND_GOOGLE_APPS = 'application/vnd.google-apps.'
MIMETYPE_GA_DOCUMENT = APPLICATION_VND_GOOGLE_APPS+'document'
MIMETYPE_GA_DRAWING = APPLICATION_VND_GOOGLE_APPS+'drawing'
MIMETYPE_GA_FILE = APPLICATION_VND_GOOGLE_APPS+'file'
MIMETYPE_GA_FOLDER = APPLICATION_VND_GOOGLE_APPS+'folder'
MIMETYPE_GA_FORM = APPLICATION_VND_GOOGLE_APPS+'form'
MIMETYPE_GA_FUSIONTABLE = APPLICATION_VND_GOOGLE_APPS+'fusiontable'
MIMETYPE_GA_MAP = APPLICATION_VND_GOOGLE_APPS+'map'
MIMETYPE_GA_PRESENTATION = APPLICATION_VND_GOOGLE_APPS+'presentation'
MIMETYPE_GA_SCRIPT = APPLICATION_VND_GOOGLE_APPS+'script'
MIMETYPE_GA_SHORTCUT = APPLICATION_VND_GOOGLE_APPS+'shortcut'
MIMETYPE_GA_3P_SHORTCUT = APPLICATION_VND_GOOGLE_APPS+'drive-sdk'
MIMETYPE_GA_SITE = APPLICATION_VND_GOOGLE_APPS+'site'
MIMETYPE_GA_SPREADSHEET = APPLICATION_VND_GOOGLE_APPS+'spreadsheet'
MIMETYPE_TEXT_HTML = 'text/html'
MIMETYPE_TEXT_PLAIN = 'text/plain'

GOOGLE_NAMESERVERS = ['8.8.8.8', '8.8.4.4']
NEVER_DATE = '1970-01-01'
NEVER_DATETIME = '1970-01-01 00:00'
NEVER_TIME = '1970-01-01T00:00:00.000Z'
NEVER_TIME_NOMS = '1970-01-01T00:00:00Z'
NEVER_END_DATE = '1969-12-31'
NEVER_START_DATE = NEVER_DATE
PROJECTION_CHOICE_MAP = {'basic': 'BASIC', 'full': 'FULL'}
REFRESH_EXPIRY = '1970-01-01T00:00:01Z'
REPLACE_GROUP_PATTERN = re.compile(r'\\(\d+)')

# Queries
ME_IN_OWNERS = "'me' in owners"
ME_IN_OWNERS_AND = ME_IN_OWNERS+" and "
AND_ME_IN_OWNERS = " and "+ME_IN_OWNERS
NOT_ME_IN_OWNERS = "not "+ME_IN_OWNERS
NOT_ME_IN_OWNERS_AND = NOT_ME_IN_OWNERS+" and "
AND_NOT_ME_IN_OWNERS = " and "+NOT_ME_IN_OWNERS
ANY_FOLDERS = "mimeType = '"+MIMETYPE_GA_FOLDER+"'"
MY_FOLDERS = ME_IN_OWNERS_AND+ANY_FOLDERS
NON_TRASHED = "trashed = false"
WITH_PARENTS = "'{0}' in parents"
ANY_NON_TRASHED_WITH_PARENTS = "trashed = false and '{0}' in parents"
ANY_NON_TRASHED_FOLDER_NAME = "mimeType = '"+MIMETYPE_GA_FOLDER+"' and name = '{0}' and trashed = false"
MY_NON_TRASHED_FOLDER_NAME = ME_IN_OWNERS_AND+ANY_NON_TRASHED_FOLDER_NAME
MY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS = ME_IN_OWNERS_AND+"mimeType = '"+MIMETYPE_GA_FOLDER+"' and name = '{0}' and trashed = false and '{1}' in parents"
WITH_ANY_FILE_NAME = "name = '{0}'"
WITH_MY_FILE_NAME = ME_IN_OWNERS_AND+WITH_ANY_FILE_NAME
WITH_OTHER_FILE_NAME = NOT_ME_IN_OWNERS_AND+WITH_ANY_FILE_NAME
AND_NOT_SHORTCUT = " and mimeType != '"+MIMETYPE_GA_SHORTCUT+"'"

# Cloudprint
CLOUDPRINT_ACCESS_URL = 'https://www.google.com/cloudprint/addpublicprinter.html?printerid={0}&key={1}'
#
DFA_CREATED_TIME = 'createdTime'
DFA_MODIFIED_TIME = 'modifiedTime'
DFA_PRESERVE_FILE_TIMES = 'preserveFileTimes'
DFA_IGNORE_DEFAULT_VISIBILITY = 'ignoreDefaultVisibility'
DFA_KEEP_REVISION_FOREVER = 'keepRevisionForever'
DFA_LOCALFILEPATH = 'localFilepath'
DFA_LOCALFILENAME = 'localFilename'
DFA_LOCALMIMETYPE = 'localMimeType'
DFA_OCRLANGUAGE = 'ocrLanguage'
DFA_ENFORCE_SINGLE_PARENT = 'enforceSingleParent'
DFA_PARENTID = 'parentId'
DFA_PARENTQUERY = 'parentQuery'
DFA_ADD_PARENT_IDS = 'addParentIds'
DFA_ADD_PARENT_NAMES = 'addParentNames'
DFA_REMOVE_PARENT_IDS = 'removeParentIds'
DFA_REMOVE_PARENT_NAMES = 'removeParentNames'
DFA_TEAMDRIVE_PARENT = 'teamDriveParent'
DFA_TEAMDRIVE_PARENTID = 'teamDriveParentId'
DFA_TEAMDRIVE_PARENTQUERY = 'teamDriveParentQuery'
DFA_KWARGS = 'kwargs'
DFA_SEARCHARGS = 'searchargs'
DFA_USE_CONTENT_AS_INDEXABLE_TEXT = 'useContentAsIndexableText'
# Program return codes
UNKNOWN_ERROR_RC = 1
USAGE_ERROR_RC = 2
SOCKET_ERROR_RC = 3
GOOGLE_API_ERROR_RC = 4
NETWORK_ERROR_RC = 5
FILE_ERROR_RC = 6
MEMORY_ERROR_RC = 7
KEYBOARD_INTERRUPT_RC = 8
HTTP_ERROR_RC = 9
SCOPES_NOT_AUTHORIZED_RC = 10
DATA_ERROR_RC = 11
API_ACCESS_DENIED_RC = 12
CONFIG_ERROR_RC = 13
SYSTEM_ERROR_RC = 14
NO_SCOPES_FOR_API_RC = 15
CLIENT_SECRETS_JSON_REQUIRED_RC = 16
OAUTH2SERVICE_JSON_REQUIRED_RC = 16
OAUTH2_TXT_REQUIRED_RC = 16
INVALID_JSON_RC = 17
JSON_ALREADY_EXISTS_RC = 17
AUTHENTICATION_TOKEN_REFRESH_ERROR_RC = 18
HARD_ERROR_RC = 19
# Information
ENTITY_IS_A_USER_RC = 20
ENTITY_IS_A_USER_ALIAS_RC = 21
ENTITY_IS_A_GROUP_RC = 22
ENTITY_IS_A_GROUP_ALIAS_RC = 23
ORPHANS_COLLECTED_RC = 30
# Warnings/Errors
ACTION_FAILED_RC = 50
ACTION_NOT_PERFORMED_RC = 51
INVALID_ENTITY_RC = 52
BAD_REQUEST_RC = 53
ENTITY_IS_NOT_UNIQUE_RC = 54
DATA_NOT_AVALIABLE_RC = 55
ENTITY_DOES_NOT_EXIST_RC = 56
ENTITY_DUPLICATE_RC = 57
ENTITY_IS_NOT_AN_ALIAS_RC = 58
ENTITY_IS_UKNOWN_RC = 59
NO_ENTITIES_FOUND = 60
INVALID_DOMAIN_RC = 61
INVALID_DOMAIN_VALUE_RC = 62
INVALID_TOKEN_RC = 63
JSON_LOADS_ERROR_RC = 64
MULTIPLE_DELETED_USERS_FOUND_RC = 65
MULTIPLE_PROJECT_FOLDERS_FOUND_RC = 65
INSUFFICIENT_PERMISSIONS_RC = 67
REQUEST_COMPLETED_NO_RESULTS_RC = 71
REQUEST_NOT_COMPLETED_RC = 72
SERVICE_NOT_APPLICABLE_RC = 73
TARGET_DRIVE_SPACE_ERROR_RC = 74
USER_REQUIRED_TO_CHANGE_PASSWORD_ERROR_RC = 75
USER_SUSPENDED_ERROR_RC = 76
#
def escapeCRsNLs(value):
  return value.replace('\r', '\\r').replace('\n', '\\n')

def unescapeCRsNLs(value):
  return value.replace('\\r', '\r').replace('\\n', '\n')

def executeBatch(dbatch):
  dbatch.execute()
  if GC.Values[GC.INTER_BATCH_WAIT] > 0:
    time.sleep(GC.Values[GC.INTER_BATCH_WAIT])

def StringIOobject(initbuff=None):
  if initbuff is None:
    return io.StringIO()
  return io.StringIO(initbuff)

def systemErrorExit(sysRC, message):
  if message:
    stderrErrorMsg(message)
  sys.exit(sysRC)

def readStdin(prompt):
  return input(prompt)

def writeStdout(data):
  try:
    GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def flushStdout():
  try:
    GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout).flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def writeStderr(data):
  flushStdout()
  try:
    GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr).write(data)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

def flushStderr():
  try:
    GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr).flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)

class _DeHTMLParser(HTMLParser): #pylint: disable=abstract-method
  def __init__(self):
    HTMLParser.__init__(self)
    self.__text = []

  def handle_data(self, data):
    self.__text.append(data)

  def handle_charref(self, name):
    self.__text.append(chr(int(name[1:], 16)) if name.startswith('x') else chr(int(name)))

  def handle_entityref(self, name):
    cp = name2codepoint.get(name)
    if cp:
      self.__text.append(chr(cp))
    else:
      self.__text.append('&'+name)

  def handle_starttag(self, tag, attrs):
    if tag == 'p':
      self.__text.append('\n\n')
    elif tag == 'br':
      self.__text.append('\n')
    elif tag == 'a':
      for attr in attrs:
        if attr[0] == 'href':
          self.__text.append(f'({attr[1]}) ')
          break
    elif tag == 'div':
      if not attrs:
        self.__text.append('\n')
    elif tag in {'http:', 'https'}:
      self.__text.append(f' ({tag}//{attrs[0][0]}) ')

  def handle_startendtag(self, tag, attrs):
    if tag == 'br':
      self.__text.append('\n\n')

  def text(self):
    return re.sub(r'\n{2}\n+', '\n\n', re.sub(r'\n +', '\n', ''.join(self.__text))).strip()

def dehtml(text):
  parser = _DeHTMLParser()
  parser.feed(str(text))
  parser.close()
  return parser.text()

def currentCount(i, count):
  return f' ({i}/{count})' if (count > GC.Values[GC.SHOW_COUNTS_MIN]) else ''

def currentCountNL(i, count):
  return f' ({i}/{count})\n' if (count > GC.Values[GC.SHOW_COUNTS_MIN]) else '\n'

# Format a key value list
#   key, value	-> "key: value" + ", " if not last item
#   key, ''	-> "key:" + ", " if not last item
#   key, None	-> "key" + " " if not last item
def formatKeyValueList(prefixStr, kvList, suffixStr):
  msg = prefixStr
  i = 0
  l = len(kvList)
  while i < l:
    if isinstance(kvList[i], (bool, float, int)):
      msg += str(kvList[i])
    else:
      msg += kvList[i]
    i += 1
    if i < l:
      val = kvList[i]
      if (val is not None) or (i == l-1):
        msg += ':'
        if (val is not None) and (not isinstance(val, str) or val):
          msg += ' '
          if isinstance(val, (bool, float, int)):
            msg += str(val)
          else:
            msg += val
        i += 1
        if i < l:
          msg += ', '
      else:
        i += 1
        if i < l:
          msg += ' '
  msg += suffixStr
  return msg

# Error exits
def setSysExitRC(sysRC):
  GM.Globals[GM.SYSEXITRC] = sysRC

def printErrorMessage(sysRC, message):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Ind.Spaces(), [ERROR, message], '\n'))

def stderrErrorMsg(message):
  writeStderr(f'\n{ERROR_PREFIX}{message}\n')

def stderrWarningMsg(message):
  writeStderr(f'\n{WARNING_PREFIX}{message}\n')

# Something's wrong with CustomerID
def accessErrorMessage(cd):
  try:
    callGAPI(cd.customers(), 'get',
             throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerKey=GC.Values[GC.CUSTOMER_ID], fields='id')
  except GAPI.badRequest:
    return formatKeyValueList('',
                              [Ent.Singular(Ent.CUSTOMER_ID), GC.Values[GC.CUSTOMER_ID],
                               Msg.INVALID],
                              '')
  except GAPI.resourceNotFound:
    return formatKeyValueList('',
                              [Ent.Singular(Ent.CUSTOMER_ID), GC.Values[GC.CUSTOMER_ID],
                               Msg.DOES_NOT_EXIST],
                              '')
  except GAPI.forbidden:
    return formatKeyValueList('',
                              Ent.FormatEntityValueList([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID],
                                                         Ent.DOMAIN, GC.Values[GC.DOMAIN],
                                                         Ent.USER, GM.Globals[GM.ADMIN]])+[Msg.ACCESS_FORBIDDEN],
                              '')
  return None

def accessErrorExit(cd):
  systemErrorExit(INVALID_DOMAIN_RC, accessErrorMessage(cd or buildGAPIObject(API.DIRECTORY)))

def ClientAPIAccessDeniedExit():
  stderrErrorMsg(Msg.API_ACCESS_DENIED)
  missingScopes = API.getClientScopesSet(GM.Globals[GM.CURRENT_CLIENT_API])-GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]
  if missingScopes:
    writeStderr(Msg.API_CHECK_CLIENT_AUTHORIZATION.format(GM.Globals[GM.OAUTH2_CLIENT_ID],
                                                          ','.join(sorted(missingScopes))))
  systemErrorExit(API_ACCESS_DENIED_RC, None)

def SvcAcctAPIAccessDeniedExit():
  if GM.Globals[GM.CURRENT_SVCACCT_API] == API.GMAIL and GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES][0] == API.GMAIL_SEND_SCOPE:
    systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, Msg.NO_SVCACCT_ACCESS_ALLOWED)
  stderrErrorMsg(Msg.API_ACCESS_DENIED)
  apiOrScopes = API.getAPIName(GM.Globals[GM.CURRENT_SVCACCT_API]) if GM.Globals[GM.CURRENT_SVCACCT_API] else ','.join(sorted(GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES]))
  writeStderr(Msg.API_CHECK_SVCACCT_AUTHORIZATION.format(GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID],
                                                         apiOrScopes,
                                                         GM.Globals[GM.CURRENT_SVCACCT_USER]))
  systemErrorExit(API_ACCESS_DENIED_RC, None)

def APIAccessDeniedExit():
  if not GM.Globals[GM.CURRENT_SVCACCT_USER] and GM.Globals[GM.CURRENT_CLIENT_API]:
    ClientAPIAccessDeniedExit()
  if GM.Globals[GM.CURRENT_SVCACCT_API]:
    SvcAcctAPIAccessDeniedExit()
  systemErrorExit(API_ACCESS_DENIED_RC, Msg.API_ACCESS_DENIED)

def checkEntityDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityDoesNotExistWarning(entityType, entityName, i, count)

def checkEntityAFDNEorAccessErrorExit(cd, entityType, entityName, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName], Msg.DOES_NOT_EXIST, i, count)

def checkEntityItemValueAFDNEorAccessErrorExit(cd, entityType, entityName, itemType, itemValue, i=0, count=0):
  message = accessErrorMessage(cd)
  if message:
    systemErrorExit(INVALID_DOMAIN_RC, message)
  entityActionFailedWarning([entityType, entityName, itemType, itemValue], Msg.DOES_NOT_EXIST, i, count)

def invalidClientSecretsJsonExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.CLIENT_SECRETS_JSON_FILE), GC.Values[GC.CLIENT_SECRETS_JSON]))
  writeStderr(Msg.INSTRUCTIONS_CLIENT_SECRETS_JSON)
  systemErrorExit(CLIENT_SECRETS_JSON_REQUIRED_RC, None)

def invalidOauth2serviceJsonExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.OAUTH2SERVICE_JSON_FILE), GC.Values[GC.OAUTH2SERVICE_JSON]))
  writeStderr(Msg.INSTRUCTIONS_OAUTH2SERVICE_JSON)
  systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, None)

def invalidOauth2TxtExit():
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.OAUTH2_TXT_FILE), GC.Values[GC.OAUTH2_TXT]))
  writeStderr(Msg.EXECUTE_GAM_OAUTH_CREATE)
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def expiredRevokedOauth2TxtExit():
  stderrErrorMsg(Msg.IS_EXPIRED_OR_REVOKED.format(Ent.Singular(Ent.OAUTH2_TXT_FILE), GC.Values[GC.OAUTH2_TXT]))
  writeStderr(Msg.EXECUTE_GAM_OAUTH_CREATE)
  systemErrorExit(OAUTH2_TXT_REQUIRED_RC, None)

def invalidDiscoveryJsonExit(fileName):
  stderrErrorMsg(Msg.DOES_NOT_EXIST_OR_HAS_INVALID_FORMAT.format(Ent.Singular(Ent.DISCOVERY_JSON_FILE), fileName))
  systemErrorExit(INVALID_JSON_RC, None)

def entityActionFailedExit(entityValueList, errMsg, i=0, count=0):
  systemErrorExit(ACTION_FAILED_RC, formatKeyValueList(Ind.Spaces(),
                                                       Ent.FormatEntityValueList(entityValueList)+[Act.Failed(), errMsg],
                                                       currentCountNL(i, count)))

def entityDoesNotExistExit(entityType, entityName, i=0, count=0, errMsg=None):
  Cmd.Backup()
  writeStderr(Cmd.CommandLineWithBadArgumentMarked(False))
  systemErrorExit(ENTITY_DOES_NOT_EXIST_RC, formatKeyValueList(Ind.Spaces(),
                                                               [Ent.Singular(entityType), entityName, errMsg or Msg.DOES_NOT_EXIST],
                                                               currentCountNL(i, count)))

def entityDoesNotHaveItemExit(entityValueList, i=0, count=0):
  Cmd.Backup()
  writeStderr(Cmd.CommandLineWithBadArgumentMarked(False))
  systemErrorExit(ENTITY_DOES_NOT_EXIST_RC, formatKeyValueList(Ind.Spaces(),
                                                               Ent.FormatEntityValueList(entityValueList)+[Msg.DOES_NOT_EXIST],
                                                               currentCountNL(i, count)))

def entityIsNotUniqueExit(entityType, entityName, valueType, valueList, i=0, count=0):
  Cmd.Backup()
  writeStderr(Cmd.CommandLineWithBadArgumentMarked(False))
  systemErrorExit(ENTITY_IS_NOT_UNIQUE_RC, formatKeyValueList(Ind.Spaces(),
                                                              [Ent.Singular(entityType), entityName, Msg.IS_NOT_UNIQUE.format(Ent.Plural(valueType), ','.join(valueList))],
                                                              currentCountNL(i, count)))

def usageErrorExit(message, extraneous=False):
  writeStderr(Cmd.CommandLineWithBadArgumentMarked(extraneous))
  stderrErrorMsg(message)
  writeStderr(Msg.HELP_SYNTAX.format(os.path.join(GM.Globals[GM.GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStderr(Msg.HELP_WIKI.format(GAM_WIKI))
  sys.exit(USAGE_ERROR_RC)

def csvFieldErrorExit(fieldName, fieldNames, backupArg=False, checkForCharset=False):
  if backupArg:
    Cmd.Backup()
    if checkForCharset and Cmd.Previous() == 'charset':
      Cmd.Backup()
      Cmd.Backup()
  usageErrorExit(Msg.HEADER_NOT_FOUND_IN_CSV_HEADERS.format(fieldName, ','.join(fieldNames)))

def csvDataAlreadySavedErrorExit():
  Cmd.Backup()
  usageErrorExit(Msg.CSV_DATA_ALREADY_SAVED)

# The last thing shown is unknown
def unknownArgumentExit():
  Cmd.Backup()
  usageErrorExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1])

# Argument describes what's expected
def expectedArgumentExit(problem, argument):
  usageErrorExit(f'{problem}: {Msg.EXPECTED} <{argument}>')

def blankArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_BLANK][1], f'{Msg.NON_BLANK} {argument}')

def emptyArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_EMPTY][1], f'{Msg.NON_EMPTY} {argument}')

def invalidArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1], argument)

def missingArgumentExit(argument):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_MISSING][1], argument)

def deprecatedArgument(argument):
  Cmd.Backup()
  writeStderr(Cmd.CommandLineWithBadArgumentMarked(False))
  Cmd.Advance()
  stderrWarningMsg(f'{Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_DEPRECATED][1]}: {Msg.IGNORED} <{argument}>')

# Choices is the valid set of choices that was expected
def formatChoiceList(choices):
  choiceList = [c if c else "''" for c in choices]
  if len(choiceList) <= 5:
    return '|'.join(choiceList)
  return '|'.join(sorted(choiceList))

def invalidChoiceExit(choice, choices, backupArg):
  if backupArg:
    Cmd.Backup()
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID_CHOICE][1].format(choice), formatChoiceList(choices))

def missingChoiceExit(choices):
  expectedArgumentExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_MISSING][1], formatChoiceList(choices))

# Check if argument present
def checkArgumentPresent(choices, required=False):
  choiceList = choices if isinstance(choices, (list, set)) else [choices]
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower().replace('_', '')
    if choice:
      if choice in choiceList:
        Cmd.Advance()
        return True
    if not required:
      return False
    invalidChoiceExit(choice, choiceList, False)
  elif not required:
    return False
  missingChoiceExit(choiceList)

# Check that there are no extraneous arguments at the end of the command line
def checkForExtraneousArguments():
  if Cmd.ArgumentsRemaining():
    usageErrorExit(Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_EXTRANEOUS][[1, 0][Cmd.MultipleArgumentsRemaining()]], extraneous=True)

# Get an argument, downshift, delete underscores
def getArgument():
  if Cmd.ArgumentsRemaining():
    argument = Cmd.Current().lower()
    if argument:
      Cmd.Advance()
      return argument.replace('_', '')
  missingArgumentExit(Cmd.OB_ARGUMENT)

def getBoolean(defaultValue=True):
  if Cmd.ArgumentsRemaining():
    boolean = Cmd.Current().strip().lower()
    if boolean in TRUE_VALUES:
      Cmd.Advance()
      return True
    if boolean in FALSE_VALUES:
      Cmd.Advance()
      return False
    if defaultValue is not None:
      return defaultValue
    invalidChoiceExit(boolean, TRUE_FALSE, False)
  if defaultValue is not None:
    return defaultValue
  missingChoiceExit(TRUE_FALSE)

def getCharSet():
  if checkArgumentPresent('charset'):
    return getString(Cmd.OB_CHAR_SET)
  return GC.Values[GC.CHARSET]

DEFAULT_CHOICE = 'defaultChoice'
CHOICE_ALIASES = 'choiceAliases'
MAP_CHOICE = 'mapChoice'
NO_DEFAULT = 'NoDefault'

def getChoice(choices, **opts):
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower()
    if choice or '' in choices:
      if choice in opts.get(CHOICE_ALIASES, []):
        choice = opts[CHOICE_ALIASES][choice]
      if choice not in choices:
        choice = choice.replace('_', '').replace('-', '')
        if choice in opts.get(CHOICE_ALIASES, []):
          choice = opts[CHOICE_ALIASES][choice]
      if choice in choices:
        Cmd.Advance()
        return choice if not opts.get(MAP_CHOICE, False) else choices[choice]
    if opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
      return opts[DEFAULT_CHOICE]
    invalidChoiceExit(choice, choices, False)
  elif opts.get(DEFAULT_CHOICE, NO_DEFAULT) != NO_DEFAULT:
    return opts[DEFAULT_CHOICE]
  missingChoiceExit(choices)

def getChoiceAndValue(item, choices, delimiter):
  if not Cmd.ArgumentsRemaining() or Cmd.Current().find(delimiter) == -1:
    return (None, None)
  choice, value = Cmd.Current().strip().split(delimiter, 1)
  choice = choice.strip().lower()
  value = value.strip()
  if choice in choices:
    if value:
      Cmd.Advance()
      return (choice, value)
    missingArgumentExit(item)
  invalidChoiceExit(choice, choices, False)

CALENDAR_COLOR_MAP = {
  'amethyst': 24, 'avocado': 10, 'banana': 12, 'basil': 8, 'birch': 20, 'blueberry': 16,
  'cherryblossom': 22, 'citron': 11, 'cobalt': 15, 'cocoa': 1, 'eucalyptus': 7, 'flamingo': 2,
  'grape': 23, 'graphite': 19, 'lavender': 17, 'mango': 6, 'peacock': 14, 'pistachio': 9,
  'pumpkin': 5, 'radicchio': 21, 'sage': 13, 'tangerine': 4, 'tomato': 3, 'wisteria': 18,
  }

CALENDAR_EVENT_COLOR_MAP = {
  'banana': 5, 'basil': 10, 'blueberry': 9, 'flamingo': 4, 'graphite': 8, 'grape': 3,
  'lavender': 1, 'peacock': 7, 'sage': 2, 'tangerine': 6, 'tomato': 11,
  }

GOOGLE_COLOR_MAP = {
  'asparagus': '#7bd148', 'bluevelvet': '#9a9cff', 'bubblegum': '#f691b2', 'cardinal': '#f83a22',
  'chocolateicecream': '#ac725e', 'denim': '#9fc6e7', 'desertsand': '#fbe983', 'earthworm': '#cca6ac',
  'macaroni': '#fad165', 'marsorange': '#ff7537', 'mountaingray': '#cabdbf', 'mountaingrey': '#cabdbf',
  'mouse': '#8f8f8f', 'oldbrickred': '#d06b64', 'pool': '#9fe1e7', 'purpledino': '#b99aff',
  'purplerain': '#cd74e6', 'rainysky': '#4986e7', 'seafoam': '#92e1c0', 'slimegreen': '#b3dc6c',
  'spearmint': '#42d692', 'toyeggplant': '#a47ae2', 'vernfern': '#16a765', 'wildstrawberries': '#fa573c',
  'yellowcab': '#ffad46',
  }

WEB_COLOR_MAP = {
  'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4',
  'azure': '#f0ffff', 'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000',
  'blanchedalmond': '#ffebcd', 'blue': '#0000ff', 'blueviolet': '#8a2be2', 'brown': '#a52a2a',
  'burlywood': '#deb887', 'cadetblue': '#5f9ea0', 'chartreuse': '#7fff00', 'chocolate': '#d2691e',
  'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c',
  'cyan': '#00ffff', 'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b',
  'darkgray': '#a9a9a9', 'darkgrey': '#a9a9a9', 'darkgreen': '#006400', 'darkkhaki': '#bdb76b',
  'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f', 'darkorange': '#ff8c00', 'darkorchid': '#9932cc',
  'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f', 'darkslateblue': '#483d8b',
  'darkslategray': '#2f4f4f', 'darkslategrey': '#2f4f4f', 'darkturquoise': '#00ced1', 'darkviolet': '#9400d3',
  'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dimgrey': '#696969',
  'dodgerblue': '#1e90ff', 'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22',
  'fuchsia': '#ff00ff', 'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700',
  'goldenrod': '#daa520', 'gray': '#808080', 'grey': '#808080', 'green': '#008000',
  'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred': '#cd5c5c',
  'indigo': '#4b0082', 'ivory': '#fffff0', 'khaki': '#f0e68c', 'lavender': '#e6e6fa',
  'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd', 'lightblue': '#add8e6',
  'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2', 'lightgray': '#d3d3d3',
  'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a',
  'lightseagreen': '#20b2aa', 'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightslategrey': '#778899',
  'lightsteelblue': '#b0c4de', 'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32',
  'linen': '#faf0e6', 'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa',
  'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3', 'mediumpurple': '#9370db', 'mediumseagreen': '#3cb371',
  'mediumslateblue': '#7b68ee', 'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585',
  'midnightblue': '#191970', 'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5',
  'navajowhite': '#ffdead', 'navy': '#000080', 'oldlace': '#fdf5e6', 'olive': '#808000',
  'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500', 'orchid': '#da70d6',
  'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#db7093',
  'papayawhip': '#ffefd5', 'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb',
  'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080', 'red': '#ff0000',
  'rosybrown': '#bc8f8f', 'royalblue': '#4169e1', 'saddlebrown': '#8b4513', 'salmon': '#fa8072',
  'sandybrown': '#f4a460', 'seagreen': '#2e8b57', 'seashell': '#fff5ee', 'sienna': '#a0522d',
  'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090',
  'slategrey': '#708090', 'snow': '#fffafa', 'springgreen': '#00ff7f', 'steelblue': '#4682b4',
  'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347',
  'turquoise': '#40e0d0', 'violet': '#ee82ee', 'wheat': '#f5deb3', 'white': '#ffffff',
  'whitesmoke': '#f5f5f5', 'yellow': '#ffff00', 'yellowgreen': '#9acd32',
  }

COLORHEX_PATTERN = re.compile(r'^#[0-9a-fA-F]{6}$')
COLORHEX_FORMAT_REQUIRED = 'ColorName|ColorHex'

def getColor():
  if Cmd.ArgumentsRemaining():
    color = Cmd.Current().strip().lower()
    if color in GOOGLE_COLOR_MAP:
      Cmd.Advance()
      return GOOGLE_COLOR_MAP[color]
    if color in WEB_COLOR_MAP:
      Cmd.Advance()
      return WEB_COLOR_MAP[color]
    tg = COLORHEX_PATTERN.match(color)
    if tg:
      Cmd.Advance()
      return tg.group(0)
    invalidArgumentExit(COLORHEX_FORMAT_REQUIRED)
  missingArgumentExit(COLORHEX_FORMAT_REQUIRED)

LABEL_COLORS = [
  '#000000', '#076239', '#0b804b', '#149e60', '#16a766', '#1a764d', '#1c4587', '#285bac',
  '#2a9c68', '#3c78d8', '#3dc789', '#41236d', '#434343', '#43d692', '#44b984', '#4a86e8',
  '#653e9b', '#666666', '#68dfa9', '#6d9eeb', '#822111', '#83334c', '#89d3b2', '#8e63ce',
  '#999999', '#a0eac9', '#a46a21', '#a479e2', '#a4c2f4', '#aa8831', '#ac2b16', '#b65775',
  '#b694e8', '#b9e4d0', '#c6f3de', '#c9daf8', '#cc3a21', '#cccccc', '#cf8933', '#d0bcf1',
  '#d5ae49', '#e07798', '#e4d7f5', '#e66550', '#eaa041', '#efa093', '#efefef', '#f2c960',
  '#f3f3f3', '#f691b3', '#f6c5be', '#f7a7c0', '#fad165', '#fb4c2f', '#fbc8d9', '#fcda83',
  '#fcdee8', '#fce8b3', '#fef1d1', '#ffad47', '#ffbc6b', '#ffd6a2', '#ffe6c7', '#ffffff',
  ]

def getLabelColor():
  if Cmd.ArgumentsRemaining():
    color = Cmd.Current().strip().lower()
    tg = COLORHEX_PATTERN.match(color)
    if tg:
      color = tg.group(0)
      if color in LABEL_COLORS:
        Cmd.Advance()
        return color
    invalidArgumentExit('|'.join(LABEL_COLORS))
  missingArgumentExit(Cmd.OB_LABEL_COLOR_HEX)

# Valid language codes
LANGUAGE_CODES_MAP = {
  'ach': 'ach', 'af': 'af', 'ag': 'ga', 'ak': 'ak', 'am': 'am', 'ar': 'ar', 'az': 'az', #Luo, Afrikaans, Irish, Akan, Amharic, Arabica, Azerbaijani
  'be': 'be', 'bem': 'bem', 'bg': 'bg', 'bn': 'bn', 'br': 'br', 'bs': 'bs', 'ca': 'ca', #Belarusian, Bemba, Bulgarian, Bengali, Breton, Bosnian, Catalan
  'chr': 'chr', 'ckb': 'ckb', 'co': 'co', 'crs': 'crs', 'cs': 'cs', 'cy': 'cy', 'da': 'da', #Cherokee, Kurdish (Sorani), Corsican, Seychellois Creole, Czech, Welsh, Danish
  'de': 'de', 'ee': 'ee', 'el': 'el', 'en': 'en', 'en-gb': 'en-GB', 'en-us': 'en-US', 'eo': 'eo', #German, Ewe, Greek, English, English (UK), English (US), Esperanto
  'es': 'es', 'es-419': 'es-419', 'et': 'et', 'eu': 'eu', 'fa': 'fa', 'fi': 'fi', 'fil': 'fil', 'fo': 'fo', #Spanish, Spanish (Latin American), Estonian, Basque, Persian, Finnish, Filipino, Faroese
  'fr': 'fr', 'fr-ca': 'fr-CA', 'fy': 'fy', 'ga': 'ga', 'gaa': 'gaa', 'gd': 'gd', 'gl': 'gl', #French, French (Canada), Frisian, Irish, Ga, Scots Gaelic, Galician
  'gn': 'gn', 'gu': 'gu', 'ha': 'ha', 'haw': 'haw', 'he': 'he', 'hi': 'hi', 'hr': 'hr', #Guarani, Gujarati, Hausa, Hawaiian, Hebrew, Hindi, Croatian
  'ht': 'ht', 'hu': 'hu', 'hy': 'hy', 'ia': 'ia', 'id': 'id', 'ig': 'ig', 'in': 'in', #Haitian Creole, Hungarian, Armenian, Interlingua, Indonesian, Igbo, in
  'is': 'is', 'it': 'it', 'iw': 'iw', 'ja': 'ja', 'jw': 'jw', 'ka': 'ka', 'kg': 'kg', #Icelandic, Italian, Hebrew, Japanese, Javanese, Georgian, Kongo
  'kk': 'kk', 'km': 'km', 'kn': 'kn', 'ko': 'ko', 'kri': 'kri', 'k': 'k', 'ky': 'ky', #Kazakh, Khmer, Kannada, Korean, Krio (Sierra Leone), Kurdish, Kyrgyz
  'la': 'la', 'lg': 'lg', 'ln': 'ln', 'lo': 'lo', 'loz': 'loz', 'lt': 'lt', 'lua': 'lua', #Latin, Luganda, Lingala, Laothian, Lozi, Lithuanian, Tshiluba
  'lv': 'lv', 'mfe': 'mfe', 'mg': 'mg', 'mi': 'mi', 'mk': 'mk', 'ml': 'ml', 'mn': 'mn', #Latvian, Mauritian Creole, Malagasy, Maori, Macedonian, Malayalam, Mongolian
  'mo': 'mo', 'mr': 'mr', 'ms': 'ms', 'mt': 'mt', 'my': 'my', 'ne': 'ne', 'nl': 'nl', #Moldavian, Marathi, Malay, Maltese, Burmese, Nepali, Dutch
  'nn': 'nn', 'no': 'no', 'nso': 'nso', 'ny': 'ny', 'nyn': 'nyn', 'oc': 'oc', 'om': 'om', #Norwegian (Nynorsk), Norwegian, Northern Sotho, Chichewa, Runyakitara, Occitan, Oromo
  'or': 'or', 'pa': 'pa', 'pcm': 'pcm', 'pl': 'pl', 'ps': 'ps', 'pt-br': 'pt-BR', 'pt-pt': 'pt-PT', #Oriya, Punjabi, Nigerian Pidgin, Polish, Pashto, Portuguese (Brazil), Portuguese (Portugal)
  'q': 'q', 'rm': 'rm', 'rn': 'rn', 'ro': 'ro', 'ru': 'ru', 'rw': 'rw', 'sd': 'sd', #Quechua, Romansh, Kirundi, Romanian, Russian, Kinyarwanda, Sindhi
  'sh': 'sh', 'si': 'si', 'sk': 'sk', 'sl': 'sl', 'sn': 'sn', 'so': 'so', 'sq': 'sq', #Serbo-Croatian, Sinhalese, Slovak, Slovenian, Shona, Somali, Albanian
  'sr': 'sr', 'sr-me': 'sr-ME', 'st': 'st', 'su': 'su', 'sv': 'sv', 'sw': 'sw', 'ta': 'ta', #Serbian, Montenegrin, Sesotho, Sundanese, Swedish, Swahili, Tamil
  'te': 'te', 'tg': 'tg', 'th': 'th', 'ti': 'ti', 'tk': 'tk', 'tl': 'tl', 'tn': 'tn', #Telugu, Tajik, Thai, Tigrinya, Turkmen, Tagalog, Setswana
  'to': 'to', 'tr': 'tr', 'tt': 'tt', 'tum': 'tum', 'tw': 'tw', 'ug': 'ug', 'uk': 'uk', #Tonga, Turkish, Tatar, Tumbuka, Twi, Uighur, Ukrainian
  'ur': 'ur', 'uz': 'uz', 'vi': 'vi', 'wo': 'wo', 'xh': 'xh', 'yi': 'yi', 'yo': 'yo', #Urdu, Uzbek, Vietnamese, Wolof, Xhosa, Yiddish, Yoruba
  'zh-cn': 'zh-CN', 'zh-hk': 'zh-HK', 'zh-tw': 'zh-TW', 'zu': 'zu', #Chinese (Simplified), Chinese (Hong Kong/Traditional), Chinese (Taiwan/Traditional), Zulu
  }

def getLanguageCode():
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower().replace('_', '-')
    if choice in LANGUAGE_CODES_MAP:
      Cmd.Advance()
      return LANGUAGE_CODES_MAP[choice]
    invalidChoiceExit(choice, LANGUAGE_CODES_MAP, False)
  missingChoiceExit(LANGUAGE_CODES_MAP)

LOCALE_CODES_MAP = {
  '': '',
  'ar_eg': 'ar_EG', #Arabic, Egypt
  'az_az': 'az_AZ', #Azerbaijani, Azerbaijan
  'be_by': 'be_BY', #Belarusian, Belarus
  'bg_bg': 'bg_BG', #Bulgarian, Bulgaria
  'bn_in': 'bn_IN', #Bengali, India
  'ca_es': 'ca_ES', #Catalan, Spain
  'cs_cz': 'cs_CZ', #Czech, Czech Republic
  'cy_gb': 'cy_GB', #Welsh, United Kingdom
  'da_dk': 'da_DK', #Danish, Denmark
  'de_ch': 'de_CH', #German, Switzerland
  'de_de': 'de_DE', #German, Germany
  'el_gr': 'el_GR', #Greek, Greece
  'en_au': 'en_AU', #English, Australia
  'en_ca': 'en_CA', #English, Canada
  'en_gb': 'en_GB', #English, United Kingdom
  'en_ie': 'en_IE', #English, Ireland
  'en_us': 'en_US', #English, U.S.A.
  'es_ar': 'es_AR', #Spanish, Argentina
  'es_bo': 'es_BO', #Spanish, Bolivia
  'es_cl': 'es_CL', #Spanish, Chile
  'es_co': 'es_CO', #Spanish, Colombia
  'es_ec': 'es_EC', #Spanish, Ecuador
  'es_es': 'es_ES', #Spanish, Spain
  'es_mx': 'es_MX', #Spanish, Mexico
  'es_py': 'es_PY', #Spanish, Paraguay
  'es_uy': 'es_UY', #Spanish, Uruguay
  'es_ve': 'es_VE', #Spanish, Venezuela
  'fi_fi': 'fi_FI', #Finnish, Finland
  'fil_ph': 'fil_PH', #Filipino, Philippines
  'fr_ca': 'fr_CA', #French, Canada
  'fr_fr': 'fr_FR', #French, France
  'gu_in': 'gu_IN', #Gujarati, India
  'hi_in': 'hi_IN', #Hindi, India
  'hr_hr': 'hr_HR', #Croatian, Croatia
  'hu_hu': 'hu_HU', #Hungarian, Hungary
  'hy_am': 'hy_AM', #Armenian, Armenia
  'in_id': 'in_ID', #Indonesian, Indonesia
  'it_it': 'it_IT', #Italian, Italy
  'iw_il': 'iw_IL', #Hebrew, Israel
  'ja_jp': 'ja_JP', #Japanese, Japan
  'ka_ge': 'ka_GE', #Georgian, Georgia
  'kk_kz': 'kk_KZ', #Kazakh, Kazakhstan
  'kn_in': 'kn_IN', #Kannada, India
  'ko_kr': 'ko_KR', #Korean, Korea
  'lt_lt': 'lt_LT', #Lithuanian, Lithuania
  'lv_lv': 'lv_LV', #Latvian, Latvia
  'ml_in': 'ml_IN', #Malayalam, India
  'mn_mn': 'mn_MN', #Mongolian, Mongolia
  'mr_in': 'mr_IN', #Marathi, India
  'my_mn': 'my_MN', #Burmese, Myanmar
  'nl_nl': 'nl_NL', #Dutch, Netherlands
  'nn_no': 'nn_NO', #Nynorsk, Norway
  'no_no': 'no_NO', #Bokmal, Norway
  'pa_in': 'pa_IN', #Punjabi, India
  'pl_pl': 'pl_PL', #Polish, Poland
  'pt_br': 'pt_BR', #Portuguese, Brazil
  'pt_pt': 'pt_PT', #Portuguese, Portugal
  'ro_ro': 'ro_RO', #Romanian, Romania
  'ru_ru': 'ru_RU', #Russian, Russia
  'sk_sk': 'sk_SK', #Slovak, Slovakia
  'sl_si': 'sl_SI', #Slovenian, Slovenia
  'sr_rs': 'sr_RS', #Serbian, Serbia
  'sv_se': 'sv_SE', #Swedish, Sweden
  'ta_in': 'ta_IN', #Tamil, India
  'te_in': 'te_IN', #Telugu, India
  'th_th': 'th_TH', #Thai, Thailand
  'tr_tr': 'tr_TR', #Turkish, Turkey
  'uk_ua': 'uk_UA', #Ukrainian, Ukraine
  'vi_vn': 'vi_VN', #Vietnamese, Vietnam
  'zh_cn': 'zh_CN', #Simplified Chinese, China
  'zh_hk': 'zh_HK', #Traditional Chinese, Hong Kong SAR China
  'zh_tw': 'zh_TW', #Traditional Chinese, Taiwan
  }

def getLocaleCode():
  if Cmd.ArgumentsRemaining():
    choice = Cmd.Current().strip().lower().replace('-', '_')
    if choice in LOCALE_CODES_MAP:
      Cmd.Advance()
      return LOCALE_CODES_MAP[choice]
    invalidChoiceExit(choice, LOCALE_CODES_MAP, False)
  missingChoiceExit(LOCALE_CODES_MAP)

def addCourseIdScope(courseId):
  if not courseId.isdigit() and courseId[:2] not in {'d:', 'p:'}:
    return f'd:{courseId}'
  return courseId

def removeCourseIdScope(courseId):
  if courseId.startswith('d:'):
    return courseId[2:]
  return courseId

def addCourseAliasScope(alias):
  if alias[:2] not in {'d:', 'p:'}:
    return f'd:{alias}'
  return alias

def removeCourseAliasScope(alias):
  if alias.startswith('d:'):
    return alias[2:]
  return alias

def getCourseAlias():
  if Cmd.ArgumentsRemaining():
    courseAlias = Cmd.Current()
    if courseAlias:
      Cmd.Advance()
      return addCourseAliasScope(courseAlias)
  missingArgumentExit(Cmd.OB_COURSE_ALIAS)

DELIVERY_SETTINGS_UNDEFINED = 'DSU'
GROUP_DELIVERY_SETTINGS_MAP = {
  'allmail': 'ALL_MAIL',
  'abridged': 'DAILY',
  'daily': 'DAILY',
  'digest': 'DIGEST',
  'disabled': 'DISABLED',
  'none': 'NONE',
  'nomail': 'NONE',
  }

def getDeliverySettings():
  if checkArgumentPresent(['delivery', 'deliverysettings']):
    return getChoice(GROUP_DELIVERY_SETTINGS_MAP, mapChoice=True)
  return getChoice(GROUP_DELIVERY_SETTINGS_MAP, defaultChoice=DELIVERY_SETTINGS_UNDEFINED, mapChoice=True)

UID_PATTERN = re.compile(r'u?id: ?(.+)', re.IGNORECASE)
PEOPLE_PATTERN = re.compile(r'people/([0-9]+)$', re.IGNORECASE)

def validateEmailAddressOrUID(emailAddressOrUID, checkPeople=True):
  cg = UID_PATTERN.match(emailAddressOrUID)
  if cg:
    return cg.group(1)
  if checkPeople:
    cg = PEOPLE_PATTERN.match(emailAddressOrUID)
    if cg:
      return cg.group(1)
  return emailAddressOrUID.find('@') != 0 and emailAddressOrUID.count('@') <= 1

# Normalize user/group email address/uid
# uid:12345abc -> 12345abc
# foo -> foo@domain
# foo@ -> foo@domain
# foo@bar.com -> foo@bar.com
# @domain -> domain
def normalizeEmailAddressOrUID(emailAddressOrUID, noUid=False, checkForCustomerId=False, noLower=False):
  if checkForCustomerId and (emailAddressOrUID == GC.Values[GC.CUSTOMER_ID]):
    return emailAddressOrUID
  if not noUid:
    cg = UID_PATTERN.match(emailAddressOrUID)
    if cg:
      return cg.group(1)
    cg = PEOPLE_PATTERN.match(emailAddressOrUID)
    if cg:
      return cg.group(1)
  atLoc = emailAddressOrUID.find('@')
  if atLoc == 0:
    return emailAddressOrUID[1:].lower() if not noLower else emailAddressOrUID[1:]
  if (atLoc == -1) or (atLoc == len(emailAddressOrUID)-1) and GC.Values[GC.DOMAIN]:
    if atLoc == -1:
      emailAddressOrUID = f'{emailAddressOrUID}@{GC.Values[GC.DOMAIN]}'
    else:
      emailAddressOrUID = f'{emailAddressOrUID}{GC.Values[GC.DOMAIN]}'
  return emailAddressOrUID.lower() if not noLower else emailAddressOrUID

# Normalize student/guardian email address/uid
# 12345678 -> 12345678
# - -> -
# Otherwise, same results as normalizeEmailAddressOrUID
def normalizeStudentGuardianEmailAddressOrUID(emailAddressOrUID, allowDash=False):
  if emailAddressOrUID.isdigit() or (allowDash and emailAddressOrUID == '-'):
    return emailAddressOrUID
  return normalizeEmailAddressOrUID(emailAddressOrUID)

def getEmailAddress(noUid=False, minLen=1, optional=False):
  if Cmd.ArgumentsRemaining():
    emailAddress = Cmd.Current().strip().lower()
    if emailAddress:
      cg = UID_PATTERN.match(emailAddress)
      if cg:
        if not noUid:
          if cg.group(1):
            Cmd.Advance()
            return cg.group(1)
        else:
          invalidArgumentExit('name@domain')
      else:
        atLoc = emailAddress.find('@')
        if atLoc == -1:
          if GC.Values[GC.DOMAIN]:
            emailAddress = f'{emailAddress}@{GC.Values[GC.DOMAIN]}'
          Cmd.Advance()
          return emailAddress
        if atLoc != 0:
          if (atLoc == len(emailAddress)-1) and GC.Values[GC.DOMAIN]:
            emailAddress = f'{emailAddress}{GC.Values[GC.DOMAIN]}'
          Cmd.Advance()
          return emailAddress
        invalidArgumentExit('name@domain')
    if optional:
      Cmd.Advance()
      return None
    if minLen == 0:
      Cmd.Advance()
      return ''
  elif optional:
    return None
  missingArgumentExit([Cmd.OB_EMAIL_ADDRESS_OR_UID, Cmd.OB_EMAIL_ADDRESS][noUid])

def getFilename():
  filename = os.path.expanduser(getString(Cmd.OB_FILE_NAME))
  if os.path.isfile(filename):
    return filename
  entityDoesNotExistExit(Ent.FILE, filename)

def getPermissionId():
  if Cmd.ArgumentsRemaining():
    emailAddress = Cmd.Current().strip()
    if emailAddress:
      cg = UID_PATTERN.match(emailAddress)
      if cg:
        Cmd.Advance()
        return (False, cg.group(1))
      emailAddress = emailAddress.lower()
      atLoc = emailAddress.find('@')
      if atLoc == -1:
        if emailAddress == 'anyone':
          Cmd.Advance()
          return (False, emailAddress)
        if emailAddress == 'anyonewithlink':
          Cmd.Advance()
          return (False, 'anyoneWithLink')
        if GC.Values[GC.DOMAIN]:
          emailAddress = f'{emailAddress}@{GC.Values[GC.DOMAIN]}'
        Cmd.Advance()
        return (True, emailAddress)
      if atLoc != 0:
        if (atLoc == len(emailAddress)-1) and GC.Values[GC.DOMAIN]:
          emailAddress = f'{emailAddress}{GC.Values[GC.DOMAIN]}'
        Cmd.Advance()
        return (True, emailAddress)
      invalidArgumentExit('name@domain')
  missingArgumentExit(Cmd.OB_DRIVE_FILE_PERMISSION_ID)

def getGoogleProduct():
  if Cmd.ArgumentsRemaining():
    product = Cmd.Current().strip()
    if product:
      Cmd.Advance()
      return SKU.normalizeProductId(product)
  missingArgumentExit(Cmd.OB_PRODUCT_ID)

def getGoogleProductList():
  if Cmd.ArgumentsRemaining():
    productsList = []
    for product in Cmd.Current().split(','):
      product = SKU.normalizeProductId(product)
      if product not in productsList:
        productsList.append(product)
    Cmd.Advance()
    return productsList
  missingArgumentExit(Cmd.OB_PRODUCT_ID_LIST)

def getGoogleSKU():
  if Cmd.ArgumentsRemaining():
    sku = Cmd.Current().strip()
    if sku:
      Cmd.Advance()
      return SKU.getProductAndSKU(sku)
  missingArgumentExit(Cmd.OB_SKU_ID)

def getGoogleSKUList():
  if Cmd.ArgumentsRemaining():
    skusList = []
    for sku in Cmd.Current().split(','):
      _, sku = SKU.getProductAndSKU(sku)
      if sku not in skusList:
        skusList.append(sku)
    Cmd.Advance()
    return skusList
  missingArgumentExit(Cmd.OB_SKU_ID_LIST)

def floatLimits(minVal, maxVal, item='float'):
  if (minVal is not None) and (maxVal is not None):
    return f'{item} {minVal:.3f}<=x<={maxVal:.3f}'
  if minVal is not None:
    return f'{item} x>={minVal:.3f}'
  if maxVal is not None:
    return f'{item} x<={maxVal:.3f}'
  return f'{item} x'

def getFloat(minVal=None, maxVal=None):
  if Cmd.ArgumentsRemaining():
    try:
      number = float(Cmd.Current().strip())
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        Cmd.Advance()
        return number
    except ValueError:
      pass
    invalidArgumentExit(floatLimits(minVal, maxVal))
  missingArgumentExit(floatLimits(minVal, maxVal))

def integerLimits(minVal, maxVal, item='integer'):
  if (minVal is not None) and (maxVal is not None):
    return f'{item} {minVal}<=x<={maxVal}'
  if minVal is not None:
    return f'{item} x>={minVal}'
  if maxVal is not None:
    return f'{item} x<={maxVal}'
  return f'{item} x'

def getInteger(minVal=None, maxVal=None):
  if Cmd.ArgumentsRemaining():
    try:
      number = int(Cmd.Current().strip())
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        Cmd.Advance()
        return number
    except ValueError:
      pass
    invalidArgumentExit(integerLimits(minVal, maxVal))
  missingArgumentExit(integerLimits(minVal, maxVal))

SORTORDER_CHOICE_MAP = {'ascending': 'ASCENDING', 'descending': 'DESCENDING'}

class OrderBy():
  def __init__(self, choiceMap):
    self.choiceMap = choiceMap
    self.items = []

  def GetChoice(self):
    fieldName = getChoice(self.choiceMap, mapChoice=True)
    if fieldName in self.items:
      self.items.remove(fieldName)
    fieldNameDesc = f'{fieldName} desc'
    if fieldNameDesc in self.items:
      self.items.remove(fieldNameDesc)
    if getChoice(SORTORDER_CHOICE_MAP, defaultChoice=None, mapChoice=True) != 'DESCENDING':
      self.items.append(fieldName)
    else:
      self.items.append(fieldNameDesc)

  def SetItems(self, itemList):
    self.items = itemList.split(',')

  @property
  def orderBy(self):
    return ','.join(self.items)

def getOrderBySortOrder(choiceMap, defaultSortOrderChoice='ASCENDING', mapSortOrderChoice=True):
  return (getChoice(choiceMap, mapChoice=True),
          getChoice(SORTORDER_CHOICE_MAP, defaultChoice=defaultSortOrderChoice, mapChoice=mapSortOrderChoice))

def orgUnitPathQuery(path, isSuspended):
  query = "orgUnitPath='{0}'".format(path.replace("'", "\\'")) if path != '/' else ''
  if isSuspended is not None:
    query += f' isSuspended={isSuspended}'
  return query

def makeOrgUnitPathAbsolute(path):
  if path == '/':
    return path
  if path.startswith('/'):
    return path.rstrip('/')
  if path.startswith('id:'):
    return path
  if path.startswith('uid:'):
    return path[1:]
  return '/'+path.rstrip('/')

def makeOrgUnitPathRelative(path):
  if path == '/':
    return path
  if path.startswith('/'):
    return path[1:].rstrip('/')
  if path.startswith('id:'):
    return path
  if path.startswith('uid:'):
    return path[1:]
  return path.rstrip('/')

def encodeOrgUnitPath(path):
  if path.find('+') == -1 and path.find('%') == -1:
    return path
  encpath = ''
  for c in path:
    if c == '+':
      encpath += '%2B'
    elif c == '%':
      encpath += '%25'
    else:
      encpath += c
  return encpath

def getOrgUnitItem(pathOnly=False, absolutePath=True):
  if Cmd.ArgumentsRemaining():
    path = Cmd.Current().strip()
    if path:
      if pathOnly and (path.startswith('id:') or path.startswith('uid:')):
        invalidArgumentExit(Cmd.OB_ORGUNIT_PATH)
      Cmd.Advance()
      if absolutePath:
        return makeOrgUnitPathAbsolute(path)
      return makeOrgUnitPathRelative(path)
  missingArgumentExit([Cmd.OB_ORGUNIT_ITEM, Cmd.OB_ORGUNIT_PATH][pathOnly])

def getTopLevelOrgId(cd, parentOrgUnitPath):
  try:
    result = callGAPI(cd.orgunits(), 'insert',
                      throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                      customerId=GC.Values[GC.CUSTOMER_ID], body={'name': 'temp-delete-me', 'parentOrgUnitPath': parentOrgUnitPath}, fields='parentOrgUnitId,orgUnitId')
  except GAPI.invalidOrgunit:
    return None
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, parentOrgUnitPath)
    return None
  try:
    callGAPI(cd.orgunits(), 'delete',
             throwReasons=[GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
             customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=result['orgUnitId'])
  except (GAPI.conditionNotMet, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    pass
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, parentOrgUnitPath)
  return result['parentOrgUnitId']

def getOrgUnitId(cd=None):
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  orgUnit = getOrgUnitItem()
  if orgUnit[:3] == 'id:':
    return (orgUnit, orgUnit)
  try:
    if orgUnit == '/':
      result = callGAPI(cd.orgunits(), 'list',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath='/', type='children',
                        fields='organizationUnits(parentOrgUnitId)')
      if result.get('organizationUnits', []):
        return (orgUnit, result['organizationUnits'][0]['parentOrgUnitId'])
      topLevelOrgId = getTopLevelOrgId(cd, '/')
      if topLevelOrgId:
        return (orgUnit, topLevelOrgId)
      return (orgUnit, '/') #Bogus but should never happen
    result = callGAPI(cd.orgunits(), 'get',
                      throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                      customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnit)), fields='orgUnitId')
    return (orgUnit, result['orgUnitId'])
  except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    entityDoesNotExistExit(Ent.ORGANIZATIONAL_UNIT, orgUnit)
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    accessErrorExit(cd)

def validateREPattern(patstr, flags=0):
  try:
    return re.compile(patstr, flags)
  except re.error as e:
    Cmd.Backup()
    usageErrorExit(f'{Cmd.OB_RE_PATTERN} {Msg.ERROR}: {e}')

def getREPattern(flags=0):
  if Cmd.ArgumentsRemaining():
    patstr = Cmd.Current()
    if patstr:
      Cmd.Advance()
      return validateREPattern(patstr, flags)
  missingArgumentExit(Cmd.OB_RE_PATTERN)

def getSheetEntity():
  if Cmd.ArgumentsRemaining():
    sheet = Cmd.Current()
    if sheet:
      cg = UID_PATTERN.match(sheet)
      if cg:
        if cg.group(1).isdigit():
          Cmd.Advance()
          return {'sheetType': Ent.SHEET_ID, 'sheetValue': int(cg.group(1)), 'sheetId': int(cg.group(1)), 'sheetTitle': ''}
      else:
        Cmd.Advance()
        return {'sheetType': Ent.SHEET, 'sheetValue': sheet, 'sheetId': None, 'sheetTitle': sheet}
  missingArgumentExit(Cmd.OB_SHEET_ENTITY)

def getSheetIdFromSheetEntity(spreadsheet, sheetEntity):
  if sheetEntity['sheetType'] == Ent.SHEET_ID:
    for sheet in spreadsheet['sheets']:
      if sheetEntity['sheetId'] == sheet['properties']['sheetId']:
        return sheet['properties']['sheetId']
  else:
    sheetTitleLower = sheetEntity['sheetTitle'].lower()
    for sheet in spreadsheet['sheets']:
      if sheetTitleLower == sheet['properties']['title'].lower():
        return sheet['properties']['sheetId']
  return None

def protectedSheetId(spreadsheet, sheetId):
  for sheet in spreadsheet['sheets']:
    for protectedRange in sheet.get('protectedRanges', []):
      if protectedRange.get('range', {}).get('sheetId', -1) == sheetId and not protectedRange.get('requestingUserCanEdit', False):
        return True
  return False

SITENAME_PATTERN = re.compile(r'^[a-z0-9\-_]+$')
SITENAME_FORMAT_REQUIRED = '[a-z,0-9,-_]+'

def validateSplitSiteName(fullSite):
  siteParts = fullSite.lower().split('/', 1)
  if (len(siteParts) == 1) or not siteParts[1]:
    domain = GC.Values[GC.DOMAIN]
    site = siteParts[0]
  elif not siteParts[0]:
    domain = GC.Values[GC.DOMAIN]
    site = siteParts[1]
  else:
    domain = siteParts[0]
    site = siteParts[1]
  if SITENAME_PATTERN.match(site):
    return (domain, site, f'{domain}/{site}')
  return (domain, site, None)

def getSiteName():
  if Cmd.ArgumentsRemaining():
    domain, site, domainSite = validateSplitSiteName(Cmd.Current())
    if domainSite:
      Cmd.Advance()
      return (domain, site, domainSite)
    invalidArgumentExit(SITENAME_FORMAT_REQUIRED)
  missingArgumentExit(SITENAME_FORMAT_REQUIRED)

def getString(item, checkBlank=False, optional=False, minLen=1, maxLen=None):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current()
    if argstr:
      if checkBlank:
        if argstr.isspace():
          blankArgumentExit(item)
      if (len(argstr) >= minLen) and ((maxLen is None) or (len(argstr) <= maxLen)):
        Cmd.Advance()
        return argstr
      invalidArgumentExit(f'{integerLimits(minLen, maxLen, Msg.STRING_LENGTH)} for {item}')
    if optional or (minLen == 0):
      Cmd.Advance()
      return ''
    emptyArgumentExit(item)
  elif optional:
    return ''
  missingArgumentExit(item)

def getStringWithCRsNLs():
  return unescapeCRsNLs(getString(Cmd.OB_STRING, minLen=0))

def getStringReturnInList(item):
  argstr = getString(item, minLen=0).strip()
  if argstr:
    return [argstr]
  return []

SORF_SIG_ARGUMENTS = {'signature', 'sig', 'textsig', 'htmlsig'}
SORF_MSG_ARGUMENTS = {'message', 'textmessage', 'htmlmessage'}
SORF_FILE_ARGUMENTS = {'file', 'textfile', 'htmlfile', 'gdoc', 'ghtml'}
SORF_HTML_ARGUMENTS = {'htmlsig', 'htmlmessage', 'htmlfile', 'ghtml'}
SORF_SIG_FILE_ARGUMENTS = SORF_SIG_ARGUMENTS.union(SORF_FILE_ARGUMENTS)
SORF_MSG_FILE_ARGUMENTS = SORF_MSG_ARGUMENTS.union(SORF_FILE_ARGUMENTS)

def getStringOrFile(myarg, minLen=0):
  if myarg in SORF_SIG_ARGUMENTS:
    if checkArgumentPresent(SORF_FILE_ARGUMENTS):
      myarg = Cmd.Previous().strip().lower().replace('_', '')
  html = myarg in SORF_HTML_ARGUMENTS
  if myarg in SORF_FILE_ARGUMENTS:
    if myarg not in {'gdoc', 'ghtml'}:
      filename = getString(Cmd.OB_FILE_NAME)
      encoding = getCharSet()
      return (readFile(filename, encoding=encoding), encoding, html)
    f = getGDocData(MIMETYPE_TEXT_HTML if html else MIMETYPE_TEXT_PLAIN)
    data = f.read()
    f.close()
    return (data, UTF8, html)
  return (getString(Cmd.OB_STRING, minLen=minLen), UTF8, html)

def getStringWithCRsNLsOrFile():
  if checkArgumentPresent(SORF_FILE_ARGUMENTS):
    return getStringOrFile(Cmd.Previous().strip().lower().replace('_', ''), minLen=0)[0]
  return unescapeCRsNLs(getString(Cmd.OB_STRING, minLen=0))

def todaysDate():
  return datetime.datetime(GM.Globals[GM.DATETIME_NOW].year, GM.Globals[GM.DATETIME_NOW].month, GM.Globals[GM.DATETIME_NOW].day,
                           tzinfo=GC.Values[GC.TIMEZONE])

def todaysTime():
  return datetime.datetime(GM.Globals[GM.DATETIME_NOW].year, GM.Globals[GM.DATETIME_NOW].month, GM.Globals[GM.DATETIME_NOW].day,
                           GM.Globals[GM.DATETIME_NOW].hour, GM.Globals[GM.DATETIME_NOW].minute,
                           tzinfo=GC.Values[GC.TIMEZONE])

def getDelta(argstr, pattern):
  if argstr == 'NOW':
    return todaysTime()
  if argstr == 'TODAY':
    return todaysDate()
  tg = pattern.match(argstr.lower())
  if tg is None:
    return None
  sign = tg.group(1)
  delta = int(tg.group(2))
  unit = tg.group(3)
  if unit == 'y':
    deltaTime = datetime.timedelta(days=delta*365)
  elif unit == 'w':
    deltaTime = datetime.timedelta(weeks=delta)
  elif unit == 'd':
    deltaTime = datetime.timedelta(days=delta)
  elif unit == 'h':
    deltaTime = datetime.timedelta(hours=delta)
  elif unit == 'm':
    deltaTime = datetime.timedelta(minutes=delta)
  baseTime = todaysDate()
  if unit in {'h', 'm'}:
    baseTime = baseTime+datetime.timedelta(hours=GM.Globals[GM.DATETIME_NOW].hour, minutes=GM.Globals[GM.DATETIME_NOW].minute)
  if sign == '-':
    return baseTime-deltaTime
  return baseTime+deltaTime

DELTA_DATE_PATTERN = re.compile(r'^([+-])(\d+)([dwy])$')
DELTA_DATE_FORMAT_REQUIRED = '(+|-)<Number>(d|w|y)'
def getDeltaDate(argstr):
  deltaDate = getDelta(argstr, DELTA_DATE_PATTERN)
  if deltaDate is None:
    invalidArgumentExit(DELTA_DATE_FORMAT_REQUIRED)
  return deltaDate

DELTA_TIME_PATTERN = re.compile(r'^([+-])(\d+)([mhdwy])$')
DELTA_TIME_FORMAT_REQUIRED = '(+|-)<Number>(m|h|d|w|y)'

def getDeltaTime(argstr):
  deltaTime = getDelta(argstr, DELTA_TIME_PATTERN)
  if deltaTime is None:
    invalidArgumentExit(DELTA_TIME_FORMAT_REQUIRED)
  return deltaTime

YYYYMMDD_FORMAT = '%Y-%m-%d'
YYYYMMDD_FORMAT_REQUIRED = 'yyyy-mm-dd'

TODAY_NOW = {'TODAY', 'NOW'}
PLUS_MINUS = {'+', '-'}

def getYYYYMMDD(minLen=1, returnTimeStamp=False, returnDateTime=False, alternateValue=None):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if alternateValue is not None and argstr == alternateValue.upper():
        Cmd.Advance()
        return None
      if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
        if argstr == 'NOW':
          argstr = 'TODAY'
        argstr = getDeltaDate(argstr).strftime(YYYYMMDD_FORMAT)
      elif argstr == 'NEVER':
        argstr = NEVER_DATE
      try:
        dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
        Cmd.Advance()
        if returnTimeStamp:
          return time.mktime(dateTime.timetuple())*1000
        if returnDateTime:
          return dateTime
        return argstr
      except ValueError:
        invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
    elif minLen == 0:
      Cmd.Advance()
      return ''
  missingArgumentExit(YYYYMMDD_FORMAT_REQUIRED)

YYYYMMDD_HHMM_FORMAT = '%Y-%m-%d %H:%M'
YYYYMMDD_HHMM_FORMAT_REQUIRED = 'yyyy-mm-dd hh:mm'

def getYYYYMMDD_HHMM():
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
        argstr = getDeltaTime(argstr).strftime(YYYYMMDD_HHMM_FORMAT)
      elif argstr == 'NEVER':
        argstr = NEVER_DATETIME
      argstr = argstr.replace('T', ' ')
      try:
        datetime.datetime.strptime(argstr, YYYYMMDD_HHMM_FORMAT)
        Cmd.Advance()
        return argstr
      except ValueError:
        invalidArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDD_HHMM_FORMAT_REQUIRED)

YYYYMMDDTHHMMSSZ_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
YYYYMMDD_PATTERN = re.compile(r'^[0-9]{4}-[0-9]{2}-[0-9]{2}$')

def getDateOrDeltaFromNow(returnDateTime=False):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
        if argstr == 'NOW':
          argstr = 'TODAY'
        argDate = getDeltaDate(argstr)
      elif argstr == 'NEVER':
        argDate = datetime.datetime.strptime(NEVER_DATE, YYYYMMDD_FORMAT)
      elif YYYYMMDD_PATTERN.match(argstr):
        try:
          argDate = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
        except ValueError:
          invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
      else:
        invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
      Cmd.Advance()
      if not returnDateTime:
        return argDate.strftime(YYYYMMDD_FORMAT)
      return (datetime.datetime(argDate.year, argDate.month, argDate.day, tzinfo=GC.Values[GC.TIMEZONE]),
              GC.Values[GC.TIMEZONE], argDate.strftime(YYYYMMDD_FORMAT))
  missingArgumentExit(YYYYMMDD_FORMAT_REQUIRED)

YYYYMMDDTHHMMSS_FORMAT_REQUIRED = 'yyyy-mm-ddThh:mm:ss[.fff](Z|(+|-(hh:mm)))'
TIMEZONE_FORMAT_REQUIRED = 'Z|(+|-(hh:mm))'

def getTimeOrDeltaFromNow(returnDateTime=False):
  if Cmd.ArgumentsRemaining():
    argstr = Cmd.Current().strip().upper()
    if argstr:
      if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
        argstr = ISOformatTimeStamp(getDeltaTime(argstr))
      elif argstr == 'NEVER':
        argstr = NEVER_TIME
      elif YYYYMMDD_PATTERN.match(argstr):
        try:
          dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
        except ValueError:
          invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)
        try:
          argstr = ISOformatTimeStamp(dateTime.replace(tzinfo=GC.Values[GC.TIMEZONE]))
        except OverflowError:
          pass
      try:
        fullDateTime, tz = iso8601.parse_date(argstr)
        Cmd.Advance()
        if not returnDateTime:
          return argstr.replace(' ', 'T')
        return (fullDateTime, tz, argstr.replace(' ', 'T'))
      except (iso8601.ParseError, OverflowError):
        pass
      invalidArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)
  missingArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)

def getRowFilterDateOrDeltaFromNow(argstr):
  argstr = argstr.strip().upper()
  if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
    if argstr == 'NOW':
      argstr = 'TODAY'
    deltaDate = getDelta(argstr, DELTA_DATE_PATTERN)
    if deltaDate is None:
      return (False, DELTA_DATE_FORMAT_REQUIRED)
    argstr = ISOformatTimeStamp(deltaDate)
  elif argstr == 'NEVER':
    argstr = NEVER_TIME
  elif YYYYMMDD_PATTERN.match(argstr):
    try:
      dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
    except ValueError:
      return (False, YYYYMMDD_FORMAT_REQUIRED)
    argstr = ISOformatTimeStamp(dateTime.replace(tzinfo=GC.Values[GC.TIMEZONE]))
  try:
    iso8601.parse_date(argstr)
    return (True, argstr.replace(' ', 'T'))
  except (iso8601.ParseError, OverflowError):
    return (False, YYYYMMDD_FORMAT_REQUIRED)

def getRowFilterTimeOrDeltaFromNow(argstr):
  argstr = argstr.strip().upper()
  if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
    deltaTime = getDelta(argstr, DELTA_TIME_PATTERN)
    if deltaTime is None:
      return (False, DELTA_TIME_FORMAT_REQUIRED)
    argstr = ISOformatTimeStamp(deltaTime)
  elif argstr == 'NEVER':
    argstr = NEVER_TIME
  elif YYYYMMDD_PATTERN.match(argstr):
    try:
      dateTime = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
    except ValueError:
      return (False, YYYYMMDD_FORMAT_REQUIRED)
    argstr = ISOformatTimeStamp(dateTime.replace(tzinfo=GC.Values[GC.TIMEZONE]))
  try:
    iso8601.parse_date(argstr)
    return (True, argstr.replace(' ', 'T'))
  except (iso8601.ParseError, OverflowError):
    return (False, YYYYMMDDTHHMMSS_FORMAT_REQUIRED)

class StartEndTime():
  def __init__(self, startkw='starttime', endkw='endtime', mode='time'):
    self.startTime = self.endTime = self.startDateTime = self.endDateTime = None
    self._startkw = startkw
    self._endkw = endkw
    self._getValueOrDeltaFromNow = getTimeOrDeltaFromNow if mode == 'time' else getDateOrDeltaFromNow

  def Get(self, myarg):
    if myarg in {'start', self._startkw}:
      self.startDateTime, _, self.startTime = self._getValueOrDeltaFromNow(True)
    elif myarg in {'end', self._endkw}:
      self.endDateTime, _, self.endTime = self._getValueOrDeltaFromNow(True)
    elif myarg == 'yesterday':
      self.startDateTime = todaysDate()+datetime.timedelta(days=-1)
      self.startTime = ISOformatTimeStamp(self.startDateTime)
      self.endDateTime = todaysDate()+datetime.timedelta(seconds=-1)
      self.endTime = ISOformatTimeStamp(self.endDateTime)
    else: # elif myarg == 'range':
      self.startDateTime, _, self.startTime = self._getValueOrDeltaFromNow(True)
      self.endDateTime, _, self.endTime = self._getValueOrDeltaFromNow(True)
    if self.startDateTime and self.endDateTime and self.endDateTime < self.startDateTime:
      Cmd.Backup()
      usageErrorExit(Msg.INVALID_DATE_TIME_RANGE.format(self._endkw, self.endTime, self._startkw, self.startTime))

EVENTID_PATTERN = re.compile(r'^[a-v0-9]{5,1024}$')
EVENTID_FORMAT_REQUIRED = '[a-v0-9]{5,1024}'

def getEventID():
  if Cmd.ArgumentsRemaining():
    tg = EVENTID_PATTERN.match(Cmd.Current().strip())
    if tg:
      Cmd.Advance()
      return tg.group(0)
    invalidArgumentExit(EVENTID_FORMAT_REQUIRED)
  missingArgumentExit(EVENTID_FORMAT_REQUIRED)

EVENT_TIME_FORMAT_REQUIRED = 'allday yyyy-mm-dd | '+YYYYMMDDTHHMMSS_FORMAT_REQUIRED

def getEventTime():
  if Cmd.ArgumentsRemaining():
    if Cmd.Current().strip().lower() == 'allday':
      Cmd.Advance()
      return {'date': getYYYYMMDD()}
    return {'dateTime': getTimeOrDeltaFromNow()}
  missingArgumentExit(EVENT_TIME_FORMAT_REQUIRED)

AGE_TIME_PATTERN = re.compile(r'^(\d+)([mhdw])$')
AGE_TIME_FORMAT_REQUIRED = '<Number>(m|h|d|w)'

def getAgeTime():
  if Cmd.ArgumentsRemaining():
    tg = AGE_TIME_PATTERN.match(Cmd.Current().strip().lower())
    if tg:
      age = int(tg.group(1))
      age_unit = tg.group(2)
      now = int(time.time())
      if age_unit == 'm':
        age = now-(age*SECONDS_PER_MINUTE)
      elif age_unit == 'h':
        age = now-(age*SECONDS_PER_HOUR)
      elif age_unit == 'd':
        age = now-(age*SECONDS_PER_DAY)
      else: # age_unit == 'w':
        age = now-(age*SECONDS_PER_WEEK)
      Cmd.Advance()
      return age*1000
    invalidArgumentExit(AGE_TIME_FORMAT_REQUIRED)
  missingArgumentExit(AGE_TIME_FORMAT_REQUIRED)

CALENDAR_REMINDER_METHODS = ['email', 'popup']
CALENDAR_REMINDER_MAX_MINUTES = 40320

def getCalendarReminder(allowClearNone=False):
  methods = CALENDAR_REMINDER_METHODS[:]
  if allowClearNone:
    methods += Cmd.CLEAR_NONE_ARGUMENT
  if Cmd.ArgumentsRemaining():
    method = Cmd.Current().strip()
    if not method.isdigit():
      method = getChoice(methods)
      minutes = getInteger(minVal=0, maxVal=CALENDAR_REMINDER_MAX_MINUTES)
    else:
      minutes = getInteger(minVal=0, maxVal=CALENDAR_REMINDER_MAX_MINUTES)
      method = getChoice(methods)
    return {'method': method, 'minutes': minutes}
  missingChoiceExit(methods)

def getCharacter():
  if Cmd.ArgumentsRemaining():
    argstr = codecs.escape_decode(bytes(Cmd.Current(), UTF8))[0].decode(UTF8)
    if argstr:
      if len(argstr) == 1:
        Cmd.Advance()
        return argstr
      invalidArgumentExit(f'{integerLimits(1, 1, Msg.STRING_LENGTH)} for {Cmd.OB_CHARACTER}')
    emptyArgumentExit(Cmd.OB_CHARACTER)
  missingArgumentExit(Cmd.OB_CHARACTER)

def getDelimiter():
  if not checkArgumentPresent('delimiter'):
    return None
  return getCharacter()

def getJSON(deleteFields):
  if not checkArgumentPresent('file'):
    encoding = getCharSet()
    if not Cmd.ArgumentsRemaining():
      missingArgumentExit(Cmd.OB_JSON_DATA)
    argstr = Cmd.Current()
    Cmd.Advance()
    try:
      if encoding == UTF8:
        jsonData = json.loads(argstr)
      else:
        jsonData = json.loads(argstr.encode(encoding).decode(UTF8))
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
      usageErrorExit(f'{str(e)}: {argstr if encoding == UTF8 else argstr.encode(encoding).decode(UTF8)}')
  else:
    filename = getString(Cmd.OB_FILE_NAME)
    encoding = getCharSet()
    try:
      jsonData = json.loads(readFile(filename, encoding=encoding))
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
      usageErrorExit(f'{str(e)}: {filename}')
  for field in deleteFields:
    jsonData.pop(field, None)
  return jsonData

def getMatchSkipFields(fieldNames):
  matchFields = {}
  skipFields = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'matchfield', 'skipfield'}:
      matchField = getString(Cmd.OB_FIELD_NAME).strip('~')
      if (not matchField) or (matchField not in fieldNames):
        csvFieldErrorExit(matchField, fieldNames, backupArg=True)
      if myarg == 'matchfield':
        matchFields[matchField] = getREPattern()
      else:
        skipFields[matchField] = getREPattern()
    else:
      Cmd.Backup()
      break
  return (matchFields, skipFields)

def checkMatchSkipFields(row, matchFields, skipFields):
  for matchField, matchPattern in iter(matchFields.items()):
    if (matchField not in row) or not matchPattern.search(row[matchField]):
      return False
  for skipField, matchPattern in iter(skipFields.items()):
    if (skipField in row) and matchPattern.search(row[skipField]):
      return False
  return True

def checkSubkeyField():
  if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.NO_CSV_FILE_SUBKEYS_SAVED)
  chkSubkeyField = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
  if chkSubkeyField != GM.Globals[GM.CSV_SUBKEY_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.SUBKEY_FIELD_MISMATCH.format(chkSubkeyField, GM.Globals[GM.CSV_SUBKEY_FIELD]))

def checkDataField():
  if not GM.Globals[GM.CSV_DATA_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.NO_CSV_FILE_DATA_SAVED)
  chkDataField = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
  if chkDataField != GM.Globals[GM.CSV_DATA_FIELD]:
    Cmd.Backup()
    usageErrorExit(Msg.DATA_FIELD_MISMATCH.format(chkDataField, GM.Globals[GM.CSV_DATA_FIELD]))

MAX_MESSAGE_BYTES_PATTERN = re.compile(r'^(\d+)([mkb]?)$')
MAX_MESSAGE_BYTES_FORMAT_REQUIRED = '<Number>[m|k|b]'

def getMaxMessageBytes(oneKiloBytes, oneMegaBytes):
  if Cmd.ArgumentsRemaining():
    tg = MAX_MESSAGE_BYTES_PATTERN.match(Cmd.Current().strip().lower())
    if tg:
      mmb = int(tg.group(1))
      mmb_unit = tg.group(2)
      if mmb_unit == 'm':
        mmb *= oneMegaBytes
      elif mmb_unit == 'k':
        mmb *= oneKiloBytes
      Cmd.Advance()
      return mmb
    invalidArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)
  missingArgumentExit(MAX_MESSAGE_BYTES_FORMAT_REQUIRED)

# Get domain from email address
def getEmailAddressDomain(emailAddress):
  atLoc = emailAddress.find('@')
  if atLoc == -1:
    return GC.Values[GC.DOMAIN]
  return emailAddress[atLoc+1:].lower()

# Get user name from email address
def getEmailAddressUsername(emailAddress):
  atLoc = emailAddress.find('@')
  if atLoc == -1:
    return emailAddress.lower()
  return emailAddress[:atLoc].lower()

# Split email address into user and domain
def splitEmailAddress(emailAddress):
  atLoc = emailAddress.find('@')
  if atLoc == -1:
    return (emailAddress.lower(), GC.Values[GC.DOMAIN])
  return (emailAddress[:atLoc].lower(), emailAddress[atLoc+1:].lower())

def formatFileSize(fileSize):
  if fileSize == 0:
    return '0kb'
  if fileSize < ONE_KILO_10_BYTES:
    return '1kb'
  if fileSize < ONE_MEGA_10_BYTES:
    return f'{fileSize//ONE_KILO_10_BYTES}kb'
  if fileSize < ONE_GIGA_10_BYTES:
    return f'{fileSize//ONE_MEGA_10_BYTES}mb'
  return f'{fileSize//ONE_GIGA_10_BYTES}gb'

def formatLocalTime(dateTimeStr):
  if dateTimeStr in {NEVER_TIME, NEVER_TIME_NOMS}:
    return GC.Values[GC.NEVER_TIME]
  if not GM.Globals[GM.CONVERT_TO_LOCAL_TIME] or not dateTimeStr.endswith('Z'):
    return dateTimeStr
  try:
    timestamp, _ = iso8601.parse_date(dateTimeStr)
    return ISOformatTimeStamp(timestamp.astimezone(GC.Values[GC.TIMEZONE]))
  except (iso8601.ParseError, OverflowError):
    return dateTimeStr

def formatLocalSecondsTimestamp(timestamp):
  return ISOformatTimeStamp(datetime.datetime.fromtimestamp(int(timestamp), GC.Values[GC.TIMEZONE]))

def formatLocalTimestamp(timestamp):
  return ISOformatTimeStamp(datetime.datetime.fromtimestamp(int(timestamp)//1000, GC.Values[GC.TIMEZONE]))

def formatLocalDatestamp(timestamp):
  return datetime.datetime.fromtimestamp(int(timestamp)//1000, GC.Values[GC.TIMEZONE]).strftime(YYYYMMDD_FORMAT)

def formatMaxMessageBytes(maxMessageBytes, oneKiloBytes, oneMegaBytes):
  if maxMessageBytes < oneKiloBytes:
    return maxMessageBytes
  if maxMessageBytes < oneMegaBytes:
    return f'{maxMessageBytes//oneKiloBytes}K'
  return f'{maxMessageBytes//oneMegaBytes}M'

def formatMilliSeconds(millis):
  seconds, millis = divmod(millis, 1000)
  minutes, seconds = divmod(seconds, 60)
  hours, minutes = divmod(minutes, 60)
  return f'{hours:02d}:{minutes:02d}:{seconds:02d}'

def getPhraseDNEorSNA(email):
  return Msg.DOES_NOT_EXIST if getEmailAddressDomain(email) == GC.Values[GC.DOMAIN] else Msg.SERVICE_NOT_APPLICABLE

def formatHTTPError(http_status, reason, message):
  return f'{http_status}: {reason} - {message}'

def getHTTPError(responses, http_status, reason, message):
  if reason in responses:
    return responses[reason]
  return formatHTTPError(http_status, reason, message)

# Warnings
def printWarningMessage(sysRC, errMessage):
  setSysExitRC(sysRC)
  writeStderr(formatKeyValueList(Ind.Spaces(), [WARNING, errMessage], '\n'))

def badRequestWarning(entityType, itemType, itemValue):
  printWarningMessage(BAD_REQUEST_RC,
                      f'{Msg.GOT} 0 {Ent.Plural(entityType)}: {Msg.INVALID} {Ent.Singular(itemType)} - {itemValue}')

def emptyQuery(query, entityType):
  return f'{Ent.Singular(Ent.QUERY)} ({query}) {Msg.NO_ENTITIES_FOUND.format(Ent.Plural(entityType))}'

def invalidQuery(query):
  return f'{Ent.Singular(Ent.QUERY)} ({query}) {Msg.INVALID}'

def invalidMember(kwargs):
  if 'userKey' in kwargs:
    badRequestWarning(Ent.GROUP, Ent.MEMBER, kwargs['userKey'])
  else:
    badRequestWarning(Ent.GROUP, Ent.QUERY, invalidQuery(kwargs['query']))

def invalidUserSchema(schema):
  if isinstance(schema, list):
    return f'{Ent.Singular(Ent.USER_SCHEMA)} ({",".join(schema)}) {Msg.INVALID}'
  return f'{Ent.Singular(Ent.USER_SCHEMA)} {schema}) {Msg.INVALID}'

def entityServiceNotApplicableWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(SERVICE_NOT_APPLICABLE_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName, Msg.SERVICE_NOT_APPLICABLE],
                                 currentCountNL(i, count)))

def entityDoesNotExistWarning(entityType, entityName, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName, Msg.DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityUnknownWarning(entityType, entityName, i=0, count=0):
  domain = getEmailAddressDomain(entityName)
  if (domain == GC.Values[GC.DOMAIN]) or (domain.endswith('google.com')):
    entityDoesNotExistWarning(entityType, entityName, i, count)
  else:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)

def entityOrEntityUnknownWarning(entity1Type, entity1Name, entity2Type, entity2Name, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [f'{Msg.EITHER} {Ent.Singular(entity1Type)}', entity1Name, getPhraseDNEorSNA(entity1Name), None,
                                  f'{Msg.OR} {Ent.Singular(entity2Type)}', entity2Name, getPhraseDNEorSNA(entity2Name)],
                                 currentCountNL(i, count)))

def entityDoesNotHaveItemWarning(entityValueList, i=0, count=0):
  setSysExitRC(ENTITY_DOES_NOT_EXIST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Msg.DOES_NOT_EXIST],
                                 currentCountNL(i, count)))

def entityDuplicateWarning(entityValueList, i=0, count=0):
  setSysExitRC(ENTITY_DUPLICATE_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Failed(), Msg.DUPLICATE],
                                 currentCountNL(i, count)))

def entityActionFailedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(ACTION_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityModifierItemValueListActionFailedWarning(entityValueList, modifier, infoTypeValueList, errMessage, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier}', None]+Ent.FormatEntityValueList(infoTypeValueList)+[Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityModifierNewValueActionFailedWarning(entityValueList, modifier, newValue, errMessage, i=0, count=0):
  setSysExitRC(ACTION_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier}', newValue, Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityNumEntitiesActionFailedWarning(entityType, entityName, itemType, itemCount, errMessage, i=0, count=0):
  setSysExitRC(ACTION_FAILED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(entityType), entityName,
                                  Ent.Choose(itemType, itemCount), itemCount,
                                  Act.Failed(), errMessage],
                                 currentCountNL(i, count)))

def entityActionNotPerformedWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(ACTION_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityItemValueListActionNotPerformedWarning(entityValueList, infoTypeValueList, errMessage, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.NotPerformed(), '']+Ent.FormatEntityValueList(infoTypeValueList)+[errMessage],
                                 currentCountNL(i, count)))

def entityModifierItemValueListActionNotPerformedWarning(entityValueList, modifier, infoTypeValueList, errMessage, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.NotPerformed()} {modifier}', None]+Ent.FormatEntityValueList(infoTypeValueList)+[errMessage],
                                 currentCountNL(i, count)))

def entityNumEntitiesActionNotPerformedWarning(entityValueList, itemType, itemCount, errMessage, i=0, count=0):
  setSysExitRC(ACTION_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Ent.Choose(itemType, itemCount), itemCount, Act.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityBadRequestWarning(entityValueList, errMessage, i=0, count=0):
  setSysExitRC(BAD_REQUEST_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[ERROR, errMessage],
                                 currentCountNL(i, count)))

def userSvcNotApplicableOrDriveDisabled(user, errMessage, i=0, count=0):
  if errMessage.find('Drive apps') == -1:
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  else:
    entityActionNotPerformedWarning([Ent.USER, user], errMessage, i, count)

# Getting ... utilities
def printGettingAllAccountEntities(entityType, query='', qualifier=''):
  if GC.Values[GC.SHOW_GETTINGS]:
    if query:
      Ent.SetGettingQuery(entityType, query)
    elif qualifier:
      Ent.SetGettingQualifier(entityType, qualifier)
    else:
      Ent.SetGetting(entityType)
    writeStderr(f'{Msg.GETTING_ALL} {Ent.PluralGetting()}{Ent.GettingPreQualifier()}{Ent.MayTakeTime(Ent.ACCOUNT)}\n')

def printGotAccountEntities(count):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(f'{Msg.GOT} {count} {Ent.ChooseGetting(count)}{Ent.GettingPostQualifier()}\n')

def printGettingAllEntityItemsForWhom(entityItem, forWhom, i=0, count=0, query='', qualifier='', entityType=None):
  if GC.Values[GC.SHOW_GETTINGS]:
    if query:
      Ent.SetGettingQuery(entityItem, query)
    elif qualifier:
      Ent.SetGettingQualifier(entityItem, qualifier)
    else:
      Ent.SetGetting(entityItem)
    Ent.SetGettingForWhom(forWhom)
    writeStderr(f'{Msg.GETTING_ALL} {Ent.PluralGetting()}{Ent.GettingPreQualifier()} {Msg.FOR} {forWhom}{Ent.MayTakeTime(entityType)}{currentCountNL(i, count)}')

def printGotEntityItemsForWhom(count):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(f'{Msg.GOT} {count} {Ent.ChooseGetting(count)}{Ent.GettingPostQualifier()} {Msg.FOR} {Ent.GettingForWhom()}\n')

def printGettingEntityItem(entityType, entityItem, i=0, count=0):
  if GC.Values[GC.SHOW_GETTINGS]:
    writeStderr(f'{Msg.GETTING} {Ent.Singular(entityType)} {entityItem}{currentCountNL(i, count)}')

def printGettingEntityItemForWhom(entityItem, forWhom, i=0, count=0):
  if GC.Values[GC.SHOW_GETTINGS]:
    Ent.SetGetting(entityItem)
    Ent.SetGettingForWhom(forWhom)
    writeStderr(f'{Msg.GETTING} {Ent.PluralGetting()} {Msg.FOR} {forWhom}{currentCountNL(i, count)}')

FIRST_ITEM_MARKER = '%%first_item%%'
LAST_ITEM_MARKER = '%%last_item%%'
TOTAL_ITEMS_MARKER = '%%total_items%%'

def getPageMessage(showFirstLastItems=False):
  if not GC.Values[GC.SHOW_GETTINGS]:
    return None
  pageMessage = f'{Msg.GOT} {TOTAL_ITEMS_MARKER} {{0}}'
  if showFirstLastItems:
    pageMessage += f': {FIRST_ITEM_MARKER} - {LAST_ITEM_MARKER}'
  else:
    pageMessage += '...'
  if GC.Values[GC.SHOW_GETTINGS_GOT_NL]:
    pageMessage += '\n'
  else:
    GM.Globals[GM.LAST_GOT_MSG_LEN] = 0
  return pageMessage

def getPageMessageForWhom(forWhom=None, showFirstLastItems=False):
  if not GC.Values[GC.SHOW_GETTINGS]:
    return None
  if forWhom:
    Ent.SetGettingForWhom(forWhom)
  pageMessage = f'{Msg.GOT} {TOTAL_ITEMS_MARKER} {{0}}{Ent.GettingPostQualifier()} {Msg.FOR} {Ent.GettingForWhom()}'
  if showFirstLastItems:
    pageMessage += f': {FIRST_ITEM_MARKER} - {LAST_ITEM_MARKER}'
  else:
    pageMessage += '...'
  if GC.Values[GC.SHOW_GETTINGS_GOT_NL]:
    pageMessage += '\n'
  else:
    GM.Globals[GM.LAST_GOT_MSG_LEN] = 0
  return pageMessage

def printLine(message):
  writeStdout(message+'\n')

def printBlankLine():
  writeStdout('\n')

def printKeyValueList(kvList):
  writeStdout(formatKeyValueList(Ind.Spaces(), kvList, '\n'))

def printKeyValueListWithCount(kvList, i, count):
  writeStdout(formatKeyValueList(Ind.Spaces(), kvList, currentCountNL(i, count)))

def printKeyValueDict(kvDict):
  for key, value in iter(kvDict.items()):
    writeStdout(formatKeyValueList(Ind.Spaces(), [key, value], '\n'))

def printKeyValueWithCRsNLs(key, value):
  if value.find('\n') >= 0 or value.find('\r') >= 0:
    if GC.Values[GC.SHOW_CONVERT_CR_NL]:
      printKeyValueList([key, escapeCRsNLs(value)])
    else:
      printKeyValueList([key, ''])
      Ind.Increment()
      printKeyValueList([Ind.MultiLineText(value)])
      Ind.Decrement()
  else:
    printKeyValueList([key, value])

def printJSONKey(key):
  writeStdout(formatKeyValueList(Ind.Spaces(), [key, None], ''))

def printJSONValue(value):
  writeStdout(formatKeyValueList(' ', [value], '\n'))

def printEntity(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList),
                                 currentCountNL(i, count)))

def printEntityMessage(entityValueList, message, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[message],
                                 currentCountNL(i, count)))

def printEntitiesCount(entityType, entityList):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Plural(entityType), None if entityList is None else f'({len(entityList)})'],
                                 '\n'))

def printEntityKVList(entityValueList, infoKVList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+infoKVList,
                                 currentCountNL(i, count)))

def performAction(entityType, entityValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [f'{Act.ToPerform()} {Ent.Singular(entityType)} {entityValue}'],
                                 currentCountNL(i, count)))

def performActionNumItems(itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [f'{Act.ToPerform()} {itemCount} {Ent.Choose(itemType, itemCount)}'],
                                 currentCountNL(i, count)))

def performActionModifierNumItems(modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 [f'{Act.ToPerform()} {modifier} {itemCount} {Ent.Choose(itemType, itemCount)}'],
                                 currentCountNL(i, count)))

def actionNotPerformedNumItemsWarning(itemCount, itemType, errMessage, i=0, count=0):
  setSysExitRC(ACTION_NOT_PERFORMED_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Choose(itemType, itemCount), itemCount, Act.NotPerformed(), errMessage],
                                 currentCountNL(i, count)))

def entityPerformAction(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()}'],
                                 currentCountNL(i, count)))

def entityPerformActionNumItems(entityValueList, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {itemCount} {Ent.Choose(itemType, itemCount)}'],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItems(entityValueList, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier} {itemCount} {Ent.Choose(itemType, itemCount)}'],
                                 currentCountNL(i, count)))

def entityPerformActionNumItemsModifier(entityValueList, itemCount, itemType, modifier, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {itemCount} {Ent.Choose(itemType, itemCount)} {modifier}'],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItems(entityValueList, subitemType, modifier, itemCount, itemType, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {Ent.Plural(subitemType)} {modifier} {itemCount} {Ent.Choose(itemType, itemCount)}'],
                                 currentCountNL(i, count)))

def entityPerformActionSubItemModifierNumItemsModifierNewValue(entityValueList, subitemType, modifier1, itemCount, itemType, modifier2, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+
                                 [f'{Act.ToPerform()} {Ent.Plural(subitemType)} {modifier1} {itemCount} {Ent.Choose(itemType, itemCount)} {modifier2}', newValue],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNumItemsModifier(entityValueList, modifier1, itemCount, itemType, modifier2, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier1} {itemCount} {Ent.Choose(itemType, itemCount)} {modifier2}'],
                                 currentCountNL(i, count)))

def entityPerformActionModifierItemValueList(entityValueList, modifier, infoTypeValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier}', None]+Ent.FormatEntityValueList(infoTypeValueList),
                                 currentCountNL(i, count)))

def entityPerformActionModifierNewValue(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier}', newValue],
                                 currentCountNL(i, count)))

def entityPerformActionModifierNewValueItemValueList(entityValueList, modifier, newValue, infoTypeValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.ToPerform()} {modifier}', newValue]+Ent.FormatEntityValueList(infoTypeValueList),
                                 currentCountNL(i, count)))

def entityPerformActionItemValue(entityValueList, itemType, itemValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.ToPerform(), None, Ent.Singular(itemType), itemValue],
                                 currentCountNL(i, count)))

def entityPerformActionInfo(entityValueList, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.ToPerform(), infoValue],
                                 currentCountNL(i, count)))

def entityActionPerformed(entityValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[Act.Performed()],
                                 currentCountNL(i, count)))

def entityActionPerformedMessage(entityValueList, message, i=0, count=0):
  if message:
    writeStdout(formatKeyValueList(Ind.Spaces(),
                                   Ent.FormatEntityValueList(entityValueList)+[Act.Performed(), message],
                                   currentCountNL(i, count)))
  else:
    writeStdout(formatKeyValueList(Ind.Spaces(),
                                   Ent.FormatEntityValueList(entityValueList)+[Act.Performed()],
                                   currentCountNL(i, count)))

def entityModifierItemValueListActionPerformed(entityValueList, modifier, infoTypeValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.Performed()} {modifier}']+Ent.FormatEntityValueList(infoTypeValueList),
                                 currentCountNL(i, count)))

def entityModifierNewValueActionPerformed(entityValueList, modifier, newValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.Performed()} {modifier}', newValue],
                                 currentCountNL(i, count)))

def entityModifierNewValueItemValueListActionPerformed(entityValueList, modifier, newValue, infoTypeValueList, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.Performed()} {modifier}', newValue]+Ent.FormatEntityValueList(infoTypeValueList),
                                 currentCountNL(i, count)))

def entityModifierNewValueKeyValueActionPerformed(entityValueList, modifier, newValue, infoKey, infoValue, i=0, count=0):
  writeStdout(formatKeyValueList(Ind.Spaces(),
                                 Ent.FormatEntityValueList(entityValueList)+[f'{Act.Performed()} {modifier}', newValue, infoKey, infoValue],
                                 currentCountNL(i, count)))

def cleanFilename(filename):
  for ch in '\\/:':
    filename = filename.replace(ch, '_')
  return filename

def fileErrorMessage(filename, e):
  return f'{Ent.Singular(Ent.FILE)}: {filename}, {str(e)}'

def fdErrorMessage(f, defaultFilename, e):
  return fileErrorMessage(getattr(f, 'name') if hasattr(f, 'name') else defaultFilename, e)

# Set file encoding to handle UTF8 BOM
def setEncoding(mode, encoding):
  if 'b' in mode:
    return {}
  if not encoding:
    encoding = GM.Globals[GM.SYS_ENCODING]
  if 'r' in mode and encoding.lower().replace('-', '') == 'utf8':
    encoding = UTF8_SIG
  return {'encoding': encoding}

# Open a file
def openFile(filename, mode=DEFAULT_FILE_READ_MODE, encoding=None, errors=None, newline=None,
             continueOnError=False, displayError=True, stripUTFBOM=False):
  try:
    if filename != '-':
      kwargs = setEncoding(mode, encoding)
      f = open(os.path.expanduser(filename), mode, errors=errors, newline=newline, **kwargs)
      if stripUTFBOM:
        if 'b' in mode:
          if f.read(3) != b'\xef\xbb\xbf':
            f.seek(0)
        elif not kwargs['encoding'].lower().startswith('utf'):
          if f.read(3).encode('iso-8859-1', 'replace') != codecs.BOM_UTF8:
            f.seek(0)
        else:
          if f.read(1) != '\ufeff':
            f.seek(0)
      return f
    if 'r' in mode:
      return StringIOobject(str(sys.stdin.read()))
    if 'b' not in mode:
      return sys.stdout
    return os.fdopen(os.dup(sys.stdout.fileno()), 'wb')
  except (IOError, LookupError, UnicodeError) as e:
    if continueOnError:
      if displayError:
        stderrWarningMsg(fileErrorMessage(filename, e))
        setSysExitRC(FILE_ERROR_RC)
      return None
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))

# Close a file
def closeFile(f, forceFlush=False):
  try:
    if forceFlush:
      # Necessary to make sure file is flushed by both Python and OS
      # https://stackoverflow.com/a/13762137/1503886
      f.flush()
      os.fsync(f.fileno())
    f.close()
    return True
  except IOError as e:
    stderrErrorMsg(fdErrorMessage(f, 'Unknown', e))
    setSysExitRC(FILE_ERROR_RC)
    return False

# Read a file
def readFile(filename, mode=DEFAULT_FILE_READ_MODE, encoding=None, newline=None,
             continueOnError=False, displayError=True):
  try:
    if filename != '-':
      kwargs = setEncoding(mode, encoding)
      with open(os.path.expanduser(filename), mode, newline=newline, **kwargs) as f:
        return f.read()
    return str(sys.stdin.read())
  except (IOError, LookupError, UnicodeDecodeError, UnicodeError) as e:
    if continueOnError:
      if displayError:
        stderrWarningMsg(fileErrorMessage(filename, e))
        setSysExitRC(FILE_ERROR_RC)
      return None
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))

# Write a file
def writeFile(filename, data, mode=DEFAULT_FILE_WRITE_MODE,
              continueOnError=False, displayError=True):
  try:
    if filename != '-':
      kwargs = setEncoding(mode, None)
      with open(os.path.expanduser(filename), mode, **kwargs) as f:
        f.write(data)
      return True
    GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout).write(data)
    return True
  except (IOError, LookupError, UnicodeError) as e:
    if continueOnError:
      if displayError:
        stderrErrorMsg(fileErrorMessage(filename, e))
      setSysExitRC(FILE_ERROR_RC)
      return False
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))

# Write a file, return error
def writeFileReturnError(filename, data, mode=DEFAULT_FILE_WRITE_MODE):
  try:
    kwargs = {'encoding': GM.Globals[GM.SYS_ENCODING]} if 'b' not in mode else {}
    with open(os.path.expanduser(filename), mode, **kwargs) as f:
      f.write(data)
    return (True, None)
  except (IOError, LookupError, UnicodeError) as e:
    return (False, e)

# Delete a file
def deleteFile(filename, continueOnError=False, displayError=True):
  if os.path.isfile(filename):
    try:
      os.remove(filename)
    except OSError as e:
      if continueOnError:
        if displayError:
          stderrWarningMsg(fileErrorMessage(filename, e))
        return
      systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))

def getGDocSheetDataFailedExit(entityValueList, errMsg, i=0, count=0):
  Act.Set(Act.RETRIEVE_DATA)
  systemErrorExit(ACTION_FAILED_RC, formatKeyValueList(Ind.Spaces(),
                                                       Ent.FormatEntityValueList(entityValueList)+[Act.NotPerformed(), errMsg],
                                                       currentCountNL(i, count)))

# gdoc <EmailAddress> <DriveFileIDEntity>|<DriveFileNameEntity>
def getGDocData(mimeType):
  user = getEmailAddress()
  fileIdEntity = getDriveFileEntity(queryShortcutsOK=False)
  user, drive, jcount = _validateUserGetFileIDs(user, 0, 0, fileIdEntity)
  if not drive:
    sys.exit(GM.Globals[GM.SYSEXITRC])
  if jcount == 0:
    getGDocSheetDataFailedExit([Ent.USER, user], Msg.NO_ENTITIES_FOUND.format(Ent.Singular(Ent.DRIVE_FILE)))
  if jcount > 1:
    getGDocSheetDataFailedExit([Ent.USER, user], Msg.MULTIPLE_ENTITIES_FOUND.format(Ent.Plural(Ent.DRIVE_FILE), jcount, ','.join(fileIdEntity['list'])))
  fileId = fileIdEntity['list'][0]
  try:
    result = callGAPI(drive.files(), 'get',
                      throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                      fileId=fileId, fields='name,mimeType,exportLinks',
                      supportsAllDrives=True)
# Google Doc
    if 'exportLinks' in result:
      if mimeType != MIMETYPE_TEXT_PLAIN or mimeType not in result['exportLinks']:
        getGDocSheetDataFailedExit([Ent.USER, user, Ent.DRIVE_FILE, result['name']],
                                   Msg.INVALID_MIMETYPE.format(result['mimeType'], mimeType))
      f = TemporaryFile(mode='w+', encoding=UTF8)
      _, content = drive._http.request(uri=result['exportLinks'][mimeType], method='GET')
      f.write(content.decode(UTF8_SIG))
      f.seek(0)
      return f
# Drive File
    if result['mimeType'] != mimeType:
      getGDocSheetDataFailedExit([Ent.USER, user, Ent.DRIVE_FILE, result['name']],
                                 Msg.INVALID_MIMETYPE.format(result['mimeType'], mimeType))
    fb = TemporaryFile(mode='wb+')
    request = drive.files().get_media(fileId=fileId)
    downloader = googleapiclient.http.MediaIoBaseDownload(fb, request)
    done = False
    while not done:
      _, done = downloader.next_chunk()
    f = TemporaryFile(mode='w+', encoding=UTF8)
    fb.seek(0)
    f.write(fb.read().decode(UTF8_SIG))
    fb.close()
    f.seek(0)
    return f
  except GAPI.fileNotFound:
    getGDocSheetDataFailedExit([Ent.USER, user, Ent.DOCUMENT, fileId], Msg.DOES_NOT_EXIST)
  except (IOError, httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
    if f:
      f.close()
    getGDocSheetDataFailedExit([Ent.USER, user, Ent.DOCUMENT, fileId], str(e))
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e))
    sys.exit(GM.Globals[GM.SYSEXITRC])

# gsheet <EmailAddress> <DriveFileIDEntity>|<DriveFileNameEntity> <SheetEntity>
def getGSheetData():
  user = getEmailAddress()
  fileIdEntity = getDriveFileEntity(queryShortcutsOK=False)
  sheetEntity = getSheetEntity()
  user, drive, jcount = _validateUserGetFileIDs(user, 0, 0, fileIdEntity)
  if not drive:
    sys.exit(GM.Globals[GM.SYSEXITRC])
  if jcount == 0:
    getGDocSheetDataFailedExit([Ent.USER, user], Msg.NO_ENTITIES_FOUND.format(Ent.Singular(Ent.DRIVE_FILE)))
  if jcount > 1:
    getGDocSheetDataFailedExit([Ent.USER, user], Msg.MULTIPLE_ENTITIES_FOUND.format(Ent.Plural(Ent.DRIVE_FILE), jcount, ','.join(fileIdEntity['list'])))
  _, sheet = buildGAPIServiceObject(API.SHEETS, user)
  if not sheet:
    sys.exit(GM.Globals[GM.SYSEXITRC])
  fileId = fileIdEntity['list'][0]
  try:
    result = callGAPI(drive.files(), 'get',
                      throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                      fileId=fileId, fields='name,mimeType', supportsAllDrives=True)
    if result['mimeType'] != MIMETYPE_GA_SPREADSHEET:
      getGDocSheetDataFailedExit([Ent.USER, user, Ent.DRIVE_FILE, result['name']],
                                 Msg.INVALID_MIMETYPE.format(result['mimeType'], MIMETYPE_GA_SPREADSHEET))
    spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                           throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                           spreadsheetId=fileId, fields='spreadsheetUrl,sheets(properties(sheetId,title))')
    sheetId = getSheetIdFromSheetEntity(spreadsheet, sheetEntity)
    if sheetId is None:
      getGDocSheetDataFailedExit([Ent.USER, user, Ent.SPREADSHEET, result['name'], sheetEntity['sheetType'], sheetEntity['sheetValue']], Msg.NOT_FOUND)
    spreadsheetUrl = f'{re.sub("/edit.*$", "/export", spreadsheet["spreadsheetUrl"])}?format=csv&id={fileId}&gid={sheetId}'
    f = TemporaryFile(mode='w+', encoding=UTF8)
    _, content = drive._http.request(uri=spreadsheetUrl, method='GET')
    f.write(content.decode(UTF8_SIG))
    f.seek(0)
    return f
  except GAPI.fileNotFound:
    getGDocSheetDataFailedExit([Ent.USER, user, Ent.SPREADSHEET, fileId], Msg.DOES_NOT_EXIST)
  except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
          GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
    getGDocSheetDataFailedExit([Ent.USER, user, Ent.SPREADSHEET, fileId, sheetEntity['sheetType'], sheetEntity['sheetValue']], str(e))
  except (IOError, httplib2.HttpLib2Error) as e:
    if f:
      f.close()
    getGDocSheetDataFailedExit([Ent.USER, user, Ent.SPREADSHEET, fileId, sheetEntity['sheetType'], sheetEntity['sheetValue']], str(e))
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e))
    sys.exit(GM.Globals[GM.SYSEXITRC])

# Open a CSV file, get optional arguments [charset <String>] [warnifnodata] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
def openCSVFileReader(filename, fieldnames=None):
  if filename.lower() != 'gsheet':
    encoding = getCharSet()
    f = openFile(filename, mode=DEFAULT_CSV_READ_MODE, encoding=encoding)
  else:
    f = getGSheetData()
    getCharSet()
  if checkArgumentPresent('warnifnodata'):
    loc = f.tell()
    try:
      if not f.readline() or not f.readline():
        stderrWarningMsg(fileErrorMessage(filename, Msg.NO_CSV_FILE_DATA_FOUND))
        sys.exit(NO_ENTITIES_FOUND)
      f.seek(loc)
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))
  if checkArgumentPresent('columndelimiter'):
    columnDelimiter = getCharacter()
  else:
    columnDelimiter = GC.Values[GC.CSV_INPUT_COLUMN_DELIMITER]
  if checkArgumentPresent('quotechar'):
    quotechar = getCharacter()
  else:
    quotechar = GC.Values[GC.CSV_INPUT_QUOTE_CHAR]
  if checkArgumentPresent('fields'):
    fieldnames = shlexSplitList(getString(Cmd.OB_FIELD_NAME_LIST))
  try:
    csvFile = csv.DictReader(f, fieldnames=fieldnames, delimiter=columnDelimiter, quotechar=quotechar)
    return (f, csvFile, csvFile.fieldnames if csvFile.fieldnames is not None else [])
  except csv.Error as e:
    systemErrorExit(FILE_ERROR_RC, e)

def incrAPICallsRetryData(errMsg, delta):
  GM.Globals[GM.API_CALLS_RETRY_DATA].setdefault(errMsg, [0, 0.0])
  GM.Globals[GM.API_CALLS_RETRY_DATA][errMsg][0] += 1
  GM.Globals[GM.API_CALLS_RETRY_DATA][errMsg][1] += delta

def initAPICallsRateCheck():
  GM.Globals[GM.RATE_CHECK_COUNT] = 0
  GM.Globals[GM.RATE_CHECK_START] = time.time()

def checkAPICallsRate():
  GM.Globals[GM.RATE_CHECK_COUNT] += 1
  if GM.Globals[GM.RATE_CHECK_COUNT] >= GC.Values[GC.API_CALLS_RATE_LIMIT]:
    current = time.time()
    delta = int(current-GM.Globals[GM.RATE_CHECK_START])
    if 0 <= delta < 100:
      delta = (100-delta)+3
      error_message = f'API calls per 100 seconds limit {GC.Values[GC.API_CALLS_RATE_LIMIT]} exceeded'
      writeStderr(f'{WARNING_PREFIX}{error_message}: Backing off: {delta} seconds\n')
      flushStderr()
      time.sleep(delta)
      if GC.Values[GC.SHOW_API_CALLS_RETRY_DATA]:
        incrAPICallsRetryData(error_message, delta)
      GM.Globals[GM.RATE_CHECK_START] = time.time()
    else:
      GM.Globals[GM.RATE_CHECK_START] = current
    GM.Globals[GM.RATE_CHECK_COUNT] = 0

# Set global variables from config file
# Check for GAM updates based on status of no_update_check in config file
# Return True if there are additional commands on the command line
def SetGlobalVariables():

  def _stringInQuotes(value):
    return (len(value) > 1) and (((value.startswith('"') and value.endswith('"'))) or ((value.startswith("'") and value.endswith("'"))))

  def _stripStringQuotes(value):
    if _stringInQuotes(value):
      return value[1:-1]
    return value

  def _quoteStringIfLeadingTrailingBlanks(value):
    if not value:
      return "''"
    if _stringInQuotes(value):
      return value
    if (value[0] != ' ') and (value[-1] != ' '):
      return value
    return f"'{value}'"

  def _getDefault(itemName, itemEntry, oldGamPath):
    if GC.VAR_SIGFILE in itemEntry:
      GC.Defaults[itemName] = itemEntry[GC.VAR_SFFT][os.path.isfile(os.path.join(oldGamPath, itemEntry[GC.VAR_SIGFILE]))]
    elif GC.VAR_ENVVAR in itemEntry:
      value = os.environ.get(itemEntry[GC.VAR_ENVVAR], GC.Defaults[itemName])
      if itemEntry[GC.VAR_TYPE] in [GC.TYPE_INTEGER, GC.TYPE_FLOAT]:
        try:
          number = int(value) if itemEntry[GC.VAR_TYPE] == GC.TYPE_INTEGER else float(value)
          minVal, maxVal = itemEntry[GC.VAR_LIMITS]
          if (minVal is not None) and (number < minVal):
            number = minVal
          elif (maxVal is not None) and (number > maxVal):
            number = maxVal
        except ValueError:
          number = GC.Defaults[itemName]
        value = str(number)
      elif itemEntry[GC.VAR_TYPE] == GC.TYPE_STRING:
        value = _quoteStringIfLeadingTrailingBlanks(value)
      GC.Defaults[itemName] = value

  def _selectSection():
    value = getString(Cmd.OB_SECTION_NAME, minLen=0)
    if (not value) or (value.upper() == configparser.DEFAULTSECT):
      return configparser.DEFAULTSECT
    if GM.Globals[GM.PARSER].has_section(value):
      return value
    Cmd.Backup()
    usageErrorExit(formatKeyValueList('', [Ent.Singular(Ent.SECTION), value, Msg.NOT_FOUND], ''))

  def _checkMakeDir(itemName):
    if not os.path.isdir(GC.Defaults[itemName]):
      try:
        os.makedirs(GC.Defaults[itemName])
        printKeyValueList([Act.PerformedName(Act.CREATE), GC.Defaults[itemName]])
      except OSError as e:
        if not os.path.isdir(GC.Defaults[itemName]):
          systemErrorExit(FILE_ERROR_RC, e)

  def _copyCfgFile(srcFile, targetDir, oldGamPath):
    if (not srcFile) or os.path.isabs(srcFile):
      return
    dstFile = os.path.join(GC.Defaults[targetDir], srcFile)
    if os.path.isfile(dstFile):
      return
    srcFile = os.path.join(oldGamPath, srcFile)
    if not os.path.isfile(srcFile):
      return
    data = readFile(srcFile, continueOnError=True, displayError=False)
    if (data is not None) and writeFile(dstFile, data, continueOnError=True):
      printKeyValueList([Act.PerformedName(Act.COPY), srcFile, Msg.TO, dstFile])

  def _printValueError(sectionName, itemName, value, errMessage, sysRC=CONFIG_ERROR_RC):
    kvlMsg = formatKeyValueList('',
                                [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                 Ent.Singular(Ent.SECTION), sectionName,
                                 Ent.Singular(Ent.ITEM), itemName,
                                 Ent.Singular(Ent.VALUE), value,
                                 errMessage],
                                '')
    if sysRC != 0:
      status['errors'] = True
      printErrorMessage(sysRC, kvlMsg)
    else:
      writeStderr(formatKeyValueList(Ind.Spaces(), [WARNING, kvlMsg], '\n'))

  def _getCfgBoolean(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName).lower()
    if value in TRUE_VALUES:
      return True
    if value in FALSE_VALUES:
      return False
    _printValueError(sectionName, itemName, value, f'{Msg.EXPECTED}: {formatChoiceList(TRUE_FALSE)}')
    return False

  def _getCfgCharacter(sectionName, itemName):
    value = codecs.escape_decode(bytes(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)), UTF8))[0].decode(UTF8)
    if not value and (itemName == 'csv_output_field_delimiter'):
      return ' '
    if len(value) == 1:
      return value
    _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.EXPECTED}: {integerLimits(1, 1, Msg.STRING_LENGTH)}')
    return ''

  def _getCfgChoice(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)).lower()
    choices = GC.VAR_INFO[itemName][GC.VAR_CHOICES]
    if value in choices:
      return choices[value]
    _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.EXPECTED}: {",".join(choices)}')
    return ''

  def _getCfgLocale(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)).lower().replace('-', '_')
    if value in LOCALE_CODES_MAP:
      return LOCALE_CODES_MAP[value]
    _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.EXPECTED}: {",".join(LOCALE_CODES_MAP)}')
    return ''

  def _getCfgNumber(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName)
    minVal, maxVal = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
    try:
      number = int(value) if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_INTEGER else float(value)
      if ((minVal is None) or (number >= minVal)) and ((maxVal is None) or (number <= maxVal)):
        return number
      if (minVal is not None) and (number < minVal):
        number = minVal
      else:
        number = maxVal
      _printValueError(sectionName, itemName, value, f'{Msg.EXPECTED}: {integerLimits(minVal, maxVal)}, {Msg.USED}: {number}', sysRC=0)
      return number
    except ValueError:
      pass
    _printValueError(sectionName, itemName, value, f'{Msg.EXPECTED}: {integerLimits(minVal, maxVal)}')
    return 0

  def _getCfgHeaderFilter(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName)
    headerFilters = []
    if not value:
      return headerFilters
    splitStatus, filters = shlexSplitListStatus(value)
    if splitStatus:
      for filterStr in filters:
        try:
          headerFilters.append(re.compile(filterStr, re.IGNORECASE))
        except re.error as e:
          _printValueError(sectionName, itemName, f'"{filterStr}"', f'{Msg.INVALID_RE}: {e}')
    else:
      _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.INVALID_LIST}: {filters}')
    return headerFilters

  ROW_FILTER_COMP_PATTERN = re.compile(r'^(date|time|count)\s*([<>]=?|=|!=)(.+)$', re.IGNORECASE)
  ROW_FILTER_RANGE_PATTERN = re.compile(r'^(daterange|timerange|countrange)(=|!=)(\S+)/(\S+)$', re.IGNORECASE)
  ROW_FILTER_BOOL_PATTERN = re.compile(r'^(boolean):(.+)$', re.IGNORECASE)
  ROW_FILTER_RE_PATTERN = re.compile(r'^(regex|regexcs|notregex|notregexcs):(.*)$', re.IGNORECASE)

  def _getCfgRowFilter(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName)
    rowFilters = []
    if not value:
      return rowFilters
    if value.startswith('{'):
      try:
        filterDict = json.loads(value.encode('unicode-escape').decode(UTF8))
      except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
        _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.FAILED_TO_PARSE_AS_JSON}: {str(e)}')
        return rowFilters
    else:
      filterDict = {}
      status, filterList = shlexSplitListStatus(value)
      if not status:
        _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.FAILED_TO_PARSE_AS_LIST}: {str(filterList)}')
        return rowFilters
      for filterVal in filterList:
        if not filterVal:
          continue
        try:
          filterTokens = shlexSplitList(filterVal, ':')
          column = filterTokens[0]
          filterStr = ':'.join(filterTokens[1:])
        except ValueError:
          _printValueError(sectionName, itemName, f'"{filterVal}"', f'{Msg.EXPECTED}: column:filter')
          continue
        filterDict[column] = filterStr
    for column, filterStr in iter(filterDict.items()):
      try:
        columnPat = re.compile(column, re.IGNORECASE)
      except re.error as e:
        _printValueError(sectionName, itemName, f'"{column}"', f'{Msg.INVALID_RE}: {e}')
        continue
      mg = ROW_FILTER_COMP_PATTERN.match(filterStr)
      if mg:
        filterType = mg.group(1).lower()
        if filterType in {'date', 'time'}:
          if filterType == 'date':
            valid, filterValue = getRowFilterDateOrDeltaFromNow(mg.group(3))
          else:
            valid, filterValue = getRowFilterTimeOrDeltaFromNow(mg.group(3))
          if valid:
            rowFilters.append((columnPat, filterType, mg.group(2), filterValue))
          else:
            _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: {filterValue}')
        else: #count
          if mg.group(3).isdigit():
            rowFilters.append((columnPat, filterType, mg.group(2), int(mg.group(3))))
          else:
            _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: <Number>')
        continue
      mg = ROW_FILTER_RANGE_PATTERN.match(filterStr)
      if mg:
        filterType = mg.group(1).lower()
        if filterType in {'daterange', 'timerange'}:
          if filterType == 'daterange':
            valid1, filterValue1 = getRowFilterDateOrDeltaFromNow(mg.group(3))
            valid2, filterValue2 = getRowFilterDateOrDeltaFromNow(mg.group(4))
          else:
            valid1, filterValue1 = getRowFilterTimeOrDeltaFromNow(mg.group(3))
            valid2, filterValue2 = getRowFilterTimeOrDeltaFromNow(mg.group(4))
          if valid1 and valid2:
            rowFilters.append((columnPat, filterType, mg.group(2), filterValue1, filterValue2))
          else:
            _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: {filterValue1}/{filterValue2}')
        else: #countrange
          if mg.group(3).isdigit() and mg.group(4).isdigit():
            rowFilters.append((columnPat, filterType, mg.group(2), int(mg.group(3)), int(mg.group(4))))
          else:
            _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: <Number>/<Number>')
        continue
      mg = ROW_FILTER_BOOL_PATTERN.match(filterStr)
      if mg:
        filterType = mg.group(1).lower()
        filterValue = mg.group(2).lower()
        if filterValue in TRUE_VALUES:
          rowFilters.append((columnPat, filterType, True))
        elif filterValue in FALSE_VALUES:
          rowFilters.append((columnPat, filterType, False))
        else:
          _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: <Boolean>')
        continue
      mg = ROW_FILTER_RE_PATTERN.match(filterStr)
      if mg:
        filterType = mg.group(1).lower()
        try:
          if filterType.endswith('cs'):
            filterType = filterType[0:-2]
            flags = 0
          else:
            flags = re.IGNORECASE
          rowFilters.append((columnPat, filterType, re.compile(mg.group(2), flags)))
        except re.error as e:
          _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.INVALID_RE}: {e}')
        continue
      _printValueError(sectionName, itemName, f'"{column}": "{filterStr}"', f'{Msg.EXPECTED}: date|time|count<Operator><Value> or boolean:<Boolean> or regex:<RegularExpression>')
    return rowFilters

  def _getCfgSection(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName))
    if (not value) or (value.upper() == configparser.DEFAULTSECT):
      return configparser.DEFAULTSECT
    if GM.Globals[GM.PARSER].has_section(value):
      return value
    _printValueError(sectionName, itemName, value, Msg.NOT_FOUND)
    return configparser.DEFAULTSECT

  def _getCfgPassword(sectionName, itemName):
    value = GM.Globals[GM.PARSER].get(sectionName, itemName)
    if isinstance(value, bytes):
      return value
    value = _stripStringQuotes(value)
    if value.startswith("b'") and value.endswith("'"):
      return bytes(value[2:-1], UTF8)
    if value:
      return value
    return ''

  def _getCfgString(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName))
    minLen, maxLen = GC.VAR_INFO[itemName].get(GC.VAR_LIMITS, (None, None))
    if ((minLen is None) or (len(value) >= minLen)) and ((maxLen is None) or (len(value) <= maxLen)):
      return value
    _printValueError(sectionName, itemName, f'"{value}"', f'{Msg.EXPECTED}: {integerLimits(minLen, maxLen, Msg.STRING_LENGTH)}')
    return ''

  def _getCfgTimezone(sectionName, itemName):
    value = _stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName).lower())
    if value == 'utc':
      GM.Globals[GM.CONVERT_TO_LOCAL_TIME] = False
      return iso8601.UTC
    GM.Globals[GM.CONVERT_TO_LOCAL_TIME] = True
    if value == 'local':
      return iso8601.Local
    try:
      return iso8601.parse_timezone_str(value)
    except (iso8601.ParseError, OverflowError):
      _printValueError(sectionName, itemName, value, f'{Msg.EXPECTED}: {TIMEZONE_FORMAT_REQUIRED}')
      GM.Globals[GM.CONVERT_TO_LOCAL_TIME] = False
      return iso8601.UTC

  def _getCfgDirectory(sectionName, itemName):
    dirPath = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)))
    if (not dirPath) or (not os.path.isabs(dirPath)):
      if (sectionName != configparser.DEFAULTSECT) and (GM.Globals[GM.PARSER].has_option(sectionName, itemName)):
        dirPath = os.path.join(os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, itemName))), dirPath)
      if not os.path.isabs(dirPath):
        dirPath = os.path.join(GM.Globals[GM.GAM_CFG_PATH], dirPath)
    return dirPath

  def _getCfgFile(sectionName, itemName):
    value = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(sectionName, itemName)))
    if value and not os.path.isabs(value):
      value = os.path.expanduser(os.path.join(_getCfgDirectory(sectionName, GC.CONFIG_DIR), value))
    elif not value and itemName == GC.CACERTS_PEM:
      if hasattr(sys, '_MEIPASS'):
        value = os.path.join(sys._MEIPASS, GC.FN_CACERTS_PEM) #pylint: disable=no-member
      else:
        value = os.path.join(GM.Globals[GM.GAM_PATH], GC.FN_CACERTS_PEM)
    return value

  def _readGamCfgFile(config, fileName):
    try:
      with open(fileName, 'r') as f:
        config.read_file(f)
    except (configparser.MissingSectionHeaderError, configparser.ParsingError) as e:
      systemErrorExit(CONFIG_ERROR_RC, formatKeyValueList('',
                                                          [Ent.Singular(Ent.CONFIG_FILE), fileName,
                                                           Msg.INVALID, str(e)],
                                                          ''))
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, fileErrorMessage(fileName, e))

  def _writeGamCfgFile(config, fileName, action):
    GM.Globals[GM.SECTION] = None # No need to save section for inner gams
    try:
      with open(fileName, DEFAULT_FILE_WRITE_MODE) as f:
        config.write(f)
      printKeyValueList([Ent.Singular(Ent.CONFIG_FILE), fileName, Act.PerformedName(action)])
    except IOError as e:
      stderrErrorMsg(fileErrorMessage(fileName, e))

  def _verifyValues(sectionName):
    printKeyValueList([Ent.Singular(Ent.SECTION), sectionName]) # Do not use printEntity
    Ind.Increment()
    for itemName in sorted(GC.VAR_INFO):
      cfgValue = GM.Globals[GM.PARSER].get(sectionName, itemName)
      varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
      if varType == GC.TYPE_CHOICE:
        for choice, value in iter(GC.VAR_INFO[itemName][GC.VAR_CHOICES].items()):
          if cfgValue == value:
            cfgValue = choice
            break
      elif varType not in [GC.TYPE_BOOLEAN, GC.TYPE_INTEGER, GC.TYPE_FLOAT, GC.TYPE_PASSWORD]:
        cfgValue = _quoteStringIfLeadingTrailingBlanks(cfgValue)
      if varType == GC.TYPE_FILE:
        expdValue = _getCfgFile(sectionName, itemName)
        if cfgValue not in ("''", expdValue):
          cfgValue = f'{cfgValue} ; {expdValue}'
      elif varType == GC.TYPE_DIRECTORY:
        expdValue = _getCfgDirectory(sectionName, itemName)
        if cfgValue not in ("''", expdValue):
          cfgValue = f'{cfgValue} ; {expdValue}'
      elif (itemName == GC.SECTION) and (sectionName != configparser.DEFAULTSECT):
        continue
      printLine(f'{Ind.Spaces()}{itemName} = {cfgValue}')
    Ind.Decrement()

  def _chkCfgDirectories(sectionName):
    for itemName in GC.VAR_INFO:
      if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_DIRECTORY:
        dirPath = GC.Values[itemName]
        if (itemName != GC.CACHE_DIR or not GC.Values[GC.NO_CACHE]) and not os.path.isdir(dirPath):
          writeStderr(formatKeyValueList(WARNING_PREFIX,
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), dirPath,
                                          Msg.INVALID_PATH],
                                         '\n'))

  def _chkCfgFiles(sectionName):
    for itemName in GC.VAR_INFO:
      if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_FILE:
        fileName = GC.Values[itemName]
        if (not fileName) and (itemName == GC.EXTRA_ARGS):
          continue
        if not os.path.isfile(fileName):
          writeStderr(formatKeyValueList([WARNING_PREFIX, ERROR_PREFIX][itemName == GC.CACERTS_PEM],
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), fileName,
                                          Msg.NOT_FOUND],
                                         '\n'))
          if itemName == GC.CACERTS_PEM:
            status['errors'] = True
        elif not os.access(fileName, GC.VAR_INFO[itemName][GC.VAR_ACCESS]):
          writeStderr(formatKeyValueList(ERROR_PREFIX,
                                         [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                          Ent.Singular(Ent.SECTION), sectionName,
                                          Ent.Singular(Ent.ITEM), itemName,
                                          Ent.Singular(Ent.VALUE), fileName,
                                          [Msg.NEED_READ_ACCESS, Msg.NEED_READ_WRITE_ACCESS][GC.VAR_INFO[itemName][GC.VAR_ACCESS] == os.R_OK | os.W_OK]],
                                         '\n'))
          status['errors'] = True

  def _setCSVFile(fileName, mode, encoding, writeHeader, multi):
    if fileName != '-':
      if fileName.startswith('./') or fileName.startswith('.\\'):
        fileName = os.path.join(os.getcwd(), fileName[2:])
      else:
        fileName = os.path.expanduser(fileName)
      if not os.path.isabs(fileName):
        fileName = os.path.join(GC.Values[GC.DRIVE_DIR], fileName)
    GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] = fileName
    GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE] = mode
    GM.Globals[GM.CSVFILE][GM.REDIRECT_ENCODING] = encoding
    GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER] = writeHeader
    GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS] = multi
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = None

  def _setSTDFile(stdtype, fileName, mode, multi):
    if stdtype == GM.STDOUT:
      GM.Globals[GM.SAVED_STDOUT] = None
    GM.Globals[stdtype][GM.REDIRECT_STD] = False
    if fileName == 'null':
      GM.Globals[stdtype][GM.REDIRECT_FD] = open(os.devnull, mode)
    elif fileName == '-':
      GM.Globals[stdtype][GM.REDIRECT_STD] = True
      if stdtype == GM.STDOUT:
        GM.Globals[stdtype][GM.REDIRECT_FD] = os.fdopen(os.dup(sys.stdout.fileno()), mode, encoding=GM.Globals[GM.SYS_ENCODING])
      else:
        GM.Globals[stdtype][GM.REDIRECT_FD] = os.fdopen(os.dup(sys.stderr.fileno()), mode, encoding=GM.Globals[GM.SYS_ENCODING])
    else:
      if fileName.startswith('./') or fileName.startswith('.\\'):
        fileName = os.path.join(os.getcwd(), fileName[2:])
      else:
        fileName = os.path.expanduser(fileName)
      if not os.path.isabs(fileName):
        fileName = os.path.join(GC.Values[GC.DRIVE_DIR], fileName)
      if multi and mode == DEFAULT_FILE_WRITE_MODE:
        deleteFile(fileName)
        mode = DEFAULT_FILE_APPEND_MODE
      GM.Globals[stdtype][GM.REDIRECT_FD] = openFile(fileName, mode)
    GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = GM.Globals[stdtype][GM.REDIRECT_FD] if not multi else StringIOobject()
    if (stdtype == GM.STDOUT) and (GC.Values[GC.DEBUG_LEVEL] > 0):
      GM.Globals[GM.SAVED_STDOUT] = sys.stdout
      sys.stdout = GM.Globals[stdtype][GM.REDIRECT_MULTI_FD]
    GM.Globals[stdtype][GM.REDIRECT_NAME] = fileName
    GM.Globals[stdtype][GM.REDIRECT_MODE] = mode
    GM.Globals[stdtype][GM.REDIRECT_MULTIPROCESS] = multi
    GM.Globals[stdtype][GM.REDIRECT_QUEUE] = 'stdout' if stdtype == GM.STDOUT else 'stderr'

  if not GM.Globals[GM.PARSER]:
    homePath = os.path.expanduser('~')
    GM.Globals[GM.GAM_CFG_PATH] = os.environ.get('GAMCFGDIR', None)
    if GM.Globals[GM.GAM_CFG_PATH]:
      GM.Globals[GM.GAM_CFG_PATH] = os.path.expanduser(GM.Globals[GM.GAM_CFG_PATH])
    else:
      GM.Globals[GM.GAM_CFG_PATH] = os.path.join(homePath, '.gam')
    GC.Defaults[GC.CONFIG_DIR] = GM.Globals[GM.GAM_CFG_PATH]
    GC.Defaults[GC.CACHE_DIR] = os.path.join(GM.Globals[GM.GAM_CFG_PATH], 'gamcache')
    GC.Defaults[GC.DRIVE_DIR] = os.path.join(homePath, 'Downloads')
    GM.Globals[GM.GAM_CFG_FILE] = os.path.join(GM.Globals[GM.GAM_CFG_PATH], FN_GAM_CFG)
    if not os.path.isfile(GM.Globals[GM.GAM_CFG_FILE]):
      for itemName, itemEntry in iter(GC.VAR_INFO.items()):
        if itemEntry[GC.VAR_TYPE] == GC.TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, None)
      oldGamPath = os.environ.get('OLDGAMPATH', GC.Defaults[GC.CONFIG_DIR])
      for itemName, itemEntry in iter(GC.VAR_INFO.items()):
        if itemEntry[GC.VAR_TYPE] != GC.TYPE_DIRECTORY:
          _getDefault(itemName, itemEntry, oldGamPath)
      GM.Globals[GM.PARSER] = configparser.RawConfigParser(defaults=collections.OrderedDict(sorted(list(GC.Defaults.items()), key=lambda t: t[0])))
      _checkMakeDir(GC.CONFIG_DIR)
      _checkMakeDir(GC.CACHE_DIR)
      _checkMakeDir(GC.DRIVE_DIR)
      for itemName in GC.VAR_INFO:
        if GC.VAR_INFO[itemName][GC.VAR_TYPE] == GC.TYPE_FILE:
          srcFile = os.path.expanduser(_stripStringQuotes(GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, itemName)))
          _copyCfgFile(srcFile, GC.CONFIG_DIR, oldGamPath)
      _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.INITIALIZE)
    else:
      GM.Globals[GM.PARSER] = configparser.RawConfigParser(defaults=collections.OrderedDict(sorted(list(GC.Defaults.items()), key=lambda t: t[0])))
      _readGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE])
    GM.Globals[GM.LAST_UPDATE_CHECK_TXT] = os.path.join(_getCfgDirectory(configparser.DEFAULTSECT, GC.CONFIG_DIR), FN_LAST_UPDATE_CHECK_TXT)
  status = {'errors': False}
  sectionName = _getCfgSection(configparser.DEFAULTSECT, GC.SECTION)
  filterSectionName = None
# select <SectionName> [save] [verify]
  if checkArgumentPresent(Cmd.SELECT_CMD):
    sectionName = _selectSection()
    GM.Globals[GM.SECTION] = sectionName # Save section for inner gams
    while Cmd.ArgumentsRemaining():
      if checkArgumentPresent('save'):
        GM.Globals[GM.PARSER].set(configparser.DEFAULTSECT, GC.SECTION, sectionName)
        _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.SAVE)
      elif checkArgumentPresent('verify'):
        _verifyValues(sectionName)
      else:
        break
# selectfilter <SectionName>
  if checkArgumentPresent(Cmd.SELECTFILTER_CMD):
    filterSectionName = _selectSection()
# Handle todrive_nobrowser and todrive_noemail if not present
  value = GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, GC.TODRIVE_NOBROWSER)
  if value == '':
    GM.Globals[GM.PARSER].set(configparser.DEFAULTSECT, GC.TODRIVE_NOBROWSER, str(_getCfgBoolean(configparser.DEFAULTSECT, GC.NO_BROWSER)).lower())
  value = GM.Globals[GM.PARSER].get(configparser.DEFAULTSECT, GC.TODRIVE_NOEMAIL)
  if value == '':
    GM.Globals[GM.PARSER].set(configparser.DEFAULTSECT, GC.TODRIVE_NOEMAIL, str(not _getCfgBoolean(configparser.DEFAULTSECT, GC.NO_BROWSER)).lower())
# config (<VariableName> [=] <Value>)* [save] [verify]
  if checkArgumentPresent(Cmd.CONFIG_CMD):
    while Cmd.ArgumentsRemaining():
      if checkArgumentPresent('save'):
        _writeGamCfgFile(GM.Globals[GM.PARSER], GM.Globals[GM.GAM_CFG_FILE], Act.SAVE)
      elif checkArgumentPresent('verify'):
        _verifyValues(sectionName)
      else:
        itemName = getChoice(GC.VAR_INFO, defaultChoice=None)
        if itemName is None:
          break
        checkArgumentPresent('=')
        varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
        if varType == GC.TYPE_BOOLEAN:
          value = TRUE if getBoolean(None) else FALSE
        elif varType == GC.TYPE_CHARACTER:
          value = getCharacter()
        elif varType == GC.TYPE_CHOICE:
          value = getChoice(GC.VAR_INFO[itemName][GC.VAR_CHOICES])
        elif varType == GC.TYPE_INTEGER:
          minVal, maxVal = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
          value = str(getInteger(minVal=minVal, maxVal=maxVal))
        elif varType == GC.TYPE_FLOAT:
          minVal, maxVal = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
          value = str(getFloat(minVal=minVal, maxVal=maxVal))
        elif varType == GC.TYPE_LOCALE:
          value = getLocaleCode()
        elif varType == GC.TYPE_PASSWORD:
          minLen, maxLen = GC.VAR_INFO[itemName][GC.VAR_LIMITS]
          value = getString(Cmd.OB_STRING, checkBlank=True, minLen=minLen, maxLen=maxLen)
          if value and value.startswith("b'") and value.endswith("'"):
            value = bytes(value[2:-1], UTF8)
        elif varType == GC.TYPE_TIMEZONE:
          value = getString(Cmd.OB_STRING, checkBlank=True)
        else:
          minLen, maxLen = GC.VAR_INFO[itemName].get(GC.VAR_LIMITS, (0, None))
          value = _quoteStringIfLeadingTrailingBlanks(getString(Cmd.OB_STRING, minLen=minLen, maxLen=maxLen))
        GM.Globals[GM.PARSER].set(sectionName, itemName, value)
  prevExtraArgsTxt = GC.Values.get(GC.EXTRA_ARGS, None)
  prevOauth2serviceJson = GC.Values.get(GC.OAUTH2SERVICE_JSON, None)
# Assign global variables, directories, timezone first as other variables depend on them
  for itemName in sorted(GC.VAR_INFO):
    varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
    if varType == GC.TYPE_DIRECTORY:
      GC.Values[itemName] = _getCfgDirectory(sectionName, itemName)
    elif varType == GC.TYPE_TIMEZONE:
      GC.Values[itemName] = _getCfgTimezone(sectionName, itemName)
  GM.Globals[GM.DATETIME_NOW] = datetime.datetime.now(GC.Values[GC.TIMEZONE])
# Everything else
  for itemName in sorted(GC.VAR_INFO):
    varType = GC.VAR_INFO[itemName][GC.VAR_TYPE]
    if varType == GC.TYPE_BOOLEAN:
      GC.Values[itemName] = _getCfgBoolean(sectionName, itemName)
    elif varType == GC.TYPE_CHARACTER:
      GC.Values[itemName] = _getCfgCharacter(sectionName, itemName)
    elif varType == GC.TYPE_CHOICE:
      GC.Values[itemName] = _getCfgChoice(sectionName, itemName)
    elif varType in [GC.TYPE_INTEGER, GC.TYPE_FLOAT]:
      GC.Values[itemName] = _getCfgNumber(sectionName, itemName)
    elif varType == GC.TYPE_HEADERFILTER:
      GC.Values[itemName] = _getCfgHeaderFilter(sectionName, itemName)
    elif varType == GC.TYPE_LOCALE:
      GC.Values[itemName] = _getCfgLocale(sectionName, itemName)
    elif varType == GC.TYPE_ROWFILTER:
      GC.Values[itemName] = _getCfgRowFilter(sectionName, itemName)
    elif varType == GC.TYPE_PASSWORD:
      GC.Values[itemName] = _getCfgPassword(sectionName, itemName)
    elif varType == GC.TYPE_STRING:
      GC.Values[itemName] = _getCfgString(sectionName, itemName)
    elif varType == GC.TYPE_FILE:
      GC.Values[itemName] = _getCfgFile(sectionName, itemName)
# Process selectfilter
  if filterSectionName:
    GC.Values[GC.CSV_OUTPUT_HEADER_FILTER] = _getCfgHeaderFilter(filterSectionName, GC.CSV_OUTPUT_HEADER_FILTER)
    GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER] = _getCfgHeaderFilter(filterSectionName, GC.CSV_OUTPUT_HEADER_DROP_FILTER)
    GC.Values[GC.CSV_OUTPUT_ROW_FILTER] = _getCfgRowFilter(filterSectionName, GC.CSV_OUTPUT_ROW_FILTER)
    GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER] = _getCfgRowFilter(filterSectionName, GC.CSV_OUTPUT_ROW_DROP_FILTER)
  if status['errors']:
    sys.exit(CONFIG_ERROR_RC)
# Global values cleanup
  GC.Values[GC.DOMAIN] = GC.Values[GC.DOMAIN].lower()
  if not GC.Values[GC.SMTP_FQDN]:
    GC.Values[GC.SMTP_FQDN] = None
# Create/set mode for oauth2.txt.lock
  if not GM.Globals[GM.OAUTH2_TXT_LOCK]:
    fileName = f'{GC.Values[GC.OAUTH2_TXT]}.lock'
    if not os.path.isfile(fileName):
      closeFile(openFile(fileName, mode=DEFAULT_FILE_APPEND_MODE))
      os.chmod(fileName, 0o666)
    GM.Globals[GM.OAUTH2_TXT_LOCK] = fileName
# Override httplib2 settings
  httplib2.debuglevel = GC.Values[GC.DEBUG_LEVEL]
# Reset global variables if required
  if prevExtraArgsTxt != GC.Values[GC.EXTRA_ARGS]:
    GM.Globals[GM.EXTRA_ARGS_LIST] = [('prettyPrint', GC.Values[GC.DEBUG_LEVEL] > 0)]
    if GC.Values[GC.EXTRA_ARGS]:
      ea_config = configparser.ConfigParser()
      ea_config.optionxform = str
      ea_config.read(GC.Values[GC.EXTRA_ARGS])
      GM.Globals[GM.EXTRA_ARGS_LIST].extend(ea_config.items('extra-args'))
  if prevOauth2serviceJson != GC.Values[GC.OAUTH2SERVICE_JSON]:
    GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = {}
    GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID] = None
  Cmd.SetEncoding(GM.Globals[GM.SYS_ENCODING])
# redirect csv <FileName> [multiprocess] [append] [noheader] [charset <CharSet>]
#	       [columndelimiter <Character>] [quotechar <Character>]]
#	       [todrive <ToDriveAttribute>*]
# redirect stdout <FileName> [multiprocess] [append]
# redirect stdout null
# redirect stderr <FileName> [multiprocess] [append]
# redirect stderr stdout
# redirect stderr null
  while checkArgumentPresent(Cmd.REDIRECT_CMD):
    myarg = getChoice(['csv', 'stdout', 'stderr'])
    filename = re.sub(r'{{Section}}', sectionName, getString(Cmd.OB_FILE_NAME, checkBlank=True))
    if myarg == 'csv':
      multi = checkArgumentPresent('multiprocess')
      mode = DEFAULT_FILE_APPEND_MODE if checkArgumentPresent('append') else DEFAULT_FILE_WRITE_MODE
      writeHeader = not checkArgumentPresent('noheader')
      encoding = getCharSet()
      if checkArgumentPresent('columndelimiter'):
        GM.Globals[GM.CSV_OUTPUT_COLUMN_DELIMITER] = GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER] = getCharacter()
      if checkArgumentPresent('quotechar'):
        GM.Globals[GM.CSV_OUTPUT_QUOTE_CHAR] = GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR] = getCharacter()
      _setCSVFile(filename, mode, encoding, writeHeader, multi)
      GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE_CSVPF] = CSVPrintFile()
      if checkArgumentPresent('todrive'):
        GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE_CSVPF].GetTodriveParameters()
        GM.Globals[GM.CSV_TODRIVE] = GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE_CSVPF].todrive.copy()
    elif myarg == 'stdout':
      if filename.lower() == 'null':
        multi = checkArgumentPresent('multiprocess')
        _setSTDFile(GM.STDOUT, 'null', DEFAULT_FILE_WRITE_MODE, multi)
      else:
        multi = checkArgumentPresent('multiprocess')
        mode = DEFAULT_FILE_APPEND_MODE if checkArgumentPresent('append') else DEFAULT_FILE_WRITE_MODE
        _setSTDFile(GM.STDOUT, filename, mode, multi)
        if GM.Globals[GM.CSVFILE].get(GM.REDIRECT_NAME) == '-':
          GM.Globals[GM.CSVFILE] = {}
    else: # myarg == 'stderr'
      if filename.lower() == 'null':
        multi = checkArgumentPresent('multiprocess')
        _setSTDFile(GM.STDERR, 'null', DEFAULT_FILE_WRITE_MODE, multi)
      elif filename.lower() != 'stdout':
        multi = checkArgumentPresent('multiprocess')
        mode = DEFAULT_FILE_APPEND_MODE if checkArgumentPresent('append') else DEFAULT_FILE_WRITE_MODE
        _setSTDFile(GM.STDERR, filename, mode, multi)
      else:
        multi = checkArgumentPresent('multiprocess')
        if not GM.Globals[GM.STDOUT]:
          _setSTDFile(GM.STDOUT, '-', DEFAULT_FILE_WRITE_MODE, multi)
        GM.Globals[GM.STDERR] = GM.Globals[GM.STDOUT].copy()
        GM.Globals[GM.STDERR][GM.REDIRECT_NAME] = 'stdout'
  if not GM.Globals[GM.STDOUT]:
    _setSTDFile(GM.STDOUT, '-', DEFAULT_FILE_WRITE_MODE, False)
  if not GM.Globals[GM.STDERR]:
    _setSTDFile(GM.STDERR, '-', DEFAULT_FILE_WRITE_MODE, False)
  if not GM.Globals[GM.CSVFILE]:
    _setCSVFile('-', GM.Globals[GM.STDOUT].get(GM.REDIRECT_MODE, DEFAULT_FILE_WRITE_MODE), GC.Values[GC.CHARSET], True, False)
  if not GC.Values[GC.NO_UPDATE_CHECK]:
    doGAMCheckForUpdates(0)
  initAPICallsRateCheck()
# Inherit csv_output_header_filter/csv_output_row_filter if not locally defined
  if GM.Globals[GM.PID] != 0:
    if not GC.Values[GC.CSV_OUTPUT_HEADER_FILTER]:
      GC.Values[GC.CSV_OUTPUT_HEADER_FILTER] = GM.Globals[GM.CSV_OUTPUT_HEADER_FILTER][:]
    if not GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER]:
      GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER] = GM.Globals[GM.CSV_OUTPUT_HEADER_DROP_FILTER][:]
    if not GC.Values[GC.CSV_OUTPUT_ROW_FILTER]:
      GC.Values[GC.CSV_OUTPUT_ROW_FILTER] = GM.Globals[GM.CSV_OUTPUT_ROW_FILTER][:]
    if not GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER]:
      GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER] = GM.Globals[GM.CSV_OUTPUT_ROW_DROP_FILTER][:]
# If no select/options commands were executed or some were and there are more arguments on the command line,
# warn if the json files are missing and return True
  if (Cmd.Location() == 1) or (Cmd.ArgumentsRemaining()):
    _chkCfgDirectories(sectionName)
    _chkCfgFiles(sectionName)
    if status['errors']:
      sys.exit(CONFIG_ERROR_RC)
    if GC.Values[GC.NO_CACHE]:
      GM.Globals[GM.CACHE_DIR] = None
      GM.Globals[GM.CACHE_DISCOVERY_ONLY] = False
    else:
      GM.Globals[GM.CACHE_DIR] = GC.Values[GC.CACHE_DIR]
      GM.Globals[GM.CACHE_DISCOVERY_ONLY] = GC.Values[GC.CACHE_DISCOVERY_ONLY]
# Set environment variables so GData API can find cacerts.pem
    os.environ['REQUESTS_CA_BUNDLE'] = GC.Values[GC.CACERTS_PEM]
    os.environ['DEFAULT_CA_BUNDLE_PATH'] = GC.Values[GC.CACERTS_PEM]
    os.environ['SSL_CERT_FILE'] = GC.Values[GC.CACERTS_PEM]
    httplib2.CA_CERTS = GC.Values[GC.CACERTS_PEM]
    return True
# We're done, nothing else to do
  return False

def handleServerError(e):
  errMsg = str(e)
  if 'setting tls' not in errMsg:
    systemErrorExit(NETWORK_ERROR_RC, errMsg)
  stderrErrorMsg(errMsg)
  writeStderr(Msg.DISABLE_TLS_MIN_MAX)
  systemErrorExit(NETWORK_ERROR_RC, None)

def getHttpObj(cache=None, timeout=None, override_min_tls=None, override_max_tls=None):
  tls_minimum_version = override_min_tls if override_min_tls else GC.Values[GC.TLS_MIN_VERSION] if GC.Values[GC.TLS_MIN_VERSION] else None
  tls_maximum_version = override_max_tls if override_max_tls else GC.Values[GC.TLS_MAX_VERSION] if GC.Values[GC.TLS_MAX_VERSION] else None
  httpObj = httplib2.Http(cache=cache,
                          timeout=timeout,
                          ca_certs=GC.Values[GC.CACERTS_PEM],
                          disable_ssl_certificate_validation=GC.Values[GC.NO_VERIFY_SSL],
                          tls_maximum_version=tls_maximum_version,
                          tls_minimum_version=tls_minimum_version)
  httpObj.redirect_codes = set(httpObj.redirect_codes) - {308}
  return httpObj

def _force_user_agent(user_agent):
  """Creates a decorator which can force a user agent in HTTP headers."""

  def decorator(request_method):
    """Wraps a request method to insert a user-agent in HTTP headers."""

    def wrapped_request_method(*args, **kwargs):
      """Modifies HTTP headers to include a specified user-agent."""
      if kwargs.get('headers') is not None:
        if kwargs['headers'].get('user-agent'):
          if user_agent not in kwargs['headers']['user-agent']:
            # Save the existing user-agent header and tack on our own.
            kwargs['headers']['user-agent'] = f'{user_agent} {kwargs["headers"]["user-agent"]}'
        else:
          kwargs['headers']['user-agent'] = user_agent
      else:
        kwargs['headers'] = {'user-agent': user_agent}
      return request_method(*args, **kwargs)

    return wrapped_request_method

  return decorator

class transportAgentRequest(google_auth_httplib2.Request):
  """A Request which forces a user agent."""

  @_force_user_agent(GAM_USER_AGENT)
  def __call__(self, *args, **kwargs): #pylint: disable=arguments-differ
    """Inserts the GAM user-agent header in requests."""
    return super(transportAgentRequest, self).__call__(*args, **kwargs)


class transportAuthorizedHttp(google_auth_httplib2.AuthorizedHttp):
  """An AuthorizedHttp which forces a user agent during requests."""

  @_force_user_agent(GAM_USER_AGENT)
  def request(self, *args, **kwargs): #pylint: disable=arguments-differ
    """Inserts the GAM user-agent header in requests."""
    return super(transportAuthorizedHttp, self).request(*args, **kwargs)

def transportCreateRequest(httpObj=None):
  """Creates a uniform Request object with a default http, if not provided.

  Args:
    httpObj: Optional httplib2.Http compatible object to be used with the request.
      If not provided, a default HTTP will be used.

  Returns:
    Request: A google_auth_httplib2.Request compatible Request.
  """
  if not httpObj:
    httpObj = getHttpObj()
  return transportAgentRequest(httpObj)

def doGAMCheckForUpdates(forceCheck):
  def _gamLatestVersionNotAvailable():
    if forceCheck:
      systemErrorExit(NETWORK_ERROR_RC, Msg.GAM_LATEST_VERSION_NOT_AVAILABLE)

  current_version = __version__
  now_time = int(time.time())
  if not forceCheck:
    last_check_time_str = readFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], continueOnError=True, displayError=False)
    last_check_time = int(last_check_time_str) if last_check_time_str and last_check_time_str.isdigit() else 0
    if last_check_time > now_time-604800:
      return
  try:
    _, c = getHttpObj(timeout=10).request(GAM_LATEST_RELEASE, 'GET', headers={'Accept': 'application/vnd.github.v3.text+json'})
    try:
      release_data = json.loads(c)
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
      _gamLatestVersionNotAvailable()
      return
    if not isinstance(release_data, dict) or 'tag_name' not in release_data:
      _gamLatestVersionNotAvailable()
      return
    latest_version = release_data['tag_name']
    if latest_version[0].lower() == 'v':
      latest_version = latest_version[1:]
    if forceCheck or (latest_version > current_version):
      if forceCheck:
        printKeyValueList(['Version Check', None])
        Ind.Increment()
        printKeyValueList(['Current', current_version])
        printKeyValueList([' Latest', latest_version])
        Ind.Decrement()
      else:
        writeStderr(formatKeyValueList(Ind.Spaces(), [WARNING, Msg.VERSION_UPDATE_AVAILABLE, 'Current', current_version, 'Latest', latest_version], '\n'))
    if latest_version <= current_version:
      writeFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
      return
    if forceCheck < 0:
      setSysExitRC(1)
      return
    writeFile(GM.Globals[GM.LAST_UPDATE_CHECK_TXT], str(now_time), continueOnError=True, displayError=forceCheck)
  except (httplib2.HttpLib2Error, OSError, google.auth.exceptions.TransportError, RuntimeError) as e:
    if forceCheck:
      handleServerError(e)

def handleOAuthTokenError(e, softErrors):
  errMsg = str(e)
  if errMsg in API.REFRESH_PERM_ERRORS:
    if softErrors:
      return None
    if not GM.Globals[GM.CURRENT_SVCACCT_USER]:
      expiredRevokedOauth2TxtExit()
  if errMsg.replace('.', '') in API.OAUTH2_TOKEN_ERRORS or errMsg.startswith('Invalid response'):
    if softErrors:
      return None
    if not GM.Globals[GM.CURRENT_SVCACCT_USER]:
      ClientAPIAccessDeniedExit()
    systemErrorExit(SERVICE_NOT_APPLICABLE_RC, Msg.SERVICE_NOT_APPLICABLE_THIS_ADDRESS.format(GM.Globals[GM.CURRENT_SVCACCT_USER]))
  stderrErrorMsg(f'Authentication Token Error - {errMsg}')
  APIAccessDeniedExit()

def getOauth2TxtCredentials(exitOnError=True):
  jsonData = readFile(GC.Values[GC.OAUTH2_TXT], continueOnError=True, displayError=False)
  if jsonData:
    try:
      jsonDict = json.loads(jsonData)
      if 'client_id' in jsonDict:
        scopesList = jsonDict.get('scopes', API.REQUIRED_SCOPES)
        if set(scopesList) == API.REQUIRED_SCOPES_SET:
          if exitOnError:
            systemErrorExit(OAUTH2_TXT_REQUIRED_RC, Msg.NO_CLIENT_ACCESS_ALLOWED)
          return (None, None)
        token_expiry = jsonDict.get('token_expiry', REFRESH_EXPIRY)
        creds = google.oauth2.credentials.Credentials.from_authorized_user_file(GC.Values[GC.OAUTH2_TXT], scopesList)
        if 'id_token_jwt' not in jsonDict:
          creds.token = jsonDict['token']
          creds._id_token = jsonDict['id_token']
          GM.Globals[GM.DECODED_ID_TOKEN] = jsonDict['decoded_id_token']
        else:
          creds.token = jsonDict['access_token']
          creds._id_token = jsonDict['id_token_jwt']
          GM.Globals[GM.DECODED_ID_TOKEN] = jsonDict['id_token']
        creds.expiry = datetime.datetime.strptime(token_expiry, YYYYMMDDTHHMMSSZ_FORMAT)
        return (True, creds)
      if (jsonDict.get('file_version') == 2) and ('credentials' in jsonDict) and (API.GAM_SCOPES in jsonDict['credentials']):
        if not jsonDict['credentials'][API.GAM_SCOPES]:
          if exitOnError:
            systemErrorExit(OAUTH2_TXT_REQUIRED_RC, Msg.NO_CLIENT_ACCESS_ALLOWED)
          return (None, None)
        if not isinstance(jsonDict['credentials'][API.GAM_SCOPES], dict):
          importCredentials = json.loads(base64.b64decode(jsonDict['credentials'][API.GAM_SCOPES]).decode('utf-8'))
        else:
          importCredentials = jsonDict['credentials'][API.GAM_SCOPES]
        if importCredentials:
          scopesList = importCredentials.get('scopes', API.REQUIRED_SCOPES)
          if set(scopesList) == API.REQUIRED_SCOPES_SET:
            if exitOnError:
              systemErrorExit(OAUTH2_TXT_REQUIRED_RC, Msg.NO_CLIENT_ACCESS_ALLOWED)
            return (None, None)
          info = {
            'client_id': importCredentials['client_id'],
            'client_secret': importCredentials['client_secret'],
            'refresh_token': importCredentials['refresh_token']
            }
          creds = google.oauth2.credentials.Credentials.from_authorized_user_info(info, scopesList)
          creds.token = importCredentials['access_token']
          creds._id_token = importCredentials['id_token_jwt']
          GM.Globals[GM.DECODED_ID_TOKEN] = importCredentials['id_token']
          creds.expiry = datetime.datetime.strptime(REFRESH_EXPIRY, YYYYMMDDTHHMMSSZ_FORMAT)
          return (False, creds)
      if jsonDict and exitOnError:
        invalidOauth2TxtExit()
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
      if exitOnError:
        invalidOauth2TxtExit()
  if exitOnError:
    systemErrorExit(OAUTH2_TXT_REQUIRED_RC, Msg.NO_CLIENT_ACCESS_ALLOWED)
  return (None, None)

def _getValueFromOAuth(field, credentials=None):
  if not GM.Globals[GM.DECODED_ID_TOKEN]:
    request = transportCreateRequest()
    if credentials is None:
      credentials = getClientCredentials()
    elif credentials.expired:
      credentials.refresh(request)
    GM.Globals[GM.DECODED_ID_TOKEN] = google.oauth2.id_token.verify_oauth2_token(credentials.id_token, request)
  return GM.Globals[GM.DECODED_ID_TOKEN].get(field, 'Unknown')

def _getAdminEmail():
  return _getValueFromOAuth('email')

def writeClientCredentials(creds, filename):
  creds_data = {
    'client_id': creds.client_id,
    'client_secret': creds.client_secret,
    'id_token': creds.id_token,
    'refresh_token': creds.refresh_token,
    'scopes': sorted(creds.scopes),
    'token': creds.token,
    'token_expiry': creds.expiry.strftime(YYYYMMDDTHHMMSSZ_FORMAT),
    'token_uri': creds.token_uri,
    }
  expected_iss = ['https://accounts.google.com', 'accounts.google.com']
  if _getValueFromOAuth('iss', creds) not in expected_iss:
    systemErrorExit(OAUTH2_TXT_REQUIRED_RC, f'Wrong OAuth 2.0 credentials issuer. Got {_getValueFromOAuth("iss", creds)} expected one of {", ".join(expected_iss)}')
  request = transportCreateRequest()
  try:
    creds_data['decoded_id_token'] = google.oauth2.id_token.verify_oauth2_token(creds.id_token, request)
  except ValueError as e:
    if 'Token used too early' in str(e):
      stderrErrorMsg(Msg.PLEASE_CORRECT_YOUR_SYSTEM_TIME)
    systemErrorExit(SYSTEM_ERROR_RC, str(e))
  GM.Globals[GM.DECODED_ID_TOKEN] = creds_data['decoded_id_token']
  if filename != '-':
    writeFile(filename, json.dumps(creds_data, indent=2, sort_keys=True)+'\n')
  else:
    writeStdout(json.dumps(creds_data, ensure_ascii=False, sort_keys=True, indent=2)+'\n')

def getClientCredentials(forceRefresh=False, forceWrite=False, filename=None):
  """Gets OAuth2 credentials which are guaranteed to be fresh and valid.
     Locks during read and possible write so that only one process will
     attempt refresh/write when running in parallel. """
  lock = FileLock(GM.Globals[GM.OAUTH2_TXT_LOCK])
  with lock:
    writeCreds, credentials = getOauth2TxtCredentials()
    if not credentials:
      invalidOauth2TxtExit()
    if credentials.expired or forceRefresh:
      retries = 3
      for n in range(1, retries+1):
        try:
          credentials.refresh(transportCreateRequest())
          if writeCreds or forceWrite:
            writeClientCredentials(credentials, filename or GC.Values[GC.OAUTH2_TXT])
          break
        except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
          if n != retries:
            waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
            continue
          handleServerError(e)
        except google.auth.exceptions.RefreshError as e:
          if isinstance(e.args, tuple):
            e = e.args[0]
          handleOAuthTokenError(e, False)
  return credentials

def waitOnFailure(n, retries, error_code, error_message):
  delta = min(2 ** n, 60)+float(random.randint(1, 1000))/1000
  if n > 3:
    writeStderr(f'Temporary error: {error_code} - {error_message}, Backing off: {int(delta)} seconds, Retry: {n}/{retries}\n')
    flushStderr()
  time.sleep(delta)
  if GC.Values[GC.SHOW_API_CALLS_RETRY_DATA]:
    incrAPICallsRetryData(error_message, delta)

def clearServiceCache(service):
  if hasattr(service._http, 'http') and hasattr(service._http.http, 'cache'):
    if service._http.http.cache is None:
      return False
    service._http.http.cache = None
    return True
  if hasattr(service._http, 'cache'):
    if service._http.cache is None:
      return False
    service._http.cache = None
    return True
  return False

DISCOVERY_URIS = [googleapiclient.discovery.V1_DISCOVERY_URI, googleapiclient.discovery.V2_DISCOVERY_URI]

def getAPIService(api, httpObj):
  api, version, v2discovery = API.getVersion(api)
  return googleapiclient.discovery.build(api, version, http=httpObj, cache_discovery=False,
                                         discoveryServiceUrl=DISCOVERY_URIS[v2discovery])

def getService(api, httpObj):
  hasLocalJSON = API.hasLocalJSON(api)
  api, version, v2discovery = API.getVersion(api)
  if api in GM.Globals[GM.CURRENT_API_SERVICES] and version in GM.Globals[GM.CURRENT_API_SERVICES][api]:
    service = googleapiclient.discovery.build_from_document(GM.Globals[GM.CURRENT_API_SERVICES][api][version], http=httpObj)
    if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
      clearServiceCache(service)
    return service
  if not hasLocalJSON:
    retries = 3
    for n in range(1, retries+1):
      try:
        service = googleapiclient.discovery.build(api, version, http=httpObj, cache_discovery=False,
                                                  discoveryServiceUrl=DISCOVERY_URIS[v2discovery])
        GM.Globals[GM.CURRENT_API_SERVICES].setdefault(api, {})
        GM.Globals[GM.CURRENT_API_SERVICES][api][version] = service._rootDesc.copy()
        if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
          clearServiceCache(service)
        return service
      except googleapiclient.errors.UnknownApiNameOrVersion as e:
        systemErrorExit(GOOGLE_API_ERROR_RC, Msg.UNKNOWN_API_OR_VERSION.format(str(e), __author__))
      except (googleapiclient.errors.InvalidJsonError, KeyError, ValueError):
        if n != retries:
          waitOnFailure(n, retries, INVALID_JSON_RC, Msg.INVALID_JSON_INFORMATION)
          continue
        systemErrorExit(INVALID_JSON_RC, Msg.INVALID_JSON_INFORMATION)
      except (http_client.ResponseNotReady, OSError, googleapiclient.errors.HttpError) as e:
        errMsg = f'Connection error: {str(e) or repr(e)}'
        if n != retries:
          waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
          continue
        systemErrorExit(SOCKET_ERROR_RC, errMsg)
      except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
        if n != retries:
          httpObj.connections = {}
          waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
          continue
        handleServerError(e)
  disc_file, discovery = readDiscoveryFile(f'{api}-{version}')
  try:
    service = googleapiclient.discovery.build_from_document(discovery, http=httpObj)
    GM.Globals[GM.CURRENT_API_SERVICES].setdefault(api, {})
    GM.Globals[GM.CURRENT_API_SERVICES][api][version] = service._rootDesc.copy()
    if GM.Globals[GM.CACHE_DISCOVERY_ONLY]:
      clearServiceCache(service)
    return service
  except (KeyError, ValueError):
    invalidDiscoveryJsonExit(disc_file)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, str(e))

def defaultSvcAcctScopes():
  scopesList = API.getSvcAcctScopesList(GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY], False)
  saScopes = {}
  for scope in scopesList:
    saScopes.setdefault(scope['api'], [])
    saScopes[scope['api']].append(scope['scope'])
  saScopes[API.DRIVEACTIVITY_V1].append(API.DRIVE_SCOPE)
  saScopes[API.DRIVEACTIVITY_V2].append(API.DRIVE_SCOPE)
  saScopes[API.DRIVE2] = saScopes[API.DRIVE3]
  saScopes[API.DRIVETD] = saScopes[API.DRIVE3]
  saScopes[API.SHEETSTD] = saScopes[API.SHEETS]
  return saScopes

def _getSvcAcctData():
  if not GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]:
    json_string = readFile(GC.Values[GC.OAUTH2SERVICE_JSON], continueOnError=True, displayError=True)
    if not json_string:
      invalidOauth2serviceJsonExit()
    try:
      GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = json.loads(json_string)
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
      invalidOauth2serviceJsonExit()
    if not GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]:
      systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, Msg.NO_SVCACCT_ACCESS_ALLOWED)
    if API.OAUTH2SA_SCOPES not in GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]:
      GM.Globals[GM.SVCACCT_SCOPES_DEFINED] = False
      GM.Globals[GM.SVCACCT_SCOPES] = defaultSvcAcctScopes()
    else:
      GM.Globals[GM.SVCACCT_SCOPES_DEFINED] = True
      GM.Globals[GM.SVCACCT_SCOPES] = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA].pop(API.OAUTH2SA_SCOPES)

def getSvcAcctCredentials(scopesOrAPI, userEmail):
  _getSvcAcctData()
  if isinstance(scopesOrAPI, str):
    GM.Globals[GM.CURRENT_SVCACCT_API] = scopesOrAPI
    GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = GM.Globals[GM.SVCACCT_SCOPES].get(scopesOrAPI, [])
    if not GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES]:
      systemErrorExit(OAUTH2SERVICE_JSON_REQUIRED_RC, Msg.NO_SVCACCT_ACCESS_ALLOWED)
  else:
    GM.Globals[GM.CURRENT_SVCACCT_API] = ''
    GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = scopesOrAPI
  try:
    credentials = google.oauth2.service_account.Credentials.from_service_account_info(GM.Globals[GM.OAUTH2SERVICE_JSON_DATA])
  except (ValueError, IndexError, KeyError):
    invalidOauth2serviceJsonExit()
  credentials = credentials.with_scopes(GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES])
  GM.Globals[GM.CURRENT_SVCACCT_USER] = userEmail
  if userEmail:
    credentials = credentials.with_subject(userEmail)
  GM.Globals[GM.ADMIN] = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email']
  GM.Globals[GM.OAUTH2SERVICE_CLIENT_ID] = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
  return credentials

def getGDataOAuthToken(gdataObj, credentials=None):
  if not credentials:
    credentials = getClientCredentials()
  try:
    credentials.refresh(transportCreateRequest())
  except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
    handleServerError(e)
  except google.auth.exceptions.RefreshError as e:
    if isinstance(e.args, tuple):
      e = e.args[0]
    handleOAuthTokenError(e, False)
  gdataObj.additional_headers['Authorization'] = f'Bearer {credentials.token}'
  if not GC.Values[GC.DOMAIN]:
    GC.Values[GC.DOMAIN] = GM.Globals[GM.DECODED_ID_TOKEN].get('hd', 'UNKNOWN').lower()
  if not GC.Values[GC.CUSTOMER_ID]:
    GC.Values[GC.CUSTOMER_ID] = GC.MY_CUSTOMER
  GM.Globals[GM.ADMIN] = GM.Globals[GM.DECODED_ID_TOKEN].get('email', 'UNKNOWN').lower()
  GM.Globals[GM.OAUTH2_CLIENT_ID] = credentials.client_id
  gdataObj.domain = GC.Values[GC.DOMAIN]
  gdataObj.source = GAM_USER_AGENT
  return True

def checkGDataError(e, service):
  error = e.args
  reason = error[0].get('reason', '')
  body = error[0].get('body', '').decode(UTF8)
  # First check for errors that need special handling
  if reason in ['Token invalid - Invalid token: Stateless token expired', 'Token invalid - Invalid token: Token not found']:
    keep_domain = service.domain
    getGDataOAuthToken(service)
    service.domain = keep_domain
    return (GDATA.TOKEN_EXPIRED, reason)
  error_code = getattr(e, 'error_code', 600)
  if error_code == 600:
    if (body.startswith('Quota exceeded for the current request') or
        body.startswith('Quota exceeded for quota metric') or
        body.startswith('Request rate higher than configured')):
      return (GDATA.QUOTA_EXCEEDED, body)
    if reason == 'Too Many Requests':
      return (GDATA.QUOTA_EXCEEDED, reason)
    if reason == 'Bad Gateway':
      return (GDATA.BAD_GATEWAY, reason)
    if reason == 'Gateway Timeout':
      return (GDATA.GATEWAY_TIMEOUT, reason)
    if reason == 'Service Unavailable':
      return (GDATA.SERVICE_UNAVAILABLE, reason)
    if reason == 'Service <jotspot> disabled by G Suite admin.':
      return (GDATA.FORBIDDEN, reason)
    if reason == 'Internal Server Error':
      return (GDATA.INTERNAL_SERVER_ERROR, reason)
    if reason == 'Token invalid - Invalid token: Token disabled, revoked, or expired.':
      return (GDATA.TOKEN_INVALID, 'Token disabled, revoked, or expired. Please delete and re-create oauth.txt')
    if reason == 'Token invalid - AuthSub token has wrong scope':
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason.startswith('Only administrators can request entries belonging to'):
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason == 'You are not authorized to access this API':
      return (GDATA.INSUFFICIENT_PERMISSIONS, reason)
    if reason == 'Invalid domain.':
      return (GDATA.INVALID_DOMAIN, reason)
    if reason.startswith('You are not authorized to perform operations on the domain'):
      return (GDATA.INVALID_DOMAIN, reason)
    if reason == 'Bad Request':
      if 'already exists' in body:
        return (GDATA.ENTITY_EXISTS, Msg.DUPLICATE)
      return (GDATA.BAD_REQUEST, body)
    if reason == 'Forbidden':
      return (GDATA.FORBIDDEN, body)
    if reason == 'Not Found':
      return (GDATA.NOT_FOUND, Msg.DOES_NOT_EXIST)
    if reason == 'Not Implemented':
      return (GDATA.NOT_IMPLEMENTED, body)
    if reason == 'Precondition Failed':
      return (GDATA.PRECONDITION_FAILED, reason)
  elif error_code == 602:
    if reason == 'Bad Request':
      return (GDATA.BAD_REQUEST, body)
  elif error_code == 610:
    if reason == 'Service <jotspot> disabled by G Suite admin.':
      return (GDATA.FORBIDDEN, reason)

  # We got a "normal" error, define the mapping below
  error_code_map = {
    1000: reason,
    1001: reason,
    1002: 'Unauthorized and forbidden',
    1100: 'User deleted recently',
    1200: 'Domain user limit exceeded',
    1201: 'Domain alias limit exceeded',
    1202: 'Domain suspended',
    1203: 'Domain feature unavailable',
    1300: f'Entity {getattr(e, "invalidInput", "<unknown>")} exists',
    1301: f'Entity {getattr(e, "invalidInput", "<unknown>")} Does Not Exist',
    1302: 'Entity Name Is Reserved',
    1303: f'Entity {getattr(e, "invalidInput", "<unknown>")} name not valid',
    1306: f'{getattr(e, "invalidInput", "<unknown>")} has members. Cannot delete.',
    1317: f'Invalid input {getattr(e, "invalidInput", "<unknown>")}, reason {getattr(e, "reason", "<unknown>")}',
    1400: 'Invalid Given Name',
    1401: 'Invalid Family Name',
    1402: 'Invalid Password',
    1403: 'Invalid Username',
    1404: 'Invalid Hash Function Name',
    1405: 'Invalid Hash Digest Length',
    1406: 'Invalid Email Address',
    1407: 'Invalid Query Parameter Value',
    1408: 'Invalid SSO Signing Key',
    1409: 'Invalid Encryption Public Key',
    1410: 'Feature Unavailable For User',
    1411: 'Invalid Encryption Public Key Format',
    1500: 'Too Many Recipients On Email List',
    1501: 'Too Many Aliases For User',
    1502: 'Too Many Delegates For User',
    1601: 'Duplicate Destinations',
    1602: 'Too Many Destinations',
    1603: 'Invalid Route Address',
    1700: 'Group Cannot Contain Cycle',
    1800: 'Group Cannot Contain Cycle',
    1801: f'Invalid value {getattr(e, "invalidInput", "<unknown>")}',
  }
  return (error_code, error_code_map.get(error_code, f'Unknown Error: {str(e)}'))

def callGData(service, function,
              bailOnInternalServerError=False, softErrors=False,
              throwErrors=None, retryErrors=None,
              **kwargs):
  if throwErrors is None:
    throwErrors = []
  if retryErrors is None:
    retryErrors = []
  allRetryErrors = GDATA.NON_TERMINATING_ERRORS+retryErrors
  method = getattr(service, function)
  retries = 10
  if GC.Values[GC.API_CALLS_RATE_CHECK]:
    checkAPICallsRate()
  for n in range(1, retries+1):
    try:
      return method(**kwargs)
    except (gdata.service.RequestError, gdata.apps.service.AppsForYourDomainException) as e:
      error_code, error_message = checkGDataError(e, service)
      if (n != retries) and (error_code in allRetryErrors):
        if error_code == GDATA.INTERNAL_SERVER_ERROR and bailOnInternalServerError and n == 2:
          raise GDATA.ERROR_CODE_EXCEPTION_MAP[error_code](error_message)
        waitOnFailure(n, retries, error_code, error_message)
        continue
      if error_code in throwErrors:
        if error_code in GDATA.ERROR_CODE_EXCEPTION_MAP:
          raise GDATA.ERROR_CODE_EXCEPTION_MAP[error_code](error_message)
        raise
      if softErrors:
        stderrErrorMsg(f'{error_code} - {error_message}{["", ": Giving up."][n > 1]}')
        return None
      if error_code == GDATA.INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(GOOGLE_API_ERROR_RC, f'{error_code} - {error_message}')
    except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
      if n != retries:
        waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
        continue
      handleServerError(e)
    except google.auth.exceptions.RefreshError as e:
      if isinstance(e.args, tuple):
        e = e.args[0]
      handleOAuthTokenError(e, GDATA.SERVICE_NOT_APPLICABLE in throwErrors)
      raise GDATA.ERROR_CODE_EXCEPTION_MAP[GDATA.SERVICE_NOT_APPLICABLE](str(e))
    except (http_client.ResponseNotReady, OSError) as e:
      errMsg = f'Connection error: {str(e) or repr(e)}'
      if n != retries:
        waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
        continue
      if softErrors:
        writeStderr(f'\n{ERROR_PREFIX}{errMsg} - Giving up.\n')
        return None
      systemErrorExit(SOCKET_ERROR_RC, errMsg)

def writeGotMessage(msg):
  if GC.Values[GC.SHOW_GETTINGS_GOT_NL]:
    writeStderr(msg)
  else:
    writeStderr('\r')
    msgLen = len(msg)
    if msgLen < GM.Globals[GM.LAST_GOT_MSG_LEN]:
      writeStderr(msg+' '*(GM.Globals[GM.LAST_GOT_MSG_LEN]-msgLen))
    else:
      writeStderr(msg)
    GM.Globals[GM.LAST_GOT_MSG_LEN] = msgLen
  flushStderr()

def callGDataPages(service, function,
                   pageMessage=None,
                   softErrors=False, throwErrors=None, retryErrors=None,
                   uri=None,
                   **kwargs):
  if throwErrors is None:
    throwErrors = []
  if retryErrors is None:
    retryErrors = []
  nextLink = None
  allResults = []
  totalItems = 0
  while True:
    this_page = callGData(service, function,
                          softErrors=softErrors, throwErrors=throwErrors, retryErrors=retryErrors,
                          uri=uri,
                          **kwargs)
    if this_page:
      nextLink = this_page.GetNextLink()
      pageItems = len(this_page.entry)
      if pageItems == 0:
        nextLink = None
      totalItems += pageItems
      allResults.extend(this_page.entry)
    else:
      nextLink = None
      pageItems = 0
    if pageMessage:
      show_message = pageMessage.replace(TOTAL_ITEMS_MARKER, str(totalItems))
      writeGotMessage(show_message.format(Ent.ChooseGetting(totalItems)))
    if nextLink is None:
      if pageMessage and (pageMessage[-1] != '\n'):
        writeStderr('\r\n')
        flushStderr()
      return allResults
    uri = nextLink.href
    if 'url_params' in kwargs:
      kwargs['url_params'].pop('start-index', None)

def checkGAPIError(e, softErrors=False, retryOnHttpError=False):
  def makeErrorDict(code, reason, message):
    return {'error': {'code': code, 'errors': [{'reason': reason, 'message': message}]}}

  try:
    error = json.loads(e.content.decode(UTF8))
    if GC.Values[GC.DEBUG_LEVEL] > 0:
      writeStdout(f'{ERROR_PREFIX} JSON: {str(error)}+\n')
  except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
    eContent = e.content.decode(UTF8) if isinstance(e.content, bytes) else e.content
    lContent = eContent.lower()
    if GC.Values[GC.DEBUG_LEVEL] > 0:
      writeStdout(f'{ERROR_PREFIX} HTTP: {str(eContent)}+\n')
    if (e.resp['status'] == '403') and (lContent.startswith('request rate higher than configured')):
      return (e.resp['status'], GAPI.QUOTA_EXCEEDED, eContent)
    if (e.resp['status'] == '429') and (lContent.startswith('quota exceeded for quota metric')):
      return (e.resp['status'], GAPI.QUOTA_EXCEEDED, eContent)
    if (e.resp['status'] == '502') and ('bad gateway' in lContent):
      return (e.resp['status'], GAPI.BAD_GATEWAY, eContent)
    if (e.resp['status'] == '503') and (lContent.startswith('quota exceeded for the current request')):
      return (e.resp['status'], GAPI.QUOTA_EXCEEDED, eContent)
    if (e.resp['status'] == '504') and ('gateway timeout' in lContent):
      return (e.resp['status'], GAPI.GATEWAY_TIMEOUT, eContent)
    if (e.resp['status'] == '403') and ('invalid domain.' in lContent):
      error = makeErrorDict(403, GAPI.NOT_FOUND, 'Domain not found')
    elif (e.resp['status'] == '403') and ('domain cannot use apis.' in lContent):
      error = makeErrorDict(403, GAPI.DOMAIN_CANNOT_USE_APIS, 'Domain cannot use apis')
    elif (e.resp['status'] == '400') and ('invalidssosigningkey' in lContent):
      error = makeErrorDict(400, GAPI.INVALID, 'InvalidSsoSigningKey')
    elif (e.resp['status'] == '400') and ('unknownerror' in lContent):
      error = makeErrorDict(400, GAPI.INVALID, 'UnknownError')
    elif (e.resp['status'] == '400') and ('featureunavailableforuser' in lContent):
      error = makeErrorDict(400, GAPI.SERVICE_NOT_AVAILABLE, 'Feature Unavailable For User')
    elif (e.resp['status'] == '400') and ('entitydoesnotexist' in lContent):
      error = makeErrorDict(400, GAPI.NOT_FOUND, 'Entity Does Not Exist')
    elif (e.resp['status'] == '400') and ('entitynamenotvalid' in lContent):
      error = makeErrorDict(400, GAPI.INVALID_INPUT, 'Entity Name Not Valid')
    elif (e.resp['status'] == '400') and ('failed to parse Content-Range header' in lContent):
      error = makeErrorDict(400, GAPI.BAD_REQUEST, 'Failed to parse Content-Range header')
    elif (e.resp['status'] == '400') and ('request contains an invalid argument' in lContent):
      error = makeErrorDict(400, GAPI.INVALID_ARGUMENT, 'Request contains an invalid argument')
    elif retryOnHttpError:
      return (-1, None, eContent)
    elif softErrors:
      stderrErrorMsg(eContent)
      return (0, None, None)
    else:
      systemErrorExit(HTTP_ERROR_RC, eContent)
  if 'error' in error:
    http_status = error['error']['code']
    if 'errors' in error['error']:
      message = error['error']['errors'][0]['message']
      status = ''
    else:
      message = error['error']['message']
      status = error['error'].get('status', '')
    lmessage = message.lower()
    if http_status == 500:
      if not lmessage:
        message = Msg.UNKNOWN
        error = makeErrorDict(http_status, GAPI.UNKNOWN_ERROR, message)
      elif 'backend error' in lmessage:
        error = makeErrorDict(http_status, GAPI.BACKEND_ERROR, message)
      elif 'internal error encountered' in lmessage:
        error = makeErrorDict(http_status, GAPI.INTERNAL_ERROR, message)
      elif 'role assignment exists: roleassignment' in lmessage:
        error = makeErrorDict(http_status, GAPI.DUPLICATE, message)
      elif 'role assignment exists: roleid' in lmessage:
        error = makeErrorDict(http_status, GAPI.DUPLICATE, message)
      elif 'operation not supported' in lmessage:
        error = makeErrorDict(http_status, GAPI.OPERATION_NOT_SUPPORTED, message)
      elif 'failed status in update settings response' in lmessage:
        error = makeErrorDict(http_status, GAPI.INVALID_INPUT, message)
    elif http_status == 502:
      if 'bad gateway' in lmessage:
        error = makeErrorDict(http_status, GAPI.BAD_GATEWAY, message)
    elif http_status == 503:
      if status == 'UNAVAILABLE' or 'the service is currently unavailable' in lmessage:
        error = makeErrorDict(http_status, GAPI.SERVICE_NOT_AVAILABLE, message)
      elif message.startswith('quota exceeded for the current request'):
        error = makeErrorDict(http_status, GAPI.QUOTA_EXCEEDED, message)
    elif http_status == 504:
      if 'gateway timeout' in lmessage:
        error = makeErrorDict(http_status, GAPI.GATEWAY_TIMEOUT, message)
    elif http_status == 400:
      if 'does not match' in lmessage or 'invalid' in lmessage:
        error = makeErrorDict(http_status, GAPI.INVALID, message)
      elif '@attachmentnotvisible' in lmessage:
        error = makeErrorDict(http_status, GAPI.BAD_REQUEST, message)
      elif status == 'FAILED_PRECONDITION' or 'precondition check failed' in lmessage:
        error = makeErrorDict(http_status, GAPI.FAILED_PRECONDITION, message)
      elif status == 'INVALID_ARGUMENT':
        error = makeErrorDict(http_status, GAPI.INVALID_ARGUMENT, message)
    elif http_status == 403:
      if status == 'PERMISSION_DENIED' or 'the caller does not have permission' in lmessage or 'permission iam.serviceaccountkeys' in lmessage:
        error = makeErrorDict(http_status, GAPI.PERMISSION_DENIED, message)
    elif http_status == 404:
      if status == 'NOT_FOUND' or 'requested entity was not found' in lmessage or 'does not exist' in lmessage:
        error = makeErrorDict(http_status, GAPI.NOT_FOUND, message)
    elif http_status == 409:
      if status == 'ALREADY_EXISTS' or 'requested entity already exists' in lmessage:
        error = makeErrorDict(http_status, GAPI.ALREADY_EXISTS, message)
    elif http_status == 429:
      if status == 'RESOURCE_EXHAUSTED' or 'quota exceeded' in lmessage:
        error = makeErrorDict(http_status, GAPI.QUOTA_EXCEEDED, message)
  else:
    if 'error_description' in error:
      if error['error_description'] == 'Invalid Value':
        message = error['error_description']
        http_status = 400
        error = makeErrorDict(http_status, GAPI.INVALID, message)
      else:
        systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
    else:
      systemErrorExit(GOOGLE_API_ERROR_RC, str(error))
  try:
    reason = error['error']['errors'][0]['reason']
    for messageItem in GAPI.REASON_MESSAGE_MAP.get(reason, []):
      if messageItem[0] in message:
        if reason in [GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND]:
          message = Msg.DOES_NOT_EXIST
        reason = messageItem[1]
        break
    if reason == GAPI.INVALID_SHARING_REQUEST:
      loc = message.find('User message: ')
      if loc != 1:
        message = message[loc+15:]
  except KeyError:
    reason = f'{http_status}'
  return (http_status, reason, message)

def callGAPI(service, function,
             bailOnInternalError=False, bailOnTransientError=False, softErrors=False,
             throwReasons=None, retryReasons=None, retries=10,
             **kwargs):
  if throwReasons is None:
    throwReasons = []
  if retryReasons is None:
    retryReasons = []
  allRetryReasons = GAPI.DEFAULT_RETRY_REASONS+retryReasons
  method = getattr(service, function)
  svcparms = dict(list(kwargs.items())+GM.Globals[GM.EXTRA_ARGS_LIST])
  if GC.Values[GC.API_CALLS_RATE_CHECK]:
    checkAPICallsRate()
  for n in range(1, retries+1):
    try:
      return method(**svcparms).execute()
    except googleapiclient.errors.HttpError as e:
      http_status, reason, message = checkGAPIError(e, softErrors=softErrors, retryOnHttpError=n < 3)
      if http_status == -1:
        # The error detail indicated that we should retry this request
        # We'll refresh credentials and make another pass
        try:
          service._http.credentials.refresh(getHttpObj())
        except TypeError:
          systemErrorExit(HTTP_ERROR_RC, message)
        continue
      if http_status == 0:
        return None
      if (n != retries) and (reason in allRetryReasons):
        if reason in [GAPI.INTERNAL_ERROR, GAPI.BACKEND_ERROR] and bailOnInternalError and n == 2:
          raise GAPI.REASON_EXCEPTION_MAP[reason](message)
        waitOnFailure(n, retries, reason, message)
        if reason == GAPI.TRANSIENT_ERROR and bailOnTransientError:
          raise GAPI.REASON_EXCEPTION_MAP[reason](message)
        continue
      if reason in throwReasons:
        if reason in GAPI.REASON_EXCEPTION_MAP:
          raise GAPI.REASON_EXCEPTION_MAP[reason](message)
        raise e
      if softErrors:
        stderrErrorMsg(f'{http_status}: {reason} - {message}{["", ": Giving up."][n > 1]}')
        return None
      if reason == GAPI.INSUFFICIENT_PERMISSIONS:
        APIAccessDeniedExit()
      systemErrorExit(HTTP_ERROR_RC, formatHTTPError(http_status, reason, message))
    except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
      if n != retries:
        service._http.connections = {}
        waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
        continue
      handleServerError(e)
    except google.auth.exceptions.RefreshError as e:
      if isinstance(e.args, tuple):
        e = e.args[0]
      handleOAuthTokenError(e, GAPI.SERVICE_NOT_AVAILABLE in throwReasons)
      raise GAPI.REASON_EXCEPTION_MAP[GAPI.SERVICE_NOT_AVAILABLE](str(e))
    except (http_client.ResponseNotReady, OSError) as e:
      errMsg = f'Connection error: {str(e) or repr(e)}'
      if n != retries:
        waitOnFailure(n, retries, SOCKET_ERROR_RC, errMsg)
        continue
      if softErrors:
        writeStderr(f'\n{ERROR_PREFIX}{errMsg} - Giving up.\n')
        return None
      systemErrorExit(SOCKET_ERROR_RC, errMsg)
    except ValueError as e:
      if clearServiceCache(service):
        continue
      systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
    except TypeError as e:
      systemErrorExit(GOOGLE_API_ERROR_RC, str(e))

def _processGAPIpagesResult(results, items, allResults, totalItems, pageMessage, messageAttribute, entityType):
  if results:
    pageToken = results.get('nextPageToken')
    if items in results:
      pageItems = len(results[items])
      totalItems += pageItems
      if allResults is not None:
        allResults.extend(results[items])
    else:
      results = {items: []}
      pageItems = 0
  else:
    pageToken = None
    results = {items: []}
    pageItems = 0
  if pageMessage:
    showMessage = pageMessage.replace(TOTAL_ITEMS_MARKER, str(totalItems))
    if messageAttribute:
      firstItem = results[items][0] if pageItems > 0 else {}
      lastItem = results[items][-1] if pageItems > 1 else firstItem
      if isinstance(messageAttribute, str):
        firstItem = str(firstItem.get(messageAttribute, ''))
        lastItem = str(lastItem.get(messageAttribute, ''))
      else:
        for attr in messageAttribute:
          firstItem = firstItem.get(attr, {})
          lastItem = lastItem.get(attr, {})
        firstItem = str(firstItem)
        lastItem = str(lastItem)
      showMessage = showMessage.replace(FIRST_ITEM_MARKER, firstItem)
      showMessage = showMessage.replace(LAST_ITEM_MARKER, lastItem)
    writeGotMessage(showMessage.replace('{0}', str(Ent.Choose(entityType, totalItems))))
  return (pageToken, totalItems)

def _finalizeGAPIpagesResult(pageMessage):
  if pageMessage and (pageMessage[-1] != '\n'):
    writeStderr('\r\n')
    flushStderr()

def callGAPIpages(service, function, items,
                  pageMessage=None, messageAttribute=None, maxItems=0,
                  throwReasons=None, retryReasons=None,
                  **kwargs):
  if throwReasons is None:
    throwReasons = []
  if retryReasons is None:
    retryReasons = []
  allResults = []
  totalItems = 0
  maxResults = kwargs.get('maxResults', 0)
  tweakMaxResults = maxItems and maxResults
  entityType = Ent.Getting() if pageMessage else None
  while True:
    if tweakMaxResults and maxItems-totalItems < maxResults:
      kwargs['maxResults'] = maxItems-totalItems
    results = callGAPI(service, function,
                       throwReasons=throwReasons, retryReasons=retryReasons,
                       **kwargs)
    pageToken, totalItems = _processGAPIpagesResult(results, items, allResults, totalItems, pageMessage, messageAttribute, entityType)
    if not pageToken or (maxItems and totalItems >= maxItems):
      _finalizeGAPIpagesResult(pageMessage)
      return allResults
    kwargs['pageToken'] = pageToken

def callGAPIitems(service, function, items,
                  throwReasons=None, retryReasons=None,
                  **kwargs):
  if throwReasons is None:
    throwReasons = []
  if retryReasons is None:
    retryReasons = []
  results = callGAPI(service, function,
                     throwReasons=throwReasons, retryReasons=retryReasons,
                     **kwargs)
  if results:
    return results.get(items, [])
  return []

def checkCloudPrintResult(result, throw_messages=None):
  if isinstance(result, bytes):
    result = result.decode(UTF8)
  if throw_messages is None:
    throw_messages = []
  if isinstance(result, str):
    try:
      result = json.loads(result)
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
      systemErrorExit(JSON_LOADS_ERROR_RC, f'{str(e)}: {result}')
  if not result['success']:
    message = result['message']
    if message in throw_messages:
      if message in GCP.MESSAGE_EXCEPTION_MAP:
        raise GCP.MESSAGE_EXCEPTION_MAP[message](message)
    systemErrorExit(ACTION_FAILED_RC, f'{result["errorCode"]}: {result["message"]}')
  return result

def getCloudPrintError(resp, result):
  if isinstance(result, bytes):
    result = result.decode(UTF8)
  mg = re.compile(r'<title>(.*)</title>').search(result)
  if mg:
    return mg.group(1)
  return f'Error: {resp["status"]}'

def callGCP(service, function,
            throw_messages=None,
            **kwargs):
  result = callGAPI(service, function,
                    **kwargs)
  return checkCloudPrintResult(result, throw_messages=throw_messages)

def readDiscoveryFile(api_version):
  disc_filename = f'{api_version}.json'
  disc_file = os.path.join(GM.Globals[GM.GAM_PATH], disc_filename)
  if hasattr(sys, '_MEIPASS'):
    json_string = readFile(os.path.join(sys._MEIPASS, disc_filename), continueOnError=True, displayError=True) #pylint: disable=no-member
  elif os.path.isfile(disc_file):
    json_string = readFile(disc_file, continueOnError=True, displayError=True)
  else:
    json_string = None
  if not json_string:
    invalidDiscoveryJsonExit(disc_file)
  try:
    discovery = json.loads(json_string)
    return (disc_file, discovery)
  except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
    invalidDiscoveryJsonExit(disc_file)

def buildGAPIObject(api):
  credentials = getClientCredentials()
  httpObj = transportAuthorizedHttp(credentials, http=getHttpObj(cache=GM.Globals[GM.CACHE_DIR]))
  service = getService(api, httpObj)
  try:
    API_Scopes = set(list(service._rootDesc['auth']['oauth2']['scopes']))
  except KeyError:
    API_Scopes = set(API.VAULT_SCOPES) if api == API.VAULT else set()
  GM.Globals[GM.CURRENT_CLIENT_API] = api
  GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = API_Scopes.intersection(credentials.scopes)
  if api != API.OAUTH2 and not GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, Msg.NO_SCOPES_FOR_API.format(API.getAPIName(api)))
  if not GC.Values[GC.DOMAIN]:
    GC.Values[GC.DOMAIN] = GM.Globals[GM.DECODED_ID_TOKEN].get('hd', 'UNKNOWN').lower()
  if not GC.Values[GC.CUSTOMER_ID]:
    GC.Values[GC.CUSTOMER_ID] = GC.MY_CUSTOMER
  GM.Globals[GM.ADMIN] = GM.Globals[GM.DECODED_ID_TOKEN].get('email', 'UNKNOWN').lower()
  GM.Globals[GM.OAUTH2_CLIENT_ID] = credentials.client_id
  return service

def getSaUser(user):
  currentClientAPI = GM.Globals[GM.CURRENT_CLIENT_API]
  currentClientAPIScopes = GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]
  userEmail = convertUIDtoEmailAddress(user) if user else ''
  GM.Globals[GM.CURRENT_CLIENT_API] = currentClientAPI
  GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = currentClientAPIScopes
  return userEmail

def buildGAPIServiceObject(api, user, i=0, count=0, displayError=True):
  userEmail = getSaUser(user)
  httpObj = getHttpObj(cache=GM.Globals[GM.CACHE_DIR])
  service = getService(api, httpObj)
  credentials = getSvcAcctCredentials(api, userEmail)
  request = transportCreateRequest(httpObj)
  retries = 3
  for n in range(1, retries+1):
    try:
      credentials.refresh(request)
      service._http = transportAuthorizedHttp(credentials, http=httpObj)
      return (userEmail, service)
    except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
      if n != retries:
        httpObj.connections = {}
        waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
        continue
      handleServerError(e)
    except google.auth.exceptions.RefreshError as e:
      if isinstance(e.args, tuple):
        e = e.args[0]
      handleOAuthTokenError(e, True)
      if displayError:
        entityServiceNotApplicableWarning(Ent.USER, userEmail, i, count)
      return (userEmail, None)

def buildGAPICloudprintObject(user, i, count):
  if user is None:
    return _getAdminEmail(), buildGAPIObject(API.CLOUDPRINT)
  return buildGAPIServiceObject(API.CLOUDPRINT, user, i, count)

def initGDataObject(gdataObj, api):
  GM.Globals[GM.CURRENT_CLIENT_API] = api
  credentials = getClientCredentials()
  GM.Globals[GM.CURRENT_CLIENT_API_SCOPES] = API.getClientScopesSet(api).intersection(credentials.scopes)
  if not GM.Globals[GM.CURRENT_CLIENT_API_SCOPES]:
    systemErrorExit(NO_SCOPES_FOR_API_RC, Msg.NO_SCOPES_FOR_API.format(API.getAPIName(api)))
  getGDataOAuthToken(gdataObj, credentials)
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    gdataObj.debug = True
  return gdataObj

def getGDataUserCredentials(api, user, i, count):
  userEmail = getSaUser(user)
  credentials = getSvcAcctCredentials(api, userEmail)
  request = transportCreateRequest()
  try:
    credentials.refresh(request)
    return (userEmail, credentials)
  except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
    handleServerError(e)
  except google.auth.exceptions.RefreshError as e:
    if isinstance(e.args, tuple):
      e = e.args[0]
    handleOAuthTokenError(e, True)
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return (userEmail, None)

def getContactsObject(entityType=Ent.DOMAIN, entityName=None, i=0, count=0, contactFeed=True):
  if entityType == Ent.DOMAIN:
    contactsObject = initGDataObject(gdata.apps.contacts.service.ContactsService(contactFeed=contactFeed),
                                     API.CONTACTS)
    return (entityName or GC.Values[GC.DOMAIN], contactsObject)
  userEmail, credentials = getGDataUserCredentials(API.CONTACTS, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  if GC.Values[GC.NO_VERIFY_SSL]:
    ssl._create_default_https_context = ssl._create_unverified_context
  contactsObject = gdata.apps.contacts.service.ContactsService(source=GAM_USER_AGENT, contactFeed=contactFeed,
                                                               additional_headers={'Authorization': f'Bearer {credentials.token}'})
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    contactsObject.debug = True
  return (userEmail, contactsObject)

def getContactsQuery(**kwargs):
  if GC.Values[GC.NO_VERIFY_SSL]:
    ssl._create_default_https_context = ssl._create_unverified_context
  return gdata.apps.contacts.service.ContactsQuery(**kwargs)

def getEmailAuditObject():
  return initGDataObject(gdata.apps.audit.service.AuditService(), API.EMAIL_AUDIT)

def getSitesObject(entityType=Ent.DOMAIN, entityName=None, i=0, count=0):
  if entityType == Ent.DOMAIN:
    sitesObject = initGDataObject(gdata.apps.sites.service.SitesService(), API.SITES)
    return (entityName or GC.Values[GC.DOMAIN], sitesObject)
  userEmail, credentials = getGDataUserCredentials(API.SITES, entityName, i, count)
  if not credentials:
    return (userEmail, None)
  if GC.Values[GC.NO_VERIFY_SSL]:
    ssl._create_default_https_context = ssl._create_unverified_context
  sitesObject = gdata.apps.sites.service.SitesService(source=GAM_USER_AGENT,
                                                      additional_headers={'Authorization': f'Bearer {credentials.token}'})
  if GC.Values[GC.DEBUG_LEVEL] > 0:
    sitesObject.debug = True
  return (userEmail, sitesObject)

# Convert UID to email address
def convertUIDtoEmailAddress(emailAddressOrUID, cd=None, emailTypes=None, checkForCustomerId=False):
  if emailTypes is None:
    emailTypes = ['user']
  elif not isinstance(emailTypes, list):
    emailTypes = [emailTypes] if emailTypes != 'any' else ['user', 'group']
  if checkForCustomerId and (emailAddressOrUID == GC.Values[GC.CUSTOMER_ID]):
    return emailAddressOrUID
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find('@') > 0:
    return normalizedEmailAddressOrUID
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  if 'user' in emailTypes:
    try:
      result = callGAPI(cd.users(), 'get',
                        throwReasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=normalizedEmailAddressOrUID, fields='primaryEmail')
      if 'primaryEmail' in result:
        return result['primaryEmail'].lower()
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      pass
  if 'group' in emailTypes:
    try:
      result = callGAPI(cd.groups(), 'get',
                        throwReasons=GAPI.GROUP_GET_THROW_REASONS,
                        groupKey=normalizedEmailAddressOrUID, fields='email')
      if 'email' in result:
        return result['email'].lower()
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      pass
  if 'resource' in emailTypes:
    try:
      result = callGAPI(cd.resources().calendars(), 'get',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        calendarResourceId=normalizedEmailAddressOrUID,
                        customer=GC.Values[GC.CUSTOMER_ID], fields='resourceEmail')
      if 'resourceEmail' in result:
        return result['resourceEmail'].lower()
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      pass
  return normalizedEmailAddressOrUID

# Convert email address to User/Group UID; called immediately after getting email address from command line
def convertEmailAddressToUID(emailAddressOrUID, cd=None, emailType='user', savedLocation=None):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  if normalizedEmailAddressOrUID.find('@') == -1:
    return normalizedEmailAddressOrUID
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  if emailType != 'group':
    try:
      return callGAPI(cd.users(), 'get',
                      throwReasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields='id')['id']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      if emailType == 'user':
        if savedLocation is not None:
          Cmd.SetLocation(savedLocation)
        entityDoesNotExistExit(Ent.USER, normalizedEmailAddressOrUID, errMsg=getPhraseDNEorSNA(normalizedEmailAddressOrUID))
  try:
    return callGAPI(cd.groups(), 'get',
                    throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                    groupKey=normalizedEmailAddressOrUID, fields='id')['id']
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
    if savedLocation is not None:
      Cmd.SetLocation(savedLocation)
    entityDoesNotExistExit([Ent.USER, Ent.GROUP][emailType == 'group'], normalizedEmailAddressOrUID, errMsg=getPhraseDNEorSNA(normalizedEmailAddressOrUID))

# Convert User UID from API call to email address
def convertUserIDtoEmail(uid, cd=None):
  primaryEmail = GM.Globals[GM.MAP_USER_ID_TO_NAME].get(uid)
  if not primaryEmail:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    try:
      primaryEmail = callGAPI(cd.users(), 'get',
                              throwReasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=uid, fields='primaryEmail')['primaryEmail']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      primaryEmail = f'uid:{uid}'
    GM.Globals[GM.MAP_USER_ID_TO_NAME][uid] = primaryEmail
  return primaryEmail

# Convert UID to split email address
# Return (foo@bar.com, foo, bar.com)
def splitEmailAddressOrUID(emailAddressOrUID):
  normalizedEmailAddressOrUID = normalizeEmailAddressOrUID(emailAddressOrUID)
  atLoc = normalizedEmailAddressOrUID.find('@')
  if atLoc > 0:
    return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  try:
    cd = buildGAPIObject(API.DIRECTORY)
    result = callGAPI(cd.users(), 'get',
                      throwReasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=normalizedEmailAddressOrUID, fields='primaryEmail')
    if 'primaryEmail' in result:
      normalizedEmailAddressOrUID = result['primaryEmail'].lower()
      atLoc = normalizedEmailAddressOrUID.find('@')
      return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID[:atLoc], normalizedEmailAddressOrUID[atLoc+1:])
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
    pass
  return (normalizedEmailAddressOrUID, normalizedEmailAddressOrUID, GC.Values[GC.DOMAIN])

# Convert Org Unit Id to Org Unit Path
def convertOrgUnitIDtoPath(orgUnitId, cd):
  orgUnitPath = GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME].get(orgUnitId)
  if not orgUnitPath:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    try:
      orgUnitPath = callGAPI(cd.orgunits(), 'get',
                             throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                             customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=orgUnitId, fields='orgUnitPath')['orgUnitPath']
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError, GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      orgUnitPath = orgUnitId
    GM.Globals[GM.MAP_ORGUNIT_ID_TO_NAME][orgUnitId] = orgUnitPath
  return orgUnitPath

def shlexSplitList(entity, dataDelimiter=' ,'):
  lexer = shlex.shlex(entity, posix=True)
  lexer.whitespace = dataDelimiter
  lexer.whitespace_split = True
  try:
    return list(lexer)
  except ValueError as e:
    Cmd.Backup()
    usageErrorExit(str(e))

def shlexSplitListStatus(entity, dataDelimiter=' ,'):
  lexer = shlex.shlex(entity, posix=True)
  lexer.whitespace = dataDelimiter
  lexer.whitespace_split = True
  try:
    return (True, list(lexer))
  except ValueError as e:
    return (False, str(e))

def getQueries(myarg):
  if myarg == 'query':
    return [getString(Cmd.OB_QUERY)]
  return shlexSplitList(getString(Cmd.OB_QUERY_LIST))

def convertEntityToList(entity, shlexSplit=False, nonListEntityType=False):
  if not entity:
    return []
  if isinstance(entity, (list, set, dict)):
    return list(entity)
  if nonListEntityType:
    return [entity.strip()]
  if not shlexSplit:
    return entity.replace(',', ' ').split()
  return shlexSplitList(entity)

GROUP_ROLES_MAP = {
  'owner': Ent.ROLE_OWNER,
  'owners': Ent.ROLE_OWNER,
  'manager': Ent.ROLE_MANAGER,
  'managers': Ent.ROLE_MANAGER,
  'member': Ent.ROLE_MEMBER,
  'members': Ent.ROLE_MEMBER,
  }
ALL_GROUP_ROLES = {Ent.ROLE_MANAGER, Ent.ROLE_MEMBER, Ent.ROLE_OWNER}

GROUP_TYPES_MAP = {
  'customer': Ent.TYPE_CUSTOMER,
  'group': Ent.TYPE_GROUP,
  'user': Ent.TYPE_USER,
  }
ALL_GROUP_TYPES = {Ent.TYPE_CUSTOMER, Ent.TYPE_GROUP, Ent.TYPE_USER}

def _getRoleVerification(memberRoles, fields):
  if memberRoles and memberRoles.find(Ent.ROLE_MEMBER) != -1:
    return (set(memberRoles.split(',')), None, fields if fields.find('role') != -1 else fields[:-1]+',role)')
  return (set(), memberRoles, fields)

def _checkMemberIsSuspended(member, isSuspended):
  memberStatus = member.get('status', 'UNKNOWN')
  return isSuspended is None or (not isSuspended and memberStatus != 'SUSPENDED') or (isSuspended and memberStatus == 'SUSPENDED')

def _checkMemberRole(member, validRoles):
  return not validRoles or member.get('role', Ent.ROLE_MEMBER) in validRoles

def _checkMemberRoleIsSuspended(member, validRoles, isSuspended):
  return _checkMemberRole(member, validRoles) and _checkMemberIsSuspended(member, isSuspended)

# Turn the entity into a list of Users/CrOS devices
def getUsersToModify(entityType, entity, memberRoles=None, isSuspended=None, groupMemberType=Ent.TYPE_USER, noListConversion=False):
  def _incrEntityDoesNotExist(entityType):
    entityError['entityType'] = entityType
    entityError[ENTITY_ERROR_DNE] += 1

  def _showInvalidEntity(entityType, entityName):
    entityError['entityType'] = entityType
    entityError[ENTITY_ERROR_INVALID] += 1
    printErrorMessage(INVALID_ENTITY_RC, formatKeyValueList('', [Ent.Singular(entityType), entityName, Msg.INVALID], ''))

  def _addGroupUsersToUsers(group, domains, recursive, includeDerivedMembership):
    printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Ent.GROUP)
    validRoles, listRoles, listFields = _getRoleVerification(memberRoles, 'nextPageToken,members(email,type,status)')
    try:
      result = callGAPIpages(cd.members(), 'list', 'members',
                             pageMessage=getPageMessageForWhom(),
                             throwReasons=GAPI.MEMBERS_THROW_REASONS,
                             includeDerivedMembership=includeDerivedMembership,
                             groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group)
      _incrEntityDoesNotExist(Ent.GROUP)
      return
    for member in result:
      if member['type'] == Ent.TYPE_USER:
        email = member['email'].lower()
        if email in entitySet:
          continue
        if _checkMemberRoleIsSuspended(member, validRoles, isSuspended):
          if domains:
            _, domain = splitEmailAddress(email)
            if domain not in domains:
              continue
          entitySet.add(email)
          entityList.append(email)
      elif recursive and member['type'] == Ent.TYPE_GROUP:
        _addGroupUsersToUsers(member['email'], domains, recursive, includeDerivedMembership)

  ENTITY_ERROR_DNE = 'doesNotExist'
  ENTITY_ERROR_INVALID = 'invalid'
  entityError = {'entityType': None, ENTITY_ERROR_DNE: 0, ENTITY_ERROR_INVALID: 0}
  entityList = []
  entitySet = set()
  entityLocation = Cmd.Location()
  if entityType in {Cmd.ENTITY_USER, Cmd.ENTITY_USERS}:
    if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
      buildGAPIObject(API.DIRECTORY)
    result = convertEntityToList(entity, nonListEntityType=entityType == Cmd.ENTITY_USER)
    for user in result:
      if validateEmailAddressOrUID(user):
        if user not in entitySet:
          entitySet.add(user)
          entityList.append(user)
      else:
        _showInvalidEntity(Ent.USER, user)
    if GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
      return entityList
  elif entityType in {Cmd.ENTITY_ALL_USERS, Cmd.ENTITY_ALL_USERS_NS, Cmd.ENTITY_ALL_USERS_NS_SUSP, Cmd.ENTITY_ALL_USERS_SUSP}:
    cd = buildGAPIObject(API.DIRECTORY)
    query = Cmd.ALL_USERS_QUERY_MAP[entityType]
    printGettingAllAccountEntities(Ent.USER)
    try:
      result = callGAPIpages(cd.users(), 'list', 'users',
                             pageMessage=getPageMessage(),
                             throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customer=GC.Values[GC.CUSTOMER_ID],
                             query=query, orderBy='email', fields='nextPageToken,users(primaryEmail)',
                             maxResults=GC.Values[GC.USER_MAX_RESULTS])
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)
    entityList = [user['primaryEmail'] for user in result]
    printGotAccountEntities(len(entityList))
  elif entityType in {Cmd.ENTITY_DOMAINS, Cmd.ENTITY_DOMAINS_NS, Cmd.ENTITY_DOMAINS_SUSP}:
    if entityType == Cmd.ENTITY_DOMAINS_NS:
      query = 'isSuspended=False'
    elif entityType == Cmd.ENTITY_DOMAINS_SUSP:
      query = 'isSuspended=True'
    else:
      query = None
    cd = buildGAPIObject(API.DIRECTORY)
    domains = convertEntityToList(entity)
    for domain in domains:
      printGettingAllEntityItemsForWhom(Ent.USER, domain, entityType=Ent.DOMAIN)
      try:
        result = callGAPIpages(cd.users(), 'list', 'users',
                               pageMessage=getPageMessage(),
                               throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN],
                               domain=domain,
                               query=query, orderBy='email', fields='nextPageToken,users(primaryEmail)',
                               maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden):
        checkEntityDNEorAccessErrorExit(cd, Ent.DOMAIN, domain)
        _incrEntityDoesNotExist(Ent.DOMAIN)
        continue
      entityList = [user['primaryEmail'] for user in result]
      printGotAccountEntities(len(entityList))
  elif entityType in {Cmd.ENTITY_GROUP, Cmd.ENTITY_GROUPS,
                      Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUPS_NS,
                      Cmd.ENTITY_GROUP_SUSP, Cmd.ENTITY_GROUPS_SUSP,
                      Cmd.ENTITY_GROUP_INDE, Cmd.ENTITY_GROUPS_INDE}:
    if entityType in {Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUPS_NS}:
      isSuspended = False
    elif entityType in {Cmd.ENTITY_GROUP_SUSP, Cmd.ENTITY_GROUPS_SUSP}:
      isSuspended = True
    includeDerivedMembership = entityType in {Cmd.ENTITY_GROUP_INDE, Cmd.ENTITY_GROUPS_INDE}
    cd = buildGAPIObject(API.DIRECTORY)
    groups = convertEntityToList(entity, nonListEntityType=entityType in {Cmd.ENTITY_GROUP, Cmd.ENTITY_GROUP_NS, Cmd.ENTITY_GROUP_SUSP, Cmd.ENTITY_GROUP_INDE})
    for group in groups:
      if validateEmailAddressOrUID(group, checkPeople=False):
        group = normalizeEmailAddressOrUID(group)
        printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, group, entityType=Ent.GROUP)
        validRoles, listRoles, listFields = _getRoleVerification(memberRoles, 'nextPageToken,members(email,id,type,status)')
        try:
          result = callGAPIpages(cd.members(), 'list', 'members',
                                 pageMessage=getPageMessageForWhom(),
                                 throwReasons=GAPI.MEMBERS_THROW_REASONS,
                                 includeDerivedMembership=includeDerivedMembership,
                                 groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
          entityUnknownWarning(Ent.GROUP, group)
          _incrEntityDoesNotExist(Ent.GROUP)
          continue
        for member in result:
          email = member['email'].lower() if member['type'] != Ent.TYPE_CUSTOMER else member['id']
          if ((groupMemberType in ('ALL', member['type'])) and
              (not includeDerivedMembership or (member['type'] == Ent.TYPE_USER)) and
              _checkMemberRoleIsSuspended(member, validRoles, isSuspended) and email not in entitySet):
            entitySet.add(email)
            entityList.append(email)
      else:
        _showInvalidEntity(Ent.GROUP, group)
  elif entityType in {Cmd.ENTITY_GROUP_USERS, Cmd.ENTITY_GROUP_USERS_NS, Cmd.ENTITY_GROUP_USERS_SUSP}:
    if entityType == Cmd.ENTITY_GROUP_USERS_NS:
      isSuspended = False
    elif entityType == Cmd.ENTITY_GROUP_USERS_SUSP:
      isSuspended = True
    cd = buildGAPIObject(API.DIRECTORY)
    groups = convertEntityToList(entity)
    includeDerivedMembership = recursive = False
    domains = []
    rolesSet = set()
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        rolesSet.add(GROUP_ROLES_MAP[myarg])
      elif myarg == 'primarydomain':
        domains.append(GC.Values[GC.DOMAIN])
      elif myarg == 'domains':
        domains.extend(getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY))
      elif myarg == 'recursive':
        recursive = True
        includeDerivedMembership = False
      elif myarg == 'includederivedmembership':
        includeDerivedMembership = True
        recursive = False
      elif myarg == 'end':
        break
      else:
        Cmd.Backup()
        missingArgumentExit('end')
    if rolesSet:
      memberRoles = ','.join(sorted(rolesSet))
    for group in groups:
      if validateEmailAddressOrUID(group, checkPeople=False):
        _addGroupUsersToUsers(normalizeEmailAddressOrUID(group), domains, recursive, includeDerivedMembership)
      else:
        _showInvalidEntity(Ent.GROUP, group)
  elif entityType in {Cmd.ENTITY_OU, Cmd.ENTITY_OUS, Cmd.ENTITY_OU_AND_CHILDREN, Cmd.ENTITY_OUS_AND_CHILDREN,
                      Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS,
                      Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP}:
    if entityType in {Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS}:
      isSuspended = False
    elif entityType in {Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP}:
      isSuspended = True
    cd = buildGAPIObject(API.DIRECTORY)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in {Cmd.ENTITY_OU, Cmd.ENTITY_OU_AND_CHILDREN,
                                                                                        Cmd.ENTITY_OU_NS, Cmd.ENTITY_OU_AND_CHILDREN_NS,
                                                                                        Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OU_AND_CHILDREN_SUSP})
    directlyInOU = entityType in {Cmd.ENTITY_OU, Cmd.ENTITY_OUS, Cmd.ENTITY_OU_NS, Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OU_SUSP, Cmd.ENTITY_OUS_SUSP}
    qualifier = Msg.DIRECTLY_IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT)) if directlyInOU else Msg.IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT))
    fields = 'nextPageToken,users(primaryEmail,orgUnitPath)' if directlyInOU else 'nextPageToken,users(primaryEmail)'
    prevLen = 0
    for ou in ous:
      ou = makeOrgUnitPathAbsolute(ou)
      try:
        if ou.startswith('id:'):
          ou = callGAPI(cd.orgunits(), 'get',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR,
                                      GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=ou, fields='orgUnitPath')['orgUnitPath']
        printGettingAllEntityItemsForWhom(Ent.USER, ou, qualifier=qualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
        result = callGAPIpages(cd.users(), 'list', 'users',
                               pageMessage=getPageMessageForWhom(),
                               throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                             GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], query=orgUnitPathQuery(ou, isSuspended), orderBy='email',
                               fields=fields, maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.badRequest, GAPI.invalidInput, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError,
              GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
        _incrEntityDoesNotExist(Ent.ORGANIZATIONAL_UNIT)
        continue
      if directlyInOU:
        ou = ou.lower()
        for user in result:
          if ou == user.get('orgUnitPath', '').lower():
            entityList.append(user['primaryEmail'])
      else:
        entityList.extend([user['primaryEmail'] for user in result])
      totalLen = len(entityList)
      printGotEntityItemsForWhom(totalLen-prevLen)
      prevLen = totalLen
  elif entityType in {Cmd.ENTITY_QUERY, Cmd.ENTITY_QUERIES}:
    cd = buildGAPIObject(API.DIRECTORY)
    queries = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType == Cmd.ENTITY_QUERY)
    prevLen = 0
    for query in queries:
      printGettingAllAccountEntities(Ent.USER, query)
      try:
        result = callGAPIpages(cd.users(), 'list', 'users',
                               pageMessage=getPageMessage(),
                               throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                             GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], query=query, orderBy='email',
                               fields='nextPageToken,users(primaryEmail,suspended)',
                               maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.invalidInput):
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_QUERY)
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
      for user in result:
        email = user['primaryEmail']
        if (isSuspended is None or isSuspended == user['suspended']) and email not in entitySet:
          entitySet.add(email)
          entityList.append(email)
      totalLen = len(entityList)
      printGotAccountEntities(totalLen-prevLen)
      prevLen = totalLen
  elif entityType == Cmd.ENTITY_LICENSES:
    entityList = doPrintLicenses(returnFields=['userId'], skus=entity.split(','))
  elif entityType in {Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_TEACHERS, Cmd.ENTITY_STUDENTS}:
    croom = buildGAPIObject(API.CLASSROOM)
    if not noListConversion:
      courses = convertEntityToList(entity)
    else:
      courses = [entity]
    for course in courses:
      courseId = addCourseIdScope(course)
      try:
        if entityType in {Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_TEACHERS}:
          printGettingAllEntityItemsForWhom(Ent.TEACHER, removeCourseIdScope(courseId), entityType=Ent.COURSE)
          result = callGAPIpages(croom.courses().teachers(), 'list', 'teachers',
                                 pageMessage=getPageMessageForWhom(),
                                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                 courseId=courseId, fields='nextPageToken,teachers/profile/emailAddress',
                                 pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          for teacher in result:
            email = teacher['profile'].get('emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
        if entityType in {Cmd.ENTITY_COURSEPARTICIPANTS, Cmd.ENTITY_STUDENTS}:
          printGettingAllEntityItemsForWhom(Ent.STUDENT, removeCourseIdScope(courseId), entityType=Ent.COURSE)
          result = callGAPIpages(croom.courses().students(), 'list', 'students',
                                 pageMessage=getPageMessageForWhom(),
                                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                 courseId=courseId, fields='nextPageToken,students/profile/emailAddress',
                                 pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          for student in result:
            email = student['profile'].get('emailAddress', None)
            if email and (email not in entitySet):
              entitySet.add(email)
              entityList.append(email)
      except GAPI.notFound:
        entityDoesNotExistWarning(Ent.COURSE, removeCourseIdScope(courseId))
        _incrEntityDoesNotExist(Ent.COURSE)
      except (GAPI.forbidden, GAPI.badRequest):
        ClientAPIAccessDeniedExit()
  elif entityType == Cmd.ENTITY_CROS:
    buildGAPIObject(API.DIRECTORY)
    result = convertEntityToList(entity)
    for deviceId in result:
      if deviceId not in entitySet:
        entitySet.add(deviceId)
        entityList.append(deviceId)
  elif entityType == Cmd.ENTITY_ALL_CROS:
    cd = buildGAPIObject(API.DIRECTORY)
    printGettingAllAccountEntities(Ent.CROS_DEVICE)
    try:
      result = callGAPIpages(cd.chromeosdevices(), 'list', 'chromeosdevices',
                             pageMessage=getPageMessage(),
                             throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                             customerId=GC.Values[GC.CUSTOMER_ID],
                             fields='nextPageToken,chromeosdevices(deviceId)',
                             maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)
    entityList = [device['deviceId'] for device in result]
  elif entityType in {Cmd.ENTITY_CROS_QUERY, Cmd.ENTITY_CROS_QUERIES, Cmd.ENTITY_CROS_SN}:
    cd = buildGAPIObject(API.DIRECTORY)
    queries = convertEntityToList(entity, shlexSplit=entityType == Cmd.ENTITY_CROS_QUERIES,
                                  nonListEntityType=entityType == Cmd.ENTITY_CROS_QUERY)
    if entityType == Cmd.ENTITY_CROS_SN:
      queries = [f'id:{query}' for query in queries]
    prevLen = 0
    for query in queries:
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      try:
        result = callGAPIpages(cd.chromeosdevices(), 'list', 'chromeosdevices',
                               pageMessage=getPageMessage(),
                               throwReasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customerId=GC.Values[GC.CUSTOMER_ID], query=query,
                               fields='nextPageToken,chromeosdevices(deviceId)',
                               maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
      except GAPI.invalidInput:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_QUERY)
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
      for device in result:
        deviceId = device['deviceId']
        if deviceId not in entitySet:
          entitySet.add(deviceId)
          entityList.append(deviceId)
      totalLen = len(entityList)
      printGotAccountEntities(totalLen-prevLen)
      prevLen = totalLen
  elif entityType in {Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OU_AND_CHILDREN, Cmd.ENTITY_CROS_OUS, Cmd.ENTITY_CROS_OUS_AND_CHILDREN}:
    cd = buildGAPIObject(API.DIRECTORY)
    ous = convertEntityToList(entity, shlexSplit=True, nonListEntityType=entityType in [Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OU_AND_CHILDREN])
    directlyInOU = entityType in {Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OUS}
    numOus = len(ous)
    allQualifier = Msg.DIRECTLY_IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, numOus)) if directlyInOU else Msg.IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, numOus))
    if entityType in {Cmd.ENTITY_CROS_OU, Cmd.ENTITY_CROS_OUS}:
      oneQualifier = Msg.DIRECTLY_IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT)) if directlyInOU else Msg.IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT))
      for ou in ous:
        ou = makeOrgUnitPathAbsolute(ou)
        printGettingAllEntityItemsForWhom(Ent.CROS_DEVICE, ou, qualifier=oneQualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
        try:
          result = callGAPIpages(cd.chromeosdevices(), 'list', 'chromeosdevices',
                                 pageMessage=getPageMessage(),
                                 throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=ou,
                                 fields='nextPageToken,chromeosdevices(deviceId)',
                                 maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        except (GAPI.badRequest, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.resourceNotFound, GAPI.forbidden):
          checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
          _incrEntityDoesNotExist(Ent.ORGANIZATIONAL_UNIT)
          continue
        entityList.extend([device['deviceId'] for device in result])
      Ent.SetGettingQualifier(Ent.CROS_DEVICE, allQualifier)
      Ent.SetGettingForWhom(','.join(ous))
      printGotEntityItemsForWhom(len(entityList))
    else:
      ouSet = set()
      for ou in ous:
        ou = makeOrgUnitPathAbsolute(ou)
        try:
          result = callGAPI(cd.orgunits(), 'get',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(ou)), fields='orgUnitPath')
        except (GAPI.badRequest, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError, GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
          checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, ou)
          _incrEntityDoesNotExist(Ent.ORGANIZATIONAL_UNIT)
          continue
        ouSet.add(result['orgUnitPath'].lower())
      if entityError[ENTITY_ERROR_DNE] == 0:
        qualifier = Msg.IN_THE.format(Ent.Choose(Ent.ORGANIZATIONAL_UNIT, len(ous)))
        printGettingAllEntityItemsForWhom(Ent.CROS_DEVICE, ','.join(ous), qualifier=allQualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
        try:
          result = callGAPIpages(cd.chromeosdevices(), 'list', 'chromeosdevices',
                                 pageMessage=getPageMessage(),
                                 throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                 customerId=GC.Values[GC.CUSTOMER_ID],
                                 fields='nextPageToken,chromeosdevices(deviceId,orgUnitPath)',
                                 maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          accessErrorExit(cd)
        for device in result:
          deviceOu = device['orgUnitPath'].lower()
          for ou in ouSet:
            if deviceOu.startswith(ou):
              entityList.append(device['deviceId'])
              break
        printGotEntityItemsForWhom(len(entityList))
  else:
    systemErrorExit(UNKNOWN_ERROR_RC, 'getUsersToModify coding error')
  for errorType in [ENTITY_ERROR_DNE, ENTITY_ERROR_INVALID]:
    if entityError[errorType] > 0:
      Cmd.SetLocation(entityLocation-1)
      writeStderr(Cmd.CommandLineWithBadArgumentMarked(False))
      count = entityError[errorType]
      if errorType == ENTITY_ERROR_DNE:
        stderrErrorMsg(Msg.BAD_ENTITIES_IN_SOURCE.format(count, Ent.Choose(entityError['entityType'], count),
                                                         Msg.DO_NOT_EXIST if count != 1 else Msg.DOES_NOT_EXIST))
        sys.exit(ENTITY_DOES_NOT_EXIST_RC)
      else:
        stderrErrorMsg(Msg.BAD_ENTITIES_IN_SOURCE.format(count, Msg.INVALID, Ent.Choose(entityError['entityType'], count)))
        sys.exit(INVALID_ENTITY_RC)
  return entityList

def splitEntityList(entity, dataDelimiter):
  if not entity:
    return []
  if not dataDelimiter:
    return [entity]
  return entity.split(dataDelimiter)

def splitEntityListShlex(entity, dataDelimiter):
  if not entity:
    return (True, [])
  if not dataDelimiter:
    return (True, [entity])
  return shlexSplitListStatus(entity, dataDelimiter)

def fileDataErrorExit(filename, row, itemName, value, errMessage):
  if itemName:
    systemErrorExit(DATA_ERROR_RC,
                    formatKeyValueList('',
                                       [Ent.Singular(Ent.FILE), filename,
                                        Ent.Singular(Ent.ROW), row,
                                        Ent.Singular(Ent.ITEM), itemName,
                                        Ent.Singular(Ent.VALUE), value,
                                        errMessage],
                                       ''))
  else:
    systemErrorExit(DATA_ERROR_RC,
                    formatKeyValueList('',
                                       [Ent.Singular(Ent.FILE), filename,
                                        Ent.Singular(Ent.ROW), row,
                                        Ent.Singular(Ent.VALUE), value,
                                        errMessage],
                                       ''))

# <FileName> [charset <String>] [delimiter <Character>]
def getEntitiesFromFile(shlexSplit):
  filename = getString(Cmd.OB_FILE_NAME)
  if filename.lower() != 'gdoc':
    encoding = getCharSet()
    f = openFile(filename, encoding=encoding, stripUTFBOM=True)
  else:
    f = getGDocData(MIMETYPE_TEXT_PLAIN)
    getCharSet()
  dataDelimiter = getDelimiter()
  entitySet = set()
  entityList = []
  i = 0
  for row in f:
    i += 1
    if shlexSplit:
      splitStatus, itemList = splitEntityListShlex(row.strip(), dataDelimiter)
      if not splitStatus:
        fileDataErrorExit(filename, i, None, row.strip(), f'{Msg.INVALID_LIST}: {itemList}')
    else:
      itemList = splitEntityList(row.strip(), dataDelimiter)
    for item in itemList:
      item = item.strip()
      if item and (item not in entitySet):
        entitySet.add(item)
        entityList.append(item)
  closeFile(f)
  return entityList

# <FileName>(:<FieldName>)+ [charset <String>] [warnifnodata] [columndelimiter <Character>] [quotechar <Character>]
#	[fields <FieldNameList>] (matchfield|skipfield <FieldName> <RegularExpression>)* [delimiter <Character>]
def getEntitiesFromCSVFile(shlexSplit):
  drive, fileFieldName = os.path.splitdrive(getString(Cmd.OB_FILE_NAME_FIELD_NAME))
  if fileFieldName.find(':') == -1:
    Cmd.Backup()
    invalidArgumentExit(Cmd.OB_FILE_NAME_FIELD_NAME)
  fileFieldNameList = fileFieldName.split(':')
  filename = drive+fileFieldNameList[0]
  f, csvFile, fieldnames = openCSVFileReader(filename)
  for fieldName in fileFieldNameList[1:]:
    if fieldName not in fieldnames:
      csvFieldErrorExit(fieldName, fieldnames, backupArg=True, checkForCharset=True)
  matchFields, skipFields = getMatchSkipFields(fieldnames)
  dataDelimiter = getDelimiter()
  entitySet = set()
  entityList = []
  i = 1
  for row in csvFile:
    i += 1
    if checkMatchSkipFields(row, matchFields, skipFields):
      for fieldName in fileFieldNameList[1:]:
        if shlexSplit:
          splitStatus, itemList = splitEntityListShlex(row[fieldName].strip(), dataDelimiter)
          if not splitStatus:
            fileDataErrorExit(filename, i, fieldName, row[fieldName].strip(), f'{Msg.INVALID_LIST}: {itemList}')
        else:
          itemList = splitEntityList(row[fieldName].strip(), dataDelimiter)
        for item in itemList:
          item = item.strip()
          if item and (item not in entitySet):
            entitySet.add(item)
            entityList.append(item)
  closeFile(f)
  return entityList

# <FileName> [charset <String>] [warnifnodata] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	keyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <Character>]
#	subkeyfield <FieldName> [keypattern <RegularExpression>] [keyvalue <String>] [delimiter <Character>]
#	(matchfield|skipfield <FieldName> <RegularExpression>)*
#	[datafield <FieldName>(:<FieldName>)* [delimiter <Character>]]
def getEntitiesFromCSVbyField():

  def getKeyFieldInfo(keyword, required, globalKeyField):
    if not checkArgumentPresent(keyword, required=required):
      GM.Globals[globalKeyField] = None
      return (None, None, None, None)
    keyField = GM.Globals[globalKeyField] = getString(Cmd.OB_FIELD_NAME)
    if keyField not in fieldnames:
      csvFieldErrorExit(keyField, fieldnames, backupArg=True)
    if checkArgumentPresent('keypattern'):
      keyPattern = getREPattern()
    else:
      keyPattern = None
    if checkArgumentPresent('keyvalue'):
      keyValue = getString(Cmd.OB_STRING)
    else:
      keyValue = keyField
    keyDelimiter = getDelimiter()
    return (keyField, keyPattern, keyValue, keyDelimiter)

  def getKeyList(row, keyField, keyPattern, keyValue, keyDelimiter, matchFields, skipFields):
    item = row[keyField].strip()
    if not item:
      return []
    if not checkMatchSkipFields(row, matchFields, skipFields):
      return []
    if keyPattern:
      keyList = [keyPattern.sub(keyValue, keyItem.strip()) for keyItem in splitEntityList(item, keyDelimiter)]
    else:
      keyList = [re.sub(keyField, keyItem.strip(), keyValue) for keyItem in splitEntityList(item, keyDelimiter)]
    return [key for key in keyList if key]

  filename = getString(Cmd.OB_FILE_NAME)
  f, csvFile, fieldnames = openCSVFileReader(filename)
  mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter = getKeyFieldInfo('keyfield', True, GM.CSV_KEY_FIELD)
  subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter = getKeyFieldInfo('subkeyfield', False, GM.CSV_SUBKEY_FIELD)
  matchFields, skipFields = getMatchSkipFields(fieldnames)
  if checkArgumentPresent('datafield'):
    if GM.Globals[GM.CSV_DATA_DICT]:
      csvDataAlreadySavedErrorExit()
    GM.Globals[GM.CSV_DATA_FIELD] = getString(Cmd.OB_FIELD_NAME, checkBlank=True)
    dataFields = GM.Globals[GM.CSV_DATA_FIELD].split(':')
    for dataField in dataFields:
      if dataField not in fieldnames:
        csvFieldErrorExit(dataField, fieldnames, backupArg=True)
    dataDelimiter = getDelimiter()
  else:
    GM.Globals[GM.CSV_DATA_FIELD] = None
    dataFields = []
    dataDelimiter = None
  entitySet = set()
  entityList = []
  csvDataKeys = {}
  GM.Globals[GM.CSV_DATA_DICT] = {}
  if not subKeyField:
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields, skipFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          if GM.Globals[GM.CSV_DATA_FIELD]:
            csvDataKeys[mainKey] = set()
            GM.Globals[GM.CSV_DATA_DICT][mainKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              if dataValue not in csvDataKeys[mainKey]:
                csvDataKeys[mainKey].add(dataValue)
                GM.Globals[GM.CSV_DATA_DICT][mainKey].append(dataValue)
  else:
    csvSubKeys = {}
    for row in csvFile:
      mainKeyList = getKeyList(row, mainKeyField, mainKeyPattern, mainKeyValue, mainKeyDelimiter, matchFields, skipFields)
      if not mainKeyList:
        continue
      for mainKey in mainKeyList:
        if mainKey not in entitySet:
          entitySet.add(mainKey)
          entityList.append(mainKey)
          csvSubKeys[mainKey] = set()
          csvDataKeys[mainKey] = {}
          GM.Globals[GM.CSV_DATA_DICT][mainKey] = {}
      subKeyList = getKeyList(row, subKeyField, subKeyPattern, subKeyValue, subKeyDelimiter, {}, {})
      if not subKeyList:
        continue
      for mainKey in mainKeyList:
        for subKey in subKeyList:
          if subKey not in csvSubKeys[mainKey]:
            csvSubKeys[mainKey].add(subKey)
            if GM.Globals[GM.CSV_DATA_FIELD]:
              csvDataKeys[mainKey][subKey] = set()
              GM.Globals[GM.CSV_DATA_DICT][mainKey][subKey] = []
      for dataField in dataFields:
        if dataField in row:
          dataList = splitEntityList(row[dataField].strip(), dataDelimiter)
          for dataValue in dataList:
            dataValue = dataValue.strip()
            if not dataValue:
              continue
            for mainKey in mainKeyList:
              for subKey in subKeyList:
                if dataValue not in csvDataKeys[mainKey][subKey]:
                  csvDataKeys[mainKey][subKey].add(dataValue)
                  GM.Globals[GM.CSV_DATA_DICT][mainKey][subKey].append(dataValue)
  closeFile(f)
  return entityList

# Typically used to map courseparticipants to students or teachers
def mapEntityType(entityType, typeMap):
  if (typeMap is not None) and (entityType in typeMap):
    return typeMap[entityType]
  return entityType

def getEntityArgument(entityList):
  if entityList is None:
    return (0, 0, entityList)
  if isinstance(entityList, dict):
    clLoc = Cmd.Location()
    Cmd.SetLocation(GM.Globals[GM.ENTITY_CL_DELAY_START])
    entityList = getUsersToModify(**entityList)
    Cmd.SetLocation(clLoc)
  return (0, len(entityList), entityList)

def getEntityToModify(defaultEntityType=None, crosAllowed=False, userAllowed=True,
                      typeMap=None, isSuspended=None, groupMemberType=Ent.TYPE_USER, delayGet=False):
  if GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
    crosAllowed = False
    selectorChoices = Cmd.SERVICE_ACCOUNT_ONLY_ENTITY_SELECTORS[:]
  else:
    selectorChoices = Cmd.BASE_ENTITY_SELECTORS[:]
  if userAllowed:
    selectorChoices += Cmd.USER_ENTITY_SELECTORS+Cmd.USER_CSVDATA_ENTITY_SELECTORS
  if crosAllowed:
    selectorChoices += Cmd.CROS_ENTITY_SELECTORS+Cmd.CROS_CSVDATA_ENTITY_SELECTORS
  entitySelector = getChoice(selectorChoices, defaultChoice=None)
  if entitySelector:
    choices = []
    if entitySelector == Cmd.ENTITY_SELECTOR_ALL:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_ALL_SUBTYPES
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_ALL_SUBTYPES
      entityType = Cmd.ENTITY_SELECTOR_ALL_SUBTYPES_MAP[getChoice(choices)]
      if not delayGet:
        return (Cmd.ENTITY_USERS if entityType != Cmd.ENTITY_ALL_CROS else Cmd.ENTITY_CROS,
                getUsersToModify(entityType, None))
      GM.Globals[GM.ENTITY_CL_DELAY_START] = Cmd.Location()
      buildGAPIObject(API.DIRECTORY)
      return (Cmd.ENTITY_USERS if entityType != Cmd.ENTITY_ALL_CROS else Cmd.ENTITY_CROS,
              {'entityType': entityType, 'entity': None})
    if userAllowed:
      if entitySelector == Cmd.ENTITY_SELECTOR_FILE:
        return (Cmd.ENTITY_USERS,
                getUsersToModify(Cmd.ENTITY_USERS, getEntitiesFromFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CSV, Cmd.ENTITY_SELECTOR_CSVFILE]:
        return (Cmd.ENTITY_USERS,
                getUsersToModify(Cmd.ENTITY_USERS, getEntitiesFromCSVFile(False)))
    if crosAllowed:
      if entitySelector == Cmd.ENTITY_SELECTOR_CROSFILE:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS, getEntitiesFromFile(False)))
      if entitySelector == Cmd.ENTITY_SELECTOR_CROSFILE_SN:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS_SN, getEntitiesFromFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CROSCSV, Cmd.ENTITY_SELECTOR_CROSCSVFILE]:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS, getEntitiesFromCSVFile(False)))
      if entitySelector in [Cmd.ENTITY_SELECTOR_CROSCSV_SN, Cmd.ENTITY_SELECTOR_CROSCSVFILE_SN]:
        return (Cmd.ENTITY_CROS,
                getUsersToModify(Cmd.ENTITY_CROS_SN, getEntitiesFromCSVFile(False)))
    if entitySelector == Cmd.ENTITY_SELECTOR_DATAFILE:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY] else [Cmd.ENTITY_USERS]
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices), typeMap)
      return (Cmd.ENTITY_USERS if entityType not in Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES else Cmd.ENTITY_CROS,
              getUsersToModify(entityType, getEntitiesFromFile(shlexSplit=entityType in [Cmd.ENTITY_OUS, Cmd.ENTITY_OUS_AND_CHILDREN,
                                                                                         Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS,
                                                                                         Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP,
                                                                                         Cmd.ENTITY_CROS_OUS, Cmd.ENTITY_CROS_OUS_AND_CHILDREN])))
    if entitySelector == Cmd.ENTITY_SELECTOR_CSVDATAFILE:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY] else [Cmd.ENTITY_USERS]
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices), typeMap)
      return (Cmd.ENTITY_USERS if entityType not in Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES else Cmd.ENTITY_CROS,
              getUsersToModify(entityType, getEntitiesFromCSVFile(shlexSplit=entityType in [Cmd.ENTITY_OUS, Cmd.ENTITY_OUS_AND_CHILDREN,
                                                                                            Cmd.ENTITY_OUS_NS, Cmd.ENTITY_OUS_AND_CHILDREN_NS,
                                                                                            Cmd.ENTITY_OUS_SUSP, Cmd.ENTITY_OUS_AND_CHILDREN_SUSP,
                                                                                            Cmd.ENTITY_CROS_OUS, Cmd.ENTITY_CROS_OUS_AND_CHILDREN])))
    if entitySelector == Cmd.ENTITY_SELECTOR_CSVKMD:
      if userAllowed:
        choices += Cmd.USER_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY] else [Cmd.ENTITY_USERS]
      if crosAllowed:
        choices += Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES
      entityType = mapEntityType(getChoice(choices, choiceAliases=Cmd.ENTITY_ALIAS_MAP), typeMap)
      return (Cmd.ENTITY_USERS if entityType not in Cmd.CROS_ENTITY_SELECTOR_DATAFILE_CSVKMD_SUBTYPES else Cmd.ENTITY_CROS,
              getUsersToModify(entityType, getEntitiesFromCSVbyField()))
    if entitySelector in [Cmd.ENTITY_SELECTOR_CSVDATA, Cmd.ENTITY_SELECTOR_CROSCSVDATA]:
      checkDataField()
      return (Cmd.ENTITY_USERS if entitySelector == Cmd.ENTITY_SELECTOR_CSVDATA else Cmd.ENTITY_CROS,
              GM.Globals[GM.CSV_DATA_DICT])
  entityChoices = []
  if userAllowed:
    entityChoices += Cmd.USER_ENTITIES if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY] else [Cmd.ENTITY_USER, Cmd.ENTITY_USERS]
  if crosAllowed:
    entityChoices += Cmd.CROS_ENTITIES
  entityType = mapEntityType(getChoice(entityChoices, choiceAliases=Cmd.ENTITY_ALIAS_MAP, defaultChoice=defaultEntityType), typeMap)
  if entityType:
    if entityType not in Cmd.CROS_ENTITIES:
      entityClass = Cmd.ENTITY_USERS
      if entityType == Cmd.ENTITY_OAUTHUSER:
        return (entityClass, [_getAdminEmail()])
      entityItem = getString(Cmd.OB_USER_ENTITY, minLen=0)
    else:
      entityClass = Cmd.ENTITY_CROS
      entityItem = getString(Cmd.OB_CROS_ENTITY, minLen=0)
    if not delayGet:
      if entityClass == Cmd.ENTITY_USERS:
        return (entityClass,
                getUsersToModify(entityType, entityItem, isSuspended=isSuspended, groupMemberType=groupMemberType))
      return (entityClass,
              getUsersToModify(entityType, entityItem))
    GM.Globals[GM.ENTITY_CL_DELAY_START] = Cmd.Location()
    if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
      buildGAPIObject(API.DIRECTORY)
    if entityClass == Cmd.ENTITY_USERS:
      if entityType in [Cmd.ENTITY_GROUP_USERS, Cmd.ENTITY_GROUP_USERS_NS, Cmd.ENTITY_GROUP_USERS_SUSP]:
        # Skip over sub-arguments
        while Cmd.ArgumentsRemaining():
          myarg = getArgument()
          if myarg in GROUP_ROLES_MAP or myarg in {'primarydomain', 'domains', 'recursive', 'includederivedmembership'}:
            pass
          elif myarg == 'end':
            break
          else:
            Cmd.Backup()
            missingArgumentExit('end')
      return (entityClass,
              {'entityType': entityType, 'entity': entityItem, 'isSuspended': isSuspended, 'groupMemberType': groupMemberType})
    return (entityClass,
            {'entityType': entityType, 'entity': entityItem})
  invalidChoiceExit(entityType, selectorChoices+entityChoices, False)

def getEntitySelector():
  return getChoice(Cmd.ENTITY_LIST_SELECTORS, defaultChoice=None)

def getEntitySelection(entitySelector, shlexSplit):
  if entitySelector in [Cmd.ENTITY_SELECTOR_FILE]:
    return getEntitiesFromFile(shlexSplit)
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSV, Cmd.ENTITY_SELECTOR_CSVFILE]:
    return getEntitiesFromCSVFile(shlexSplit)
  if entitySelector == Cmd.ENTITY_SELECTOR_CSVKMD:
    return getEntitiesFromCSVbyField()
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSVSUBKEY]:
    checkSubkeyField()
    return GM.Globals[GM.CSV_DATA_DICT]
  if entitySelector in [Cmd.ENTITY_SELECTOR_CSVDATA]:
    checkDataField()
    return GM.Globals[GM.CSV_DATA_DICT]
  return []

def getEntityList(item, shlexSplit=False):
  entitySelector = getEntitySelector()
  if entitySelector:
    return getEntitySelection(entitySelector, shlexSplit)
  return convertEntityToList(getString(item, minLen=0), shlexSplit=shlexSplit)

def getNormalizedEmailAddressEntity(shlexSplit=False, noUid=True):
  return [normalizeEmailAddressOrUID(emailAddress, noUid) for emailAddress in getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY, shlexSplit)]

def getUserObjectEntity(clObject, itemType):
  entity = {'item': itemType, 'list': getEntityList(clObject), 'dict': None}
  if isinstance(entity['list'], dict):
    entity['dict'] = entity['list']
  return entity

def _validateUserGetObjectList(user, i, count, entity):
  if entity['dict']:
    entityList = entity['dict'][user]
  else:
    entityList = entity['list']
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if not gmail:
    return (user, None, [], 0)
  jcount = len(entityList)
  entityPerformActionNumItems([Ent.USER, user], jcount, entity['item'], i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, gmail, entityList, jcount)

def _validateUserGetMessageIds(user, i, count, entity):
  if entity:
    if entity['dict']:
      entityList = entity['dict'][user]
    else:
      entityList = entity['list']
  else:
    entityList = []
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if not gmail:
    return (user, None, None)
  return (user, gmail, entityList)

def checkUserExists(cd, user, i=0, count=0):
  user = normalizeEmailAddressOrUID(user)
  try:
    return callGAPI(cd.users(), 'get',
                    throwReasons=GAPI.USER_GET_THROW_REASONS,
                    userKey=user, fields='primaryEmail')['primaryEmail']
  except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
    entityUnknownWarning(Ent.USER, user, i, count)
    return None

# Add attachements to an email message
def _addAttachmentsToMessage(message, attachments):
  for attachment in attachments:
    try:
      attachFilename = attachment[0]
      attachContentType, attachEncoding = mimetypes.guess_type(attachFilename)
      if attachContentType is None or attachEncoding is not None:
        attachContentType = 'application/octet-stream'
      main_type, sub_type = attachContentType.split('/', 1)
      if main_type == 'text':
        msg = MIMEText(readFile(attachFilename, 'r', attachment[1]), _subtype=sub_type, _charset=UTF8)
      elif main_type == 'image':
        msg = MIMEImage(readFile(attachFilename, 'rb'), _subtype=sub_type)
      elif main_type == 'audio':
        msg = MIMEAudio(readFile(attachFilename, 'rb'), _subtype=sub_type)
      elif main_type == 'application':
        msg = MIMEApplication(readFile(attachFilename, 'rb'), _subtype=sub_type)
      else:
        msg = MIMEBase(main_type, sub_type)
        msg.set_payload(readFile(attachFilename, 'rb'))
      msg.add_header('Content-Disposition', 'attachment', filename=os.path.basename(attachFilename))
      message.attach(msg)
    except (IOError, UnicodeDecodeError) as e:
      usageErrorExit(f'{attachFilename}: {str(e)}')

NAME_EMAIL_ADDRESS_PATTERN = re.compile(r'^.*<(.+)>$')

# Send an email
def send_email(msgSubject, msgBody, msgTo, i=0, count=0, clientAccess=False, msgFrom=None, msgReplyTo=None,
               html=False, charset=UTF8, attachments=None, ccRecipients=None, bccRecipients=None, mailBox=None):
  def checkResult(entityType, recipients):
    if not recipients:
      return
    toSent = set(recipients.split(','))
    toFailed = {}
    for addr, err in iter(result.items()):
      if addr in toSent:
        toSent.remove(addr)
        toFailed[addr] = f'{err[0]}: {err[1]}'
    if toSent:
      entityActionPerformed([entityType, ','.join(toSent), Ent.MESSAGE, msgSubject], i, count)
    for addr, errMsg in iter(toFailed.items()):
      entityActionFailedWarning([entityType, addr, Ent.MESSAGE, msgSubject], errMsg, i, count)

  def cleanAddr(emailAddr):
    match = NAME_EMAIL_ADDRESS_PATTERN.match(emailAddr)
    if match:
      return match.group(1)
    return emailAddr

  if msgFrom is None:
    msgFrom = _getAdminEmail()
  # Force ASCII for RFC compliance
  # xmlcharref seems to work to display at least
  # some unicode in HTML body and is ignored in
  # plain text body.
#  msgBody = msgBody.encode('ascii', 'xmlcharrefreplace').decode(UTF8)
  if not attachments:
    message = MIMEText(msgBody, ['plain', 'html'][html], charset)
  else:
    message = MIMEMultipart()
    msg = MIMEText(msgBody, ['plain', 'html'][html], charset)
    message.attach(msg)
    _addAttachmentsToMessage(message, attachments)
  message['Subject'] = msgSubject
  message['From'] = msgFrom
  if msgReplyTo is not None:
    message['Reply-To'] = msgReplyTo
  if ccRecipients:
    message['CC'] = ccRecipients.lower()
  if bccRecipients:
    message['BCC'] = bccRecipients.lower()
  if mailBox is None:
    mailBox = msgFrom
  mailBoxAddr = normalizeEmailAddressOrUID(cleanAddr(mailBox), noUid=True)
  action = Act.Get()
  Act.Set(Act.SENDEMAIL)
  if not GC.Values[GC.SMTP_HOST]:
    if not clientAccess:
      userId, gmail = buildGAPIServiceObject(API.GMAIL, mailBoxAddr)
      if not gmail:
        return
    else:
      userId = mailBoxAddr
      gmail = buildGAPIObject(API.GMAIL)
    message['To'] = (msgTo if msgTo else userId).lower()
    try:
      callGAPI(gmail.users().messages(), 'send',
               throwReasons=[GAPI.SERVICE_NOT_AVAILABLE, GAPI.AUTH_ERROR, GAPI.DOMAIN_POLICY,
                             GAPI.INVALID_ARGUMENT, GAPI.FORBIDDEN],
               userId=userId, body={'raw': base64.urlsafe_b64encode(message.as_bytes()).decode()}, fields='')
      entityActionPerformed([Ent.RECIPIENT, msgTo, Ent.MESSAGE, msgSubject], i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy,
            GAPI.invalidArgument, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.RECIPIENT, msgTo, Ent.MESSAGE, msgSubject], str(e), i, count)
  else:
    message['To'] = (msgTo if msgTo else mailBoxAddr).lower()
    server = None
    try:
      server = smtplib.SMTP(GC.Values[GC.SMTP_HOST], 587, GC.Values[GC.SMTP_FQDN])
      if GC.Values[GC.DEBUG_LEVEL] > 0:
        server.set_debuglevel(1)
      server.starttls(context=ssl.create_default_context(cafile=GC.Values[GC.CACERTS_PEM]))
      if GC.Values[GC.SMTP_USERNAME] and GC.Values[GC.SMTP_PASSWORD]:
        if isinstance(GC.Values[GC.SMTP_PASSWORD], bytes):
          server.login(GC.Values[GC.SMTP_USERNAME], base64.b64decode(GC.Values[GC.SMTP_PASSWORD]).decode(UTF8))
        else:
          server.login(GC.Values[GC.SMTP_USERNAME], GC.Values[GC.SMTP_PASSWORD])
      result = server.send_message(message)
      checkResult(Ent.RECIPIENT, message['To'])
      checkResult(Ent.RECIPIENT_CC, ccRecipients)
      checkResult(Ent.RECIPIENT_BCC, bccRecipients)
    except smtplib.SMTPException as e:
      entityActionFailedWarning([Ent.RECIPIENT, msgTo, Ent.MESSAGE, msgSubject], str(e), i, count)
    if server:
      try:
        server.quit()
      except Exception:
        pass
  Act.Set(action)

def addFieldToFieldsList(fieldName, fieldsChoiceMap, fieldsList):
  fields = fieldsChoiceMap[fieldName.lower()]
  if isinstance(fields, list):
    fieldsList.extend(fields)
  else:
    fieldsList.append(fields)

def _getFieldsList():
  return getString(Cmd.OB_FIELD_NAME_LIST).lower().replace('_', '').replace(',', ' ').split()

def _addInitialField(fieldsList, initialField):
  if isinstance(initialField, list):
    fieldsList.extend(initialField)
  else:
    fieldsList.append(initialField)

# myarg is command line argument
# fieldChoiceMap maps myarg to API field names
#FIELD_CHOICES_MAP = {
#  'foo': 'foo',
#  'foobar': 'fooBar',
#  }
# fieldsList is the list of API fields
def getFieldsList(myarg, fieldsChoiceMap, fieldsList, initialField=None, fieldsArg='fields'):
  def addMappedFields(mappedFields):
    if isinstance(mappedFields, list):
      fieldsList.extend(mappedFields)
    else:
      fieldsList.append(mappedFields)

  if myarg in fieldsChoiceMap:
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    addMappedFields(fieldsChoiceMap[myarg])
  elif myarg == fieldsArg:
    if not fieldsList and initialField is not None:
      _addInitialField(fieldsList, initialField)
    for field in _getFieldsList():
      if field in fieldsChoiceMap:
        addMappedFields(fieldsChoiceMap[field])
      else:
        invalidChoiceExit(field, fieldsChoiceMap, True)
  else:
    return False
  return True

def getFieldsFromFieldsList(fieldsList):
  if fieldsList:
    return ','.join(set(fieldsList)).replace('.', '/')
  return None

def getItemFieldsFromFieldsList(item, fieldsList, returnItemIfNoneList=False):
  if  fieldsList:
    return f'nextPageToken,{item}({",".join(set(fieldsList))})'.replace('.', '/')
  if not returnItemIfNoneList:
    return None
  return f'nextPageToken,{item}'

class CSVPrintFile():

  def __init__(self, titles=None, sortTitles=None, indexedTitles=None):
    self.rows = []
    self.todrive = GM.Globals[GM.CSV_TODRIVE]
    self.titlesSet = set()
    self.titlesList = []
    self.JSONtitlesSet = set()
    self.JSONtitlesList = []
    if titles is not None:
      self.SetTitles(titles)
      self.SetJSONTitles(titles)
    self.SetColumnDelimiter(GM.Globals.get(GM.CSV_OUTPUT_COLUMN_DELIMITER, GC.Values.get(GC.CSV_OUTPUT_COLUMN_DELIMITER, ',')))
    self.SetQuoteChar(GM.Globals.get(GM.CSV_OUTPUT_QUOTE_CHAR, GC.Values.get(GC.CSV_OUTPUT_QUOTE_CHAR, '"')))
    self.SetFormatJSON(False)
    self.SetFixPaths(False)
    self.SetShowPermissionsLast(False)
    self.sortTitlesSet = set()
    self.sortTitlesList = []
    if sortTitles is not None:
      if not isinstance(sortTitles, str) or sortTitles != 'sortall':
        self.SetSortTitles(sortTitles)
      else:
        self.SetSortAllTitles()
    self.SetIndexedTitles(indexedTitles if indexedTitles is not None else [])
    self.SetHeaderFilter(GC.Values[GC.CSV_OUTPUT_HEADER_FILTER])
    self.SetHeaderDropFilter(GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER])
    self.SetRowFilter(GC.Values[GC.CSV_OUTPUT_ROW_FILTER])
    self.SetRowDropFilter(GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER])
    self.SetZeroBlankMimeTypeCounts(False)

  def AddTitle(self, title):
    self.titlesSet.add(title)
    self.titlesList.append(title)

  def AddTitles(self, titles):
    for title in titles if isinstance(titles, list) else [titles]:
      if title not in self.titlesSet:
        self.AddTitle(title)

  def SetTitles(self, titles):
    self.titlesSet = set()
    self.titlesList = []
    self.AddTitles(titles)

  def RemoveTitles(self, titles):
    for title in titles if isinstance(titles, list) else [titles]:
      if title in self.titlesSet:
        self.titlesSet.remove(title)
        self.titlesList.remove(title)

  def MoveTitlesToEnd(self, titles):
    self.RemoveTitles(titles)
    self.AddTitles(titles)

  def AddSortTitle(self, title):
    self.sortTitlesSet.add(title)
    self.sortTitlesList.append(title)

  def AddSortTitles(self, titles):
    for title in titles if isinstance(titles, list) else [titles]:
      if title not in self.sortTitlesSet:
        self.AddSortTitle(title)

  def SetSortTitles(self, titles):
    self.sortTitlesSet = set()
    self.sortTitlesList = []
    self.AddSortTitles(titles)

  def SetSortAllTitles(self):
    self.sortTitlesList = self.titlesList[:]
    self.sortTitlesSet = set(self.sortTitlesList)

  def UpdateMappedTitles(self):
    self.titlesSet = set(self.titlesList)

  def AddJSONTitle(self, title):
    self.JSONtitlesSet.add(title)
    self.JSONtitlesList.append(title)

  def AddJSONTitles(self, titles):
    for title in titles if isinstance(titles, list) else [titles]:
      if title not in self.JSONtitlesSet:
        self.AddJSONTitle(title)

  def MoveJSONTitlesToEnd(self, titles):
    for title in titles if isinstance(titles, list) else [titles]:
      self.JSONtitlesList.remove(title)
      self.JSONtitlesList.append(title)

  def SetJSONTitles(self, titles):
    self.JSONtitlesSet = set()
    self.JSONtitlesList = []
    self.AddJSONTitles(titles)

# fieldName is command line argument
# fieldNameMap maps fieldName to API field names; CSV file header will be API field name
#ARGUMENT_TO_PROPERTY_MAP = {
#  'admincreated': 'adminCreated',
#  'aliases': ['aliases', 'nonEditableAliases'],
#  }
# fieldsList is the list of API fields
  def AddField(self, fieldName, fieldNameMap, fieldsList):
    fields = fieldNameMap[fieldName.lower()]
    if isinstance(fields, list):
      for field in fields:
        if field not in fieldsList:
          fieldsList.append(field)
          self.AddTitles(field)
    elif fields not in fieldsList:
      fieldsList.append(fields)
      self.AddTitles(fields)

  def GetFieldsListTitles(self, fieldName, fieldsChoiceMap, fieldsList, initialField=None):
    if fieldName in fieldsChoiceMap:
      if not fieldsList and initialField is not None:
        _addInitialField(fieldsList, initialField)
      self.AddField(fieldName, fieldsChoiceMap, fieldsList)
    elif fieldName == 'fields':
      if not fieldsList and initialField is not None:
        _addInitialField(fieldsList, initialField)
      for field in _getFieldsList():
        if field in fieldsChoiceMap:
          self.AddField(field, fieldsChoiceMap, fieldsList)
        else:
          invalidChoiceExit(field, fieldsChoiceMap, True)
    else:
      return False
    return True

  TDSHEET_ENTITY_MAP = {'tdsheet': 'sheetEntity', 'tdbackupsheet': 'backupSheetEntity', 'tdcopysheet': 'copySheetEntity'}

  def GetTodriveParameters(self):
    def invalidTodriveFileIdExit(entityValueList, message, location):
      Cmd.SetLocation(location-1)
      usageErrorExit(formatKeyValueList('', Ent.FormatEntityValueList([Ent.DRIVE_FILE_ID, self.todrive['fileId']]+entityValueList)+[message], ''))

    def invalidTodriveParentExit(entityType, message):
      Cmd.SetLocation(tdparentLocation-1)
      if not localParent:
        usageErrorExit(Msg.INVALID_ENTITY.format(Ent.Singular(entityType),
                                                 formatKeyValueList('',
                                                                    [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                                                     Ent.Singular(Ent.ITEM), GC.TODRIVE_PARENT,
                                                                     Ent.Singular(Ent.VALUE), self.todrive['parent'],
                                                                     message],
                                                                    '')))
      else:
        usageErrorExit(Msg.INVALID_ENTITY.format(Ent.Singular(entityType), message))

    def invalidTodriveUserExit(entityType, message):
      Cmd.SetLocation(tduserLocation-1)
      if not localUser:
        usageErrorExit(Msg.INVALID_ENTITY.format(Ent.Singular(entityType),
                                                 formatKeyValueList('',
                                                                    [Ent.Singular(Ent.CONFIG_FILE), GM.Globals[GM.GAM_CFG_FILE],
                                                                     Ent.Singular(Ent.ITEM), GC.TODRIVE_USER,
                                                                     Ent.Singular(Ent.VALUE), self.todrive['user'],
                                                                     message],
                                                                    '')))
      else:
        usageErrorExit(Msg.INVALID_ENTITY.format(Ent.Singular(entityType), message))

    def getDriveObject():
      if not GC.Values[GC.TODRIVE_CLIENTACCESS]:
        _, drive = buildGAPIServiceObject(API.DRIVETD, self.todrive['user'])
        if not drive:
          invalidTodriveUserExit(Ent.USER, Msg.NOT_FOUND)
      else:
        drive = buildGAPIObject(API.DRIVE3)
      return drive

    CELL_WRAP_MAP = {'clip': 'CLIP', 'overflow': 'OVERFLOW_CELL', 'overflowcell': 'OVERFLOW_CELL', 'wrap': 'WRAP'}

    localUser = localParent = False
    tdfileidLocation = tdparentLocation = tdupdatesheetLocation = tduserLocation = Cmd.Location()
    tdsheetLocation = {}
    for sheetEntity in iter(self.TDSHEET_ENTITY_MAP.values()):
      tdsheetLocation[sheetEntity] = Cmd.Location()
    self.todrive = {'user': GC.Values[GC.TODRIVE_USER], 'title': None, 'description': None,
                    'sheetEntity': None, 'updatesheet': False,
                    'cellwrap': None, 'clearfilter': GC.Values[GC.TODRIVE_CLEARFILTER],
                    'backupSheetEntity': None, 'copySheetEntity': None,
                    'locale': GC.Values[GC.TODRIVE_LOCALE], 'timeZone': GC.Values[GC.TODRIVE_TIMEZONE],
                    'timestamp': GC.Values[GC.TODRIVE_TIMESTAMP], 'daysoffset': 0, 'hoursoffset': 0,
                    'timeformat': GC.Values[GC.TODRIVE_TIMEFORMAT],
                    'fileId': None, 'parentId': None, 'parent': GC.Values[GC.TODRIVE_PARENT],
                    'localcopy': GC.Values[GC.TODRIVE_LOCALCOPY], 'nobrowser': GC.Values[GC.TODRIVE_NOBROWSER],
                    'noemail': GC.Values[GC.TODRIVE_NOEMAIL]}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'tduser':
        self.todrive['user'] = getString(Cmd.OB_EMAIL_ADDRESS)
        tduserLocation = Cmd.Location()
        localUser = True
      elif myarg == 'tdtitle':
        self.todrive['title'] = getString(Cmd.OB_STRING)
      elif myarg == 'tddescription':
        self.todrive['description'] = getString(Cmd.OB_STRING)
      elif myarg in self.TDSHEET_ENTITY_MAP:
        sheetEntity = self.TDSHEET_ENTITY_MAP[myarg]
        tdsheetLocation[sheetEntity] = Cmd.Location()
        self.todrive[sheetEntity] = getSheetEntity()
      elif myarg == 'tdupdatesheet':
        tdupdatesheetLocation = Cmd.Location()
        self.todrive['updatesheet'] = getBoolean()
      elif myarg == 'tdcellwrap':
        self.todrive['cellwrap'] = getChoice(CELL_WRAP_MAP, mapChoice=True)
      elif myarg == 'tdclearfilter':
        self.todrive['clearfilter'] = getBoolean()
      elif myarg == 'tdlocale':
        self.todrive['locale'] = getLocaleCode()
      elif myarg == 'tdtimezone':
        self.todrive['timeZone'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == 'tdtimestamp':
        self.todrive['timestamp'] = getBoolean()
      elif myarg == 'tdtimeformat':
        self.todrive['timeformat'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == 'tddaysoffset':
        self.todrive['daysoffset'] = getInteger(minVal=0)
      elif myarg == 'tdhoursoffset':
        self.todrive['hoursoffset'] = getInteger(minVal=0)
      elif myarg == 'tdfileid':
        self.todrive['fileId'] = getString(Cmd.OB_DRIVE_FILE_ID)
        tdfileidLocation = Cmd.Location()
      elif myarg == 'tdparent':
        self.todrive['parent'] = escapeDriveFileName(getString(Cmd.OB_DRIVE_FOLDER_NAME, minLen=0))
        tdparentLocation = Cmd.Location()
        localParent = True
      elif myarg == 'tdlocalcopy':
        self.todrive['localcopy'] = getBoolean()
      elif myarg == 'tdnobrowser':
        self.todrive['nobrowser'] = getBoolean()
      elif myarg == 'tdnoemail':
        self.todrive['noemail'] = getBoolean()
      else:
        Cmd.Backup()
        break
    if self.todrive['updatesheet'] and (not self.todrive['fileId'] or not self.todrive['sheetEntity']):
      Cmd.SetLocation(tdupdatesheetLocation-1)
      missingArgumentExit('tdfileid and tdsheet')
    if self.todrive['sheetEntity'] and self.todrive['sheetEntity']['sheetId'] and (not self.todrive['fileId'] or not self.todrive['updatesheet']):
      Cmd.SetLocation(tdsheetLocation['sheetEntity']-1)
      missingArgumentExit('tdfileid and tdupdatesheet')
    if not self.todrive['user'] or GC.Values[GC.TODRIVE_CLIENTACCESS]:
      self.todrive['user'] = _getAdminEmail()
    if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY] and not GC.Values[GC.TODRIVE_CLIENTACCESS]:
      user = checkUserExists(buildGAPIObject(API.DIRECTORY), self.todrive['user'])
      if not user:
        invalidTodriveUserExit(Ent.USER, Msg.NOT_FOUND)
      self.todrive['user'] = user
    else:
      self.todrive['user'] = normalizeEmailAddressOrUID(self.todrive['user'])
    if self.todrive['fileId']:
      drive = getDriveObject()
      try:
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                          fileId=self.todrive['fileId'], fields='id,mimeType,capabilities(canEdit)', supportsAllDrives=True)
        if result['mimeType'] == MIMETYPE_GA_FOLDER:
          invalidTodriveFileIdExit([], Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FILE)), tdfileidLocation)
        if not result['capabilities']['canEdit']:
          invalidTodriveFileIdExit([], Msg.NOT_WRITABLE, tdfileidLocation)
        if self.todrive['sheetEntity']:
          if result['mimeType'] != MIMETYPE_GA_SPREADSHEET:
            invalidTodriveFileIdExit([], f'{Msg.NOT_A} {Ent.Singular(Ent.SPREADSHEET)}', tdfileidLocation)
          if not GC.Values[GC.TODRIVE_CLIENTACCESS]:
            _, sheet = buildGAPIServiceObject(API.SHEETSTD, self.todrive['user'])
            if sheet is None:
              invalidTodriveUserExit(Ent.USER, Msg.NOT_FOUND)
          else:
            sheet = buildGAPIObject(API.SHEETS)
          try:
            spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                                   throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                                   spreadsheetId=self.todrive['fileId'],
                                   fields='spreadsheetUrl,sheets(properties(sheetId,title),protectedRanges(range(sheetId),requestingUserCanEdit))')
            for sheetEntity in iter(self.TDSHEET_ENTITY_MAP.values()):
              if self.todrive[sheetEntity]:
                sheetId = getSheetIdFromSheetEntity(spreadsheet, self.todrive[sheetEntity])
                if sheetId is None:
                  invalidTodriveFileIdExit([self.todrive[sheetEntity]['sheetType'], self.todrive[sheetEntity]['sheetValue']], Msg.NOT_FOUND, tdsheetLocation[sheetEntity])
                if protectedSheetId(spreadsheet, sheetId):
                  invalidTodriveFileIdExit([self.todrive[sheetEntity]['sheetType'], self.todrive[sheetEntity]['sheetValue']], Msg.NOT_WRITABLE, tdsheetLocation[sheetEntity])
                self.todrive[sheetEntity]['sheetId'] = sheetId
          except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
                  GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
            invalidTodriveFileIdExit([], str(e), tdfileidLocation)
      except GAPI.fileNotFound:
        invalidTodriveFileIdExit([], Msg.NOT_FOUND, tdfileidLocation)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        invalidTodriveUserExit(Ent.USER, str(e))
    elif not self.todrive['parent'] or self.todrive['parent'] == ROOT:
      self.todrive['parentId'] = ROOT
    else:
      drive = getDriveObject()
      if self.todrive['parent'].startswith('id:'):
        try:
          result = callGAPI(drive.files(), 'get',
                            throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.INVALID],
                            fileId=self.todrive['parent'][3:], fields='id,mimeType,capabilities(canEdit)', supportsAllDrives=True)
        except GAPI.fileNotFound:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_FOUND)
        except GAPI.invalid as e:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, str(e))
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          invalidTodriveUserExit(Ent.USER, str(e))
        if result['mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER)))
        if not result['capabilities']['canEdit']:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_ID, Msg.NOT_WRITABLE)
        self.todrive['parentId'] = result['id']
      else:
        try:
          results = callGAPIpages(drive.files(), 'list', 'files',
                                  throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY],
                                  retryReasons=[GAPI.UNKNOWN_ERROR],
                                  q=f"name = '{self.todrive['parent']}'",
                                  fields='nextPageToken,files(id,mimeType,capabilities(canEdit))',
                                  pageSize=1, supportsAllDrives=True)
        except GAPI.invalidQuery:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_FOUND)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          invalidTodriveUserExit(Ent.USER, str(e))
        if not results:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_FOUND)
        if results[0]['mimeType'] != MIMETYPE_GA_FOLDER:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER)))
        if not results[0]['capabilities']['canEdit']:
          invalidTodriveParentExit(Ent.DRIVE_FOLDER_NAME, Msg.NOT_WRITABLE)
        self.todrive['parentId'] = results[0]['id']

  def SortTitles(self):
    if not self.sortTitlesList:
      return
    restoreTitles = []
    for title in self.sortTitlesList:
      if title in self.titlesSet:
        self.titlesList.remove(title)
        restoreTitles.append(title)
    self.titlesList.sort()
    for title in restoreTitles[::-1]:
      self.titlesList.insert(0, title)

  def SetIndexedTitles(self, indexedTitles):
    self.indexedTitles = indexedTitles

  def SortIndexedTitles(self, titlesList):
    for field in self.indexedTitles:
      fieldDotN = re.compile(fr'({field})\.(\d+)(.*)')
      indexes = []
      subtitles = []
      for i, v in enumerate(titlesList):
        mg = fieldDotN.match(v)
        if mg:
          indexes.append(i)
          subtitles.append(mg.groups(''))
      for i, ii in enumerate(indexes):
        titlesList[ii] = [f'{subtitle[0]}.{subtitle[1]}{subtitle[2]}' for subtitle in sorted(subtitles, key=lambda k: (int(k[1]), k[2]))][i]

  @staticmethod
  def FixPathsTitles(titlesList):
# Put paths before path.0
    try:
      index = titlesList.index('path.0')
      titlesList.remove('paths')
      titlesList.insert(index, 'paths')
    except ValueError:
      pass

  def MovePermsToEnd(self):
# Put permissions at end of titles
    try:
      last = len(self.titlesList)
      start = end = self.titlesList.index('permissions')
      while end < last and self.titlesList[end].startswith('permissions'):
        end += 1
      self.titlesList = self.titlesList[:start]+self.titlesList[end:]+self.titlesList[start:end]
    except ValueError:
      pass

  def SetColumnDelimiter(self, columnDelimiter):
    self.columnDelimiter = columnDelimiter

  def SetQuoteChar(self, quoteChar):
    self.quoteChar = quoteChar

  def SetFormatJSON(self, formatJSON):
    self.formatJSON = formatJSON

  def SetFixPaths(self, fixPaths):
    self.fixPaths = fixPaths

  def SetShowPermissionsLast(self, showPermissionsLast):
    self.showPermissionsLast = showPermissionsLast

  def FixCourseAliasesTitles(self):
# Put Aliases.* after Aliases
    try:
      aliasesIndex = self.sortTitlesList.index('Aliases')
      index = self.titlesList.index('Aliases.0')
      tempSortTitlesList = self.sortTitlesList[:]
      self.SetSortTitles(tempSortTitlesList[:aliasesIndex+1])
      while self.titlesList[index].startswith('Aliases.'):
        self.AddSortTitle(self.titlesList[index])
        index += 1
      self.AddSortTitles(tempSortTitlesList[aliasesIndex+1:])
    except ValueError:
      pass

  def RearrangeCourseTitles(self, ttitles, stitles):
# Put teachers and students after courseMaterialSets if present, otherwise at end
    ttitles['list'].sort()
    stitles['list'].sort()
    try:
      cmsIndex = self.titlesList.index('courseMaterialSets')
      self.titlesList = self.titlesList[:cmsIndex]+ttitles['list']+stitles['list']+self.titlesList[cmsIndex:]
    except ValueError:
      self.titlesList.extend(ttitles['list'])
      self.titlesList.extend(stitles['list'])

  def SortRows(self, title, reverse):
    if title in self.titlesSet:
      self.rows.sort(key=lambda k: k[title], reverse=reverse)

  def SortRowsTwoTitles(self, title1, title2, reverse):
    if title1 in self.titlesSet and title2 in self.titlesSet:
      self.rows.sort(key=lambda k: (k[title1], k[title2]), reverse=reverse)

  def SetRowFilter(self, rowFilter):
    self.rowFilter = rowFilter

  def SetRowDropFilter(self, rowDropFilter):
    self.rowDropFilter = rowDropFilter

  def RowFilterMatch(self, row):
    def rowRegexFilterMatch(filterPattern):
      for column in columns:
        if filterPattern.search(str(row.get(column, ''))):
          return True
      return False

    def rowNotRegexFilterMatch(filterPattern):
      for column in columns:
        if filterPattern.search(str(row.get(column, ''))):
          return False
      return True

    def stripTimeFromDateTime(rowDate):
      if YYYYMMDD_PATTERN.match(rowDate):
        try:
          rowTime = datetime.datetime.strptime(rowDate, YYYYMMDD_FORMAT)
        except ValueError:
          return None
        tz = GC.Values[GC.TIMEZONE]
      else:
        try:
          rowTime, tz = iso8601.parse_date(rowDate)
        except (iso8601.ParseError, OverflowError):
          return None
      return ISOformatTimeStamp(datetime.datetime(rowTime.year, rowTime.month, rowTime.day, tzinfo=tz))

    def rowDateTimeFilterMatch(dateMode, op, filterDate):
      def checkMatch(rowDate):
        if not rowDate or not isinstance(rowDate, str):
          return False
        if rowDate == GC.Values[GC.NEVER_TIME]:
          rowDate = NEVER_TIME
        if dateMode:
          rowDate = stripTimeFromDateTime(rowDate)
          if not rowDate:
            return False
        if op == '<':
          return rowDate < filterDate
        if op == '<=':
          return rowDate <= filterDate
        if op == '>':
          return rowDate > filterDate
        if op == '>=':
          return rowDate >= filterDate
        if op == '!=':
          return rowDate != filterDate
        return rowDate == filterDate

      for column in columns:
        if checkMatch(row.get(column, '')):
          return True
      return False

    def rowDateTimeRangeFilterMatch(dateMode, op, filterDateL, filterDateR):
      def checkMatch(rowDate):
        if not rowDate or not isinstance(rowDate, str):
          return False
        if rowDate == GC.Values[GC.NEVER_TIME]:
          rowDate = NEVER_TIME
        if dateMode:
          rowDate = stripTimeFromDateTime(rowDate)
          if not rowDate:
            return False
        if op == '!=':
          return not filterDateL <= rowDate <= filterDateR
        return filterDateL <= rowDate <= filterDateR

      for column in columns:
        if checkMatch(row.get(column, '')):
          return True
      return False

    def rowCountFilterMatch(op, filterCount):
      def checkMatch(rowCount):
        if isinstance(rowCount, str):
          if not rowCount.isdigit():
            return False
          rowCount = int(rowCount)
        elif not isinstance(rowCount, int):
          return False
        if op == '<':
          return rowCount < filterCount
        if op == '<=':
          return rowCount <= filterCount
        if op == '>':
          return rowCount > filterCount
        if op == '>=':
          return rowCount >= filterCount
        if op == '!=':
          return rowCount != filterCount
        return rowCount == filterCount

      for column in columns:
        if checkMatch(row.get(column, 0)):
          return True
      return False

    def rowCountRangeFilterMatch(op, filterCountL, filterCountR):
      def checkMatch(rowCount):
        if isinstance(rowCount, str):
          if not rowCount.isdigit():
            return False
          rowCount = int(rowCount)
        elif not isinstance(rowCount, int):
          return False
        if op == '!=':
          return not filterCountL <= rowCount <= filterCountR
        return filterCountL <= rowCount <= filterCountR

      for column in columns:
        if checkMatch(row.get(column, 0)):
          return True
      return False

    def rowBooleanFilterMatch(filterBoolean):
      def checkMatch(rowBoolean):
        if isinstance(rowBoolean, bool):
          return rowBoolean == filterBoolean
        if isinstance(rowBoolean, str) and rowBoolean.lower() in TRUE_FALSE:
          return rowBoolean.capitalize() == str(filterBoolean)
        return False

      for column in columns:
        if checkMatch(row.get(column, False)):
          return True
      return False

    def filterMatch(filterVal):
      if filterVal[1] == 'regex':
        if rowRegexFilterMatch(filterVal[2]):
          return True
      elif filterVal[1] == 'notregex':
        if rowNotRegexFilterMatch(filterVal[2]):
          return True
      elif filterVal[1] in {'date', 'time'}:
        if rowDateTimeFilterMatch(filterVal[1] == 'date', filterVal[2], filterVal[3]):
          return True
      elif filterVal[1] in {'daterange', 'timerange'}:
        if rowDateTimeRangeFilterMatch(filterVal[1] == 'date', filterVal[2], filterVal[3], filterVal[4]):
          return True
      elif filterVal[1] == 'count':
        if rowCountFilterMatch(filterVal[2], filterVal[3]):
          return True
      elif filterVal[1] == 'countrange':
        if rowCountRangeFilterMatch(filterVal[2], filterVal[3], filterVal[4]):
          return True
      else: #boolean
        if rowBooleanFilterMatch(filterVal[2]):
          return True
      return False

    for filterVal in self.rowFilter:
      columns = [t for t in self.titlesList if filterVal[0].match(t)]
      if not columns:
        columns = [None]
      if not filterMatch(filterVal):
        return False
    for filterVal in self.rowDropFilter:
      columns = [t for t in self.titlesList if filterVal[0].match(t)]
      if not columns:
        columns = [None]
      if filterMatch(filterVal):
        return False
    return True

  def WriteRowNoFilter(self, row):
    self.rows.append(row)

  def WriteRow(self, row):
    if self.RowFilterMatch(row):
      self.rows.append(row)

  def WriteRowTitles(self, row):
    for title in row:
      if title not in self.titlesSet:
        self.AddTitle(title)
    if self.RowFilterMatch(row):
      self.rows.append(row)

  def WriteRowTitlesNoFilter(self, row):
    for title in row:
      if title not in self.titlesSet:
        self.AddTitle(title)
    self.rows.append(row)

  def WriteRowTitlesJSONNoFilter(self, row):
    for title in row:
      if title not in self.JSONtitlesSet:
        self.AddJSONTitle(title)
    self.rows.append(row)

  def CheckRowTitles(self, row):
    if not self.rowFilter:
      return True
    for title in row:
      if title not in self.titlesSet:
        self.AddTitle(title)
    return self.RowFilterMatch(row)

  def UpdateMimeTypeCounts(self, row, mimeTypeCounts):
    for title in row:
      if title not in self.titlesSet:
        self.AddTitle(title)
    if self.RowFilterMatch(row):
      mimeTypeCounts.setdefault(row['mimeType'], 0)
      mimeTypeCounts[row['mimeType']] += 1

  def SetZeroBlankMimeTypeCounts(self, zeroBlankMimeTypeCounts):
    self.zeroBlankMimeTypeCounts = zeroBlankMimeTypeCounts

  def ZeroBlankMimeTypeCounts(self):
    for row in self.rows:
      for title in self.titlesList:
        if title not in self.sortTitlesSet and title not in row:
          row[title] = 0

  def CheckRowFilterHeaders(self):
    for filterVal in self.rowFilter:
      columns = [t for t in self.titlesList if filterVal[0].match(t)]
      if not columns:
        stderrWarningMsg(Msg.COLUMN_DOES_NOT_MATCH_ANY_OUTPUT_COLUMNS.format(GC.CSV_OUTPUT_ROW_FILTER, filterVal[0].pattern))
    for filterVal in self.rowDropFilter:
      columns = [t for t in self.titlesList if filterVal[0].match(t)]
      if not columns:
        stderrWarningMsg(Msg.COLUMN_DOES_NOT_MATCH_ANY_OUTPUT_COLUMNS.format(GC.CSV_OUTPUT_ROW_DROP_FILTER, filterVal[0].pattern))

  def SetHeaderFilter(self, headerFilter):
    self.headerFilter = headerFilter

  def SetHeaderDropFilter(self, headerDropFilter):
    self.headerDropFilter = headerDropFilter

  @staticmethod
  def HeaderFilterMatch(filters, title):
    for filterStr in filters:
      if filterStr.match(title):
        return True
    return False

  def FilterHeaders(self):
    if self.headerDropFilter:
      self.titlesList = [t for t in self.titlesList if not self.HeaderFilterMatch(self.headerDropFilter, t)]
    if self.headerFilter:
      self.titlesList = [t for t in self.titlesList if self.HeaderFilterMatch(self.headerFilter, t)]
    self.titlesSet = set(self.titlesList)
    if not self.titlesSet:
      systemErrorExit(USAGE_ERROR_RC, Msg.NO_COLUMNS_SELECTED_WITH_CSV_OUTPUT_HEADER_FILTER.format(GC.CSV_OUTPUT_HEADER_FILTER, GC.CSV_OUTPUT_HEADER_DROP_FILTER))

  def FilterJSONHeaders(self):
    if self.headerDropFilter:
      self.JSONtitlesList = [t for t in self.JSONtitlesList if not self.HeaderFilterMatch(self.headerDropFilter, t)]
    if self.headerFilter:
      self.JSONtitlesList = [t for t in self.JSONtitlesList if self.HeaderFilterMatch(self.headerFilter, t)]
    self.JSONtitlesSet = set(self.JSONtitlesList)
    if not self.JSONtitlesSet:
      systemErrorExit(USAGE_ERROR_RC, Msg.NO_COLUMNS_SELECTED_WITH_CSV_OUTPUT_HEADER_FILTER.format(GC.CSV_OUTPUT_HEADER_FILTER, GC.CSV_OUTPUT_HEADER_DROP_FILTER))

  def writeCSVfile(self, list_type):

    def todriveCSVErrorExit(entityValueList, errMsg):
      systemErrorExit(ACTION_FAILED_RC, formatKeyValueList(Ind.Spaces(),
                                                           Ent.FormatEntityValueList(entityValueList)+[Act.NotPerformed(), errMsg],
                                                           currentCountNL(0, 0)))

    def writeCSVData(writer):
      try:
        if GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER]:
          writer.writerow(dict((item, item) for item in writer.fieldnames))
        writer.writerows(self.rows)
        return True
      except IOError as e:
        stderrErrorMsg(e)
        return False

    def writeCSVToStdout():
      csvFile = StringIOobject()
      writer = csv.DictWriter(csvFile, titlesList,
                              extrasaction=extrasaction, quoting=csv.QUOTE_MINIMAL, quotechar=self.quoteChar,
                              delimiter=self.columnDelimiter, lineterminator='\n')
      if writeCSVData(writer):
        try:
          GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].write(csvFile.getvalue())
        except IOError as e:
          stderrErrorMsg(fdErrorMessage(GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD], 'stdout', e))
          setSysExitRC(FILE_ERROR_RC)
      closeFile(csvFile)

    def writeCSVToFile():
      csvFile = openFile(GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME], GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE], newline='',
                         encoding=GM.Globals[GM.CSVFILE][GM.REDIRECT_ENCODING], errors='backslashreplace',
                         continueOnError=True)
      if csvFile:
        writer = csv.DictWriter(csvFile, titlesList,
                                extrasaction=extrasaction, quoting=csv.QUOTE_MINIMAL, quotechar=self.quoteChar,
                                delimiter=self.columnDelimiter, lineterminator=str(GC.Values[GC.CSV_OUTPUT_LINE_TERMINATOR]))
        writeCSVData(writer)
        closeFile(csvFile)

    def writeCSVToDrive():
      if self.todrive['updatesheet']:
        csvFile = TemporaryFile(mode='w+', encoding=UTF8)
      else:
        csvFile = StringIOobject()
      writer = csv.DictWriter(csvFile, titlesList,
                              extrasaction=extrasaction, quoting=csv.QUOTE_MINIMAL, quotechar=self.quoteChar,
                              delimiter=self.columnDelimiter, lineterminator='\n')
      if writeCSVData(writer):
        title = self.todrive['title'] or f'{GC.Values[GC.DOMAIN]} - {list_type}'
        if self.todrive['timestamp']:
          tdtime = datetime.datetime.now(GC.Values[GC.TIMEZONE])+datetime.timedelta(days=-self.todrive['daysoffset'], hours=-self.todrive['hoursoffset'])
          if not self.todrive['timeformat']:
            title += ' - '+ISOformatTimeStamp(tdtime)
          else:
            title += ' - '+tdtime.strftime(self.todrive['timeformat'])
        action = Act.Get()
        if not GC.Values[GC.TODRIVE_CLIENTACCESS]:
          user, drive = buildGAPIServiceObject(API.DRIVETD, self.todrive['user'])
          if not drive:
            closeFile(csvFile)
            return
        else:
          user = self.todrive['user']
          drive = buildGAPIObject(API.DRIVE3)
        importSize = csvFile.tell()
# Update sheet
        try:
          if self.todrive['updatesheet']:
            Act.Set(Act.UPDATE)
            result = callGAPI(drive.about(), 'get',
                              throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fields='maxImportSizes')
            if len(self.rows)*len(titlesList) > MAX_GOOGLE_SHEET_CELLS or importSize > int(result['maxImportSizes'][MIMETYPE_GA_SPREADSHEET]):
              todriveCSVErrorExit([Ent.USER, user], Msg.RESULTS_TOO_LARGE_FOR_GOOGLE_SPREADSHEET)
            fields = ','.join(['id', 'mimeType', 'webViewLink', 'name', 'capabilities(canEdit)'])
            body = {'name': title, 'description': self.todrive['description']}
            if body['description'] is None:
              body['description'] = Cmd.QuotedArgumentList(Cmd.AllArguments())
            result = callGAPI(drive.files(), 'update',
                              throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INSUFFICIENT_PERMISSIONS, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR],
                              fileId=self.todrive['fileId'], body=body, fields=fields, supportsAllDrives=True)
            entityValueList = [Ent.USER, user, Ent.DRIVE_FILE_ID, self.todrive['fileId']]
            if not result['capabilities']['canEdit']:
              todriveCSVErrorExit(entityValueList, Msg.NOT_WRITABLE)
            if result['mimeType'] != MIMETYPE_GA_SPREADSHEET:
              todriveCSVErrorExit(entityValueList, f'{Msg.NOT_A} {Ent.Singular(Ent.SPREADSHEET)}')
            if not GC.Values[GC.TODRIVE_CLIENTACCESS]:
              _, sheet = buildGAPIServiceObject(API.SHEETSTD, user)
              if sheet is None:
                return
            else:
              sheet = buildGAPIObject(API.SHEETS)
            csvFile.seek(0)
            spreadsheet = None
            for sheetEntity in iter(self.TDSHEET_ENTITY_MAP.values()):
              if self.todrive[sheetEntity]:
                entityValueList = [Ent.USER, user, Ent.SPREADSHEET, title, self.todrive[sheetEntity]['sheetType'], self.todrive[sheetEntity]['sheetValue']]
                if spreadsheet is None:
                  spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                                         throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                                         spreadsheetId=self.todrive['fileId'],
                                         fields='spreadsheetUrl,sheets(properties(sheetId,title),protectedRanges(range(sheetId),requestingUserCanEdit))')
                sheetId = getSheetIdFromSheetEntity(spreadsheet, self.todrive[sheetEntity])
                if sheetId is None:
                  todriveCSVErrorExit(entityValueList, Msg.NOT_FOUND)
                if protectedSheetId(spreadsheet, sheetId):
                  todriveCSVErrorExit(entityValueList, Msg.NOT_WRITABLE)
                self.todrive[sheetEntity]['sheetId'] = sheetId
            body = {'requests': []}
            if self.todrive['backupSheetEntity']:
              body['requests'].append({"copyPaste": {"source": {"sheetId": self.todrive['sheetEntity']['sheetId']},
                                                     "destination": {"sheetId": self.todrive['backupSheetEntity']['sheetId']}, "pasteType": "PASTE_NORMAL"}})
            if self.todrive['clearfilter']:
              body['requests'].append({'clearBasicFilter': {'sheetId': self.todrive['sheetEntity']['sheetId']}})
            body['requests'].append({'updateCells': {'range': {'sheetId': self.todrive['sheetEntity']['sheetId']}, 'fields': '*'}})
            body['requests'].append({'pasteData': {'coordinate': {'sheetId': self.todrive['sheetEntity']['sheetId'], 'rowIndex': '0', 'columnIndex': '0'},
                                                   'data': csvFile.read(), 'type': 'PASTE_NORMAL', 'delimiter': self.columnDelimiter}})
            if self.todrive['cellwrap']:
              body['requests'].append({'repeatCell': {'range': {'sheetId': self.todrive['sheetEntity']['sheetId']},
                                                      'fields': 'userEnteredFormat.wrapStrategy',
                                                      'cell': {'userEnteredFormat': {'wrapStrategy': self.todrive['cellwrap']}}}})
            if self.todrive['copySheetEntity']:
              body['requests'].append({"copyPaste": {"source": {"sheetId": self.todrive['sheetEntity']['sheetId']},
                                                     "destination": {"sheetId": self.todrive['copySheetEntity']['sheetId']}, "pasteType": "PASTE_NORMAL"}})
            try:
              callGAPI(sheet.spreadsheets(), 'batchUpdate',
                       throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                       spreadsheetId=self.todrive['fileId'], body=body)
            except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
                    GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
              todriveCSVErrorExit(entityValueList, str(e))
            closeFile(csvFile)
# Create/update file
          else:
            if GC.Values[GC.TODRIVE_CONVERSION]:
              result = callGAPI(drive.about(), 'get',
                                throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                fields='maxImportSizes')
              if len(self.rows)*len(titlesList) > MAX_GOOGLE_SHEET_CELLS or importSize > int(result['maxImportSizes'][MIMETYPE_GA_SPREADSHEET]):
                printKeyValueList([WARNING, Msg.RESULTS_TOO_LARGE_FOR_GOOGLE_SPREADSHEET])
                mimeType = 'text/csv'
              else:
                mimeType = MIMETYPE_GA_SPREADSHEET
            else:
              mimeType = 'text/csv'
            fields = ','.join(['id', 'mimeType', 'webViewLink'])
            body = {'name': title, 'description': self.todrive['description'], 'mimeType': mimeType}
            if body['description'] is None:
              body['description'] = Cmd.QuotedArgumentList(Cmd.AllArguments())
            if not self.todrive['fileId']:
              Act.Set(Act.CREATE)
              body['parents'] = [self.todrive['parentId']]
              result = callGAPI(drive.files(), 'create',
                                throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR],
                                body=body,
                                media_body=googleapiclient.http.MediaIoBaseUpload(io.BytesIO(csvFile.getvalue().encode()), mimetype='text/csv', resumable=True),
                                fields=fields, supportsAllDrives=True)
            else:
              Act.Set(Act.UPDATE)
              result = callGAPI(drive.files(), 'update',
                                bailOnInternalError=True,
                                throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INSUFFICIENT_PERMISSIONS, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR],
                                fileId=self.todrive['fileId'],
                                body=body,
                                media_body=googleapiclient.http.MediaIoBaseUpload(io.BytesIO(csvFile.getvalue().encode()), mimetype='text/csv', resumable=True),
                                fields=fields, supportsAllDrives=True)
            closeFile(csvFile)
            if (result['mimeType'] == MIMETYPE_GA_SPREADSHEET) and (self.todrive['sheetEntity'] or self.todrive['locale'] or self.todrive['timeZone'] or self.todrive['cellwrap']):
              if not GC.Values[GC.TODRIVE_CLIENTACCESS]:
                _, sheet = buildGAPIServiceObject(API.SHEETSTD, user)
                if sheet is None:
                  return
              else:
                sheet = buildGAPIObject(API.SHEETS)
              spreadsheetId = result['id']
              try:
                body = {'requests': []}
                if self.todrive['sheetEntity'] or self.todrive['cellwrap']:
                  spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                                         throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                                         spreadsheetId=spreadsheetId, fields='sheets/properties')
                  if self.todrive['sheetEntity'] and self.todrive['sheetEntity']['sheetTitle']:
                    spreadsheet['sheets'][0]['properties']['title'] = self.todrive['sheetEntity']['sheetTitle']
                    body['requests'].append({'updateSheetProperties':
                                               {'properties': spreadsheet['sheets'][0]['properties'], 'fields': 'title'}})
                  if self.todrive['cellwrap']:
                    body['requests'].append({'repeatCell': {'range': {'sheetId': spreadsheet['sheets'][0]['properties']['sheetId']},
                                                            'fields': 'userEnteredFormat.wrapStrategy',
                                                            'cell': {'userEnteredFormat': {'wrapStrategy': self.todrive['cellwrap']}}}})
                if self.todrive['locale']:
                  body['requests'].append({'updateSpreadsheetProperties':
                                             {'properties': {'locale': self.todrive['locale']}, 'fields': 'locale'}})
                if self.todrive['timeZone']:
                  body['requests'].append({'updateSpreadsheetProperties':
                                             {'properties': {'timeZone': self.todrive['timeZone']}, 'fields': 'timeZone'}})
                if body['requests']:
                  callGAPI(sheet.spreadsheets(), 'batchUpdate',
                           throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                           spreadsheetId=spreadsheetId, body=body)
              except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
                      GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
                todriveCSVErrorExit([Ent.USER, user, Ent.SPREADSHEET, title], str(e))
          Act.Set(action)
          file_url = result['webViewLink']
          msg_txt = f'{Msg.DATA_UPLOADED_TO_DRIVE_FILE}:\n{file_url}'
          printKeyValueList([msg_txt])
          if not self.todrive['noemail']:
            send_email(title, msg_txt, user, clientAccess=GC.Values[GC.TODRIVE_CLIENTACCESS])
          if not self.todrive['nobrowser']:
            webbrowser.open(file_url)
        except (GAPI.forbidden, GAPI.insufficientPermissions):
          printWarningMessage(INSUFFICIENT_PERMISSIONS_RC, Msg.INSUFFICIENT_PERMISSIONS_TO_PERFORM_TASK)
        except (GAPI.fileNotFound, GAPI.unknownError, GAPI.internalError) as e:
          if not self.todrive['fileId']:
            entityActionFailedWarning([Ent.DRIVE_FOLDER, self.todrive['parentId']], str(e))
          else:
            entityActionFailedWarning([Ent.DRIVE_FILE, self.todrive['fileId']], str(e))
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), 0, 0)
      else:
        closeFile(csvFile)

    if GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] is not None:
      GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_NAME, list_type))
      GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_TODRIVE, self.todrive))
      GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_CSVPF,
                                                     (self.titlesList, self.sortTitlesList, self.indexedTitles,
                                                      self.formatJSON, self.JSONtitlesList, self.quoteChar,
                                                      self.fixPaths, self.showPermissionsLast,
                                                      self.zeroBlankMimeTypeCounts)))
      GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE].put((GM.REDIRECT_QUEUE_DATA, self.rows))
      return
    if self.zeroBlankMimeTypeCounts:
      self.ZeroBlankMimeTypeCounts()
    if self.rowFilter or self.rowDropFilter:
      self.CheckRowFilterHeaders()
    if self.headerFilter or self.headerDropFilter:
      if not self.formatJSON:
        self.FilterHeaders()
      else:
        self.FilterJSONHeaders()
      extrasaction = 'ignore'
    else:
      extrasaction = 'raise'
    if not self.formatJSON:
      self.SortTitles()
      self.SortIndexedTitles(self.titlesList)
      if self.fixPaths:
        self.FixPathsTitles(self.titlesList)
      if self.showPermissionsLast:
        self.MovePermsToEnd()
      titlesList = self.titlesList
    else:
      titlesList = self.JSONtitlesList
    if (not self.todrive) or self.todrive['localcopy']:
      if GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] == '-':
        if GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]:
          writeCSVToStdout()
        else:
          GM.Globals[GM.CSVFILE][GM.REDIRECT_NAME] = GM.Globals[GM.STDOUT][GM.REDIRECT_NAME]
          writeCSVToFile()
      else:
        writeCSVToFile()
    if self.todrive:
      writeCSVToDrive()
    if GM.Globals[GM.CSVFILE][GM.REDIRECT_MODE] == DEFAULT_FILE_APPEND_MODE:
      GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER] = False

def writeEntityNoHeaderCSVFile(entityType, entityList):
  csvPF = CSVPrintFile(entityType)
  _, _, entityList = getEntityArgument(entityList)
  if entityType == Ent.USER:
    for entity in entityList:
      csvPF.WriteRowNoFilter({entityType: normalizeEmailAddressOrUID(entity)})
  else:
    for entity in entityList:
      csvPF.WriteRowNoFilter({entityType: entity})
  GM.Globals[GM.CSVFILE][GM.REDIRECT_WRITE_HEADER] = False
  csvPF.writeCSVfile(Ent.Plural(entityType))

DEFAULT_SKIP_OBJECTS = {'kind', 'etag', 'etags'}

# Clean a JSON object
def cleanJSON(topStructure, listLimit=None, skipObjects=None, timeObjects=None):
  def _clean(structure, key):
    if not isinstance(structure, (dict, list)):
      if key not in timeObjects:
        if isinstance(structure, str) and GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]:
          return escapeCRsNLs(structure)
        return structure
      if isinstance(structure, str) and not structure.isdigit():
        return formatLocalTime(structure)
      return formatLocalTimestamp(structure)
    if isinstance(structure, list):
      listLen = len(structure)
      listLen = min(listLen, listLimit or listLen)
      return [_clean(v, '') for v in structure[0:listLen]]
    return {k: _clean(v, k) for k, v in sorted(iter(structure.items())) if k not in allSkipObjects}

  allSkipObjects = DEFAULT_SKIP_OBJECTS.union(skipObjects or set())
  timeObjects = timeObjects or set()
  return _clean(topStructure, '')

# Flatten a JSON object
def flattenJSON(topStructure, flattened=None,
                listLimit=None, skipObjects=None, timeObjects=None, noLenObjects=None, simpleLists=None, delimiter=None):
  def _flatten(structure, key, path):
    if not isinstance(structure, (dict, list)):
      if key not in timeObjects:
        if isinstance(structure, str):
          if GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL] and (structure.find('\n') >= 0 or structure.find('\r') >= 0):
            flattened[path] = escapeCRsNLs(structure)
          else:
            flattened[path] = structure
        else:
          flattened[path] = structure
      else:
        if isinstance(structure, str) and not structure.isdigit():
          flattened[path] = formatLocalTime(structure)
        else:
          flattened[path] = formatLocalTimestamp(structure)
    elif isinstance(structure, list):
      listLen = len(structure)
      listLen = min(listLen, listLimit or listLen)
      if key in simpleLists:
        flattened[path] = delimiter.join(structure[:listLen])
      else:
        if key not in noLenObjects:
          flattened[path] = listLen
        for i in range(listLen):
          _flatten(structure[i], '', f'{path}.{i}')
    else:
      if structure:
        for k, v in sorted(iter(structure.items())):
          if k not in allSkipObjects:
            _flatten(v, k, f'{path}.{k}')
      else:
        flattened[path] = ''

  flattened = flattened or {}
  allSkipObjects = DEFAULT_SKIP_OBJECTS.union(skipObjects or set())
  timeObjects = timeObjects or set()
  noLenObjects = noLenObjects or set()
  simpleLists = simpleLists or set()
  for k, v in sorted(iter(topStructure.items())):
    if k not in allSkipObjects:
      _flatten(v, k, k)
  return flattened

# Show a json object
def showJSON(showName, showValue, skipObjects=None, timeObjects=None, simpleLists=None, dictObjectsKey=None):
  def _show(objectName, objectValue, subObjectKey, level):
    if objectName in allSkipObjects:
      return
    if objectName is not None:
      printJSONKey(objectName)
      subObjectKey = dictObjectsKey.get(objectName)
    if isinstance(objectValue, list):
      if objectName in simpleLists:
        printJSONValue(' '.join(objectValue))
        return
      if len(objectValue) == 1 and isinstance(objectValue[0], (str, bool, float, int)):
        if objectName is not None:
          printJSONValue(objectValue[0])
        else:
          printKeyValueList([objectValue[0]])
        return
      if objectName is not None:
        printBlankLine()
        Ind.Increment()
      for subValue in objectValue:
        if isinstance(subValue, (str, bool, float, int)):
          printKeyValueList([subValue])
        else:
          _show(None, subValue, subObjectKey, level+1)
      if objectName is not None:
        Ind.Decrement()
    elif isinstance(objectValue, dict):
      indentAfterFirst = unindentAfterLast = False
      if objectName is not None:
        printBlankLine()
        Ind.Increment()
      elif level > 0:
        indentAfterFirst = unindentAfterLast = True
      subObjects = sorted(objectValue)
      if subObjectKey and (subObjectKey in subObjects):
        subObjects.remove(subObjectKey)
        subObjects.insert(0, subObjectKey)
        subObjectKey = None
      for subObject in subObjects:
        if subObject not in allSkipObjects:
          _show(subObject, objectValue[subObject], subObjectKey, level+1)
          if indentAfterFirst:
            Ind.Increment()
            indentAfterFirst = False
      if objectName is not None or ((not indentAfterFirst) and unindentAfterLast):
        Ind.Decrement()
    else:
      if objectName not in timeObjects:
        if isinstance(objectValue, str) and (objectValue.find('\n') >= 0 or objectValue.find('\r') >= 0):
          if GC.Values[GC.SHOW_CONVERT_CR_NL]:
            printJSONValue(escapeCRsNLs(objectValue))
          else:
            printBlankLine()
            Ind.Increment()
            printKeyValueList([Ind.MultiLineText(objectValue)])
            Ind.Decrement()
        else:
          printJSONValue(objectValue)
      else:
        if isinstance(objectValue, str) and not objectValue.isdigit():
          printJSONValue(formatLocalTime(objectValue))
        else:
          printJSONValue(formatLocalTimestamp(objectValue))

  allSkipObjects = DEFAULT_SKIP_OBJECTS.union(skipObjects or set())
  timeObjects = timeObjects or set()
  simpleLists = simpleLists or set()
  dictObjectsKey = dictObjectsKey or {}
  _show(showName, showValue, None, 0)

class FormatJSONQuoteChar():

  def __init__(self, csvPF=None, formatJSONOnly=False):
    self.SetCsvPF(csvPF)
    self.SetFormatJSON(False)
    self.SetQuoteChar(GM.Globals.get(GM.CSV_OUTPUT_QUOTE_CHAR, GC.Values.get(GC.CSV_OUTPUT_QUOTE_CHAR, '"')))
    if not formatJSONOnly:
      return
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'formatjson':
        self.SetFormatJSON(True)
        return
      unknownArgumentExit()

  def SetCsvPF(self, csvPF):
    self.csvPF = csvPF

  def SetFormatJSON(self, formatJSON):
    self.formatJSON = formatJSON
    if self.csvPF:
      self.csvPF.SetFormatJSON(formatJSON)

  def GetFormatJSON(self, myarg):
    if myarg == 'formatjson':
      self.SetFormatJSON(True)
      return
    unknownArgumentExit()

  def SetQuoteChar(self, quoteChar):
    self.quoteChar = quoteChar
    if self.csvPF:
      self.csvPF.SetQuoteChar(quoteChar)

  def GetQuoteChar(self, myarg):
    if self.csvPF and myarg == 'quotechar':
      self.SetQuoteChar(getCharacter())
      return
    unknownArgumentExit()

  def GetFormatJSONQuoteChar(self, myarg, addTitle=False, noExit=False):
    if myarg == 'formatjson':
      self.SetFormatJSON(True)
      if self.csvPF and addTitle:
        self.csvPF.AddJSONTitles('JSON')
      return True
    if self.csvPF and myarg == 'quotechar':
      self.SetQuoteChar(getCharacter())
      return True
    if noExit:
      return False
    unknownArgumentExit()

# Batch processing request_id fields
RI_ENTITY = 0
RI_I = 1
RI_COUNT = 2
RI_J = 3
RI_JCOUNT = 4
RI_ITEM = 5
RI_ROLE = 6
RI_OPTION = 7

def batchRequestID(entityName, i, count, j, jcount, item, role=None, option=None):
  if role is None and option is None:
    return f'{entityName}\n{i}\n{count}\n{j}\n{jcount}\n{item}'
  return f'{entityName}\n{i}\n{count}\n{j}\n{jcount}\n{item}\n{role}\n{option}'

TIME_OFFSET_UNITS = [('day', SECONDS_PER_DAY), ('hour', SECONDS_PER_HOUR), ('minute', SECONDS_PER_MINUTE), ('second', 1)]

def getLocalGoogleTimeOffset(testLocation='www.googleapis.com'):
  # we disable SSL verify so we can still get time even if clock
  # is way off. This could be spoofed / MitM but we'll fail for those
  # situations everywhere else but here.
  httpObj = getHttpObj()
  httpObj.disable_ssl_certificate_validation = True
  try:
    googleUTC = datetime.datetime.strptime(httpObj.request('https://'+testLocation, 'HEAD')[0]['date'], '%a, %d %b %Y %H:%M:%S %Z').replace(tzinfo=iso8601.UTC)
  except (httplib2.HttpLib2Error, RuntimeError, ValueError) as e:
    handleServerError(e)
  offset = remainder = int(abs((datetime.datetime.now(iso8601.UTC)-googleUTC).total_seconds()))
  timeoff = []
  for tou in TIME_OFFSET_UNITS:
    uval, remainder = divmod(remainder, tou[1])
    if uval:
      timeoff.append(f'{uval} {tou[0]}{"s" if uval != 1 else ""}')
  if not timeoff:
    timeoff.append(Msg.LESS_THAN_1_SECOND)
  nicetime = ', '.join(timeoff)
  return (offset, nicetime)

def _getServerTLSUsed(location):
  url = 'https://'+location
  _, netloc, _, _, _, _ = urlparse(url)
  conn = 'https:'+netloc
  httpObj = getHttpObj()
  retries = 5
  for n in range(1, retries+1):
    try:
      httpObj.request(url, headers={'user-agent': GAM_USER_AGENT})
      cipher_name, tls_ver, _ = httpObj.connections[conn].sock.cipher()
      return tls_ver, cipher_name
    except (httplib2.HttpLib2Error, RuntimeError) as e:
      if n != retries:
        httpObj.connections = {}
        waitOnFailure(n, retries, NETWORK_ERROR_RC, str(e))
        continue
      handleServerError(e)

MACOS_CODENAMES = {
  6:  'Snow Leopard',
  7:  'Lion',
  8:  'Mountain Lion',
  9:  'Mavericks',
  10: 'Yosemite',
  11: 'El Capitan',
  12: 'Sierra',
  13: 'High Sierra',
  14: 'Mojave',
  15: 'Catalina'
  }

def getOSPlatform():
  myos = platform.system()
  if myos == 'Linux':
    pltfrm = ' '.join(distro.linux_distribution(full_distribution_name=False)).title()
  elif myos == 'Windows':
    pltfrm = ' '.join(platform.win32_ver())
  elif myos == 'Darwin':
    myos = 'MacOS'
    mac_ver = platform.mac_ver()[0]
    minor_ver = int(mac_ver.split('.')[1]) # macver 10.14.6 == minor_ver 14
    codename = MACOS_CODENAMES.get(minor_ver, '')
    pltfrm = ' '.join([codename, mac_ver])
  else:
    pltfrm = platform.platform()
  return f'{myos} {pltfrm}'

# gam version [check|checkrc|simple|extended] [timeoffset] [location <HostName>]
def doVersion(checkForArgs=True):
  forceCheck = 0
  extended = timeOffset = simple = False
  testLocation = 'www.googleapis.com'
  if checkForArgs:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'check':
        forceCheck = 1
      elif myarg == 'checkrc':
        forceCheck = -1
      elif myarg == 'simple':
        simple = True
      elif myarg == 'extended':
        extended = timeOffset = True
      elif myarg == 'timeoffset':
        timeOffset = True
      elif myarg == 'location':
        testLocation = getString(Cmd.OB_HOST_NAME)
      else:
        unknownArgumentExit()
  if simple:
    writeStdout(__version__)
    return
  writeStdout((f'{GAM} {__version__} - {GAM_URL} - {GM.Globals[GM.GAM_TYPE]}\n'
               f'{__author__}\n'
               f'Python {sys.version_info[0]}.{sys.version_info[1]}.{sys.version_info[2]} {struct.calcsize("P")*8}-bit {sys.version_info[3]}\n'
               f'google-api-python-client {googleapiclient.__version__}\n'
               f'httplib2 {httplib2.__version__}\n'
               f'{getOSPlatform()} {platform.machine()}\n'
               f'Path: {GM.Globals[GM.GAM_PATH]}\n'
               ))
  if sys.platform.startswith('win') and str(struct.calcsize('P')*8).find('32') != -1 and platform.machine().find('64') != -1:
    printKeyValueList([Msg.UPDATE_GAM_TO_64BIT])
  if timeOffset:
    offsetSeconds, offsetFormatted = getLocalGoogleTimeOffset(testLocation)
    printKeyValueList([Msg.YOUR_SYSTEM_TIME_DIFFERS_FROM_GOOGLE.format(testLocation, offsetFormatted)])
    if offsetSeconds > MAX_LOCAL_GOOGLE_TIME_OFFSET:
      systemErrorExit(NETWORK_ERROR_RC, Msg.PLEASE_CORRECT_YOUR_SYSTEM_TIME)
  if forceCheck:
    doGAMCheckForUpdates(forceCheck)
  if extended:
    printKeyValueList([ssl.OPENSSL_VERSION])
    tls_ver, cipher_name = _getServerTLSUsed(testLocation)
    printKeyValueList([f'{testLocation} connects using {tls_ver} {cipher_name}'])

# gam help
def doUsage():
  printBlankLine()
  doVersion(checkForArgs=False)
  writeStdout(Msg.HELP_SYNTAX.format(os.path.join(GM.Globals[GM.GAM_PATH], FN_GAMCOMMANDS_TXT)))
  writeStdout(Msg.HELP_WIKI.format(GAM_WIKI))

class NullHandler(logging.Handler):
  def emit(self, record):
    pass

def initializeLogging():
  nh = NullHandler()
  logging.getLogger().addHandler(nh)

def saveNonPickleableValues():
  savedValues = {GM.STDOUT: {}, GM.STDERR: {}}
  savedValues[GM.STDOUT][GM.REDIRECT_FD] = GM.Globals[GM.STDOUT].get(GM.REDIRECT_FD, None)
  GM.Globals[GM.STDOUT].pop(GM.REDIRECT_FD, None)
  savedValues[GM.STDERR][GM.REDIRECT_FD] = GM.Globals[GM.STDERR].get(GM.REDIRECT_FD, None)
  GM.Globals[GM.STDERR].pop(GM.REDIRECT_FD, None)
  savedValues[GM.STDOUT][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, None)
  GM.Globals[GM.STDOUT].pop(GM.REDIRECT_MULTI_FD, None)
  savedValues[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, None)
  GM.Globals[GM.STDERR].pop(GM.REDIRECT_MULTI_FD, None)
  return savedValues

def restoreNonPickleableValues(savedValues):
  GM.Globals[GM.STDOUT][GM.REDIRECT_FD] = savedValues[GM.STDOUT][GM.REDIRECT_FD]
  GM.Globals[GM.STDERR][GM.REDIRECT_FD] = savedValues[GM.STDERR][GM.REDIRECT_FD]
  GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = savedValues[GM.STDOUT][GM.REDIRECT_MULTI_FD]
  GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = savedValues[GM.STDERR][GM.REDIRECT_MULTI_FD]

def CSVFileQueueHandler(mpQueue, mpQueueStdout, mpQueueStderr, csvPF):
  global Cmd

  def reopenSTDFile(stdtype):
    if GM.Globals[stdtype][GM.REDIRECT_NAME] == 'null':
      GM.Globals[stdtype][GM.REDIRECT_FD] = open(os.devnull, GM.Globals[stdtype][GM.REDIRECT_MODE])
    elif GM.Globals[stdtype][GM.REDIRECT_NAME] == '-':
      GM.Globals[stdtype][GM.REDIRECT_FD] = os.fdopen(os.dup([sys.stderr.fileno(), sys.stdout.fileno()][stdtype == GM.STDOUT]),
                                                      GM.Globals[stdtype][GM.REDIRECT_MODE], encoding=GM.Globals[GM.SYS_ENCODING])
    elif stdtype == GM.STDERR and GM.Globals[stdtype][GM.REDIRECT_NAME] == 'stdout':
      GM.Globals[stdtype][GM.REDIRECT_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_FD]
    else:
      GM.Globals[stdtype][GM.REDIRECT_FD] = openFile(GM.Globals[stdtype][GM.REDIRECT_NAME], GM.Globals[stdtype][GM.REDIRECT_MODE])
    if stdtype == GM.STDERR and GM.Globals[stdtype][GM.REDIRECT_NAME] == 'stdout':
      GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]
    else:
      GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = GM.Globals[stdtype][GM.REDIRECT_FD] if not GM.Globals[stdtype][GM.REDIRECT_MULTIPROCESS] else StringIOobject()

  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
  if GM.Globals[GM.WINDOWS]:
    Cmd = glclargs.GamCLArgs()
  else:
    csvPF.SetColumnDelimiter(GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER])
    csvPF.SetQuoteChar(GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR])
    csvPF.SetHeaderFilter(GC.Values[GC.CSV_OUTPUT_HEADER_FILTER])
    csvPF.SetHeaderDropFilter(GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER])
    csvPF.SetRowFilter(GC.Values[GC.CSV_OUTPUT_ROW_FILTER])
    csvPF.SetRowDropFilter(GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER])
  list_type = 'CSV'
  while True:
    dataType, dataItem = mpQueue.get()
    if dataType == GM.REDIRECT_QUEUE_NAME:
      list_type = dataItem
    elif dataType == GM.REDIRECT_QUEUE_TODRIVE:
      csvPF.todrive = dataItem
    elif dataType == GM.REDIRECT_QUEUE_CSVPF:
      csvPF.AddTitles(dataItem[0])
      csvPF.SetSortTitles(dataItem[1])
      csvPF.SetIndexedTitles(dataItem[2])
      csvPF.SetFormatJSON(dataItem[3])
      csvPF.AddJSONTitles(dataItem[4])
      csvPF.SetQuoteChar(dataItem[5])
      csvPF.SetFixPaths(dataItem[6])
      csvPF.SetShowPermissionsLast(dataItem[7])
      csvPF.SetZeroBlankMimeTypeCounts(dataItem[8])
    elif dataType == GM.REDIRECT_QUEUE_DATA:
      csvPF.rows.extend(dataItem)
    elif dataType == GM.REDIRECT_QUEUE_ARGS:
      Cmd.InitializeArguments(dataItem)
    elif dataType == GM.REDIRECT_QUEUE_GLOBALS:
      GM.Globals = dataItem
      if GM.Globals[GM.WINDOWS]:
        reopenSTDFile(GM.STDOUT)
        reopenSTDFile(GM.STDERR)
    elif dataType == GM.REDIRECT_QUEUE_VALUES:
      GC.Values = dataItem
      csvPF.SetColumnDelimiter(GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER])
      csvPF.SetQuoteChar(GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR])
      csvPF.SetHeaderFilter(GC.Values[GC.CSV_OUTPUT_HEADER_FILTER])
      csvPF.SetHeaderDropFilter(GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER])
      csvPF.SetRowFilter(GC.Values[GC.CSV_OUTPUT_ROW_FILTER])
      csvPF.SetRowDropFilter(GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER])
    else:
      break
  csvPF.writeCSVfile(list_type)
  if mpQueueStdout:
    mpQueueStdout.put((0, GM.REDIRECT_QUEUE_DATA, GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].getvalue()))
  else:
    flushStdout()
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((0, GM.REDIRECT_QUEUE_DATA, GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].getvalue()))
  else:
    flushStderr()

def initializeCSVFileQueueHandler(mpQueueStdout, mpQueueStderr):
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=CSVFileQueueHandler, args=(mpQueue, mpQueueStdout, mpQueueStderr, GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE_CSVPF]))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateCSVFileQueueHandler(mpQueue, mpQueueHandler):
  GM.Globals[GM.PARSER] = None
  GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = None
  if GM.Globals[GM.WINDOWS]:
    mpQueue.put((GM.REDIRECT_QUEUE_ARGS, Cmd.AllArguments()))
    savedValues = saveNonPickleableValues()
    mpQueue.put((GM.REDIRECT_QUEUE_GLOBALS, GM.Globals))
    restoreNonPickleableValues(savedValues)
    mpQueue.put((GM.REDIRECT_QUEUE_VALUES, GC.Values))
  mpQueue.put((GM.REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def StdQueueHandler(mpQueue, stdtype, gmGlobals, gcValues):

  PROCESS_MSG = '{0}: {1:6d}, {2:>5s}: {3}, RC: {4:3d}, Cmd: {5}\n'

  def _writeData(data):
    fd.write(data)

  def _writePidData(pid, data):
    try:
      if pid != 0 and GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        _writeData(PROCESS_MSG.format(pidData[pid]['queue'], pid, 'Start', pidData[pid]['start'], data[0], pidData[pid]['cmd']))
      if data[1] is not None:
        _writeData(data[1])
      if GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        _writeData(PROCESS_MSG.format(pidData[pid]['queue'], pid, 'End', currentISOformatTimeStamp(), data[0], pidData[pid]['cmd']))
      fd.flush()
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, fdErrorMessage(fd, GM.Globals[stdtype][GM.REDIRECT_NAME], e))

  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    GM.Globals = gmGlobals.copy()
    GC.Values = gcValues.copy()
  pid0DataItem = [KEYBOARD_INTERRUPT_RC, None]
  pidData = {}
  if GM.Globals[GM.WINDOWS]:
    if GM.Globals[stdtype][GM.REDIRECT_NAME] == 'null':
      fd = open(os.devnull, GM.Globals[stdtype][GM.REDIRECT_MODE])
    elif GM.Globals[stdtype][GM.REDIRECT_NAME] == '-':
      fd = os.fdopen(os.dup([sys.stderr.fileno(), sys.stdout.fileno()][GM.Globals[stdtype][GM.REDIRECT_QUEUE] == 'stdout']),
                     GM.Globals[stdtype][GM.REDIRECT_MODE], encoding=GM.Globals[GM.SYS_ENCODING])
    elif GM.Globals[stdtype][GM.REDIRECT_NAME] == 'stdout' and GM.Globals[stdtype][GM.REDIRECT_QUEUE] == 'stderr':
      fd = os.fdopen(os.dup(sys.stdout.fileno()), GM.Globals[stdtype][GM.REDIRECT_MODE], encoding=GM.Globals[GM.SYS_ENCODING])
    else:
      fd = openFile(GM.Globals[stdtype][GM.REDIRECT_NAME], GM.Globals[stdtype][GM.REDIRECT_MODE])
  else:
    fd = GM.Globals[stdtype][GM.REDIRECT_FD]
  while True:
    pid, dataType, dataItem = mpQueue.get()
    if dataType == GM.REDIRECT_QUEUE_START:
      pidData[pid] = {'queue': GM.Globals[stdtype][GM.REDIRECT_QUEUE],
                      'start': currentISOformatTimeStamp(),
                      'cmd': Cmd.QuotedArgumentList(dataItem)}
      if pid == 0 and GC.Values[GC.SHOW_MULTIPROCESS_INFO]:
        fd.write(PROCESS_MSG.format(pidData[pid]['queue'], pid, 'Start', pidData[pid]['start'], 0, pidData[pid]['cmd']))
    elif dataType == GM.REDIRECT_QUEUE_DATA:
      _writeData(dataItem)
    elif dataType == GM.REDIRECT_QUEUE_END:
      if pid != 0:
        _writePidData(pid, dataItem)
        del pidData[pid]
      else:
        pid0DataItem = dataItem
    else:
      break
  for pid in pidData:
    if pid != 0:
      _writePidData(pid, [KEYBOARD_INTERRUPT_RC, None])
  _writePidData(0, pid0DataItem)
  if fd not in [sys.stdout, sys.stderr]:
    try:
      fd.close()
    except IOError:
      pass
  GM.Globals[stdtype][GM.REDIRECT_FD] = None

def initializeStdQueueHandler(stdtype, gmGlobals, gcValues):
  mpQueue = multiprocessing.Manager().Queue()
  mpQueueHandler = multiprocessing.Process(target=StdQueueHandler, args=(mpQueue, stdtype, gmGlobals, gcValues))
  mpQueueHandler.start()
  return (mpQueue, mpQueueHandler)

def terminateStdQueueHandler(mpQueue, mpQueueHandler):
  mpQueue.put((0, GM.REDIRECT_QUEUE_EOF, None))
  mpQueueHandler.join()

def ProcessGAMCommandMulti(pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr,
                           todrive,
                           csvColumnDelimiter, csvQuoteChar,
                           csvHeaderFilter, csvHeaderDropFilter,
                           csvRowFilter, csvRowDropFilter,
                           args):
  initializeLogging()
  if sys.platform.startswith('win'):
    signal.signal(signal.SIGINT, signal.SIG_IGN)
  GM.Globals[GM.PID] = pid
  GM.Globals[GM.SYSEXITRC] = 0
  GM.Globals[GM.CSV_DATA_DICT] = {}
  GM.Globals[GM.CSV_KEY_FIELD] = None
  GM.Globals[GM.CSV_SUBKEY_FIELD] = None
  GM.Globals[GM.CSV_DATA_FIELD] = None
  GM.Globals[GM.CSV_TODRIVE] = todrive.copy()
  GM.Globals[GM.CSV_OUTPUT_COLUMN_DELIMITER] = csvColumnDelimiter
  GM.Globals[GM.CSV_OUTPUT_QUOTE_CHAR] = csvQuoteChar
  GM.Globals[GM.CSV_OUTPUT_HEADER_FILTER] = csvHeaderFilter[:]
  GM.Globals[GM.CSV_OUTPUT_HEADER_DROP_FILTER] = csvHeaderDropFilter[:]
  GM.Globals[GM.CSV_OUTPUT_ROW_FILTER] = csvRowFilter[:]
  GM.Globals[GM.CSV_OUTPUT_ROW_DROP_FILTER] = csvRowDropFilter[:]
  GM.Globals[GM.CSVFILE] = {}
  if mpQueueCSVFile:
    GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = mpQueueCSVFile
  if mpQueueStdout:
    GM.Globals[GM.STDOUT] = {GM.REDIRECT_NAME: '', GM.REDIRECT_FD: None, GM.REDIRECT_MULTI_FD: StringIOobject()}
    if GM.Globals[GM.SAVED_STDOUT] is not None:
      GM.Globals[GM.SAVED_STDOUT] = sys.stdout
      sys.stdout = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]
    mpQueueStdout.put((pid, GM.REDIRECT_QUEUE_START, args))
  else:
    GM.Globals[GM.STDOUT] = {}
  if mpQueueStderr:
    if mpQueueStderr is not mpQueueStdout:
      GM.Globals[GM.STDERR] = {GM.REDIRECT_NAME: '', GM.REDIRECT_FD: None, GM.REDIRECT_MULTI_FD: StringIOobject()}
      mpQueueStderr.put((pid, GM.REDIRECT_QUEUE_START, args))
    else:
      GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]
  else:
    GM.Globals[GM.STDERR] = {}
  sysRC = ProcessGAMCommand(args)
  if mpQueueStdout:
    mpQueueStdout.put((pid, GM.REDIRECT_QUEUE_END, [sysRC, GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = None
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((pid, GM.REDIRECT_QUEUE_END, [sysRC, GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = None
  return pid

def batchWriteStderr(data):
  fd = GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr)
  if not GM.Globals[GM.STDERR].get(GM.REDIRECT_STD, False):
    try:
      sys.stderr.write(data)
      sys.stderr.flush()
    except IOError as e:
      systemErrorExit(FILE_ERROR_RC, fileErrorMessage('stderr', e))
  try:
    fd.write(data)
    fd.flush()
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, fdErrorMessage(fd, 'stderr', e))

ERROR_PLURAL_SINGULAR = [Msg.ERRORS, Msg.ERROR]
PROCESS_PLURAL_SINGULAR = [Msg.PROCESSES, Msg.PROCESS]
THREAD_PLURAL_SINGULAR = [Msg.THREADS, Msg.THREAD]

def MultiprocessGAMCommands(items, logCmds):
  def poolCallback(pid):
    poolProcessResults[0] -= 1
    if logCmds:
      batchWriteStderr(f'{currentISOformatTimeStamp()},{pid},Complete\n')

  if not items:
    return
  numPoolProcesses = min(len(items), GC.Values[GC.NUM_THREADS])
  if GC.Values[GC.MULTIPROCESS_POOL_LIMIT] == -1:
    parallelPoolProcesses = -1
  elif GC.Values[GC.MULTIPROCESS_POOL_LIMIT] == 0:
    parallelPoolProcesses = numPoolProcesses
  else:
    parallelPoolProcesses = min(len(items), GC.Values[GC.MULTIPROCESS_POOL_LIMIT])
  origSigintHandler = signal.signal(signal.SIGINT, signal.SIG_IGN)
  try:
    pool = multiprocessing.Pool(processes=numPoolProcesses, maxtasksperchild=200)
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, e)
  except AssertionError as e:
    Cmd.SetLocation(0)
    usageErrorExit(str(e))
  if GM.Globals[GM.WINDOWS]:
    savedValues = saveNonPickleableValues()
  if GM.Globals[GM.STDOUT][GM.REDIRECT_MULTIPROCESS]:
    mpQueueStdout, mpQueueHandlerStdout = initializeStdQueueHandler(GM.STDOUT, GM.Globals, GC.Values)
    mpQueueStdout.put((0, GM.REDIRECT_QUEUE_START, Cmd.AllArguments()))
  else:
    mpQueueStdout = None
  if GM.Globals[GM.STDERR][GM.REDIRECT_MULTIPROCESS]:
    if GM.Globals[GM.STDERR][GM.REDIRECT_NAME] != 'stdout':
      mpQueueStderr, mpQueueHandlerStderr = initializeStdQueueHandler(GM.STDERR, GM.Globals, GC.Values)
      mpQueueStderr.put((0, GM.REDIRECT_QUEUE_START, Cmd.AllArguments()))
    else:
      mpQueueStderr = mpQueueStdout
  else:
    mpQueueStderr = None
  if GM.Globals[GM.WINDOWS]:
    restoreNonPickleableValues(savedValues)
  if GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS]:
    mpQueueCSVFile, mpQueueHandlerCSVFile = initializeCSVFileQueueHandler(mpQueueStdout, mpQueueStderr)
  else:
    mpQueueCSVFile = None
  signal.signal(signal.SIGINT, origSigintHandler)
  batchWriteStderr(Msg.USING_N_PROCESSES.format(currentISOformatTimeStamp(),
                                                numPoolProcesses, PROCESS_PLURAL_SINGULAR[numPoolProcesses == 1]))
  try:
    pid = 0
    poolProcessResults = {pid: 0}
    for item in items:
      if item[0] == Cmd.COMMIT_BATCH_CMD:
        batchWriteStderr(Msg.COMMIT_BATCH_WAIT_N_PROCESSES.format(currentISOformatTimeStamp(),
                                                                  poolProcessResults[0],
                                                                  PROCESS_PLURAL_SINGULAR[poolProcessResults[0] == 1]))
        while poolProcessResults[0] > 0:
          time.sleep(1)
        batchWriteStderr(Msg.COMMIT_BATCH_COMPLETE.format(currentISOformatTimeStamp(), Msg.PROCESSES))
        continue
      if item[0] == Cmd.PRINT_CMD:
        batchWriteStderr(Cmd.QuotedArgumentList(item[1:])+'\n')
        continue
      pid += 1
      if not logCmds and pid % 100 == 0:
        batchWriteStderr(Msg.PROCESSING_ITEM_N.format(currentISOformatTimeStamp(), pid))
      if logCmds:
        batchWriteStderr(f'{currentISOformatTimeStamp()},{pid},{Cmd.QuotedArgumentList(item)}\n')
      pool.apply_async(ProcessGAMCommandMulti,
                       [pid, mpQueueCSVFile, mpQueueStdout, mpQueueStderr,
                        GM.Globals[GM.CSV_TODRIVE],
                        GC.Values[GC.CSV_OUTPUT_COLUMN_DELIMITER], GC.Values[GC.CSV_OUTPUT_QUOTE_CHAR],
                        GC.Values[GC.CSV_OUTPUT_HEADER_FILTER], GC.Values[GC.CSV_OUTPUT_HEADER_DROP_FILTER],
                        GC.Values[GC.CSV_OUTPUT_ROW_FILTER], GC.Values[GC.CSV_OUTPUT_ROW_DROP_FILTER],
                        item],
                       callback=poolCallback)
      poolProcessResults[0] += 1
      if parallelPoolProcesses > 0:
        while poolProcessResults[0] == parallelPoolProcesses:
          time.sleep(1)
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    pool.terminate()
  else:
    pool.close()
  pool.join()
  if logCmds:
    batchWriteStderr(f'{currentISOformatTimeStamp()},0,Complete\n')
  if mpQueueCSVFile:
    terminateCSVFileQueueHandler(mpQueueCSVFile, mpQueueHandlerCSVFile)
  if mpQueueStdout:
    mpQueueStdout.put((0, GM.REDIRECT_QUEUE_END, [GM.Globals[GM.SYSEXITRC], GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStdout, mpQueueHandlerStdout)
  if mpQueueStderr and mpQueueStderr is not mpQueueStdout:
    mpQueueStderr.put((0, GM.REDIRECT_QUEUE_END, [GM.Globals[GM.SYSEXITRC], GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].getvalue()]))
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD].close()
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = None
    terminateStdQueueHandler(mpQueueStderr, mpQueueHandlerStderr)

def threadBatchWorker(logCmds=False):
  while True:
    pid, item = GM.Globals[GM.TBATCH_QUEUE].get()
    try:
      sysRC = subprocess.call(item, stdout=GM.Globals[GM.STDOUT].get(GM.REDIRECT_MULTI_FD, sys.stdout),
                              stderr=GM.Globals[GM.STDERR].get(GM.REDIRECT_MULTI_FD, sys.stderr))
      if logCmds:
        batchWriteStderr(f'{currentISOformatTimeStamp()},{pid},Complete,{sysRC}\n')
    except Exception as e:
      batchWriteStderr(f'{currentISOformatTimeStamp()},{pid},{str(e)}\n')
    GM.Globals[GM.TBATCH_QUEUE].task_done()

def ThreadBatchGAMCommands(items, logCmds):
  if not items:
    return
  pythonCmd = [sys.executable]
  if not getattr(sys, 'frozen', False): # we're not frozen
    pythonCmd.append(os.path.realpath(Cmd.Argument(0)))
  numWorkerThreads = min(len(items), GC.Values[GC.NUM_TBATCH_THREADS])
# GM.Globals[GM.TBATCH_QUEUE].put() gets blocked when trying to create more items than there are workers
  GM.Globals[GM.TBATCH_QUEUE] = queue.Queue(maxsize=numWorkerThreads)
  batchWriteStderr(Msg.USING_N_PROCESSES.format(currentISOformatTimeStamp(),
                                                numWorkerThreads, THREAD_PLURAL_SINGULAR[numWorkerThreads == 1]))
  for _ in range(numWorkerThreads):
    t = threading.Thread(target=threadBatchWorker, kwargs={'logCmds': logCmds})
    t.daemon = True
    t.start()
  pid = 0
  numThreadsInUse = 0
  for item in items:
    if item[0] == Cmd.COMMIT_BATCH_CMD:
      batchWriteStderr(Msg.COMMIT_BATCH_WAIT_N_PROCESSES.format(currentISOformatTimeStamp(),
                                                                numThreadsInUse,
                                                                THREAD_PLURAL_SINGULAR[numThreadsInUse == 1]))
      GM.Globals[GM.TBATCH_QUEUE].join()
      batchWriteStderr(Msg.COMMIT_BATCH_COMPLETE.format(currentISOformatTimeStamp(), Msg.THREADS))
      numThreadsInUse = 0
      continue
    if item[0] == Cmd.PRINT_CMD:
      batchWriteStderr(f'{currentISOformatTimeStamp()},0,{Cmd.QuotedArgumentList(item[1:])}\n')
      continue
    pid += 1
    if not logCmds and pid % 100 == 0:
      batchWriteStderr(Msg.PROCESSING_ITEM_N.format(currentISOformatTimeStamp(), pid))
    if logCmds:
      batchWriteStderr(f'{currentISOformatTimeStamp()},{pid},{Cmd.QuotedArgumentList(item)}\n')
    if item[0] == Cmd.GAM_CMD:
      GM.Globals[GM.TBATCH_QUEUE].put((pid, pythonCmd+item[1:]))
    else:
      GM.Globals[GM.TBATCH_QUEUE].put((pid, item[1:]))
    numThreadsInUse += 1
  GM.Globals[GM.TBATCH_QUEUE].join()
  if logCmds:
    batchWriteStderr(f'{currentISOformatTimeStamp()},0,Complete\n')

# gam batch <FileName>|-|(gdoc <UserGoogleDoc>) [charset <Charset>] [showcmds]
def doBatch(threadBatch=False):
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == '-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.BATCH_CMD))
  if filename.lower() != 'gdoc':
    encoding = getCharSet()
    f = openFile(filename, encoding=encoding, stripUTFBOM=True)
  else:
    f = getGDocData(MIMETYPE_TEXT_PLAIN)
    getCharSet()
  logCmds = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'showcmds':
      logCmds = getBoolean()
    else:
      unknownArgumentExit()
  items = []
  errors = 0
  try:
    for line in f:
      if line.startswith('#'):
        continue
      try:
        argv = shlex.split(line)
      except ValueError as e:
        writeStderr(f'Command: >>>{line.strip()}<<<\n')
        writeStderr(f'{ERROR_PREFIX}{str(e)}\n')
        errors += 1
        continue
      if argv:
        cmd = argv[0].strip().lower()
        if (not cmd) or ((len(argv) == 1) and (cmd not in [Cmd.COMMIT_BATCH_CMD, Cmd.PRINT_CMD])):
          continue
        if cmd == Cmd.GAM_CMD:
          items.append(argv)
        elif cmd == Cmd.COMMIT_BATCH_CMD:
          items.append([cmd])
        elif cmd == Cmd.EXECUTE_CMD:
          items.append(argv)
        elif cmd == Cmd.PRINT_CMD:
          items.append(argv)
        else:
          writeStderr(f'Command: >>>{Cmd.QuotedArgumentList([argv[0]])}<<< {Cmd.QuotedArgumentList(argv[1:])}\n')
          writeStderr(f'{ERROR_PREFIX}{Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1]}: {Msg.EXPECTED} <{formatChoiceList([Cmd.GAM_CMD, Cmd.COMMIT_BATCH_CMD, Cmd.PRINT_CMD])}>\n')
          errors += 1
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))
  closeFile(f)
  if errors == 0:
    if not threadBatch:
      MultiprocessGAMCommands(items, logCmds)
    else:
      ThreadBatchGAMCommands(items, logCmds)
  else:
    writeStderr(Msg.BATCH_NOT_PROCESSED_ERRORS.format(ERROR_PREFIX, filename, errors, ERROR_PLURAL_SINGULAR[errors == 1]))
    setSysExitRC(USAGE_ERROR_RC)

# gam tbatch <FileName>|-|(gdoc <UserGoogleDoc>) [charset <Charset>] [showcmds]
def doThreadBatch():
  adjustRedirectedSTDFilesIfNotMultiprocessing()
  doBatch(True)

def doAutoBatch(entityType, entityList, CL_command):
  remaining = Cmd.Remaining()
  items = []
  initial_argv = [Cmd.GAM_CMD]
  if GM.Globals[GM.SECTION]:
    initial_argv.extend([Cmd.SELECT_CMD, GM.Globals[GM.SECTION]])
  for entity in entityList:
    items.append(initial_argv+[entityType, entity, CL_command]+remaining)
  MultiprocessGAMCommands(items, False)

# Process command line arguments, find substitutions
# An argument containing instances of ~~xxx~!~pattern~!~replacement~~ has ~~...~~ replaced by re.sub(pattern, replacement, value of field xxx from the CSV file)
# For example, ~~primaryEmail~!~^(.+)@(.+)$~!~\1 AT \2~~ would replace foo@bar.com (from the primaryEmail column) with foo AT bar.com
# An argument containing instances of ~~xxx~~ has xxx replaced by the value of field xxx from the CSV file
# An argument containing exactly ~xxx is replaced by the value of field xxx from the CSV file
# Otherwise, the argument is preserved as is

SUB_PATTERN = re.compile(r'~~(.+?)~~')
RE_PATTERN = re.compile(r'~~(.+?)~!~(.+?)~!~(.+?)~~')
SUB_TYPE = 'sub'
RE_TYPE = 're'

# SubFields is a dictionary; the key is the argument number, the value is a list of tuples that mark
# the substition (type, fieldname, start, end). Type is 'sub' for simple substitution, 're' for regex substitution.
# Example: update user '~User' address type work unstructured '~~Street~~, ~~City~~, ~~State~~ ~~ZIP~~' primary
# {2: [('sub', 'User', 0, 5)], 7: [('sub', 'Street', 0, 10), ('sub', 'City', 12, 20), ('sub', 'State', 22, 31), ('sub', 'ZIP', 32, 39)]}
def getSubFields(initial_argv, fieldNames):
  subFields = {}
  GAM_argv = initial_argv[:]
  GAM_argvI = len(GAM_argv)
  while Cmd.ArgumentsRemaining():
    myarg = Cmd.Current()
    if not myarg:
      GAM_argv.append(myarg)
    elif SUB_PATTERN.search(myarg):
      pos = 0
      subFields.setdefault(GAM_argvI, [])
      while True:
        submatch = SUB_PATTERN.search(myarg, pos)
        if not submatch:
          break
        rematch = RE_PATTERN.match(submatch.group(0))
        if not rematch:
          fieldName = submatch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          subFields[GAM_argvI].append((SUB_TYPE, fieldName, submatch.start(), submatch.end()))
        else:
          fieldName = rematch.group(1)
          if fieldName not in fieldNames:
            csvFieldErrorExit(fieldName, fieldNames)
          try:
            re.compile(rematch.group(2))
            subFields[GAM_argvI].append((RE_TYPE, fieldName, submatch.start(), submatch.end(), rematch.group(2), rematch.group(3)))
          except re.error as e:
            usageErrorExit(f'{Cmd.OB_RE_PATTERN} {Msg.ERROR}: {e}')
        pos = submatch.end()
      GAM_argv.append(myarg)
    elif myarg[0] == '~':
      fieldName = myarg[1:]
      if fieldName in fieldNames:
        subFields[GAM_argvI] = [(SUB_TYPE, fieldName, 0, len(myarg))]
        GAM_argv.append(myarg)
      else:
        csvFieldErrorExit(fieldName, fieldNames)
    else:
      GAM_argv.append(myarg)
    GAM_argvI += 1
    Cmd.Advance()
  return(GAM_argv, subFields)

def processSubFields(GAM_argv, row, subFields):
  argv = GAM_argv[:]
  for GAM_argvI, fields in iter(subFields.items()):
    oargv = argv[GAM_argvI][:]
    argv[GAM_argvI] = ''
    pos = 0
    for field in fields:
      argv[GAM_argvI] += oargv[pos:field[2]]
      if field[0] == SUB_TYPE:
        if row[field[1]]:
          argv[GAM_argvI] += row[field[1]]
      else:
        if row[field[1]]:
          argv[GAM_argvI] += re.sub(field[4], field[5], row[field[1]])
      pos = field[3]
    argv[GAM_argvI] += oargv[pos:]
  return argv

# gam csv <FileName>|-|(gsheet <UserGoogleSheet>) [charset <Charset>] [warnifnodata]
#	[columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	(matchfield|skipfield <FieldName> <RegularExpression>)* [showcmds [<Boolean>]] gam <GAM argument list>
def doCSV(testMode=False):
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == '-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.CSV_CMD))
  f, csvFile, fieldnames = openCSVFileReader(filename)
  matchFields, skipFields = getMatchSkipFields(fieldnames)
  logCmds = checkArgumentPresent('showcmds')
  if logCmds:
    logCmds = getBoolean()
  checkArgumentPresent(Cmd.GAM_CMD, required=True)
  if not Cmd.ArgumentsRemaining():
    missingArgumentExit(Cmd.OB_GAM_ARGUMENT_LIST)
  initial_argv = [Cmd.GAM_CMD]
  if GM.Globals[GM.SECTION] and not Cmd.PeekArgumentPresent(Cmd.SELECT_CMD):
    initial_argv.extend([Cmd.SELECT_CMD, GM.Globals[GM.SECTION]])
  GAM_argv, subFields = getSubFields(initial_argv, fieldnames)
  items = []
  for row in csvFile:
    if checkMatchSkipFields(row, matchFields, skipFields):
      items.append(processSubFields(GAM_argv, row, subFields))
  closeFile(f)
  if not testMode:
    MultiprocessGAMCommands(items, logCmds)
  else:
    numItems = min(len(items), 10)
    writeStdout(Msg.CSV_FILE_HEADERS.format(filename))
    Ind.Increment()
    for field in fieldnames:
      writeStdout(f'{Ind.Spaces()}{field}\n')
    Ind.Decrement()
    writeStdout(Msg.CSV_SAMPLE_COMMANDS.format(numItems, GAM))
    Ind.Increment()
    for i in range(numItems):
      writeStdout(f'{Ind.Spaces()}{Cmd.QuotedArgumentList(items[i])}\n')
    Ind.Decrement()

def doCSVTest():
  doCSV(testMode=True)

def _doList(entityList, entityType):
  buildGAPIObject(API.DIRECTORY)
  if GM.Globals[GM.CSV_DATA_DICT]:
    keyField = GM.Globals[GM.CSV_KEY_FIELD]
    dataField = GM.Globals[GM.CSV_DATA_FIELD]
  else:
    keyField = 'Entity'
    dataField = 'Data'
  csvPF = CSVPrintFile(keyField)
  if checkArgumentPresent('todrive'):
    csvPF.GetTodriveParameters()
  if entityList is None:
    entityList = getEntityList(Cmd.OB_ENTITY)
  showData = checkArgumentPresent('data')
  if showData:
    if not entityType:
      itemType, itemList = getEntityToModify(crosAllowed=True)
    else:
      itemType = None
      itemList = getEntityList(Cmd.OB_ENTITY)
    entityItemLists = itemList if isinstance(itemList, dict) else None
    csvPF.AddTitle(dataField)
  else:
    entityItemLists = None
  dataDelimiter = getDelimiter()
  checkForExtraneousArguments()
  _, _, entityList = getEntityArgument(entityList)
  for entity in entityList:
    entityEmail = normalizeEmailAddressOrUID(entity)
    if showData:
      if entityItemLists:
        if entity not in entityItemLists:
          csvPF.WriteRow({keyField: entityEmail})
          continue
        itemList = entityItemLists[entity]
        if itemType == Cmd.ENTITY_USERS:
          for i, item in enumerate(itemList):
            itemList[i] = normalizeEmailAddressOrUID(item)
      if dataDelimiter:
        csvPF.WriteRow({keyField: entityEmail, dataField: dataDelimiter.join(itemList)})
      else:
        for item in itemList:
          csvPF.WriteRow({keyField: entityEmail, dataField: item})
    else:
      csvPF.WriteRow({keyField: entityEmail})
  csvPF.writeCSVfile('Entity')

# gam list [todrive <ToDriveAttribute>*] <EntityList> [data <CrOSTypeEntity>|<UserTypeEntity> [delimiter <Character>]]
def doListType():
  _doList(None, None)

# gam <CrOSTypeEntity> list [todrive <ToDriveAttribute>*] [data <EntityList> [delimiter <Character>]]
def doListCrOS(entityList):
  _doList(entityList, Cmd.ENTITY_CROS)

# gam <UserTypeEntity> list [todrive <ToDriveAttribute>*] [data <EntityList> [delimiter <Character>]]
def doListUser(entityList):
  _doList(entityList, Cmd.ENTITY_USERS)

VALIDEMAIL_PATTERN = re.compile(r'^[^@]+@[^@]+\.[^@]+$')

def _getValidateLoginHint(login_hint, projectId=None):
  while True:
    if not login_hint:
      if not projectId:
        login_hint = readStdin(Msg.ENTER_GSUITE_ADMIN_EMAIL_ADDRESS).strip()
      else:
        login_hint = readStdin(Msg.ENTER_MANAGE_GCP_PROJECT_EMAIL_ADDRESS.format(projectId)).strip()
    if login_hint.find('@') == -1 and GC.Values[GC.DOMAIN]:
      login_hint = f'{login_hint}@{GC.Values[GC.DOMAIN]}'
    if VALIDEMAIL_PATTERN.match(login_hint):
      return login_hint
    sys.stdout.write(f'{ERROR_PREFIX}Invalid email address: {login_hint}\n')
    login_hint = None

def getOAuthClientIDAndSecret():
  cs_data = readFile(GC.Values[GC.CLIENT_SECRETS_JSON], continueOnError=True, displayError=True)
  if not cs_data:
    invalidClientSecretsJsonExit()
  try:
    cs_json = json.loads(cs_data)
    if not cs_json:
      systemErrorExit(CLIENT_SECRETS_JSON_REQUIRED_RC, Msg.NO_CLIENT_ACCESS_CREATE_UPDATE_ALLOWED)
    # chop off .apps.googleusercontent.com suffix as it's not needed and we need to keep things short for the Auth URL.
    return (re.sub(r'\.apps\.googleusercontent\.com$', '', cs_json['installed']['client_id']),
            cs_json['installed']['client_secret'])
  except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
    invalidClientSecretsJsonExit()

def getScopesFromUser(scopesList, clientAccess, currentScopes=None):
  OAUTH2_CMDS = ['s', 'u', 'e', 'c']
  oauth2_menu = '''
Select the authorized scopes by entering a number.
Append an 'r' to grant read-only access or an 'a' to grant action-only access.

'''
  numScopes = len(scopesList)
  for a_scope in scopesList:
    oauth2_menu += '[%%%%s] %%2d)  %s' % (a_scope['name'])
    if a_scope['subscopes']:
      oauth2_menu += f' (supports {" and ".join(a_scope["subscopes"])})'
    oauth2_menu += '\n'
  oauth2_menu += '''
     s)  Select all scopes
     u)  Unselect all scopes
     e)  Exit without changes
     c)  Continue to authorization
'''
  menu = oauth2_menu % tuple(range(numScopes))
  selectedScopes = ['*'] * numScopes
  if currentScopes is None and clientAccess:
    lock = FileLock(GM.Globals[GM.OAUTH2_TXT_LOCK])
    with lock:
      _, credentials = getOauth2TxtCredentials(exitOnError=False)
      if credentials and credentials.scopes is not None:
        currentScopes = sorted(credentials.scopes)
  if currentScopes is not None:
    if clientAccess:
      i = 0
      for a_scope in scopesList:
        selectedScopes[i] = ' '
        possibleScope = a_scope['scope']
        for currentScope in currentScopes:
          if currentScope == possibleScope:
            selectedScopes[i] = '*'
            break
          if 'readonly' in a_scope['subscopes']:
            if currentScope == possibleScope+'.readonly':
              selectedScopes[i] = 'R'
              break
          if 'action' in a_scope['subscopes']:
            if currentScope == possibleScope+'.action':
              selectedScopes[i] = 'A'
              break
        i += 1
    else:
      i = 0
      for a_scope in scopesList:
        selectedScopes[i] = ' '
        api = a_scope['api']
        possibleScope = a_scope['scope']
        if api in currentScopes:
          for scope in currentScopes[api]:
            if scope == possibleScope:
              selectedScopes[i] = '*'
              break
            if 'readonly' in a_scope['subscopes']:
              if scope == possibleScope+'.readonly':
                selectedScopes[i] = 'R'
                break
        i += 1
  else:
    i = 0
    for a_scope in scopesList:
      selectedScopes[i] = ' ' if a_scope.get('offByDefault', False) else '*'
      i += 1
  prompt = f'Please enter 0-{numScopes-1}[a|r] or {"|".join(OAUTH2_CMDS)}: '
  while True:
    os.system(['clear', 'cls'][GM.Globals[GM.WINDOWS]])
    sys.stdout.write(menu % tuple(selectedScopes))
    while True:
      choice = readStdin(prompt)
      if choice:
        selection = choice.lower()
        if selection.find('r') >= 0:
          mode = 'R'
          selection = selection.replace('r', '')
        elif selection.find('a') >= 0:
          mode = 'A'
          selection = selection.replace('a', '')
        else:
          mode = ' '
        if selection and selection.isdigit():
          selection = int(selection)
        if isinstance(selection, int) and selection < numScopes:
          if mode == 'R':
            if 'readonly' not in scopesList[selection]['subscopes']:
              sys.stdout.write(f'{ERROR_PREFIX}Scope {selection} does not support read-only mode!\n')
              continue
          elif mode == 'A':
            if 'action' not in scopesList[selection]['subscopes']:
              sys.stdout.write(f'{ERROR_PREFIX}Scope {selection} does not support action-only mode!\n')
              continue
          elif selectedScopes[selection] != '*':
            mode = '*'
          else:
            mode = ' '
          selectedScopes[selection] = mode
          break
        if isinstance(selection, str) and selection in OAUTH2_CMDS:
          if selection == 's':
            for i in range(numScopes):
              selectedScopes[i] = '*'
          elif selection == 'u':
            for i in range(numScopes):
              selectedScopes[i] = ' '
          elif selection == 'e':
            return None
          break
        sys.stdout.write(f'{ERROR_PREFIX}Invalid input "{choice}"\n')
    if selection == 'c':
      break
  return selectedScopes

def writeGAMOauthURLfile(oauthURL):
  writeFile(GM.Globals[GM.GAM_OAUTH_URL_TXT], oauthURL, mode='w', continueOnError=True, displayError=True)

def _run_oauth_flow(client_id, client_secret, scopes, login_hint, access_type):
  client_config = {
    'installed': {
      'client_id': client_id,
      'client_secret': client_secret,
      'redirect_uris': ['http://localhost', 'urn:ietf:wg:oauth:2.0:oob'],
      'auth_uri': 'https://accounts.google.com/o/oauth2/v2/auth',
      'token_uri': 'https://oauth2.googleapis.com/token',
      }
    }

  flow = google_auth_oauthlib.flow.InstalledAppFlow.from_client_config(client_config, scopes, autogenerate_code_verifier=True)
  kwargs = {'access_type': access_type}
  if login_hint:
    kwargs['login_hint'] = login_hint
  try:
    if GC.Values[GC.NO_BROWSER]:
      GM.Globals[GM.GAM_OAUTH_URL_TXT] = os.path.join(GM.Globals[GM.GAM_PATH], FN_GAM_OAUTH_URL_TXT)
      kwargs['auth_url_callback'] = writeGAMOauthURLfile
      flow.run_console(
        authorization_prompt_message=Msg.OAUTH2_GO_TO_LINK_MESSAGE.format(Msg.THE_LINK_MAY_BE_COPIED_FROM_THE_FILE_RATHER_THAN_THE_SCREEN.format(GM.Globals[GM.GAM_OAUTH_URL_TXT])),
        authorization_code_message=Msg.ENTER_VERIFICATION_CODE,
        **kwargs)
      deleteFile(GM.Globals[GM.GAM_OAUTH_URL_TXT], continueOnError=True, displayError=True)
    else:
      flow.run_local_server(
        authorization_prompt_message=Msg.OAUTH2_BROWSER_OPENED_MESSAGE,
        success_message=Msg.AUTHENTICATION_FLOW_COMPLETE,
        **kwargs)
    return flow.credentials
  except Exception as e:
    stderrErrorMsg(Msg.AUTHENTICATION_FLOW_FAILED.format(str(e)))
    if GC.Values[GC.NO_BROWSER]:
      deleteFile(GM.Globals[GM.GAM_OAUTH_URL_TXT], continueOnError=True, displayError=True)
    systemErrorExit(SCOPES_NOT_AUTHORIZED_RC, None)

def doOAuthRequest(currentScopes, login_hint, verifyScopes=False):
  client_id, client_secret = getOAuthClientIDAndSecret()
  scopesList = API.getClientScopesList(GC.Values[GC.TODRIVE_CLIENTACCESS])
  if not currentScopes or verifyScopes:
    selectedScopes = getScopesFromUser(scopesList, True, currentScopes)
    if selectedScopes is None:
      return False
    scopes = API.REQUIRED_SCOPES[:]
    i = 0
    for scope in scopesList:
      if selectedScopes[i] == '*':
        scopes.append(scope['scope'])
      elif selectedScopes[i] == 'R':
        scopes.append(f'{scope["scope"]}.readonly')
      elif selectedScopes[i] == 'A':
        scopes.append(f'{scope["scope"]}.action')
      i += 1
  else:
    scopes = currentScopes+API.REQUIRED_SCOPES[:]
  login_hint = _getValidateLoginHint(login_hint)
# Needs to be set so oauthlib doesn't puke when Google changes our scopes
  os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = 'true'
  credentials = _run_oauth_flow(client_id, client_secret, scopes, login_hint, 'offline')
  lock = FileLock(GM.Globals[GM.OAUTH2_TXT_LOCK])
  with lock:
    writeClientCredentials(credentials, GC.Values[GC.OAUTH2_TXT])
  entityActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]])
  return True

# gam oauth|oauth2 create|request [<EmailAddress>]
# gam oauth|oauth2 create|request [admin <EmailAddress>] [scope|scopes <APIScopeURLList>]
def doOAuthCreate():
  if not Cmd.PeekArgumentPresent(['admin', 'scope', 'scopes']):
    login_hint = getEmailAddress(noUid=True, optional=True)
    scopes = None
    checkForExtraneousArguments()
  else:
    login_hint = None
    scopes = []
    scopesList = API.getClientScopesList(GC.Values[GC.TODRIVE_CLIENTACCESS])
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'admin':
        login_hint = getEmailAddress(noUid=True)
      elif myarg in {'scope', 'scopes'}:
        for uscope in getString(Cmd.OB_API_SCOPE_URL_LIST).lower().replace(',', ' ').split():
          if uscope in {'openid', 'email', API.USERINFO_EMAIL_SCOPE, 'profile', API.USERINFO_PROFILE_SCOPE}:
            continue
          for scope in scopesList:
            if ((uscope == scope['scope']) or
                (uscope.endswith('.action') and 'action' in scope['subscopes']) or
                (uscope.endswith('.readonly') and 'readonly' in scope['subscopes'])):
              scopes.append(uscope)
              break
          else:
            invalidChoiceExit(uscope, API.getClientScopesURLs(GC.Values[GC.TODRIVE_CLIENTACCESS]), True)
      else:
        unknownArgumentExit()
  doOAuthRequest(scopes, login_hint)

def exitIfNoOauth2Txt():
  if not os.path.isfile(GC.Values[GC.OAUTH2_TXT]):
    entityActionNotPerformedWarning([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], Msg.DOES_NOT_EXIST)
    sys.exit(GM.Globals[GM.SYSEXITRC])

# gam oauth|oauth2 delete|revoke
def doOAuthDelete():
  checkForExtraneousArguments()
  exitIfNoOauth2Txt()
  lock = FileLock(GM.Globals[GM.OAUTH2_TXT_LOCK], timeout=10)
  with lock:
    _, credentials = getOauth2TxtCredentials()
    if not credentials:
      return
    entityType = Ent.OAUTH2_TXT_FILE
    entityName = GC.Values[GC.OAUTH2_TXT]
    sys.stdout.write(f'{Ent.Singular(entityType)}: {entityName}, will be Deleted in 3...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write('2...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write('1...')
    sys.stdout.flush()
    time.sleep(1)
    sys.stdout.write('boom!\n')
    sys.stdout.flush()
    httpObj = getHttpObj()
    params = {'token': credentials.refresh_token}
    revoke_uri = f'https://accounts.google.com/o/oauth2/revoke?{urlencode(params)}'
    httpObj.request(revoke_uri, 'GET')
    deleteFile(GC.Values[GC.OAUTH2_TXT], continueOnError=True)
    entityActionPerformed([entityType, entityName])

# gam oauth|oauth2 info|verify [showsecret] [accesstoken <AccessToken> idtoken <IDToken>] [showdetails]
def doOAuthInfo():
  credentials = access_token = id_token = None
  showDetails = showSecret = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'accesstoken':
      access_token = getString(Cmd.OB_ACCESS_TOKEN)
    elif myarg == 'idtoken':
      id_token = getString(Cmd.OB_ID_TOKEN)
    elif myarg == 'showdetails':
      showDetails = True
    elif myarg == 'showsecret':
      showSecret = True
    else:
      unknownArgumentExit()
  exitIfNoOauth2Txt()
  if not access_token and not id_token:
    credentials = getClientCredentials()
    access_token = credentials.token
    printEntity([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]])
  oa2 = buildGAPIObject(API.OAUTH2)
  try:
    token_info = callGAPI(oa2, 'tokeninfo',
                          throwReasons=[GAPI.INVALID],
                          access_token=access_token, id_token=id_token)
  except GAPI.invalid as e:
    entityActionFailedExit([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], str(e))
  if 'issued_to' in token_info:
    printKeyValueList(['Client ID', token_info['issued_to']])
  if credentials is not None and showSecret:
    printKeyValueList(['Secret', credentials.client_secret])
  if 'scope' in token_info:
    scopes = token_info['scope'].split(' ')
    printKeyValueList(['Scopes', len(scopes)])
    Ind.Increment()
    for scope in sorted(scopes):
      printKeyValueList([scope])
    Ind.Decrement()
  if 'email' in token_info:
    printKeyValueList(['G Suite Admin', f'{token_info["email"]}'])
  if 'expires_in' in token_info:
    printKeyValueList(['Expires', ISOformatTimeStamp((datetime.datetime.now()+datetime.timedelta(seconds=token_info['expires_in'])).replace(tzinfo=GC.Values[GC.TIMEZONE]))])
  if showDetails:
    for k, v in sorted(iter(token_info.items())):
      if k not in  ['email', 'expires_in', 'issued_to', 'scope']:
        printKeyValueList([k, v])
  printBlankLine()

# gam oauth|oauth2 update [<EmailAddress>]
# gam oauth|oauth2 update [admin <EmailAddress>]
def doOAuthUpdate():
  if Cmd.PeekArgumentPresent(['admin']):
    Cmd.Advance()
    login_hint = getEmailAddress(noUid=True)
  else:
    login_hint = getEmailAddress(noUid=True, optional=True)
  checkForExtraneousArguments()
  exitIfNoOauth2Txt()
  lock = FileLock(GM.Globals[GM.OAUTH2_TXT_LOCK])
  with lock:
    jsonData = readFile(GC.Values[GC.OAUTH2_TXT], continueOnError=True, displayError=False)
  if not jsonData:
    invalidOauth2TxtExit()
  try:
    jsonDict = json.loads(jsonData)
    if 'client_id' in jsonDict:
      if 'scopes' in jsonDict:
        currentScopes = jsonDict['scopes']
      else:
        currentScopes = API.getClientScopesURLs(GC.Values[GC.TODRIVE_CLIENTACCESS])
    elif (jsonDict.get('file_version') == 2) and ('credentials' in jsonDict) and (API.GAM_SCOPES in jsonDict['credentials']):
      if not jsonDict['credentials'][API.GAM_SCOPES]:
        currentScopes = []
      else:
        if not isinstance(jsonDict['credentials'][API.GAM_SCOPES], dict):
          importCredentials = json.loads(base64.b64decode(jsonDict['credentials'][API.GAM_SCOPES]).decode('utf-8'))
        else:
          importCredentials = jsonDict['credentials'][API.GAM_SCOPES]
        if importCredentials:
          currentScopes = list(importCredentials.get('scopes', []))
        else:
          currentScopes = []
    elif ((jsonDict.get('file_version') == 2) and ('credentials' in jsonDict) and
          (API.FAM1_SCOPES in jsonDict['credentials']) and (API.FAM2_SCOPES in jsonDict['credentials'])):
      backup = GC.Values[GC.OAUTH2_TXT]+'.bak'
      if not os.path.isfile(backup):
        writeFile(backup, jsonData)
      import1Credentials = json.loads(base64.b64decode(jsonDict['credentials'][API.FAM1_SCOPES]).decode('utf-8'))
      import2Credentials = json.loads(base64.b64decode(jsonDict['credentials'][API.FAM2_SCOPES]).decode('utf-8'))
      currentScopes = list(import1Credentials['scopes'].union(import2Credentials['scopes']))
    else:
      currentScopes = []
  except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
    invalidOauth2TxtExit()
  if not doOAuthRequest(currentScopes, login_hint, verifyScopes=True):
    entityActionNotPerformedWarning([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], Msg.USER_CANCELLED)
    sys.exit(GM.Globals[GM.SYSEXITRC])

# gam oauth|oauth2 refresh
def doOAuthRefresh():
  checkForExtraneousArguments()
  exitIfNoOauth2Txt()
  getClientCredentials(forceRefresh=True, forceWrite=True, filename=GC.Values[GC.OAUTH2_TXT])
  entityActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]])

# gam oauth|oauth2 export [<FileName>]
def doOAuthExport():
  if Cmd.ArgumentsRemaining():
    filename = getString(Cmd.OB_FILE_NAME)
    checkForExtraneousArguments()
  else:
    filename = GC.Values[GC.OAUTH2_TXT]
  getClientCredentials(forceRefresh=True, forceWrite=True, filename=filename)
  if filename != '-':
    entityModifierNewValueActionPerformed([Ent.OAUTH2_TXT_FILE, GC.Values[GC.OAUTH2_TXT]], Act.MODIFIER_TO, filename)

def getCRMService(login_hint):
  scopes = ['https://www.googleapis.com/auth/cloud-platform']
  client_id = '297408095146-fug707qsjv4ikron0hugpevbrjhkmsk7.apps.googleusercontent.com'
  client_secret = 'qM3dP8f_4qedwzWQE1VR4zzU'
  credentials = _run_oauth_flow(client_id, client_secret, scopes, login_hint, 'online')
  httpObj = transportAuthorizedHttp(credentials, http=getHttpObj())
  return (httpObj, getAPIService(API.CLOUDRESOURCEMANAGER_V1, httpObj))

def enableGAMProjectAPIs(httpObj, projectId, checkEnabled, i=0, count=0):
  apis = API.PROJECT_APIS[:]
  projectName = f'projects/{projectId}'
  serveu = getAPIService(API.SERVICEUSAGE, httpObj)
  status = True
  if checkEnabled:
    try:
      services = callGAPIpages(serveu.services(), 'list', 'services',
                               throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                               parent=projectName, filter='state:ENABLED',
                               fields='nextPageToken,services(name)')
      Act.Set(Act.CHECK)
      jcount = len(services)
      entityPerformActionNumItems([Ent.PROJECT, projectId], jcount, Ent.API, i, count)
      Ind.Increment()
      j = 0
      for service in sorted(services, key=lambda k: k['name']):
        j += 1
        if 'name' in service:
          serviceName = service['name'].split('/')[-1]
          if serviceName in apis:
            printEntityKVList([Ent.API, serviceName], ['Already enabled'], j, jcount)
            apis.remove(serviceName)
          else:
            printEntityKVList([Ent.API, serviceName], ['Already enabled (non-GAM which is fine)'], j, jcount)
      Ind.Decrement()
    except (GAPI.notFound, GAPI.permissionDenied) as e:
      entityActionFailedWarning([Ent.PROJECT, projectId], str(e), i, count)
      status = False
  jcount = len(apis)
  if status and jcount > 0:
    Act.Set(Act.ENABLE)
    entityPerformActionNumItems([Ent.PROJECT, projectId], jcount, Ent.API, i, count)
    Ind.Increment()
    j = 0
    for api in apis:
      j += 1
      serviceName = f'projects/{projectId}/services/{api}'
      while True:
        try:
          callGAPI(serveu.services(), 'enable',
                   throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                   name=serviceName)
          entityActionPerformed([Ent.API, api], j, jcount)
          break
        except GAPI.failedPrecondition as e:
          entityActionFailedWarning([Ent.API, api], str(e), j, jcount)
          writeStderr(Msg.PLEASE_RESOLVE_ERROR)
          readStdin(Msg.PRESS_ENTER_ONCE_ERROR_RESOLVED)
        except (GAPI.forbidden, GAPI.permissionDenied) as e:
          entityActionFailedWarning([Ent.API, api], str(e), j, jcount)
          status = False
          break
    Ind.Decrement()
  return status

def _grantSARotateRights(iam, projectId, sa_email):
  printEntityMessage([Ent.PROJECT, projectId, Ent.SVCACCT, sa_email], Msg.HAS_RIGHTS_TO_ROTATE_OWN_PRIVATE_KEY)
  body = {'policy': {'bindings': [{'role': 'roles/iam.serviceAccountKeyAdmin',
                                   'members': [f'serviceAccount:{sa_email}']}]}}
  callGAPI(iam.projects().serviceAccounts(), 'setIamPolicy',
           resource=f'projects/{projectId}/serviceAccounts/{sa_email}', body=body)

def _createOauth2serviceJSON(httpObj, projectInfo, svcAcctInfo):
  iam = getAPIService(API.IAM, httpObj)
  try:
    service_account = callGAPI(iam.projects().serviceAccounts(), 'create',
                               throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.ALREADY_EXISTS],
                               name=f'projects/{projectInfo["projectId"]}',
                               body={'accountId': svcAcctInfo['name'],
                                     'serviceAccount': {'displayName': svcAcctInfo['displayName'],
                                                        'description': svcAcctInfo['description']}})
    entityActionPerformed([Ent.PROJECT, projectInfo['projectId'], Ent.SVCACCT, service_account['name'].rsplit('/', 1)[-1]])
  except (GAPI.notFound, GAPI.permissionDenied) as e:
    entityActionFailedWarning([Ent.PROJECT, projectInfo['projectId']], str(e))
    return False
  except GAPI.alreadyExists as e:
    entityActionFailedWarning([Ent.PROJECT, projectInfo['projectId'], Ent.SVCACCT, svcAcctInfo['name']], str(e))
    return False
  GM.Globals[GM.SVCACCT_SCOPES_DEFINED] = False
  if not doProcessSvcAcctKeys(mode='retainexisting', iam=iam, projectId=service_account['projectId'],
                              clientEmail=service_account['email'], clientId=service_account['uniqueId']):
    return False
  _grantSARotateRights(iam, projectInfo['projectId'], service_account['name'].rsplit('/', 1)[-1])
  return True

def setGAMProjectConsentScreen(httpObj, projectId, appInfo):
  print('Setting GAM project consent screen...')
  iap = getAPIService(API.IAP, httpObj)
  try:
    callGAPI(iap.projects().brands(), 'create',
             throwReasons=[GAPI.ALREADY_EXISTS, GAPI.INVALID_ARGUMENT],
             parent=f'projects/{projectId}', body=appInfo)
  except GAPI.invalidArgument as e:
    entityActionFailedWarning([Ent.PROJECT, projectId, Ent.APP_NAME, appInfo['applicationTitle'], Ent.EMAIL, appInfo['supportEmail']], str(e))
    return False
  except GAPI.alreadyExists:
    pass
  return True

def _createClientSecretsOauth2service(httpObj, login_hint, appInfo, projectInfo, svcAcctInfo):

  def _checkClientAndSecret(csHttpObj, client_id, client_secret):
    post_data = {'client_id': client_id, 'client_secret': client_secret,
                 'code': 'ThisIsAnInvalidCodeOnlyBeingUsedToTestIfClientAndSecretAreValid',
                 'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob', 'grant_type': 'authorization_code'}
    _, content = csHttpObj.request('https://oauth2.googleapis.com/token', 'POST', urlencode(post_data),
                                   headers={'Content-type': 'application/x-www-form-urlencoded'})
    try:
      content = json.loads(content)
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
      sys.stderr.write(f'{str(e)}: {content}')
      return False
    if not 'error' in content or not 'error_description' in content:
      sys.stderr.write(f'Unknown error: {content}\n')
      return False
    if content['error'] == 'invalid_grant':
      return True
    if content['error_description'] == 'The OAuth client was not found.':
      sys.stderr.write(f'\n\n{client_id}\n\nIs not a valid client ID. '\
                         'Please make sure you are following the directions exactly and that there are no extra spaces in your client ID.\n')
      return False
    if content['error_description'] == 'Unauthorized':
      sys.stderr.write(f'\n\n{client_secret}\n\nIs not a valid client secret. '\
                         'Please make sure you are following the directions exactly and that there are no extra spaces in your client secret.\n')
      return False
    sys.stderr.write(f'Unknown error: {content}\n')
    return False

  if not enableGAMProjectAPIs(httpObj, projectInfo['projectId'], False):
    return
  if appInfo and not setGAMProjectConsentScreen(httpObj, projectInfo['projectId'], appInfo):
    return
  if not _createOauth2serviceJSON(httpObj, projectInfo, svcAcctInfo):
    return
  console_url = f'https://console.cloud.google.com/apis/credentials/oauthclient?project={projectInfo["projectId"]}'
  csHttpObj = getHttpObj()
  while True:
    sys.stdout.write(f'''Please go to:

{console_url}

1. Choose "Desktop App" or "Other" for "Application type".
2. Enter "GAM" or another desired value for "Name".
3. Click the blue "Create" button.
4. Copy your "client ID" value that shows on the next page.

''')
    client_id = readStdin('Enter your Client ID: ').strip()
    if not client_id:
      client_id = readStdin('').strip()
    sys.stdout.write('\n5. Go back to your browser and copy your "client secret" value.\n')
    client_secret = readStdin('Enter your Client Secret: ').strip()
    if not client_secret:
      client_secret = readStdin('').strip()
    client_valid = _checkClientAndSecret(csHttpObj, client_id, client_secret)
    if client_valid:
      break
    sys.stdout.write('\n')
  cs_data = f'''{{
    "installed": {{
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "auth_uri": "https://accounts.google.com/o/oauth2/v2/auth",
        "client_id": "{client_id}",
        "client_secret": "{client_secret}",
        "created_by": "{login_hint}",
        "project_id": "{projectInfo['projectId']}",
        "redirect_uris": ["http://localhost", "urn:ietf:wg:oauth:2.0:oob"],
        "token_uri": "https://oauth2.googleapis.com/token"
    }}
}}'''
  writeFile(GC.Values[GC.CLIENT_SECRETS_JSON], cs_data, continueOnError=False)
  sys.stdout.write('6. Go back to your browser and click OK to close the "OAuth client" popup if it\'s still open.\n')
  sys.stdout.write('That\'s it! Your GAM Project is created and ready to use.\n')

def _getProjects(crm, pfilter):
  try:
    return callGAPIpages(crm.projects(), 'list', 'projects',
                         throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_ARGUMENT],
                         filter=pfilter)
  except (GAPI.badRequest, GAPI.invalidArgument) as e:
    entityActionFailedExit([Ent.PROJECT, pfilter], str(e))

def convertGCPFolderNameToID(parent, crm2):
  # crm2.folders() is broken requiring pageToken, etc in body, not URL.
  # for now just use callGAPI and if user has that many folders they'll
  # just need to be specific.
  folders = callGAPIitems(crm2.folders(), 'search', items='folders',
                          body={'pageSize': 1000, 'query': f'displayName="{parent}"'})
  if not folders:
    entityActionFailedExit([Ent.PROJECT_FOLDER, parent], Msg.NOT_FOUND)
  jcount = len(folders)
  if jcount > 1:
    entityActionNotPerformedWarning([Ent.PROJECT_FOLDER, parent],
                                    Msg.PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Ent.Plural(Ent.PROJECT_FOLDER), 'use in create', 'parent <String>'))
    Ind.Increment()
    j = 0
    for folder in folders:
      printKeyValueListWithCount(['Name', folder['name'], 'ID', folder['displayName']], j, jcount)
    Ind.Decrement()
    systemErrorExit(MULTIPLE_PROJECT_FOLDERS_FOUND_RC, None)
  return folders['folders'][0]['name']

PROJECTID_PATTERN = re.compile(r'^[a-z][a-z0-9-]{4,28}[a-z0-9]$')
PROJECTID_FORMAT_REQUIRED = '[a-z][a-z0-9-]{4,28}[a-z0-9]'
def _checkProjectId(projectId):
  if not PROJECTID_PATTERN.match(projectId):
    Cmd.Backup()
    invalidArgumentExit(PROJECTID_FORMAT_REQUIRED)

PROJECTNAME_PATTERN = re.compile('^[a-zA-Z0-9 '+"'"+'"!-]{4,30}$')
PROJECTNAME_FORMAT_REQUIRED = '[a-zA-Z0-9 \'"!-]{4,30}'
def _checkProjectName(projectName):
  if not PROJECTNAME_PATTERN.match(projectName):
    Cmd.Backup()
    invalidArgumentExit(PROJECTNAME_FORMAT_REQUIRED)

def _getSvcAcctInfo(myarg, svcAcctInfo):
  if myarg == 'saname':
    svcAcctInfo['name'] = getString(Cmd.OB_STRING, minLen=6, maxLen=30)
    _checkProjectId(svcAcctInfo['name'])
  elif myarg == 'sadisplayname':
    svcAcctInfo['displayName'] = getString(Cmd.OB_STRING, maxLen=100)
  elif myarg == 'sadescription':
    svcAcctInfo['description'] = getString(Cmd.OB_STRING, maxLen=256)
  else:
    return False
  return True

def _getAppInfo(myarg, appInfo):
  if myarg == 'appname':
    appInfo['applicationTitle'] = getString(Cmd.OB_STRING)
  elif myarg == 'supportemail':
    appInfo['supportEmail'] = getEmailAddress(noUid=True)
  else:
    return False
  return True

def _generateProjectSvcAcctId(prefix):
  psaId = prefix
  for _ in range(3):
    psaId += f'-{"".join(random.choice(LOWERNUMERIC_CHARS) for _ in range(3))}'
  return psaId

def _getLoginHintProjectInfo(createCmd):
  login_hint = None
  appInfo = {'applicationTitle': 'GAM', 'supportEmail': ''}
  projectInfo = {'projectId': '', 'parent': '', 'name': 'GAM Project'}
  svcAcctInfo = {'name': '', 'displayName': '', 'description': ''}
  if not Cmd.PeekArgumentPresent(['admin', 'appname', 'supportemail', 'project', 'parent', 'projectname', 'saname', 'sadisplayname', 'sadescription']):
    login_hint = getString(Cmd.OB_EMAIL_ADDRESS, optional=True)
    if login_hint and login_hint.find('@') == -1:
      Cmd.Backup()
      login_hint = None
    projectInfo['projectId'] = getString(Cmd.OB_STRING, optional=True, minLen=6, maxLen=30).strip()
    if projectInfo['projectId']:
      _checkProjectId(projectInfo['projectId'])
    checkForExtraneousArguments()
  else:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'admin':
        login_hint = getEmailAddress(noUid=True)
      elif myarg == 'project':
        projectInfo['projectId'] = getString(Cmd.OB_STRING, minLen=6, maxLen=30)
        _checkProjectId(projectInfo['projectId'])
      elif createCmd and myarg == 'parent':
        projectInfo['parent'] = getString(Cmd.OB_STRING)
      elif myarg == 'projectname':
        projectInfo['name'] = getString(Cmd.OB_STRING, minLen=4, maxLen=30)
        _checkProjectName(projectInfo['name'])
      elif _getSvcAcctInfo(myarg, svcAcctInfo):
        pass
      elif createCmd and _getAppInfo(myarg, appInfo):
        pass
      else:
        unknownArgumentExit()
  if not projectInfo['projectId']:
    if createCmd:
      projectInfo['projectId'] = _generateProjectSvcAcctId('gam-project')
    else:
      projectInfo['projectId'] = readStdin('\nWhat is your API project ID? ').strip()
      if not PROJECTID_PATTERN.match(projectInfo['projectId']):
        systemErrorExit(USAGE_ERROR_RC, f'{Cmd.ARGUMENT_ERROR_NAMES[Cmd.ARGUMENT_INVALID][1]} {Cmd.OB_PROJECT_ID}: {Msg.EXPECTED} <{PROJECTID_FORMAT_REQUIRED}>')
  if not svcAcctInfo['name']:
    svcAcctInfo['name'] = projectInfo['projectId']
  if not svcAcctInfo['displayName']:
    svcAcctInfo['displayName'] = projectInfo['name']
  if not svcAcctInfo['description']:
    svcAcctInfo['description'] = svcAcctInfo['displayName']
  login_hint = _getValidateLoginHint(login_hint, projectInfo['projectId'])
  if not appInfo['supportEmail']:
    appInfo['supportEmail'] = login_hint
  httpObj, crm = getCRMService(login_hint)
  if projectInfo['parent'] and not projectInfo['parent'].startswith('organizations/') and not projectInfo['parent'].startswith('folders/'):
    crm2 = getAPIService(API.CLOUDRESOURCEMANAGER_V2, httpObj)
    projectInfo['parent'] = convertGCPFolderNameToID(projectInfo['parent'], crm2)
  if projectInfo['parent']:
    parent_type, parent_id = projectInfo['parent'].split('/')
    if parent_type[-1] == 's':
      parent_type = parent_type[:-1] # folders > folder, organizations > organization
    projectInfo['parent'] = {'type': parent_type, 'id': parent_id}
  projects = _getProjects(crm, f'id:{projectInfo["projectId"]}')
  if not createCmd:
    if not projects:
      entityActionFailedExit([Ent.USER, login_hint, Ent.PROJECT, projectInfo['projectId']], Msg.DOES_NOT_EXIST)
    if projects[0]['lifecycleState'] != 'ACTIVE':
      entityActionFailedExit([Ent.USER, login_hint, Ent.PROJECT, projectInfo['projectId']], Msg.NOT_ACTIVE)
  else:
    if projects:
      entityActionFailedExit([Ent.USER, login_hint, Ent.PROJECT, projectInfo['projectId']], Msg.DUPLICATE)
  return (crm, httpObj, login_hint, appInfo, projectInfo, svcAcctInfo)

def _getCurrentProjectId():
  cs_data = readFile(GC.Values[GC.CLIENT_SECRETS_JSON], continueOnError=True, displayError=True)
  if not cs_data:
    invalidClientSecretsJsonExit()
  try:
    return json.loads(cs_data)['installed']['project_id']
  except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
    invalidClientSecretsJsonExit()

GAM_PROJECT_FILTER = 'id:gam-project-*'
PROJECTID_FILTER_REQUIRED = 'current|gam|<ProjectID>|(filter <String>)'
PROJECTS_CREATESVCACCT_OPTIONS = {'saname', 'sadisplayname', 'sadescription'}
PROJECTS_DELETESVCACCT_OPTIONS = {'saemail', 'saname', 'sauniqueid'}
PROJECTS_PRINTSHOW_OPTIONS = {'showsakeys', 'showiampolicies', 'onememberperrow', 'states', 'todrive', 'delimiter', 'formatjson', 'quotechar'}

def _getLoginHintProjects(createSvcAcctCmd=False, deleteSvcAcctCmd=False, printShowCmd=False, readOnly=False):
  if checkArgumentPresent(['admin']):
    login_hint = getString(Cmd.OB_EMAIL_ADDRESS)
  else:
    login_hint = getString(Cmd.OB_EMAIL_ADDRESS, optional=True)
  if login_hint and login_hint.find('@') == -1:
    Cmd.Backup()
    login_hint = None
  pfilter = getString(Cmd.OB_STRING, optional=True)
  if not pfilter:
    pfilter = 'current' if not printShowCmd else GAM_PROJECT_FILTER
  elif printShowCmd and pfilter in PROJECTS_PRINTSHOW_OPTIONS:
    pfilter = GAM_PROJECT_FILTER
    Cmd.Backup()
  elif createSvcAcctCmd and pfilter in PROJECTS_CREATESVCACCT_OPTIONS:
    pfilter = 'current'
    Cmd.Backup()
  elif deleteSvcAcctCmd and pfilter in PROJECTS_DELETESVCACCT_OPTIONS:
    pfilter = 'current'
    Cmd.Backup()
  elif printShowCmd and pfilter.lower() == 'all':
    pfilter = None
  elif pfilter.lower() == 'current':
    pfilter = 'current'
  elif pfilter.lower() == 'gam':
    pfilter = GAM_PROJECT_FILTER
  elif pfilter.lower() == 'filter':
    pfilter = getString(Cmd.OB_STRING)
  elif PROJECTID_PATTERN.match(pfilter):
    pfilter = f'id:{pfilter}'
  else:
    Cmd.Backup()
    invalidArgumentExit(['', 'all|'][printShowCmd]+PROJECTID_FILTER_REQUIRED)
  if not printShowCmd and not createSvcAcctCmd and not deleteSvcAcctCmd:
    checkForExtraneousArguments()
  if pfilter in {'current', 'id:current'}:
    projectId = _getCurrentProjectId()
  else:
    projectId = f'filter {pfilter or "all"}'
  login_hint = _getValidateLoginHint(login_hint, projectId)
  crm = None
  if readOnly:
    _getSvcAcctData()
    if GM.Globals[GM.SVCACCT_SCOPES_DEFINED] and API.CLOUDRESOURCEMANAGER_V1 in GM.Globals[GM.SVCACCT_SCOPES]:
      _, crm = buildGAPIServiceObject(API.CLOUDRESOURCEMANAGER_V1, login_hint)
      if crm:
        httpObj = crm._http
  if not crm:
    httpObj, crm = getCRMService(login_hint)
  if pfilter in {'current', 'id:current'}:
    if not printShowCmd:
      projects = [{'projectId': projectId}]
    else:
      projects = _getProjects(crm, f'id:{projectId}')
  else:
    projects = _getProjects(crm, pfilter)
  return (crm, httpObj, login_hint, projects)

def _checkForExistingProjectFiles(projectFiles):
  for a_file in projectFiles:
    if os.path.exists(a_file):
      systemErrorExit(JSON_ALREADY_EXISTS_RC, Msg.AUTHORIZATION_FILE_ALREADY_EXISTS.format(a_file, Act.ToPerform()))

# gam create project [<EmailAddress>] [<ProjectID>]
# gam create project [admin <EmailAddress>] [project <ProjectID>]
#	[appname <String>] [supportemail <EmailAddress>]
#	[projectname <ProjectName>] [parent <String>]
#	[saname <ServiceAccountName>] [sadisplayname <ServiceAccountDisplayName>>] [sadescription <ServiceAccountDescription>]
def doCreateProject():
  _checkForExistingProjectFiles([GC.Values[GC.OAUTH2SERVICE_JSON], GC.Values[GC.CLIENT_SECRETS_JSON]])
  crm, httpObj, login_hint, appInfo, projectInfo, svcAcctInfo = _getLoginHintProjectInfo(True)
  login_domain = getEmailAddressDomain(login_hint)
  body = {'projectId': projectInfo['projectId'], 'name': projectInfo['name']}
  if projectInfo['parent']:
    body['parent'] = projectInfo['parent']
  while True:
    create_again = False
    sys.stdout.write(f'Creating project "{body["name"]}"...\n')
    try:
      create_operation = callGAPI(crm.projects(), 'create',
                                  throwReasons=[GAPI.BAD_REQUEST, GAPI.ALREADY_EXISTS],
                                  body=body)
    except (GAPI.badRequest, GAPI.alreadyExists) as e:
      entityActionFailedExit([Ent.USER, login_hint, Ent.PROJECT, projectInfo['projectId']], str(e))
    operation_name = create_operation['name']
    time.sleep(5) # Google recommends always waiting at least 5 seconds
    for i in range(1, 5):
      sys.stdout.write('Checking project status...\n')
      status = callGAPI(crm.operations(), 'get',
                        name=operation_name)
      if 'error' in status:
        if status['error'].get('message', '') == 'No permission to create project in organization':
          sys.stdout.write('Hmm... Looks like you have no rights to your Google Cloud Organization.\nAttempting to fix that...\n')
          getorg = callGAPI(crm.organizations(), 'search',
                            body={'filter': f'domain:{login_domain}'})
          try:
            organization = getorg['organizations'][0]['name']
            sys.stdout.write(f'Your organization name is {organization}\n')
          except (KeyError, IndexError):
            systemErrorExit(3, 'You have no rights to create projects for your organization and you don\'t seem to be a super admin! Sorry, there\'s nothing more I can do.')
          org_policy = callGAPI(crm.organizations(), 'getIamPolicy',
                                resource=organization)
          if 'bindings' not in org_policy:
            org_policy['bindings'] = []
            sys.stdout.write('Looks like no one has rights to your Google Cloud Organization. Attempting to give you create rights...\n')
          else:
            sys.stdout.write('The following rights seem to exist:\n')
            for a_policy in org_policy['bindings']:
              if 'role' in a_policy:
                sys.stdout.write(f'  Role: {a_policy["role"]}\n')
              if 'members' in a_policy:
                sys.stdout.write('  Members:\n')
                for member in a_policy['members']:
                  sys.stdout.write(f'    {member}\n')
          my_role = 'roles/resourcemanager.projectCreator'
          sys.stdout.write(f'Giving {login_hint} the role of {my_role}...\n')
          org_policy['bindings'].append({'role': my_role, 'members': [f'user:{login_hint}']})
          callGAPI(crm.organizations(), 'setIamPolicy',
                   resource=organization, body={'policy': org_policy})
          create_again = True
          break
        try:
          if status['error']['details'][0]['violations'][0]['description'] == 'Callers must accept Terms of Service':
            readStdin('''Please go to:

https://console.cloud.google.com/start

and accept the Terms of Service (ToS). As soon as you've accepted the ToS popup, you can return here and press enter.\n''')
            create_again = True
            break
        except (IndexError, KeyError):
          pass
        systemErrorExit(1, str(status)+'\n')
      if status.get('done', False):
        break
      sleep_time = i ** 2
      sys.stdout.write(Msg.PROJECT_STILL_BEING_CREATED_SLEEPING.format(sleep_time))
      time.sleep(sleep_time)
    if create_again:
      continue
    if not status.get('done', False):
      systemErrorExit(1, f'Failed to create project: {status}\n')
    elif 'error' in status:
      systemErrorExit(2, status['error']+'\n')
    break
  _createClientSecretsOauth2service(httpObj, login_hint, appInfo, projectInfo, svcAcctInfo)

# gam use project [<EmailAddress>] [<ProjectID>]
# gam use project [admin <EmailAddress>] [project <ProjectID>]
#	[saname <ServiceAccountName>] [sadisplayname <ServiceAccountDisplayName>>] [sadescription <ServiceAccountDescription>]
def doUseProject():
  _checkForExistingProjectFiles([GC.Values[GC.OAUTH2SERVICE_JSON], GC.Values[GC.CLIENT_SECRETS_JSON]])
  _, httpObj, login_hint, _, projectInfo, svcAcctInfo = _getLoginHintProjectInfo(False)
  _createClientSecretsOauth2service(httpObj, login_hint, {}, projectInfo, svcAcctInfo)

# gam update project [[admin] <EmailAddress>] [current|gam|<ProjectID>|(filter <String>)]
def doUpdateProject():
  _, httpObj, login_hint, projects = _getLoginHintProjects()
  count = len(projects)
  entityPerformActionNumItems([Ent.USER, login_hint], count, Ent.PROJECT)
  Ind.Increment()
  i = 0
  for project in projects:
    i += 1
    projectId = project['projectId']
    Act.Set(Act.UPDATE)
    if not enableGAMProjectAPIs(httpObj, projectId, True, i, count):
      continue
    iam = getAPIService(API.IAM, httpObj)
    _getSvcAcctData() # needed to read in GM.OAUTH2SERVICE_JSON_DATA
    _grantSARotateRights(iam, projectId, GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email'])
  Ind.Decrement()

# gam delete project [[admin] <EmailAddress>] [current|gam|<ProjectID>|(filter <String>)]
def doDeleteProject():
  crm, _, login_hint, projects = _getLoginHintProjects()
  count = len(projects)
  entityPerformActionNumItems([Ent.USER, login_hint], count, Ent.PROJECT)
  Ind.Increment()
  i = 0
  for project in projects:
    i += 1
    projectId = project['projectId']
    try:
      callGAPI(crm.projects(), 'delete',
               throwReasons=[GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
               projectId=projectId)
      entityActionPerformed([Ent.PROJECT, projectId])
    except (GAPI.forbidden, GAPI.permissionDenied) as e:
      entityActionFailedWarning([Ent.PROJECT, projectId], str(e))
  Ind.Decrement()

PROJECT_TIMEOBJECTS = ['createTime']
PROJECT_STATE_CHOICE_MAP = {
  'all': {'ACTIVE', 'DELETE_REQUESTED'},
  'active': {'ACTIVE'},
  'deleterequested': {'DELETE_REQUESTED'}
  }

# gam print projects [[admin] <EmailAddress>] [all|current|gam|<ProjectID>|(filter <String>)] [todrive <ToDriveAttribute>*]
#	[states all|active|deleterequested] [showiampolicies 0|1|3 [onememberperrow]]
#	[delimiter <Character>] [formatjson [quotechar <Character>]]
# gam show projects [[admin] <EmailAddress>] [all|current|gam|<ProjectID>|(filter <String>)]
#	[states all|active|deleterequested] [showiampolicies 0|1|3]
def doPrintShowProjects():
  def _getProjectPolicies(crm, projectId, policyBody, i, count):
    try:
      policy = callGAPI(crm.projects(), 'getIamPolicy',
                        throwReasons=[GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                        resource=projectId, body=policyBody)
      return policy
    except (GAPI.forbidden, GAPI.permissionDenied) as e:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.IAM_POLICY], str(e), i, count)
    return {}

  crm, _, login_hint, projects = _getLoginHintProjects(printShowCmd=True, readOnly=True)
  csvPF = CSVPrintFile(['User', 'projectId']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  oneMemberPerRow = False
  showIAMPolicies = -1
  lifecycleStates = PROJECT_STATE_CHOICE_MAP['active']
  policy = None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif csvPF and myarg == 'onememberperrow':
      oneMemberPerRow = True
    elif myarg == 'states':
      lifecycleStates = getChoice(PROJECT_STATE_CHOICE_MAP, mapChoice=True)
    elif myarg == 'showiampolicies':
      showIAMPolicies = int(getChoice(['0', '1', '3']))
      policyBody = {'options': {"requestedPolicyVersion": showIAMPolicies}}
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if not csvPF:
    count = len(projects)
    entityPerformActionNumItems([Ent.USER, login_hint], count, Ent.PROJECT)
    Ind.Increment()
    i = 0
    for project in projects:
      i += 1
      if project['lifecycleState'] not in lifecycleStates:
        continue
      projectId = project['projectId']
      if showIAMPolicies >= 0:
        policy = _getProjectPolicies(crm, projectId, policyBody, i, count)
      printEntity([Ent.PROJECT, projectId], i, count)
      Ind.Increment()
      printKeyValueList(['projectNumber', project['projectNumber']])
      printKeyValueList(['name', project['name']])
      printKeyValueList(['createTime', formatLocalTime(project['createTime'])])
      printKeyValueList(['lifecycleState', project['lifecycleState']])
      jcount = len(project.get('labels', []))
      if jcount > 0:
        printKeyValueList(['labels', jcount])
        Ind.Increment()
        for k, v in iter(project['labels'].items()):
          printKeyValueList([k, v])
        Ind.Decrement()
      if 'parent' in project:
        printKeyValueList(['parent', ''])
        Ind.Increment()
        printKeyValueList(['type', project['parent']['type']])
        printKeyValueList(['id', project['parent']['id']])
        Ind.Decrement()
      if policy:
        printKeyValueList([Ent.Singular(Ent.IAM_POLICY), ''])
        Ind.Increment()
        bindings = policy.get('bindings', [])
        jcount = len(bindings)
        printKeyValueList(['version', policy['version']])
        printKeyValueList(['bindings', jcount])
        Ind.Increment()
        j = 0
        for binding in bindings:
          j += 1
          printKeyValueListWithCount(['role', binding['role']], j, jcount)
          Ind.Increment()
          for member in binding.get('members', []):
            printKeyValueList(['member', member])
          if 'condition' in binding:
            printKeyValueList(['condition', ''])
            Ind.Increment()
            for k, v in iter(binding['condition'].items()):
              printKeyValueList([k, v])
            Ind.Decrement()
          Ind.Decrement()
        Ind.Decrement()
        Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  else:
    if not FJQC.formatJSON:
      csvPF.AddTitles(['projectId', 'projectNumber', 'name', 'createTime', 'lifecycleState'])
      csvPF.SetSortAllTitles()
    count = len(projects)
    i = 0
    for project in projects:
      i += 1
      if project['lifecycleState'] not in lifecycleStates:
        continue
      projectId = project['projectId']
      if showIAMPolicies >= 0:
        policy = _getProjectPolicies(crm, projectId, policyBody, i, count)
      if FJQC.formatJSON:
        if policy is not None:
          project['policy'] = policy
        row = flattenJSON(project, flattened={'User': login_hint}, timeObjects=PROJECT_TIMEOBJECTS)
        if not csvPF.rowFilter or csvPF.CheckRowTitles(row):
          csvPF.WriteRowNoFilter({'User': login_hint, 'projectId': projectId,
                                  'JSON': json.dumps(cleanJSON(project),
                                                     ensure_ascii=False, sort_keys=True)})
        continue
      row = flattenJSON(project, flattened={'User': login_hint}, timeObjects=PROJECT_TIMEOBJECTS)
      if not policy:
        csvPF.WriteRowTitles(row)
        continue
      row['policy.version'] = policy['version']
      for binding in policy.get('bindings', []):
        prow = row.copy()
        prow['policy.role'] = binding['role']
        if 'condition' in binding:
          for k, v in iter(binding['condition'].items()):
            prow[f'policy.condition.{k}'] = v
        members = binding.get('members', [])
        if not oneMemberPerRow:
          prow['policy.members'] = delimiter.join(members)
          csvPF.WriteRowTitles(prow)
        else:
          for member in members:
            mrow = prow.copy()
            mrow['policy.member'] = member
            csvPF.WriteRowTitles(mrow)
    csvPF.writeCSVfile('Projects')

# gam create|add svcacct [[admin] <EmailAddress>] [current|gam|<ProjectID>|(filter <String>)]
#	[saname <ServiceAccountName>] [sadisplayname <ServiceAccountDisplayName>>] [sadescription <ServiceAccountDescription>]
def doCreateSvcAcct():
  _checkForExistingProjectFiles([GC.Values[GC.OAUTH2SERVICE_JSON]])
  _, httpObj, login_hint, projects = _getLoginHintProjects(createSvcAcctCmd=True)
  svcAcctInfo = {'name': '', 'displayName': '', 'description': ''}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getSvcAcctInfo(myarg, svcAcctInfo):
      pass
    else:
      unknownArgumentExit()
  if not svcAcctInfo['name']:
    svcAcctInfo['name'] = _generateProjectSvcAcctId('gam-svcacct')
  if not svcAcctInfo['displayName']:
    svcAcctInfo['displayName'] = svcAcctInfo['name']
  if not svcAcctInfo['description']:
    svcAcctInfo['description'] = svcAcctInfo['displayName']
  count = len(projects)
  entityPerformActionSubItemModifierNumItems([Ent.USER, login_hint], Ent.SVCACCT, Act.MODIFIER_TO, count, Ent.PROJECT)
  Ind.Increment()
  i = 0
  for project in projects:
    i += 1
    projectInfo = {'projectId': project['projectId']}
    _createOauth2serviceJSON(httpObj, projectInfo, svcAcctInfo)
  Ind.Decrement()

# gam delete svcacct [[admin] <EmailAddress>] [current|gam|<ProjectID>|(filter <String>)]
#	(saemail <ServiceAccountEmail>)|(saname <ServiceAccountName>)|(sauniqueid <ServiceAccountUniqueID>)
def doDeleteSvcAcct():
  _, httpObj, login_hint, projects = _getLoginHintProjects(deleteSvcAcctCmd=True)
  iam = getAPIService(API.IAM, httpObj)
  clientEmail = clientId = clientName = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'saemail':
      clientEmail = getEmailAddress(noUid=True)
      clientName = clientId = None
    elif myarg == 'saname':
      clientName = getString(Cmd.OB_STRING, minLen=6, maxLen=30).strip()
      _checkProjectId(clientName)
      clientEmail = clientId = None
    elif myarg == 'sauniqueid':
      clientId = getInteger(minVal=0)
      clientEmail = clientName = None
    else:
      unknownArgumentExit()
  if not clientEmail and not clientId and not clientName:
    missingArgumentExit('email|name|uniqueid')
  count = len(projects)
  entityPerformActionSubItemModifierNumItems([Ent.USER, login_hint], Ent.SVCACCT, Act.MODIFIER_FROM, count, Ent.PROJECT)
  Ind.Increment()
  i = 0
  for project in projects:
    i += 1
    projectId = project['projectId']
    try:
      if clientEmail:
        saName = clientEmail
      elif clientName:
        saName = f'{clientName}@{projectId}.iam.gserviceaccount.com'
      else: #clientId
        saName = clientId
      callGAPI(iam.projects().serviceAccounts(), 'delete',
               throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST],
               name=f'projects/{projectId}/serviceAccounts/{saName}')
      entityActionPerformed([Ent.PROJECT, projectId, Ent.SVCACCT, saName], i, count)
    except (GAPI.notFound, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, saName], str(e), i, count)
    Ind.Decrement()

# gam <UserTypeEntity> check serviceaccount (scope|scopes <APIScopeURLList>)* [writeurltofile]
# gam <UserTypeEntity> update serviceaccount [writeurltofile]
def checkServiceAccount(users):
  def printMessage(message):
    writeStdout(Ind.Spaces()+message+'\n')

  def printPassFail(description, result):
    writeStdout(Ind.Spaces()+f'{description:73} {result}'+'\n')

  def authorizeScopes(message):
    long_url = ('https://admin.google.com/ac/owl/domainwidedelegation'
                f'?clientScopeToAdd={",".join(checkScopes)}'
                f'&clientIdToAdd={service_account}&overwriteClientId=true')
    if not writeURLtoFile:
      printLine(message.format('', long_url))
    else:
      filename = os.path.join(GM.Globals[GM.GAM_PATH], FN_GAM_SVCACCT_URL_TXT)
      printLine(message.format(Msg.THE_LINK_MAY_BE_COPIED_FROM_THE_FILE_RATHER_THAN_THE_SCREEN.format(filename), long_url))
      writeFile(filename, long_url, mode='w', continueOnError=True, displayError=True)
      readStdin(Msg.PRESS_ENTER_ONCE_AUTHORIZATION_IS_COMPLETE)
      deleteFile(filename, continueOnError=True, displayError=True)

  credentials = getSvcAcctCredentials([API.USERINFO_EMAIL_SCOPE], None)
  checkScopesSet = set()
  writeURLtoFile = False
  if Act.Get() == Act.CHECK:
    allScopes = API.getSvcAcctScopes(GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY], False)
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in {'scope', 'scopes'}:
        for scope in getString(Cmd.OB_API_SCOPE_URL_LIST).lower().replace(',', ' ').split():
          api = API.getSvcAcctScopeAPI(scope)
          if api is not None:
            checkScopesSet.add(scope)
          else:
            invalidChoiceExit(scope, allScopes, True)
      elif myarg == 'writeurltofile':
        writeURLtoFile = True
      else:
        unknownArgumentExit()
    if not checkScopesSet:
      for scope in iter(GM.Globals[GM.SVCACCT_SCOPES].values()):
        checkScopesSet.update(scope)
  else:
    writeURLtoFile = checkArgumentPresent('writeurltofile')
    checkForExtraneousArguments()
    saScopes = {}
    scopesList = API.getSvcAcctScopesList(GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY], True)
    selectedScopes = getScopesFromUser(scopesList, False, GM.Globals[GM.SVCACCT_SCOPES])
    if selectedScopes is None:
      return False
    i = 0
    for scope in scopesList:
      if selectedScopes[i] == '*':
        saScopes.setdefault(scope['api'], [])
        saScopes[scope['api']].append(scope['scope'])
        checkScopesSet.add(scope['scope'])
      elif selectedScopes[i] == 'R':
        saScopes.setdefault(scope['api'], [])
        saScopes[scope['api']].append(f'{scope["scope"]}.readonly')
        checkScopesSet.add(f'{scope["scope"]}.readonly')
      i += 1
    if API.DRIVEACTIVITY_V1 in saScopes and API.DRIVE3 in saScopes:
      saScopes[API.DRIVEACTIVITY_V1].append(API.DRIVE_SCOPE)
    if API.DRIVEACTIVITY_V2 in saScopes and API.DRIVE3 in saScopes:
      saScopes[API.DRIVEACTIVITY_V2].append(API.DRIVE_SCOPE)
    if API.DRIVE3 in saScopes:
      saScopes[API.DRIVE2] = saScopes[API.DRIVE3]
    GM.Globals[GM.OAUTH2SERVICE_JSON_DATA][API.OAUTH2SA_SCOPES] = saScopes
    writeFile(GC.Values[GC.OAUTH2SERVICE_JSON],
              json.dumps(GM.Globals[GM.OAUTH2SERVICE_JSON_DATA], ensure_ascii=False, sort_keys=True, indent=2),
              continueOnError=False)
  checkScopes = sorted(checkScopesSet)
  jcount = len(checkScopes)
  printMessage(Msg.SYSTEM_TIME_STATUS)
  offsetSeconds, offsetFormatted = getLocalGoogleTimeOffset()
  if offsetSeconds <= MAX_LOCAL_GOOGLE_TIME_OFFSET:
    timeStatus = 'PASS'
  else:
    timeStatus = 'FAIL'
  Ind.Increment()
  printPassFail(Msg.YOUR_SYSTEM_TIME_DIFFERS_FROM_GOOGLE.format('www.googleapis.com', offsetFormatted), timeStatus)
  Ind.Decrement()
  oa2 = buildGAPIObject(API.OAUTH2)
  printMessage(Msg.SERVICE_ACCOUNT_PRIVATE_KEY_AUTHENTICATION)
  # We are explicitly not doing DwD here, just confirming service account can auth
  auth_error = ''
  try:
    request = transportCreateRequest()
    credentials.refresh(request)
    sa_token_info = callGAPI(oa2, 'tokeninfo', access_token=credentials.token)
    if sa_token_info:
      saTokenStatus = 'PASS'
    else:
      saTokenStatus = 'FAIL'
  except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
    handleServerError(e)
  except google.auth.exceptions.RefreshError as e:
    saTokenStatus = 'FAIL'
    if isinstance(e.args, tuple):
      e = e.args[0]
    auth_error = ' - '+str(e)
  Ind.Increment()
  printPassFail(f'Authentication{auth_error}', saTokenStatus)
  Ind.Decrement()
  if saTokenStatus == 'FAIL':
    invalidOauth2serviceJsonExit()
  printMessage(Msg.SERVICE_ACCOUNT_CHECK_PRIVATE_KEY_AGE)
  _, iam = buildGAPIServiceObject(API.IAM, None)
  currentPrivateKeyId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['private_key_id']
  projectId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['project_id']
  clientId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
  name = f'projects/{projectId}/serviceAccounts/{clientId}/keys/{currentPrivateKeyId}'
  Ind.Increment()
  try:
    key = callGAPI(iam.projects().serviceAccounts().keys(), 'get',
                   throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                   name=name, fields='validAfterTime')
    # Both Google and GAM set key valid after to day before creation
    key_created, _ = iso8601.parse_date(key['validAfterTime'])
    key_age = todaysTime()-(key_created+datetime.timedelta(days=1))
    printPassFail(Msg.SERVICE_ACCOUNT_PRIVATE_KEY_AGE.format(key_age.days), 'WARN' if key_age.days > 30 else 'PASS')
  except GAPI.permissionDenied:
    printMessage(Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
    printPassFail(Msg.SERVICE_ACCOUNT_PRIVATE_KEY_AGE.format('UNKNOWN'), 'WARN')
  except (GAPI.badRequest, GAPI.invalid, GAPI.notFound) as e:
    entityActionFailedWarning([Ent.PROJECT, GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['project_id'],
                               Ent.SVCACCT, GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email']],
                              str(e))
    printPassFail(Msg.SERVICE_ACCOUNT_PRIVATE_KEY_AGE.format('UNKNOWN'), 'WARN')
  Ind.Decrement()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    allScopesPass = True
    user = convertUIDtoEmailAddress(user)
    printKeyValueListWithCount([Msg.DOMAIN_WIDE_DELEGATION_AUTHENTICATION, '',
                                Ent.Singular(Ent.USER), user,
                                Ent.Choose(Ent.SCOPE, jcount), jcount],
                               i, count)
    Ind.Increment()
    j = 0
    for scope in checkScopes:
      j += 1
      # try with and without email scope
      for scopes in [[scope, API.USERINFO_EMAIL_SCOPE], [scope]]:
        try:
          credentials = getSvcAcctCredentials(scopes, user)
          credentials.refresh(request)
          break
        except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
          handleServerError(e)
        except google.auth.exceptions.RefreshError:
          continue
      if credentials.token:
        token_info = callGAPI(oa2, 'tokeninfo', access_token=credentials.token)
        if scope in token_info.get('scope', '').split(' ') and user == token_info.get('email', user).lower():
          scopeStatus = 'PASS'
        else:
          scopeStatus = 'FAIL'
          allScopesPass = False
      else:
        scopeStatus = 'FAIL'
        allScopesPass = False
      printPassFail(scope, f'{scopeStatus}{currentCount(j, jcount)}')
    Ind.Decrement()
    service_account = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
    if allScopesPass:
      if Act.Get() == Act.CHECK:
        printLine(Msg.SCOPE_AUTHORIZATION_PASSED.format(service_account))
      else:
        authorizeScopes(Msg.SCOPE_AUTHORIZATION_UPDATE_PASSED)
    else:
      # Tack on email scope for more accurate checking
      checkScopes.append(API.USERINFO_EMAIL_SCOPE)
      setSysExitRC(SCOPES_NOT_AUTHORIZED_RC)
      authorizeScopes(Msg.SCOPE_AUTHORIZATION_FAILED)
    printBlankLine()

# gam check svcacct <UserTypeEntity> (scope|scopes <APIScopeURLList>)*
# gam update svcacct <UserTypeEntity>
def doCheckUpdateSvcAcct():
  _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USER)
  checkServiceAccount(entityList)

def _getSAKeys(iam, projectId, clientEmail, name, keyTypes):
  try:
    keys = callGAPIitems(iam.projects().serviceAccounts().keys(), 'list', 'keys',
                         throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                         name=name, keyTypes=keyTypes)
    return (True, keys)
  except GAPI.permissionDenied:
    entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
  except GAPI.badRequest as e:
    entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
  return (False, None)

SVCACCT_KEY_TIME_OBJECTS = ['validAfterTime', 'validBeforeTime']

def _showSAKeys(keys, count, currentPrivateKeyId):
  Ind.Increment()
  i = 0
  for key in keys:
    i += 1
    keyName = key.pop('name').rsplit('/', 1)[-1]
    printKeyValueListWithCount(['name', keyName], i, count)
    Ind.Increment()
    for k, v in sorted(iter(key.items())):
      if k not in SVCACCT_KEY_TIME_OBJECTS:
        printKeyValueList([k, v])
      else:
        printKeyValueList([k, formatLocalTime(v)])
    if keyName == currentPrivateKeyId:
      printKeyValueList(['usedToAuthenticateThisRequest', True])
    Ind.Decrement()
  Ind.Decrement()

SVCACCT_DISPLAY_FIELDS = ['displayName', 'description', 'oauth2ClientId', 'uniqueId', 'disabled']
SVCACCT_KEY_TYPE_CHOICE_MAP = {
  'all': None,
  'system': 'SYSTEM_MANAGED',
  'systemmanaged': 'SYSTEM_MANAGED',
  'user': 'USER_MANAGED',
  'usermanaged': 'USER_MANAGED'
  }

# gam print svcaccts [[admin] <EmailAddress>] [all|current|gam|<ProjectID>|(filter <String>)]
#	[showsakeys all|system|user]
#	[todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam show svcaccts [<EmailAddress>] [all|current|gam|<ProjectID>|(filter <String>)]
#	[showsakeys all|system|user]
def doPrintShowSvcAccts():
  _, httpObj, login_hint, projects = _getLoginHintProjects(printShowCmd=True, readOnly=True)
  csvPF = CSVPrintFile(['User', 'projectId']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  iam = getAPIService(API.IAM, httpObj)
  keyTypes = None
  showSAKeys = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'showsakeys':
      keyTypes = getChoice(SVCACCT_KEY_TYPE_CHOICE_MAP, mapChoice=True)
      showSAKeys = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  count = len(projects)
  if not csvPF:
    entityPerformActionSubItemModifierNumItems([Ent.USER, login_hint], Ent.SVCACCT, Act.MODIFIER_FOR, count, Ent.PROJECT)
  else:
    csvPF.AddTitles(['projectId']+SVCACCT_DISPLAY_FIELDS)
    csvPF.SetSortAllTitles()
  Ind.Increment()
  i = 0
  for project in projects:
    i += 1
    projectId = project['projectId']
    if csvPF:
      printGettingAllEntityItemsForWhom(Ent.SVCACCT, projectId, i, count)
    if project['lifecycleState'] != 'ACTIVE':
      entityActionNotPerformedWarning([Ent.PROJECT, projectId], Msg.DELETED, i, count)
      continue
    try:
      svcAccts = callGAPIpages(iam.projects().serviceAccounts(), 'list', 'accounts',
                               throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                               name=f'projects/{projectId}')
      jcount = len(svcAccts)
      if not csvPF:
        entityPerformActionNumItems([Ent.PROJECT, projectId], jcount, Ent.SVCACCT, i, count)
        Ind.Increment()
        j = 0
        for svcAcct in svcAccts:
          j += 1
          printKeyValueListWithCount(['email', svcAcct['email']], j, jcount)
          Ind.Increment()
          for field in SVCACCT_DISPLAY_FIELDS:
            if field in svcAcct:
              printKeyValueList([field, svcAcct[field]])
          if showSAKeys:
            name = f"projects/{projectId}/serviceAccounts/{svcAcct['oauth2ClientId']}"
            status, keys = _getSAKeys(iam, projectId, svcAcct['email'], name, keyTypes)
            if status:
              kcount = len(keys)
              if kcount > 0:
                printKeyValueList([Ent.Choose(Ent.SVCACCT_KEY, kcount), kcount])
                _showSAKeys(keys, kcount, '')
          Ind.Decrement()
        Ind.Decrement()
      else:
        for svcAcct in svcAccts:
          if showSAKeys:
            name = f"projects/{projectId}/serviceAccounts/{svcAcct['oauth2ClientId']}"
            status, keys = _getSAKeys(iam, projectId, svcAcct['email'], name, keyTypes)
            if status:
              svcAcct['keys'] = keys
          row = flattenJSON(svcAcct, flattened={'User': login_hint}, timeObjects=SVCACCT_KEY_TIME_OBJECTS)
          if not FJQC.formatJSON:
            csvPF.WriteRowTitles(row)
          elif not csvPF.rowFilter or csvPF.CheckRowTitles(row):
            csvPF.WriteRowNoFilter({'User': login_hint, 'projectId': projectId,
                                    'JSON': json.dumps(cleanJSON(svcAcct, timeObjects=SVCACCT_KEY_TIME_OBJECTS),
                                                       ensure_ascii=False, sort_keys=True)})
    except (GAPI.notFound, GAPI.permissionDenied) as e:
      entityActionFailedWarning([Ent.PROJECT, projectId], str(e))
  Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Service Accounts')

def _generatePrivateKeyAndPublicCert(projectId, clientEmail, name, key_size):
  printEntityMessage([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.GENERATING_NEW_PRIVATE_KEY)
  private_key = rsa.generate_private_key(public_exponent=65537, key_size=key_size, backend=default_backend())
  private_pem = private_key.private_bytes(encoding=serialization.Encoding.PEM,
                                          format=serialization.PrivateFormat.PKCS8,
                                          encryption_algorithm=serialization.NoEncryption()).decode()
  printEntityMessage([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.EXTRACTING_PUBLIC_CERTIFICATE)
  public_key = private_key.public_key()
  builder = x509.CertificateBuilder()
  builder = builder.subject_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, name)]))
  builder = builder.issuer_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, name)]))
  not_valid_before = datetime.datetime.today() - datetime.timedelta(days=1)
  not_valid_after = datetime.datetime.today() + datetime.timedelta(days=365*10-1)
  builder = builder.not_valid_before(not_valid_before)
  builder = builder.not_valid_after(not_valid_after)
  builder = builder.serial_number(x509.random_serial_number())
  builder = builder.public_key(public_key)
  builder = builder.add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True)
  builder = builder.add_extension(x509.KeyUsage(key_cert_sign=False,
                                                crl_sign=False, digital_signature=True, content_commitment=False,
                                                key_encipherment=False, data_encipherment=False, key_agreement=False,
                                                encipher_only=False, decipher_only=False), critical=True)
  builder = builder.add_extension(x509.ExtendedKeyUsage([x509.oid.ExtendedKeyUsageOID.SERVER_AUTH]), critical=True)
  certificate = builder.sign(private_key=private_key, algorithm=hashes.SHA256(), backend=default_backend())
  public_cert_pem = certificate.public_bytes(serialization.Encoding.PEM).decode()
  publicKeyData = base64.b64encode(public_cert_pem.encode())
  if isinstance(publicKeyData, bytes):
    publicKeyData = publicKeyData.decode()
  printEntityMessage([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.DONE_GENERATING_PRIVATE_KEY_AND_PUBLIC_CERTIFICATE)
  return (private_pem, publicKeyData)

def _formatOAuth2ServiceData(projectId, clientEmail, clientId, private_key, private_key_id):
  quotedEmail = quote(clientEmail)
  GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = {
    'auth_provider_x509_cert_url': 'https://www.googleapis.com/oauth2/v1/certs',
    'auth_uri': 'https://accounts.google.com/o/oauth2/auth',
    'client_email': clientEmail,
    'client_id': clientId,
    'client_x509_cert_url': f'https://www.googleapis.com/robot/v1/metadata/x509/{quotedEmail}',
    'private_key': private_key,
    'private_key_id': private_key_id,
    'project_id': projectId,
    'token_uri': 'https://oauth2.googleapis.com/token',
    'type': 'service_account',
    }
  return json.dumps(GM.Globals[GM.OAUTH2SERVICE_JSON_DATA], indent=2, sort_keys=True)

# gam rotate sakey|sakeys [retain_none|retain_existing|replace_current]
#	[(algorithm KEY_ALG_RSA_1024|KEY_ALG_RSA_2048)|(localkeysize 1024|2048|4096)]
def doProcessSvcAcctKeys(mode=None, iam=None, projectId=None, clientEmail=None, clientId=None):
  local_key_size = 2048
  body = {}
  if iam is None:
    _, iam = buildGAPIServiceObject(API.IAM, None)
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'algorithm':
        body['keyAlgorithm'] = getChoice(["key_alg_rsa_1024", "key_alg_rsa_2048"]).upper()
        local_key_size = 0
      elif myarg == 'localkeysize':
        local_key_size = int(getChoice(['1024', '2048', '4096']))
      elif mode is None and myarg in ['retainnone', 'retainexisting', 'replacecurrent']:
        mode = myarg
      else:
        unknownArgumentExit()
    if mode is None:
      mode = 'retainnone'
    currentPrivateKeyId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['private_key_id']
    projectId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['project_id']
    clientEmail = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email']
    clientId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
  name = f'projects/{projectId}/serviceAccounts/{clientId}'
  if mode != 'retainexisting':
    try:
      keys = callGAPIitems(iam.projects().serviceAccounts().keys(), 'list', 'keys',
                           throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                           name=name, keyTypes='USER_MANAGED')
    except GAPI.permissionDenied:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
      return False
    except GAPI.badRequest as e:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
      return False
  if local_key_size:
    Act.Set(Act.UPLOAD)
    private_key, publicKeyData = _generatePrivateKeyAndPublicCert(projectId, clientEmail, name, local_key_size)
    maxRetries = 10
    printEntityMessage([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPLOADING_NEW_PUBLIC_CERTIFICATE_TO_GOOGLE)
    for i in range(1, maxRetries+1):
      try:
        result = callGAPI(iam.projects().serviceAccounts().keys(), 'upload',
                          throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                          name=name, body={'publicKeyData': publicKeyData})
        break
      except GAPI.notFound as e:
        if i == maxRetries:
          entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
          return False
        sleep_time = i*5
        if i > 3:
          sys.stdout.write(Msg.WAITING_FOR_SERVICE_ACCOUNT_CREATION_TO_COMPLETE_SLEEPING.format(sleep_time))
        time.sleep(sleep_time)
      except GAPI.permissionDenied:
        entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
        return False
      except GAPI.badRequest as e:
        entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
        return False
    private_key_id = result['name'].rsplit('/', 1)[-1]
    oauth2service_data = _formatOAuth2ServiceData(projectId, clientEmail, clientId, private_key, private_key_id)
  else:
    Act.Set(Act.CREATE)
    try:
      result = callGAPI(iam.projects().serviceAccounts().keys(), 'create',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                        name=name, body=body)
    except GAPI.permissionDenied:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
      return False
    except GAPI.badRequest as e:
      entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
      return False
    oauth2service_data = base64.b64decode(result['privateKeyData']).decode(UTF8)
    private_key_id = result['name'].rsplit('/', 1)[-1]
  entityActionPerformed([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail, Ent.SVCACCT_KEY, private_key_id])
  if GM.Globals[GM.SVCACCT_SCOPES_DEFINED]:
    try:
      GM.Globals[GM.OAUTH2SERVICE_JSON_DATA] = json.loads(oauth2service_data)
    except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
      invalidOauth2serviceJsonExit()
    GM.Globals[GM.OAUTH2SERVICE_JSON_DATA][API.OAUTH2SA_SCOPES] = GM.Globals[GM.SVCACCT_SCOPES]
    oauth2service_data = json.dumps(GM.Globals[GM.OAUTH2SERVICE_JSON_DATA], ensure_ascii=False, sort_keys=True, indent=2)
  writeFile(GC.Values[GC.OAUTH2SERVICE_JSON], oauth2service_data, continueOnError=False)
  Act.Set(Act.UPDATE)
  entityActionPerformed([Ent.OAUTH2SERVICE_JSON_FILE, GC.Values[GC.OAUTH2SERVICE_JSON],
                         Ent.SVCACCT_KEY, private_key_id])
  if mode != 'retainexisting':
    Act.Set(Act.REVOKE)
    count = len(keys) if mode == 'retainnone' else 1
    entityPerformActionNumItems([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], count, Ent.SVCACCT_KEY)
    Ind.Increment()
    i = 0
    for key in keys:
      keyName = key['name'].rsplit('/', 1)[-1]
      if mode == 'retainnone' or keyName == currentPrivateKeyId:
        i += 1
        try:
          callGAPI(iam.projects().serviceAccounts().keys(), 'delete',
                   throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                   name=key['name'])
          entityActionPerformed([Ent.SVCACCT_KEY, keyName], i, count)
        except GAPI.permissionDenied:
          entityActionFailedWarning([Ent.SVCACCT_KEY, keyName], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
          break
        except GAPI.badRequest as e:
          entityActionFailedWarning([Ent.SVCACCT_KEY, keyName], str(e), i, count)
        if mode != 'retainnone':
          break
    Ind.Decrement()
  return True

# gam create sakey|sakeys [(algorithm KEY_ALG_RSA_1024|KEY_ALG_RSA_2048)|(localkeysize 1024|2048|4096)]
def doCreateSvcAcctKeys():
  doProcessSvcAcctKeys(mode='retainexisting')

# gam update sakey|sakeys [(algorithm KEY_ALG_RSA_1024|KEY_ALG_RSA_2048)|(localkeysize 1024|2048|4096)]
def doUpdateSvcAcctKeys():
  doProcessSvcAcctKeys(mode='replacecurrent')

# gam replace sakey|sakeys [(algorithm KEY_ALG_RSA_1024|KEY_ALG_RSA_2048)|(localkeysize 1024|2048|4096)]
def doReplaceSvcAcctKeys():
  doProcessSvcAcctKeys(mode='retainnone')

# gam delete sakeys <ServiceAccountKeyList>
def doDeleteSvcAcctKeys():
  _, iam = buildGAPIServiceObject(API.IAM, None)
  doit = False
  keyList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'doit':
      doit = True
    else:
      Cmd.Backup()
      keyList.extend(getString(Cmd.OB_SERVICE_ACCOUNT_KEY_LIST, minLen=0).strip().replace(',', ' ').split())
  currentPrivateKeyId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['private_key_id']
  projectId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['project_id']
  clientEmail = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email']
  clientId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
  name = f'projects/{projectId}/serviceAccounts/{clientId}'
  try:
    keys = callGAPIitems(iam.projects().serviceAccounts().keys(), 'list', 'keys',
                         throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                         name=name, keyTypes='USER_MANAGED')
  except GAPI.permissionDenied:
    entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
    return
  except GAPI.badRequest as e:
    entityActionFailedWarning([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], str(e))
    return
  Act.Set(Act.REVOKE)
  count = len(keyList)
  entityPerformActionNumItems([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], count, Ent.SVCACCT_KEY)
  Ind.Increment()
  i = 0
  for dkeyName in keyList:
    i += 1
    for key in keys:
      keyName = key['name'].rsplit('/', 1)[-1]
      if keyName == dkeyName:
        if keyName == currentPrivateKeyId and not doit:
          entityActionNotPerformedWarning([Ent.SVCACCT_KEY, keyName],
                                          Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION+Msg.ON_CURRENT_PRIVATE_KEY, i, count)
          break
        try:
          callGAPI(iam.projects().serviceAccounts().keys(), 'delete',
                   throwReasons=[GAPI.BAD_REQUEST, GAPI.PERMISSION_DENIED],
                   name=key['name'])
          entityActionPerformed([Ent.SVCACCT_KEY, keyName], i, count)
        except GAPI.permissionDenied:
          entityActionFailedWarning([Ent.SVCACCT_KEY, keyName], Msg.UPDATE_PROJECT_TO_VIEW_MANAGE_SAKEYS)
        except GAPI.badRequest as e:
          entityActionFailedWarning([Ent.SVCACCT_KEY, keyName], str(e), i, count)
        break
    else:
      entityActionNotPerformedWarning([Ent.SVCACCT_KEY, dkeyName], Msg.NOT_FOUND, i, count)
  Ind.Decrement()

# gam show sakeys [all|system|user]
def doShowSvcAcctKeys():
  _, iam = buildGAPIServiceObject(API.IAM, None)
  keyTypes = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in SVCACCT_KEY_TYPE_CHOICE_MAP:
      keyTypes = SVCACCT_KEY_TYPE_CHOICE_MAP[myarg]
    else:
      unknownArgumentExit()
  currentPrivateKeyId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['private_key_id']
  projectId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['project_id']
  clientEmail = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_email']
  clientId = GM.Globals[GM.OAUTH2SERVICE_JSON_DATA]['client_id']
  name = f'projects/{projectId}/serviceAccounts/{clientId}'
  status, keys = _getSAKeys(iam, projectId, clientEmail, name, keyTypes)
  if not status:
    return
  count = len(keys)
  entityPerformActionNumItems([Ent.PROJECT, projectId, Ent.SVCACCT, clientEmail], count, Ent.SVCACCT_KEY)
  if count > 0:
    _showSAKeys(keys, count, currentPrivateKeyId)

# gam whatis <EmailItem> [noinfo]
def doWhatIs():
  def _showPrimaryType(entityType, email):
    printEntity([entityType, email])

  def _showAliasType(entityType, email, primaryEntityType, primaryEmail):
    printEntity([entityType, email, primaryEntityType, primaryEmail])

  cd = buildGAPIObject(API.DIRECTORY)
  email = getEmailAddress()
  showInfo = not checkArgumentPresent('noinfo')
  if not showInfo:
    checkForExtraneousArguments()
  try:
    result = callGAPI(cd.users(), 'get',
                      throwReasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=email, fields='id,primaryEmail')
    if (result['primaryEmail'].lower() == email) or (result['id'] == email):
      if showInfo:
        infoUsers(entityList=[email])
      else:
        _showPrimaryType(Ent.USER, email)
      setSysExitRC(ENTITY_IS_A_USER_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showAliasType(Ent.USER_ALIAS, email, Ent.USER, result['primaryEmail'])
      setSysExitRC(ENTITY_IS_A_USER_ALIAS_RC)
    return
  except (GAPI.userNotFound, GAPI.badRequest):
    pass
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.backendError, GAPI.systemError):
    entityUnknownWarning(Ent.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  try:
    result = callGAPI(cd.groups(), 'get',
                      throwReasons=GAPI.GROUP_GET_THROW_REASONS,
                      groupKey=email, fields='id,email')
    if (result['email'].lower() == email) or (result['id'] == email):
      if showInfo:
        infoGroups([email])
      else:
        _showPrimaryType(Ent.GROUP, email)
      setSysExitRC(ENTITY_IS_A_GROUP_RC)
    else:
      if showInfo:
        infoAliases(entityList=[email])
      else:
        _showAliasType(Ent.GROUP_ALIAS, email, Ent.GROUP, result['email'])
      setSysExitRC(ENTITY_IS_A_GROUP_ALIAS_RC)
    return
  except GAPI.groupNotFound:
    pass
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
    entityUnknownWarning(Ent.EMAIL, email)
    setSysExitRC(ENTITY_IS_UKNOWN_RC)
    return
  entityUnknownWarning(Ent.EMAIL, email)
  setSysExitRC(ENTITY_IS_UKNOWN_RC)

def _adjustTryDate(errMsg, noDateChange):
  match_date = re.match('Data for dates later than (.*) is not yet available. Please check back later', errMsg)
  if not match_date:
    match_date = re.match('Start date can not be later than (.*)', errMsg)
  if (not match_date) or noDateChange:
    printWarningMessage(DATA_NOT_AVALIABLE_RC, errMsg)
    return None
  return match_date.group(1)

def _checkDataRequiredServices(warnings, tryDate, dataRequiredServices, hasReports):
  oneDay = datetime.timedelta(days=1)
  # move to day before if we don't have at least one usageReport
  if not hasReports:
    tryDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)-oneDay
    return (0, tryDateTime.strftime(YYYYMMDD_FORMAT))
  for warning in warnings:
    if warning['code'] == 'PARTIAL_DATA_AVAILABLE':
      for app in warning['data']:
        if app['key'] == 'application' and app['value'] != 'docs' and ('all' in dataRequiredServices or app['value'] in dataRequiredServices):
          tryDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)-oneDay
          return (0, tryDateTime.strftime(YYYYMMDD_FORMAT))
    elif warning['code'] == 'DATA_NOT_AVAILABLE':
      for app in warning['data']:
        if app['key'] == 'application' and app['value'] != 'docs' and ('all' in dataRequiredServices or app['value'] in dataRequiredServices):
          return (-1, tryDate)
  return (1, tryDate)

CUSTOMER_USER_CHOICES = {'customer', 'user'}

# gam report usageparameters customer|user [todrive <ToDriveAttribute>*]
def doReportUsageParameters():
  report = getChoice(CUSTOMER_USER_CHOICES)
  csvPF = CSVPrintFile(['parameter'], 'sortall')
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  rep = buildGAPIObject(API.REPORTS)
  if report == 'customer':
    service = rep.customerUsageReports()
    kwargs = {}
  else: # 'user'
    service = rep.userUsageReport()
    kwargs = {'userKey': _getAdminEmail()}
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  tryDate = todaysDate().strftime(YYYYMMDD_FORMAT)
  allParameters = set()
  dataRequiredServices = {'all'}
  while True:
    try:
      result = callGAPI(service, 'get',
                        throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST],
                        date=tryDate, customerId=customerId, fields='warnings,usageReports(parameters(name))', **kwargs)
      warnings = result.get('warnings', [])
      usage = result.get('usageReports')
      hasReports = bool(usage)
      fullData, tryDate = _checkDataRequiredServices(warnings, tryDate, dataRequiredServices, hasReports)
      if fullData < 0:
        printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_USAGE_PARAMETERS_DATA_AVAILABLE)
        return
      if hasReports:
        for parameter in usage[0]['parameters']:
          name = parameter.get('name')
          if name:
            allParameters.add(name)
      if fullData == 1:
        break
    except GAPI.badRequest:
      printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
      return
    except GAPI.invalid as e:
      tryDate = _adjustTryDate(str(e), False)
      if not tryDate:
        break
  for parameter in sorted(allParameters):
    csvPF.WriteRow({'parameter': parameter})
  csvPF.writeCSVfile(f'{report.capitalize()} Report Usage Parameters')

REPORTS_PARAMETERS_SIMPLE_TYPES = ['intValue', 'boolValue', 'datetimeValue', 'stringValue']

# gam report usage user [todrive <ToDriveAttribute>*]
#	[(user all|<UserItem>)|(orgunit|org|ou <OrgUnitPath>)|(select <UserTypeEntity>)]
#	[start|startdate <Date>] [end|enddate <Date>] [range <Date> <Date>]
#	[fields|parameters <String>)]
# gam report usage |customer [todrive <ToDriveAttribute>*]
#	[start|startdate <Date>] [end|enddate <Date>] [range <Date> <Date>]
#	[fields|parameters <String>)]
def doReportUsage():
  def usageEntitySelectors():
    selectorChoices = Cmd.USER_ENTITY_SELECTORS+Cmd.USER_CSVDATA_ENTITY_SELECTORS
    if GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
      selectorChoices += Cmd.SERVICE_ACCOUNT_ONLY_ENTITY_SELECTORS[:]+[Cmd.ENTITY_USER, Cmd.ENTITY_USERS]
    else:
      selectorChoices += Cmd.BASE_ENTITY_SELECTORS[:]+Cmd.USER_ENTITIES[:]
    return selectorChoices

  def validateYYYYMMDD(argstr):
    if argstr in TODAY_NOW or argstr[0] in PLUS_MINUS:
      if argstr == 'NOW':
        argstr = 'TODAY'
      deltaDate = getDelta(argstr, DELTA_DATE_PATTERN)
      if deltaDate is None:
        Cmd.Backup()
        invalidArgumentExit(DELTA_DATE_FORMAT_REQUIRED)
      return deltaDate
    try:
      argDate = datetime.datetime.strptime(argstr, YYYYMMDD_FORMAT)
      return datetime.datetime(argDate.year, argDate.month, argDate.day, tzinfo=GC.Values[GC.TIMEZONE])
    except ValueError:
      Cmd.Backup()
      invalidArgumentExit(YYYYMMDD_FORMAT_REQUIRED)

  report = getChoice(CUSTOMER_USER_CHOICES)
  rep = buildGAPIObject(API.REPORTS)
  titles = ['date']
  if report == 'customer':
    userReports = False
    service = rep.customerUsageReports()
    kwargs = [{}]
  else: # 'user'
    userReports = True
    service = rep.userUsageReport()
    kwargs = [{'userKey': 'all'}]
    titles.append('user')
  csvPF = CSVPrintFile(titles, 'sortall')
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  parameters = set()
  users = []
  orgUnitId = None
  startEndTime = StartEndTime('startdate', 'enddate', 'date')
  skipDayNumbers = []
  skipDates = set()
  oneDay = datetime.timedelta(days=1)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'start', 'startdate', 'end', 'enddate', 'range'}:
      startEndTime.Get(myarg)
    elif userReports and myarg in ['orgunit', 'org', 'ou']:
      _, orgUnitId = getOrgUnitId()
    elif myarg in {'fields', 'parameters'}:
      parameters = parameters.union(getString(Cmd.OB_STRING).replace(',', ' ').split())
    elif myarg == 'skipdates':
      for skip in getString(Cmd.OB_STRING).upper().split(','):
        if skip.find(':') == -1:
          skipDates.add(validateYYYYMMDD(skip))
        else:
          skipStart, skipEnd = skip.split(':', 1)
          skipStartDate = validateYYYYMMDD(skipStart)
          skipEndDate = validateYYYYMMDD(skipEnd)
          if skipEndDate < skipStartDate:
            Cmd.Backup()
            usageErrorExit(Msg.INVALID_DATE_TIME_RANGE.format(myarg, skipEnd, myarg, skipStart))
          while skipStartDate <= skipEndDate:
            skipDates.add(skipStartDate)
            skipStartDate += oneDay
    elif myarg == 'skipdaysofweek':
      skipdaynames = getString(Cmd.OB_STRING).split(',')
      dow = [d.lower() for d in calendarlib.day_abbr]
      skipDayNumbers = [dow.index(d) for d in skipdaynames if d in dow]
    elif userReports and myarg == 'select' or myarg in usageEntitySelectors():
      if myarg != 'select':
        Cmd.Backup()
      _, users = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    else:
      unknownArgumentExit()
  if startEndTime.endDateTime is None:
    startEndTime.endDateTime = todaysDate()
  if startEndTime.startDateTime is None:
    startEndTime.startDateTime = startEndTime.endDateTime+datetime.timedelta(days=-30)
  startDateTime = startEndTime.startDateTime
  startDate = startDateTime.strftime(YYYYMMDD_FORMAT)
  endDateTime = startEndTime.endDateTime
  endDate = endDateTime.strftime(YYYYMMDD_FORMAT)
  startUseDate = endUseDate = None
  if users:
    kwargs = [{'userKey': normalizeEmailAddressOrUID(user)} for user in users]
  if orgUnitId:
    for kw in kwargs:
      kw['orgUnitID'] = orgUnitId
  parameters = ','.join(parameters) if parameters else None
  while startDateTime <= endDateTime:
    if startDateTime.weekday() in skipDayNumbers or startDateTime in skipDates:
      startDateTime += oneDay
      continue
    useDate = startDateTime.strftime(YYYYMMDD_FORMAT)
    startDateTime += oneDay
    try:
      for kwarg in kwargs:
        try:
          usage = callGAPIpages(service, 'get', 'usageReports',
                                throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                customerId=customerId, date=useDate,
                                parameters=parameters, **kwarg)
        except GAPI.badRequest:
          continue
        for entity in usage:
          row = {'date': useDate}
          if 'userEmail' in entity['entity']:
            row['user'] = entity['entity']['userEmail']
          for item in entity.get('parameters', []):
            if 'name' not in item:
              continue
            name = item['name']
            if name == 'cros:device_version_distribution':
              versions = {}
              for version in item['msgValue']:
                versions[version['version_number']] = version['num_devices']
              for k, v in sorted(iter(versions.items()), reverse=True):
                title = f'cros:num_devices_chrome_.{k}'
                row[title] = v
            else:
              for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
                if ptype in item:
                  if ptype != 'datetimeValue':
                    row[name] = item[ptype]
                  else:
                    row[name] = formatLocalTime(item[ptype])
                  break
              else:
                row[name] = ''
          if not startUseDate:
            startUseDate = useDate
          endUseDate = useDate
          csvPF.WriteRowTitles(row)
    except GAPI.invalid as e:
      stderrWarningMsg(str(e))
      break
    except GAPI.forbidden:
      accessErrorExit(None)
  if startUseDate:
    reportName = f'{report.capitalize()} Usage Report - {startUseDate}:{endUseDate}'
  else:
    reportName = f'{report.capitalize()} Usage Report - {startDate}:{endDate} - No Data'
  csvPF.writeCSVfile(reportName)

NL_SPACES_PATTERN = re.compile(r'\n +')
DISABLED_REASON_TIME_PATTERN = re.compile(r'.*(\d{4}/\d{2}/\d{2}-\d{2}:\d{2}:\d{2})')

REPORT_CHOICE_MAP = {
  'access': 'access_transparency',
  'accesstransparency': 'access_transparency',
  'admin': 'admin',
  'calendar': 'calendar',
  'calendars': 'calendar',
  'chat': 'chat',
  'customer': 'customer',
  'customers': 'customer',
  'doc': 'drive',
  'docs': 'drive',
  'domain': 'customer',
  'drive': 'drive',
  'enterprisegroups': 'groups_enterprise',
  'gcp': 'gcp',
  'gplus': 'gplus',
  'google+': 'gplus',
  'group': 'groups',
  'groups': 'groups',
  'groupsenterprise': 'groups_enterprise',
  'hangoutsmeet': 'meet',
  'jamboard': 'jamboard',
  'login': 'login',
  'logins': 'login',
  'meet': 'meet',
  'mobile': 'mobile',
  'oauthtoken': 'token',
  'rules': 'rules',
  'saml': 'saml',
  'token': 'token',
  'tokens': 'token',
  'usage': 'usage',
  'usageparameters': 'usageparameters',
  'user': 'user',
  'users': 'user',
  'useraccounts': 'user_accounts',
  }

CUSTOMER_REPORT_SERVICES = [
  'accounts',
  'app_maker',
  'apps_scripts',
  'calendar',
  'classroom',
  'cros',
  'device_management',
  'docs',
  'drive',
  'gmail',
  'gplus',
  'meet',
  'sites',
  ]

USER_REPORT_SERVICES = [
  'accounts',
  'classroom',
  'docs',
  'drive',
  'gmail',
  'gplus',
  ]

REPORT_ACTIVITIES_TIME_OBJECTS = {'time'}

# gam report <ActivityApplictionName> [todrive <ToDriveAttribute>*]
#	[(user all|<UserItem>)|(orgunit|org|ou <OrgUnitPath>)|(select <UserTypeEntity>)]
#	[([start <Time>] [end <Time>])|(range <Time> <Time>)|yesterday]
#	[filtertime.* <Time>] [filter|filters <String>]
#	[event|events <EventNameList>] [ip <String>]
#	[maxactivities <Number>] [maxresults <Number>]
#	[countsonly [summary] [eventrowfilter]]
# gam report users|user [todrive <ToDriveAttribute>*]
#	[(user all|<UserItem>)|(orgunit|org|ou <OrgUnitPath>)|(select <UserTypeEntity>)]
#	[(date <Date>)|(range <Date> <Date>)] [nodatechange | (fulldatarequired all|<UserServiceNameList>)]
#	[filtertime.* <Time>] [filter|filters <String>]
#	[(fields|parameters <String>)|(services <UserServiceNameList>)]
#	[aggregatebydate [Boolean]]
#	[maxresults <Number>]
# gam report customers|customer|domain [todrive <ToDriveAttribute>*]
#	[(date <Date>)|(range <Date> <Date>)] [nodatechange | (fulldatarequired all|<CustomerServiceNameList>)]
#	[(fields|parameters <String>)|(services <CustomerServiceNameList>)] [noauthorizedapps]
def doReport():
  def processUserUsage(usage, lastDate):
    if not usage or lastDate == usage[0]['date']:
      return (lastDate is None, lastDate)
    lastDate = usage[0]['date']
    for user_report in usage:
      if 'entity' not in user_report:
        continue
      row = {'email': user_report['entity']['userEmail'], 'date': user_report['date']}
      for item in user_report.get('parameters', []):
        if 'name' not in item:
          continue
        name = item['name']
        service, _ = name.split(':', 1)
        if service not in includeServices:
          continue
        if name == 'accounts:disabled_reason':
          mg = DISABLED_REASON_TIME_PATTERN.match(item['stringValue'])
          if mg:
            try:
              disabledTime = formatLocalTime(datetime.datetime.strptime(mg.group(1), '%Y/%m/%d-%H:%M:%S').replace(tzinfo=iso8601.UTC).strftime(YYYYMMDDTHHMMSSZ_FORMAT))
              row['accounts:disabled_time'] = disabledTime
              csvPF.AddTitles('accounts:disabled_time')
            except ValueError:
              pass
        csvPF.AddTitles(name)
        for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
          if ptype in item:
            if ptype != 'datetimeValue':
              row[name] = item[ptype]
            else:
              row[name] = formatLocalTime(item[ptype])
            break
        else:
          row[name] = ''
      csvPF.WriteRow(row)
    return (True, lastDate)

  def processAggregateUserUsage(usage, lastDate):
    if not usage or lastDate == usage[0]['date']:
      return (lastDate is None, lastDate)
    lastDate = usage[0]['date']
    for user_report in usage:
      if 'entity' not in user_report:
        continue
      for item in user_report.get('parameters', []):
        if 'name' not in item:
          continue
        name = item['name']
        service, _ = name.split(':', 1)
        if service not in includeServices:
          continue
        if 'intValue' in item:
          csvPF.AddTitles(name)
          eventCounts.setdefault(lastDate, {})
          eventCounts[lastDate].setdefault(name, 0)
          eventCounts[lastDate][name] += int(item['intValue'])
    return (True, lastDate)

  def processCustomerUsageOneRow(usage, lastDate):
    if not usage or lastDate == usage[0]['date']:
      return (lastDate is None, lastDate)
    lastDate = usage[0]['date']
    row = {'date': lastDate}
    for item in usage[0].get('parameters', []):
      if 'name' not in item:
        continue
      name = item['name']
      service, _ = name.split(':', 1)
      if service not in includeServices:
        continue
      for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
        if ptype in item:
          csvPF.AddTitles(name)
          if ptype != 'datetimeValue':
            row[name] = item[ptype]
          else:
            row[name] = formatLocalTime(item[ptype])
          break
      else:
        if 'msgValue' in item:
          if name == 'accounts:authorized_apps':
            if noAuthorizedApps:
              continue
            for app in item['msgValue']:
              appName = f'App: {escapeCRsNLs(app["client_name"])}'
              for key in ['num_users', 'client_id']:
                title = f'{appName}.{key}'
                csvPF.AddTitles(title)
                row[title] = app[key]
          elif name == 'cros:device_version_distribution':
            versions = {}
            for version in item['msgValue']:
              versions[version['version_number']] = version['num_devices']
            for k, v in sorted(iter(versions.items()), reverse=True):
              title = f'cros:device_version.{k}'
              csvPF.AddTitles(title)
              row[title] = v
          else:
            values = []
            for subitem in item['msgValue']:
              if 'count' in subitem:
                mycount = myvalue = None
                for key, value in subitem.items():
                  if key == 'count':
                    mycount = value
                  else:
                    myvalue = value
                  if mycount and myvalue:
                    values.append(f'{myvalue}:{mycount}')
                value = ' '.join(values)
              elif 'version_number' in subitem and 'num_devices' in subitem:
                values.append(f'{subitem["version_number"]}:{subitem["num_devices"]}')
              else:
                continue
              value = ' '.join(sorted(values, reverse=True))
            csvPF.AddTitles(name)
            row['name'] = value
    csvPF.WriteRow(row)
    return (True, lastDate)

  def processCustomerUsage(usage, lastDate):
    if not usage or lastDate == usage[0]['date']:
      return (lastDate is None, lastDate)
    lastDate = usage[0]['date']
    for item in usage[0].get('parameters', []):
      if 'name' not in item:
        continue
      name = item['name']
      service, _ = name.split(':', 1)
      if service not in includeServices:
        continue
      for ptype in REPORTS_PARAMETERS_SIMPLE_TYPES:
        if ptype in item:
          if ptype != 'datetimeValue':
            csvPF.WriteRow({'date': lastDate, 'name': name, 'value': item[ptype]})
          else:
            csvPF.WriteRow({'date': lastDate, 'name': name, 'value': formatLocalTime(item[ptype])})
          break
      else:
        if 'msgValue' in item:
          if name == 'accounts:authorized_apps':
            if noAuthorizedApps:
              continue
            for subitem in item['msgValue']:
              app = {'date': lastDate}
              for an_item in subitem:
                if an_item == 'client_name':
                  app['name'] = f'App: {escapeCRsNLs(subitem[an_item])}'
                elif an_item == 'num_users':
                  app['value'] = f'{subitem[an_item]} users'
                elif an_item == 'client_id':
                  app['client_id'] = subitem[an_item]
              authorizedApps.append(app)
          elif name == 'cros:device_version_distribution':
            values = []
            for subitem in item['msgValue']:
              values.append(f'{subitem["version_number"]}:{subitem["num_devices"]}')
            csvPF.WriteRow({'date': lastDate, 'name': name, 'value': ' '.join(sorted(values, reverse=True))})
          else:
            values = []
            for subitem in item['msgValue']:
              if 'count' in subitem:
                mycount = myvalue = None
                for key, value in subitem.items():
                  if key == 'count':
                    mycount = value
                  else:
                    myvalue = value
                  if mycount and myvalue:
                    values.append(f'{myvalue}:{mycount}')
              else:
                continue
            csvPF.WriteRow({'date': lastDate, 'name': name, 'value': ' '.join(sorted(values, reverse=True))})
    csvPF.SortRowsTwoTitles('date', 'name', False)
    if authorizedApps:
      csvPF.AddTitle('client_id')
      for row in sorted(authorizedApps, key=lambda k: (k['date'], k['name'].lower())):
        csvPF.WriteRow(row)
    return (True, lastDate)

  report = getChoice(REPORT_CHOICE_MAP, mapChoice=True)
  if report == 'usage':
    doReportUsage()
    return
  if report == 'usageparameters':
    doReportUsageParameters()
    return
  rep = buildGAPIObject(API.REPORTS)
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  csvPF = CSVPrintFile()
  filters = actorIpAddress = orgUnit = orgUnitId = None
  parameters = set()
  eventCounts = {}
  eventNames = []
  startEndTime = StartEndTime('start', 'end')
  oneDay = datetime.timedelta(days=1)
  filterTimes = {}
  maxActivities = 0
  maxResults = 1000
  aggregateUserUsage = countsOnly = eventRowFilter = exitUserLoop = noAuthorizedApps = noDateChange = normalizeUsers = select = summary = userCustomerRange = False
  userKey = 'all'
  customerReports = report == 'customer'
  userReports = report == 'user'
  usageReports = customerReports or userReports
  activityReports = not usageReports
  dataRequiredServices = set()
  if usageReports:
    fullDataServices = CUSTOMER_REPORT_SERVICES if customerReports else USER_REPORT_SERVICES
    includeServices = set()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'range':
      startEndTime.Get(myarg)
      userCustomerRange = True
    elif myarg in {'orgunit', 'org', 'ou'}:
      orgUnit, orgUnitId = getOrgUnitId()
    elif usageReports and myarg == 'date':
      startEndTime.Get('start')
      startEndTime.endDateTime = startEndTime.startDateTime
      userCustomerRange = False
    elif usageReports and myarg == 'nodatechange':
      noDateChange = True
    elif usageReports and myarg in {'fields', 'parameters'}:
      parameters = parameters.union(getString(Cmd.OB_STRING).replace(',', ' ').split())
    elif usageReports and myarg == 'fulldatarequired':
      fdr = getString(Cmd.OB_SERVICE_NAME_LIST, minLen=0).lower()
      if fdr:
        if fdr != 'all':
          for field in fdr.replace(',', ' ').split():
            if field in fullDataServices:
              dataRequiredServices.add(field)
            else:
              invalidChoiceExit(field, fullDataServices, True)
        else:
          dataRequiredServices = {'all'}
    elif usageReports and myarg in {'service', 'services'}:
      for field in getString(Cmd.OB_SERVICE_NAME_LIST).lower().replace(',', ' ').split():
        if field in fullDataServices:
          includeServices.add(field)
        else:
          invalidChoiceExit(field, fullDataServices, True)
    elif customerReports and myarg == 'noauthorizedapps':
      noAuthorizedApps = True
    elif activityReports and myarg == 'maxactivities':
      maxActivities = getInteger(minVal=0)
    elif activityReports and myarg in {'start', 'starttime', 'end', 'endtime', 'yesterday'}:
      startEndTime.Get(myarg)
    elif activityReports and myarg in {'event', 'events'}:
      for event in getString(Cmd.OB_EVENT_NAME_LIST).replace(',', ' ').split():
        event = event.lower() if report not in {'access_transparency', 'admin', 'gcp', 'mobile'} else event.upper()
        if event not in eventNames:
          eventNames.append(event)
    elif activityReports and myarg == 'ip':
      actorIpAddress = getString(Cmd.OB_STRING)
    elif activityReports and myarg == 'countsonly':
      countsOnly = True
    elif activityReports and myarg == 'summary':
      summary = True
    elif activityReports and myarg == 'eventrowfilter':
      eventRowFilter = True
    elif not customerReports and myarg.startswith('filtertime'):
      filterTimes[myarg] = getTimeOrDeltaFromNow()
    elif not customerReports and myarg in {'filter', 'filters'}:
      filters = getString(Cmd.OB_STRING)
    elif not customerReports and myarg == 'maxresults':
      maxResults = getInteger(minVal=1, maxVal=1000)
    elif not customerReports and myarg == 'user':
      userKey = getString(Cmd.OB_EMAIL_ADDRESS)
    elif not customerReports and myarg == 'select':
      _, users = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
      select = True
    elif userReports and myarg == 'aggregatebydate':
      aggregateUserUsage = getBoolean()
    else:
      unknownArgumentExit()
  parameters = ','.join(parameters) if parameters else None
  if usageReports and not includeServices:
    includeServices = set(fullDataServices)
  if filterTimes and filters is not None:
    for filterTimeName, filterTimeValue in iter(filterTimes.items()):
      filters = filters.replace(f'#{filterTimeName}#', filterTimeValue)
  if userReports:
    if startEndTime.startDateTime is None:
      startEndTime.startDateTime = startEndTime.endDateTime = todaysDate()
    if select:
      pageMessage = None
      normalizeUsers = True
      orgUnitId = None
    elif userKey == 'all':
      printGettingEntityItemForWhom(Ent.REPORT, f'users in orgUnit {orgUnit}' if orgUnit else 'all users')
      pageMessage = getPageMessage()
      users = ['all']
    else:
      Ent.SetGetting(Ent.USER)
      pageMessage = getPageMessage()
      users = [normalizeEmailAddressOrUID(userKey)]
      orgUnitId = None
    csvPF.SetTitles(['email', 'date'] if not aggregateUserUsage else ['date'])
    csvPF.SetSortAllTitles()
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      if user != 'all':
        printGettingEntityItemForWhom(Ent.REPORT, user, i, count)
      startDateTime = startEndTime.startDateTime
      endDateTime = startEndTime.endDateTime
      lastDate = None
      while startDateTime <= endDateTime:
        tryDate = startDateTime.strftime(YYYYMMDD_FORMAT)
        try:
          if not userCustomerRange:
            result = callGAPI(rep.userUsageReport(), 'get',
                              throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                              userKey=user, date=tryDate, customerId=customerId,
                              orgUnitID=orgUnitId, fields='warnings,usageReports', maxResults=1)
            warnings = result.get('warnings', [])
            hasReports = bool(result.get('usageReports', []))
            fullData, tryDate = _checkDataRequiredServices(warnings, tryDate, dataRequiredServices, hasReports)
            if fullData < 0:
              printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
              break
            if fullData == 0:
              if noDateChange:
                break
              startDateTime = endDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)
              continue
          usage = callGAPIpages(rep.userUsageReport(), 'get', 'usageReports',
                                pageMessage=pageMessage,
                                throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                                userKey=user, date=tryDate, customerId=customerId,
                                orgUnitID=orgUnitId, filters=filters, parameters=parameters,
                                maxResults=maxResults)
          if not aggregateUserUsage:
            status, lastDate = processUserUsage(usage, lastDate)
          else:
            status, lastDate = processAggregateUserUsage(usage, lastDate)
          if not status:
            break
        except GAPI.invalid as e:
          tryDate = _adjustTryDate(str(e), noDateChange)
          if not tryDate:
            break
          startDateTime = endDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)
          continue
        except GAPI.badRequest:
          if user != 'all':
            entityUnknownWarning(Ent.USER, user, i, count)
          else:
            printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
            exitUserLoop = True
          break
        except GAPI.forbidden:
          accessErrorExit(None)
        startDateTime += oneDay
      if exitUserLoop:
        break
    if not aggregateUserUsage:
      csvPF.SortRowsTwoTitles('email', 'date', False)
      csvPF.writeCSVfile(f'User Reports - {tryDate}')
    else:
      for usageDate, events in iter(eventCounts.items()):
        row = {'date': usageDate}
        for event, count in iter(events.items()):
          row[event] = count
        csvPF.WriteRow(row)
      csvPF.SortRows('date', False)
      csvPF.writeCSVfile(f'User Reports Aggregate - {tryDate}')
  elif customerReports:
    if startEndTime.startDateTime is None:
      startEndTime.startDateTime = startEndTime.endDateTime = todaysDate()
    csvPF.SetTitles('date')
    if not userCustomerRange:
      csvPF.AddTitles(['name', 'value'])
    authorizedApps = []
    startDateTime = startEndTime.startDateTime
    endDateTime = startEndTime.endDateTime
    lastDate = None
    while startDateTime <= endDateTime:
      tryDate = startDateTime.strftime(YYYYMMDD_FORMAT)
      try:
        if not userCustomerRange:
          result = callGAPI(rep.customerUsageReports(), 'get',
                            throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                            date=tryDate, customerId=customerId, fields='warnings,usageReports')
          warnings = result.get('warnings', [])
          hasReports = bool(result.get('usageReports', []))
          fullData, tryDate = _checkDataRequiredServices(warnings, tryDate, dataRequiredServices, hasReports)
          if fullData < 0:
            printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_REPORT_AVAILABLE.format(report))
            break
          if fullData == 0:
            if noDateChange:
              break
            startDateTime = endDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)
            continue
        usage = callGAPIpages(rep.customerUsageReports(), 'get', 'usageReports',
                              throwReasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                              date=tryDate, customerId=customerId, parameters=parameters)
        if userCustomerRange:
          status, lastDate = processCustomerUsageOneRow(usage, lastDate)
        else:
          status, lastDate = processCustomerUsage(usage, lastDate)
        if not status:
          break
      except GAPI.invalid as e:
        tryDate = _adjustTryDate(str(e), noDateChange)
        if not tryDate:
          break
        startDateTime = endDateTime = datetime.datetime.strptime(tryDate, YYYYMMDD_FORMAT)
        continue
      except GAPI.forbidden:
        accessErrorExit(None)
      startDateTime += oneDay
    csvPF.writeCSVfile(f'Customer Report - {tryDate}')
  else: # activityReports
    if select:
      pageMessage = None
      normalizeUsers = True
      orgUnitId = None
    elif userKey == 'all':
      printGettingEntityItemForWhom(Ent.ACTIVITY, f'users in orgUnit {orgUnit}' if orgUnit else 'all users')
      pageMessage = getPageMessage()
      users = ['all']
    else:
      Ent.SetGetting(Ent.ACTIVITY)
      pageMessage = getPageMessage()
      users = [normalizeEmailAddressOrUID(userKey)]
      orgUnitId = None
    if not eventNames:
      eventNames.append(None)
    i = 0
    count = len(users)
    for user in users:
      i += 1
      if normalizeUsers:
        user = normalizeEmailAddressOrUID(user)
      if select or user != 'all':
        printGettingEntityItemForWhom(Ent.ACTIVITY, user, i, count)
      for eventName in eventNames:
        try:
          feed = callGAPIpages(rep.activities(), 'list', 'items',
                               pageMessage=pageMessage, maxItems=maxActivities,
                               throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.AUTH_ERROR],
                               applicationName=report, userKey=user, customerId=customerId,
                               actorIpAddress=actorIpAddress, orgUnitID=orgUnitId,
                               startTime=startEndTime.startTime, endTime=startEndTime.endTime,
                               eventName=eventName, filters=filters, maxResults=maxResults)
        except GAPI.badRequest:
          if user != 'all':
            entityUnknownWarning(Ent.USER, user, i, count)
            continue
          printErrorMessage(BAD_REQUEST_RC, Msg.BAD_REQUEST)
          break
        except GAPI.invalid as e:
          systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
        except GAPI.authError:
          accessErrorExit(None)
        for activity in feed:
          events = activity.pop('events')
          actor = activity['actor'].get('email', activity['actor'].get('key', 'Unknown'))
          if not countsOnly or eventRowFilter:
            activity_row = flattenJSON(activity, timeObjects=REPORT_ACTIVITIES_TIME_OBJECTS)
            purge_parameters = True
            for event in events:
              for item in event.get('parameters', []):
                itemSet = set(item)
                if not itemSet.difference({'value', 'name'}):
                  event[item['name']] = NL_SPACES_PATTERN.sub('', item['value'])
                elif not itemSet.difference({'intValue', 'name'}):
                  if item['name'] in {'start_time', 'end_time'}:
                    val = item.get('intValue')
                    if val is not None:
                      val = int(val)
                      if val >= 62135683200:
                        event[item['name']] = ISOformatTimeStamp(datetime.datetime.fromtimestamp(val-62135683200, GC.Values[GC.TIMEZONE]))
                      else:
                        event[item['name']] = val
                  else:
                    event[item['name']] = item['intValue']
                elif not itemSet.difference({'boolValue', 'name'}):
                  event[item['name']] = item['boolValue']
                elif not itemSet.difference({'multiValue', 'name'}):
                  event[item['name']] = ' '.join(item['multiValue'])
                elif item['name'] == 'scope_data':
                  parts = {}
                  for message in item['multiMessageValue']:
                    for mess in message['parameter']:
                      value = mess.get('value', ' '.join(mess.get('multiValue', [])))
                      parts[mess['name']] = parts.get(mess['name'], [])+[value]
                  for part, v in parts.items():
                    if part == 'scope_name':
                      part = 'scope'
                    event[part] = ' '.join(v)
                else:
                  purge_parameters = False
              if purge_parameters:
                event.pop('parameters', None)
              row = flattenJSON(event)
              row.update(activity_row)
            if not countsOnly:
              csvPF.WriteRowTitles(row)
            elif not csvPF.rowFilter or csvPF.CheckRowTitles(row):
              if not summary:
                eventCounts.setdefault(actor, {})
                eventCounts[actor].setdefault(event['name'], 0)
                eventCounts[actor][event['name']] += 1
              else:
                eventCounts.setdefault(event['name'], 0)
                eventCounts[event['name']] += 1
          elif not summary:
            eventCounts.setdefault(actor, {})
            for event in events:
              eventCounts[actor].setdefault(event['name'], 0)
              eventCounts[actor][event['name']] += 1
          else:
            for event in events:
              eventCounts.setdefault(event['name'], 0)
              eventCounts[event['name']] += 1
    if not countsOnly:
      csvPF.SetSortTitles(['name'])
    else:
      if eventRowFilter:
        csvPF.SetRowFilter([])
      if not summary:
        csvPF.SetTitles('emailAddress')
        for actor, events in iter(eventCounts.items()):
          row = {'emailAddress': actor}
          for event, count in iter(events.items()):
            row[event] = count
          csvPF.WriteRowTitles(row)
        csvPF.SetSortTitles(['emailAddress'])
      else:
        csvPF.SetTitles(['event', 'count'])
        for event in sorted(eventCounts):
          csvPF.WriteRow({'event': event, 'count': eventCounts[event]})
    csvPF.writeCSVfile(f'{report.capitalize()} Activity Report')

# Substitute for #user#, #email#, #usernamne#
def _substituteForUser(field, user, userName):
  if field.find('#') == -1:
    return field
  return field.replace('#user#', user).replace('#email#', user).replace('#username#', userName)

# Tag utilities
TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP = {
  'country': 'country',
  'countrycode': 'countryCode',
  'customtype': 'customType',
  'extendedaddress': 'extendedAddress',
  'formatted': 'formatted',
  'locality': 'locality',
  'pobox': 'poBox',
  'postalcode': 'postalCode',
  'primary': 'primary',
  'region': 'region',
  'streetaddress': 'streetAddress',
  'type': 'type',
  }

TAG_EMAIL_ARGUMENT_TO_FIELD_MAP = {
  'domain': 'domain',
  'primaryemail': 'primaryEmail',
  'username': 'username',
  }

TAG_KEYWORD_ARGUMENT_TO_FIELD_MAP = {
  'customtype': 'customType',
  'type': 'type',
  'value': 'value',
  }

TAG_LOCATION_ARGUMENT_TO_FIELD_MAP = {
  'area': 'area',
  'buildingid': 'buildingId',
  'buildingname': 'buildingName',
  'customtype': 'customType',
  'deskcode': 'deskCode',
  'floorname': 'floorName',
  'floorsection': 'floorSection',
  'type': 'type',
  }

TAG_NAME_ARGUMENT_TO_FIELD_MAP = {
  'familyname': 'familyName',
  'fullname': 'fullName',
  'givenname': 'givenName',
  }

TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
  'costcenter': 'costCenter',
  'customtype': 'customType',
  'department': 'department',
  'description': 'description',
  'domain': 'domain',
  'fulltimeequivalent': 'fullTimeEquivalent',
  'location': 'location',
  'name': 'name',
  'primary': 'primary',
  'symbol': 'symbol',
  'title': 'title',
  'type': 'type',
  }

TAG_OTHEREMAIL_ARGUMENT_TO_FIELD_MAP = {
  'address': 'address',
  'customtype': 'customType',
  'primary': 'primary',
  'type': 'type',
  }

TAG_PHONE_ARGUMENT_TO_FIELD_MAP = {
  'customtype': 'customType',
  'primary': 'primary',
  'type': 'type',
  'value': 'value',
  }

TAG_FIELD_SUBFIELD_CHOICE_MAP = {
  'address': ('addresses', TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP),
  'addresses': ('addresses', TAG_ADDRESS_ARGUMENT_TO_FIELD_MAP),
  'email': ('primaryEmail', TAG_EMAIL_ARGUMENT_TO_FIELD_MAP),
  'keyword': ('keywords', TAG_KEYWORD_ARGUMENT_TO_FIELD_MAP),
  'keywords': ('keywords', TAG_KEYWORD_ARGUMENT_TO_FIELD_MAP),
  'location': ('locations', TAG_LOCATION_ARGUMENT_TO_FIELD_MAP),
  'locations': ('locations', TAG_LOCATION_ARGUMENT_TO_FIELD_MAP),
  'name': ('name', TAG_NAME_ARGUMENT_TO_FIELD_MAP),
  'organization': ('organizations', TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP),
  'organizations': ('organizations', TAG_ORGANIZATION_ARGUMENT_TO_FIELD_MAP),
  'otheremail': ('emails', TAG_OTHEREMAIL_ARGUMENT_TO_FIELD_MAP),
  'otheremails': ('emails', TAG_OTHEREMAIL_ARGUMENT_TO_FIELD_MAP),
  'phone': ('phones', TAG_PHONE_ARGUMENT_TO_FIELD_MAP),
  'phones': ('phones', TAG_PHONE_ARGUMENT_TO_FIELD_MAP),
  }

def _initTagReplacements():
  return {'cd': None, 'tags': {}, 'subs': False,
          'fieldsSet': set(), 'fields': '',
          'schemasSet': set(), 'customFieldMask': None}

def _getTagReplacement(tagReplacements, allowSubs):
  matchTag = getString(Cmd.OB_TAG)
  matchReplacement = getString(Cmd.OB_STRING, minLen=0)
  if matchReplacement.startswith('field:'):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements['subs'] = True
    field = matchReplacement[6:].strip().lower()
    if field.find('.') != -1:
      args = field.split('.', 3)
      field = args[0]
      subfield = args[1]
      if len(args) == 2:
        matchfield = matchvalue = ''
      elif len(args) == 4:
        matchfield = args[2]
        matchvalue = args[3]
        if matchfield == 'primary':
          matchvalue = matchvalue.lower()
          if matchvalue == TRUE:
            matchvalue = True
          elif matchvalue == FALSE:
            matchvalue = ''
          else:
            invalidChoiceExit(matchvalue, TRUE_FALSE, True)
      else:
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_TAG_SPECIFICATION)
    else:
      field = ''
    if not field or field not in TAG_FIELD_SUBFIELD_CHOICE_MAP:
      invalidChoiceExit(field, TAG_FIELD_SUBFIELD_CHOICE_MAP, True)
    field, subfieldsChoiceMap = TAG_FIELD_SUBFIELD_CHOICE_MAP[field]
    if subfield not in subfieldsChoiceMap:
      invalidChoiceExit(subfield, subfieldsChoiceMap, True)
    subfield = subfieldsChoiceMap[subfield]
    if matchfield:
      if matchfield not in subfieldsChoiceMap:
        invalidChoiceExit(matchfield, subfieldsChoiceMap, True)
      matchfield = subfieldsChoiceMap[matchfield]
    tagReplacements['fieldsSet'].add(field)
    tagReplacements['fields'] = ','.join(tagReplacements['fieldsSet'])
    tagReplacements['tags'][matchTag] = {'field': field, 'subfield': subfield,
                                         'matchfield': matchfield, 'matchvalue': matchvalue, 'value': ''}
    if field == 'locations' and subfield == 'buildingName':
      _makeBuildingIdNameMap()
  elif matchReplacement.startswith('schema:'):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements['subs'] = True
    matchReplacement = matchReplacement[7:].strip()
    if matchReplacement.find('.') != -1:
      schemaName, schemaField = matchReplacement.split('.', 1)
    else:
      schemaName = ''
    if not schemaName or not schemaField:
      invalidArgumentExit(Cmd.OB_SCHEMA_NAME_FIELD_NAME)
    tagReplacements['fieldsSet'].add('customSchemas')
    tagReplacements['fields'] = ','.join(tagReplacements['fieldsSet'])
    tagReplacements['schemasSet'].add(schemaName)
    tagReplacements['customFieldMask'] = ','.join(tagReplacements['schemasSet'])
    tagReplacements['tags'][matchTag] = {'schema': schemaName, 'schemafield': schemaField, 'value': ''}
  elif ((matchReplacement.find('#') >= 0) and
        (matchReplacement.find('#user#') >= 0) or (matchReplacement.find('#email#') >= 0) or (matchReplacement.find('#username#') >= 0)):
    if not allowSubs:
      usageErrorExit(Msg.USER_SUBS_NOT_ALLOWED_TAG_REPLACEMENT)
    tagReplacements['subs'] = True
    tagReplacements['tags'][matchTag] = {'template': matchReplacement, 'value': ''}
  else:
    tagReplacements['tags'][matchTag] = {'value': matchReplacement}

def _getTagReplacementFieldValues(user, i, count, tagReplacements, results=None):
  if results is None:
    if tagReplacements['fields'] and tagReplacements['fields'] != 'primaryEmail':
      if not tagReplacements['cd']:
        tagReplacements['cd'] = buildGAPIObject(API.DIRECTORY)
      try:
        results = callGAPI(tagReplacements['cd'].users(), 'get',
                           throwReasons=GAPI.USER_GET_THROW_REASONS,
                           userKey=user, projection='custom', customFieldMask=tagReplacements['customFieldMask'], fields=tagReplacements['fields'])
      except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
        entityUnknownWarning(Ent.USER, user, i, count)
        return
    else:
      results = {'primaryEmail': user}
  userName, domain = splitEmailAddress(user)
  for _, tag in iter(tagReplacements['tags'].items()):
    if tag.get('field'):
      field = tag['field']
      if field == 'primaryEmail':
        subfield = tag['subfield']
        if subfield == 'username':
          tag['value'] = userName
        elif subfield == 'domain':
          tag['value'] = domain
        else:
          tag['value'] = user
      else:
        if field in ['addresses', 'emails', 'organizations', 'phones']:
          items = results.get(field, [])
          if not tag['matchfield']:
            for data in items:
              if data.get('primary'):
                break
            else:
              if items:
                data = items[0]
              else:
                data = {}
          else:
            for data in items:
              if data.get(tag['matchfield'], '') == tag['matchvalue']:
                break
            else:
              data = {}
        elif field in ['keywords', 'locations']:
          items = results.get(field, [])
          if not tag['matchfield']:
            if items:
              data = items[0]
              data['buildingName'] = GM.Globals[GM.MAP_BUILDING_ID_TO_NAME].get(data.get('buildingId', ''), '')
            else:
              data = {}
          else:
            for data in items:
              if data.get(tag['matchfield'], '') == tag['matchvalue']:
                break
            else:
              data = {}
        else:
          data = results.get(field, {})
        tag['value'] = str(data.get(tag['subfield'], ''))
    elif tag.get('schema'):
      tag['value'] = str(results.get('customSchemas', {}).get(tag['schema'], {}).get(tag['schemafield'], ''))
    elif tag.get('template'):
      tag['value'] = _substituteForUser(tag['template'], user, userName)

RTL_PATTERN = re.compile(r'(?s){RTL}.*?{/RTL}')
RT_PATTERN = re.compile(r'(?s){RT}.*?{/RT}')
TAG_REPLACE_PATTERN = re.compile(r'{(.+?)}')
RT_MARKERS = {'RT', '/RT', 'RTL', '/RTL'}
SKIP_PATTERNS = [re.compile(r'<head>.*?</head>'), re.compile(r'<script>.*?</script>')]

def _processTagReplacements(tagReplacements, message):
# Identify areas of message to avoid replacements
  skipAreas = []
  for pattern in SKIP_PATTERNS:
    pos = 0
    while True:
      match = pattern.search(message, pos)
      if not match:
        break
      skipAreas.append(match.span())
      pos = match.end()
  skipTags = set()
# Find all {tag}, note replacement value and starting location; note tags in skipAreas
  tagFields = []
  tagSubs = {}
  pos = 0
  while True:
    match = TAG_REPLACE_PATTERN.search(message, pos)
    if not match:
      break
    start, end = match.span()
    tag = match.group(1)
    if tag not in RT_MARKERS:
      for skipArea in skipAreas:
        if start >= skipArea[0] and end <= skipArea[1]:
          skipTags.add(tag)
          break
      else:
        tagSubs.setdefault(tag, tagReplacements['tags'].get(tag, {'value': ''})['value'])
        tagFields.append((tagSubs[tag], start))
    pos = end
# Find all {RT}.*?{/RT} sequences
# If any non-empty {tag} replacement value falls between them, then mark {RT} and {/RT} to be stripped
# Otherwise, mark the entire {RT}.*?{/RT} sequence to be stripped
  rtStrips = []
  pos = 0
  while True:
    match = RT_PATTERN.search(message, pos)
    if not match:
      break
    start, end = match.span()
    stripEntireRT = True
    hasTags = False
    for tagField in tagFields:
      if tagField[1] >= end:
        break
      if tagField[1] >= start:
        hasTags = True
        if tagField[0]:
          rtStrips.append((False, start, start+4))
          rtStrips.append((False, end-5, end))
          stripEntireRT = False
          break
    if stripEntireRT:
      if hasTags or start+4 == end-5:
        rtStrips.append((True, start, end))
      else:
        rtStrips.append((False, start, start+4))
        rtStrips.append((False, end-5, end))
    pos = end
# Find all {RTL}.*?{/RTL} sequences
# If any non-empty {RT}...{tag}... {/RT} falls between them, then mark {RTL} and {/RTL} to be stripped
# Otherwise, mark the entire {RTL}.*{/RTL} sequence to be stripped
  rtlStrips = []
  pos = 0
  while True:
    match = RTL_PATTERN.search(message, pos)
    if not match:
      break
    start, end = match.span()
    stripEntireRTL = True
    hasTags = False
    for tagField in tagFields:
      if tagField[1] >= end:
        break
      if tagField[1] >= start:
        hasTags = True
        if tagField[0]:
          rtlStrips.append((False, start, start+5, end-6, end))
          stripEntireRTL = False
          break
    if stripEntireRTL:
      for rtStrip in rtStrips:
        if rtStrip[1] >= end:
          break
        if rtStrip[1] >= start:
          hasTags = True
          if not rtStrip[0]:
            rtlStrips.append((False, start, start+5, end-6, end))
            stripEntireRTL = False
            break
    if stripEntireRTL:
      if hasTags or start+5 == end-6:
        rtlStrips.append((True, start, end))
      else:
        rtlStrips.append((False, start, start+5, end-6, end))
    pos = end
  if rtlStrips:
    allStrips = []
    i = 0
    l = len(rtStrips)
    for rtlStrip in rtlStrips:
      while i < l and rtStrips[i][1] < rtlStrip[1]:
        allStrips.append(rtStrips[i])
        i += 1
      allStrips.append((False, rtlStrip[1], rtlStrip[2]))
      if not rtlStrip[0]:
        while i < l and rtStrips[i][1] < rtlStrip[3]:
          allStrips.append(rtStrips[i])
          i += 1
        allStrips.append((False, rtlStrip[3], rtlStrip[4]))
      else:
        while i < l and rtStrips[i][1] < rtlStrip[2]:
          i += 1
    while i < l:
      allStrips.append(rtStrips[i])
      i += 1
  else:
    allStrips = rtStrips
# Strip {RTL} {/RTL}, {RT} {/RT}, {RTL}.*?{/RTL}, {RT}.*?{/RT} sequences
  for rtStrip in allStrips[::-1]:
    message = message[:rtStrip[1]]+message[rtStrip[2]:]
# Make {tag} replacements; ignore tags in skipAreas
  pos = 0
  while True:
    match = TAG_REPLACE_PATTERN.search(message, pos)
    if not match:
      break
    start, end = match.span()
    tag = match.group(1)
    if tag not in RT_MARKERS:
      if tag not in skipTags:
        message = re.sub(match.group(0), tagSubs[tag], message)
        pos = start+1
      else:
        pos = end
    else:
# Replace invalid RT tags with ERROR(RT)
      message = re.sub(match.group(0), f'ERROR({tag})', message)
      pos = start+1
  return message

def sendCreateUpdateUserNotification(body, basenotify, tagReplacements, i=0, count=0, msgFrom=None, createMessage=True):
  def _makeSubstitutions(field):
    notify[field] = _substituteForUser(notify[field], body['primaryEmail'], userName)
    notify[field] = notify[field].replace('#domain#', domain)
    notify[field] = notify[field].replace('#givenname#', body['name'].get('givenName', ''))
    notify[field] = notify[field].replace('#familyname#', body['name'].get('familyName', ''))
    notify[field] = notify[field].replace('#password#', notify['password'])

  userName, domain = splitEmailAddress(body['primaryEmail'])
  notify = basenotify.copy()
  if not notify['subject']:
    notify['subject'] = Msg.CREATE_USER_NOTIFY_SUBJECT if createMessage else Msg.UPDATE_USER_PASSWORD_CHANGE_NOTIFY_SUBJECT
  _makeSubstitutions('subject')
  if not notify['message']:
    notify['message'] = Msg.CREATE_USER_NOTIFY_MESSAGE if createMessage else Msg.UPDATE_USER_PASSWORD_CHANGE_NOTIFY_MESSAGE
  elif notify['html']:
    notify['message'] = notify['message'].replace('\r', '').replace('\\n', '<br/>')
  else:
    notify['message'] = notify['message'].replace('\r', '').replace('\\n', '\n')
  _makeSubstitutions('message')
  if tagReplacements['subs']:
    _getTagReplacementFieldValues(body['primaryEmail'], i, count, tagReplacements, body if createMessage else None)
  notify['subject'] = _processTagReplacements(tagReplacements, notify['subject'])
  notify['message'] = _processTagReplacements(tagReplacements, notify['message'])
  send_email(notify['subject'], notify['message'], notify['emailAddress'], i, count,
             msgFrom=msgFrom, html=notify['html'], charset=notify['charset'])

# gam sendemail <RecipientEntity> [from <EmailAddress>] [mailbox <EmailAddress>] [replyto <EmailAddress>]
#	[cc <RecipientEntity>] [bcc <RecipientEntity>] [singlemessage]
#	[subject <String>]
#	(message|textmessage <String>)|(file|textfile <FileName> [charset <CharSet>])|(gdoc <UserGoogleDoc>)
#	(htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])|(ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)* [html [<Boolean>]] (attach <FileName> [charset <CharSet>])*
#	[newuser <EmailAddress> firstname|givenname <String> lastname|familyname <string> password <Password>]
# gam <UserTypeEntity> sendemail [recipient <RecipientEntity>] [replyto <EmailAddress>]
#	[cc <RecipientEntity>] [bcc <RecipientEntity>] [singlemessage]
#	[subject <String>]
#	(message|textmessage <String>)|(file|textfile <FileName> [charset <CharSet>])|(gdoc <UserGoogleDoc>)
#	(htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])|(ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)* [html [<Boolean>]] (attach <FileName> [charset <CharSet>])*
#	[newuser <EmailAddress> firstname|givenname <String> lastname|familyname <string> password <Password>]
def doSendEmail(users=None):
  def getRecipients():
    if checkArgumentPresent('select'):
      _, recipients = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
      return [normalizeEmailAddressOrUID(emailAddress, noUid=True) for emailAddress in recipients]
    return getNormalizedEmailAddressEntity()

  body = {}
  notify = {'subject': '', 'message': '', 'html': False, 'charset': UTF8, 'password': ''}
  if users is None:
    msgFroms = [None]
    checkArgumentPresent({'recipient', 'recipients', 'to'})
    recipients = getRecipients()
  else:
    msgFroms = users
    recipients = ['']
  ccRecipients = []
  bccRecipients = []
  mailBox = None
  msgReplyTo = None
  singleMessage = False
  tagReplacements = _initTagReplacements()
  attachments = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if users is None and myarg == 'from':
      msgFroms = [getString(Cmd.OB_EMAIL_ADDRESS)]
    elif users is not None and myarg in {'recipient', 'recipients', 'to'}:
      recipients = getRecipients()
    elif myarg == 'replyto':
      msgReplyTo = getString(Cmd.OB_EMAIL_ADDRESS)
    elif myarg == 'subject':
      notify['subject'] = getString(Cmd.OB_STRING)
    elif myarg in SORF_MSG_FILE_ARGUMENTS:
      notify['message'], notify['charset'], notify['html'] = getStringOrFile(myarg)
    elif myarg == 'cc':
      ccRecipients = getRecipients()
    elif myarg == 'bcc':
      bccRecipients = getRecipients()
    elif myarg == 'mailbox':
      mailBox = getString(Cmd.OB_EMAIL_ADDRESS)
    elif myarg == 'singlemessage':
      singleMessage = True
    elif myarg == 'html':
      notify['html'] = getBoolean()
    elif myarg == 'newuser':
      body['primaryEmail'] = getEmailAddress()
    elif myarg in {'firstname', 'givenname'}:
      body.setdefault('name', {})
      body['name']['givenName'] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
    elif myarg in {'lastname', 'familyname'}:
      body.setdefault('name', {})
      body['name']['familyName'] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
    elif myarg in {'password', 'notifypassword'}:
      body['password'] = notify['password'] = getString(Cmd.OB_PASSWORD, maxLen=100)
    elif myarg == 'replace':
      _getTagReplacement(tagReplacements, False)
    elif myarg == 'attach':
      attachments.append((getFilename(), getCharSet()))
    else:
      unknownArgumentExit()
  notify['message'] = notify['message'].replace('\r', '').replace('\\n', '\n')
  if tagReplacements['tags']:
    notify['message'] = _processTagReplacements(tagReplacements, notify['message'])
  if tagReplacements['tags']:
    notify['subject'] = _processTagReplacements(tagReplacements, notify['subject'])
  jcount = len(recipients)
  if body.get('primaryEmail'):
    if ((jcount == 1) and recipients[0] and
        ('password' in body) and ('name' in body) and ('givenName' in body['name']) and ('familyName' in body['name'])):
      notify['emailAddress'] = recipients[0]
      sendCreateUpdateUserNotification(body, notify, tagReplacements, msgFrom=msgFroms[0])
    else:
      usageErrorExit(Msg.NEWUSER_REQUIREMENTS, True)
    return
  if ccRecipients or bccRecipients:
    singleMessage = True
  if users is not None:
    i, count, msgFroms = getEntityArgument(users)
  else:
    i = 0
    count = len(msgFroms)
  for msgFrom in msgFroms:
    i += 1
    if singleMessage:
      entityPerformActionModifierNumItems([Ent.USER, msgFrom],
                                          Act.MODIFIER_TO, jcount+len(ccRecipients)+len(bccRecipients), Ent.RECIPIENT, i, count)
      send_email(notify['subject'], notify['message'], ','.join(recipients), i, count,
                 msgFrom=msgFrom, msgReplyTo=msgReplyTo, html=notify['html'], charset=notify['charset'],
                 attachments=attachments, ccRecipients=','.join(ccRecipients), bccRecipients=','.join(bccRecipients), mailBox=mailBox)
    else:
      entityPerformActionModifierNumItems([Ent.USER, msgFrom], Act.MODIFIER_TO, jcount, Ent.RECIPIENT, i, count)
      Ind.Increment()
      j = 0
      for recipient in recipients:
        j += 1
        send_email(notify['subject'], notify['message'], recipient, j, jcount,
                   msgFrom=msgFrom, msgReplyTo=msgReplyTo, html=notify['html'], charset=notify['charset'],
                   attachments=attachments, mailBox=mailBox)
      Ind.Decrement()

ADDRESS_FIELDS_PRINT_ORDER = ['contactName', 'organizationName', 'addressLine1', 'addressLine2', 'addressLine3', 'locality', 'region', 'postalCode', 'countryCode']

def _showCustomerAddressPhoneNumber(customerInfo):
  if 'postalAddress' in customerInfo:
    printKeyValueList(['Address', None])
    Ind.Increment()
    for field in ADDRESS_FIELDS_PRINT_ORDER:
      if field in customerInfo['postalAddress']:
        printKeyValueList([field, customerInfo['postalAddress'][field]])
    Ind.Decrement()
  if 'phoneNumber' in customerInfo:
    printKeyValueList(['Phone', customerInfo['phoneNumber']])

ADDRESS_FIELDS_ARGUMENT_MAP = {
  'contact': 'contactName', 'contactname': 'contactName',
  'name': 'organizationName', 'organizationname': 'organizationName',
  'address': 'addressLine1', 'address1': 'addressLine1', 'addressline1': 'addressLine1',
  'address2': 'addressLine2', 'addressline2': 'addressLine2',
  'address3': 'addressLine3', 'addressline3': 'addressLine3',
  'city': 'locality', 'locality': 'locality',
  'state': 'region', 'region': 'region',
  'zipcode': 'postalCode', 'postal': 'postalCode', 'postalcode': 'postalCode',
  'country': 'countryCode', 'countrycode': 'countryCode',
  }

def _getResoldCustomerAttr():
  body = {}
  customerAuthToken = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADDRESS_FIELDS_ARGUMENT_MAP:
      body.setdefault('postalAddress', {})
      body['postalAddress'][ADDRESS_FIELDS_ARGUMENT_MAP[myarg]] = getString(Cmd.OB_STRING, minLen=0, maxLen=255)
    elif myarg in {'email', 'alternateemail'}:
      body['alternateEmail'] = getEmailAddress(noUid=True)
    elif myarg in {'phone', 'phonenumber'}:
      body['phoneNumber'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in {'customerauthtoken', 'transfertoken'}:
      customerAuthToken = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return customerAuthToken, body

# gam create resoldcustomer <CustomerDomain> (customer_auth_token <String>) <ResoldCustomerAttribute>+
def doCreateResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerDomain = getString('customerDomain')
  customerAuthToken, body = _getResoldCustomerAttr()
  body['customerDomain'] = customerDomain
  try:
    result = callGAPI(res.customers(), 'insert',
                      throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      body=body, customerAuthToken=customerAuthToken, fields='customerId')
    entityActionPerformed([Ent.CUSTOMER_DOMAIN, body['customerDomain'], Ent.CUSTOMER_ID, result['customerId']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_DOMAIN, body['customerDomain']], str(e))

# gam update resoldcustomer <CustomerID> [customer_auth_token <String>] <ResoldCustomerAttribute>+
def doUpdateResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  customerAuthToken, body = _getResoldCustomerAttr()
  try:
    callGAPI(res.customers(), 'patch',
             throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerId=customerId, body=body, customerAuthToken=customerAuthToken, fields='')
    entityActionPerformed([Ent.CUSTOMER_ID, customerId])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

# gam info resoldcustomer <CustomerID>
def doInfoResoldCustomer():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  checkForExtraneousArguments()
  try:
    customerInfo = callGAPI(res.customers(), 'get',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId)
    printKeyValueList(['Customer ID', customerInfo['customerId']])
    printKeyValueList(['Customer Domain', customerInfo['customerDomain']])
    printKeyValueList(['Customer Domain Verified', customerInfo['customerDomainVerified']])
    _showCustomerAddressPhoneNumber(customerInfo)
    printKeyValueList(['Customer Alternate Email', customerInfo['alternateEmail']])
    printKeyValueList(['Customer Admin Console URL', customerInfo['resourceUiUrl']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

def getCustomerSubscription(res):
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  skuId = getString(Cmd.OB_SKU_ID)
  try:
    subscriptions = callGAPIpages(res.subscriptions(), 'list', 'subscriptions',
                                  throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  customerId=customerId, fields='nextPageToken,subscriptions(skuId,subscriptionId)')
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.SUBSCRIPTION, None], str(e))
    sys.exit(GM.Globals[GM.SYSEXITRC])
  for subscription in subscriptions:
    if skuId == subscription['skuId']:
      return (customerId, skuId, subscription['subscriptionId'])
  Cmd.Backup()
  usageErrorExit(f'{Ent.FormatEntityValueList([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])}, {Msg.SUBSCRIPTION_NOT_FOUND}')

PLAN_NAME_MAP = {
  'annualmonthlypay': 'ANNUAL_MONTHLY_PAY',
  'annualyearlypay': 'ANNUAL_YEARLY_PAY',
  'flexible': 'FLEXIBLE',
  'trial': 'TRIAL',
  }

def _getResoldSubscriptionAttr(customerId):
  body = {'customerId': customerId,
          'plan': {},
          'seats': {},
          'skuId': None,
         }
  customerAuthToken = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'deal', 'dealcode'}:
      body['dealCode'] = getString('dealCode')
    elif myarg in {'plan', 'planname'}:
      body['plan']['planName'] = getChoice(PLAN_NAME_MAP, mapChoice=True)
    elif myarg in {'purchaseorderid', 'po'}:
      body['purchaseOrderId'] = getString('purchaseOrderId')
    elif myarg == 'seats':
      body['seats']['numberOfSeats'] = getInteger(minVal=0)
      body['seats']['maximumNumberOfSeats'] = getInteger(minVal=0)
    elif myarg in {'sku', 'skuid'}:
      _, body['skuId'] = SKU.getProductAndSKU(getString(Cmd.OB_SKU_ID))
    elif myarg in {'customerauthtoken', 'transfertoken'}:
      customerAuthToken = getString('customer_auth_token')
    else:
      unknownArgumentExit()
  for field in ['plan', 'seats', 'skuId']:
    if not body[field]:
      missingArgumentExit(field.lower())
  return customerAuthToken, body

SUBSCRIPTION_SKIP_OBJECTS = {'customerId', 'skuId', 'subscriptionId'}
SUBSCRIPTION_TIME_OBJECTS = {'creationTime', 'startTime', 'endTime', 'trialEndTime', 'transferabilityExpirationTime'}

def _showSubscription(subscription):
  Ind.Increment()
  printEntity([Ent.SUBSCRIPTION, subscription['subscriptionId']])
  showJSON(None, subscription, SUBSCRIPTION_SKIP_OBJECTS, SUBSCRIPTION_TIME_OBJECTS)
  Ind.Decrement()

# gam create resoldsubscription <CustomerID> (sku <SKUID>)
#	 (plan annual_monthly_pay|annual_yearly_pay|flexible|trial) (seats <NumberOfSeats> <MaximumNumberOfSeats>)
#	 [customer_auth_token <String>] [deal <String>] [purchaseorderid <String>]
def doCreateResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId = getString(Cmd.OB_CUSTOMER_ID)
  customerAuthToken, body = _getResoldSubscriptionAttr(customerId)
  try:
    subscription = callGAPI(res.subscriptions(), 'insert',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, customerAuthToken=customerAuthToken, body=body)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, subscription['skuId']])
    _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

RENEWAL_TYPE_MAP = {
  'autorenewmonthlypay': 'AUTO_RENEW_MONTHLY_PAY',
  'autorenewyearlypay': 'AUTO_RENEW_YEARLY_PAY',
  'cancel': 'CANCEL',
  'renewcurrentusersmonthlypay': 'RENEW_CURRENT_USERS_MONTHLY_PAY',
  'renewcurrentusersyearlypay': 'RENEW_CURRENT_USERS_YEARLY_PAY',
  'switchtopayasyougo': 'SWITCH_TO_PAY_AS_YOU_GO',
  }

# gam update resoldsubscription <CustomerID> <SKUID>
#	activate|suspend|startpaidservice|
#	(renewal auto_renew_monthly_pay|auto_renew_yearly_pay|cancel|renew_current_users_monthly_pay|renew_current_users_yearly_pay|switch_to_pay_as_you_go)|
#	(seats <NumberOfSeats> [<MaximumNumberOfSeats>])|
#	(plan annual_monthly_pay|annual_yearly_pay|flexible|trial [deal <String>] [purchaseorderid <String>] [seats <NumberOfSeats> [<MaximumNumberOfSeats>]])
def doUpdateResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  function = None
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  kwargs = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'activate':
      function = 'activate'
    elif myarg == 'suspend':
      function = 'suspend'
    elif myarg == 'startpaidservice':
      function = 'startPaidService'
    elif myarg in {'renewal', 'renewaltype'}:
      function = 'changeRenewalSettings'
      kwargs['body'] = {'renewalType': getChoice(RENEWAL_TYPE_MAP, mapChoice=True)}
    elif myarg == 'seats':
      function = 'changeSeats'
      kwargs['body'] = {'numberOfSeats': getInteger(minVal=0)}
      if Cmd.ArgumentsRemaining() and Cmd.Current().isdigit():
        kwargs['body']['maximumNumberOfSeats'] = getInteger(minVal=0)
    elif myarg == 'plan':
      function = 'changePlan'
      kwargs['body'] = {'planName': getChoice(PLAN_NAME_MAP, mapChoice=True)}
      while Cmd.ArgumentsRemaining():
        planarg = getArgument()
        if planarg == 'seats':
          kwargs['body']['seats'] = {'numberOfSeats': getInteger(minVal=0)}
          if Cmd.ArgumentsRemaining() and Cmd.Current().isdigit():
            kwargs['body']['seats']['maximumNumberOfSeats'] = getInteger(minVal=0)
        elif planarg in {'purchaseorderid', 'po'}:
          kwargs['body']['purchaseOrderId'] = getString('purchaseOrderId')
        elif planarg in {'dealcode', 'deal'}:
          kwargs['body']['dealCode'] = getString('dealCode')
        else:
          unknownArgumentExit()
    else:
      unknownArgumentExit()
  try:
    subscription = callGAPI(res.subscriptions(), function,
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, subscriptionId=subscriptionId, **kwargs)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
    if subscription:
      _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId], str(e))

DELETION_TYPE_MAP = {
  'cancel': 'cancel',
  'downgrade': 'downgrade',
  'transfertodirect': 'transfer_to_direct',
  }

# gam delete resoldsubscription <CustomerID> <SKUID> cancel|downgrade|transfer_to_direct
def doDeleteResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  deletionType = getChoice(DELETION_TYPE_MAP, mapChoice=True)
  checkForExtraneousArguments()
  try:
    callGAPI(res.subscriptions(), 'delete',
             throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customerId=customerId, subscriptionId=subscriptionId, deletionType=deletionType)
    entityActionPerformed([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId], str(e))

# gam info resoldsubscription <CustomerID> <SKUID>
def doInfoResoldSubscription():
  res = buildGAPIObject(API.RESELLER)
  customerId, skuId, subscriptionId = getCustomerSubscription(res)
  checkForExtraneousArguments()
  try:
    subscription = callGAPI(res.subscriptions(), 'get',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=customerId, subscriptionId=subscriptionId)
    printEntity([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId])
    _showSubscription(subscription)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.CUSTOMER_ID, customerId, Ent.SKU, skuId], str(e))

PRINT_RESOLD_SUBSCRIPTIONS_TITLES = ['customerId', 'skuId', 'subscriptionId']

# gam print resoldsubscriptions [todrive <ToDriveAttribute>*] [customerid <CustomerID>] [customer_auth_token <String>] [customer_prefix <String>]
# gam show resoldsubscriptions [customerid <CustomerID>] [customer_auth_token <String>] [customer_prefix <String>]
def doPrintShowResoldSubscriptions():
  res = buildGAPIObject(API.RESELLER)
  kwargs = {}
  csvPF = CSVPrintFile(PRINT_RESOLD_SUBSCRIPTIONS_TITLES, 'sortall') if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'customerid':
      kwargs['customerId'] = getString(Cmd.OB_CUSTOMER_ID)
    elif myarg in {'customerauthtoken', 'transfertoken'}:
      kwargs['customerAuthToken'] = getString(Cmd.OB_CUSTOMER_AUTH_TOKEN)
    elif myarg == 'customerprefix':
      kwargs['customerNamePrefix'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  try:
    subscriptions = callGAPIpages(res.subscriptions(), 'list', 'subscriptions',
                                  throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  fields='nextPageToken,subscriptions', **kwargs)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.SUBSCRIPTION, None], str(e))
    return
  jcount = len(subscriptions)
  if not csvPF:
    performActionNumItems(jcount, Ent.SUBSCRIPTION)
    Ind.Increment()
    j = 0
    for subscription in subscriptions:
      j += 1
      printEntity([Ent.CUSTOMER_ID, subscription['customerId'], Ent.SKU, subscription['skuId']], j, jcount)
      _showSubscription(subscription)
    Ind.Decrement()
  else:
    for subscription in subscriptions:
      csvPF.WriteRowTitles(flattenJSON(subscription, timeObjects=SUBSCRIPTION_TIME_OBJECTS))
    csvPF.writeCSVfile('Resold Subscriptions')

# gam create domainalias|aliasdomain <DomainAlias> <DomainName>
def doCreateDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {'domainAliasName': getString(Cmd.OB_DOMAIN_ALIAS)}
  body['parentDomainName'] = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), 'insert',
             throwReasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
    entityActionPerformed([Ent.DOMAIN, body['parentDomainName'], Ent.DOMAIN_ALIAS, body['domainAliasName']])
  except GAPI.domainNotFound:
    entityActionFailedWarning([Ent.DOMAIN, body['parentDomainName']], Msg.DOES_NOT_EXIST)
  except GAPI.duplicate:
    entityActionFailedWarning([Ent.DOMAIN, body['parentDomainName'], Ent.DOMAIN_ALIAS, body['domainAliasName']], Msg.DUPLICATE)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete domainalias|aliasdomain <DomainAlias>
def doDeleteDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  domainAliasName = getString(Cmd.OB_DOMAIN_ALIAS)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domainAliases(), 'delete',
             throwReasons=[GAPI.DOMAIN_ALIAS_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], domainAliasName=domainAliasName)
    entityActionPerformed([Ent.DOMAIN_ALIAS, domainAliasName])
  except GAPI.domainAliasNotFound:
    entityActionFailedWarning([Ent.DOMAIN_ALIAS, domainAliasName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

DOMAIN_TIME_OBJECTS = {'creationTime'}
DOMAIN_ALIAS_PRINT_ORDER = ['parentDomainName', 'creationTime', 'verified']
DOMAIN_ALIAS_SKIP_OBJECTS = {'domainAliasName'}

def _showDomainAlias(alias, FJQC, aliasSkipObjects, i=0, count=0):
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(alias, timeObjects=DOMAIN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.DOMAIN_ALIAS, alias['domainAliasName']], i, count)
  Ind.Increment()
  if 'creationTime' in alias:
    alias['creationTime'] = formatLocalTimestamp(alias['creationTime'])
  for field in DOMAIN_ALIAS_PRINT_ORDER:
    if field in alias:
      printKeyValueList([field, alias[field]])
      aliasSkipObjects.add(field)
  showJSON(None, alias, aliasSkipObjects)
  Ind.Decrement()

# gam info domainalias|aliasdomain <DomainAlias> [formatjson]
def doInfoDomainAlias():
  cd = buildGAPIObject(API.DIRECTORY)
  domainAliasName = getString(Cmd.OB_DOMAIN_ALIAS)
  FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  try:
    result = callGAPI(cd.domainAliases(), 'get',
                      throwReasons=[GAPI.DOMAIN_ALIAS_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      customer=GC.Values[GC.CUSTOMER_ID], domainAliasName=domainAliasName)
    aliasSkipObjects = DOMAIN_ALIAS_SKIP_OBJECTS
    _showDomainAlias(result, FJQC, aliasSkipObjects)
  except GAPI.domainAliasNotFound:
    entityActionFailedWarning([Ent.DOMAIN_ALIAS, domainAliasName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

def _printDomain(domain, csvPF):
  row = {}
  for attr in domain:
    if attr not in DEFAULT_SKIP_OBJECTS:
      if attr in DOMAIN_TIME_OBJECTS:
        row[attr] = formatLocalTimestamp(domain[attr])
      else:
        row[attr] = domain[attr]
      csvPF.AddTitles(attr)
  csvPF.WriteRow(row)

DOMAIN_ALIAS_SORT_TITLES = ['domainAliasName', 'parentDomainName', 'creationTime', 'verified']

# gam print domainaliases [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam show domainaliases [formatjson]
def doPrintShowDomainAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['domainAliasName'], DOMAIN_ALIAS_SORT_TITLES) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  try:
    domainAliases = callGAPIitems(cd.domainAliases(), 'list', 'domainAliases',
                                  throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                  customer=GC.Values[GC.CUSTOMER_ID])
    count = len(domainAliases)
    i = 0
    for domainAlias in domainAliases:
      i += 1
      if not csvPF:
        aliasSkipObjects = DOMAIN_ALIAS_SKIP_OBJECTS
        _showDomainAlias(domainAlias, FJQC, aliasSkipObjects, i, count)
      elif not FJQC.formatJSON:
        _printDomain(domainAlias, csvPF)
      else:
        csvPF.WriteRowNoFilter({'domainAliasName': domainAlias['domainAliasName'],
                                'JSON': json.dumps(cleanJSON(domainAlias, timeObjects=DOMAIN_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvPF:
    csvPF.writeCSVfile('Domain Aliases')

# gam create domain <DomainName>
def doCreateDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {'domainName': getString(Cmd.OB_DOMAIN_NAME)}
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), 'insert',
             throwReasons=[GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
    entityActionPerformed([Ent.DOMAIN, body['domainName']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.DOMAIN, body['domainName']])
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam update domain <DomainName> primary
def doUpdateDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'primary':
      body['customerDomain'] = domainName
    else:
      unknownArgumentExit()
  if not body:
    missingArgumentExit('primary')
  try:
    callGAPI(cd.customers(), 'update',
             throwReasons=[GAPI.DOMAIN_NOT_VERIFIED_SECONDARY, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_INPUT],
             customerKey=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
    entityActionPerformedMessage([Ent.DOMAIN, domainName], Msg.NOW_THE_PRIMARY_DOMAIN)
  except GAPI.domainNotVerifiedSecondary:
    entityActionFailedWarning([Ent.DOMAIN, domainName], Msg.DOMAIN_NOT_VERIFIED_SECONDARY)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden, GAPI.invalidInput):
    accessErrorExit(cd)

# gam delete domain <DomainName>
def doDeleteDomain():
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.domains(), 'delete',
             throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], domainName=domainName)
    entityActionPerformed([Ent.DOMAIN, domainName])
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

CUSTOMER_LICENSE_MAP = {
  'accounts:num_users': 'Total Users',
  'accounts:gsuite_basic_total_licenses': 'G Suite Basic Licenses',
  'accounts:gsuite_basic_used_licenses': 'G Suite Basic Users',
  'accounts:gsuite_enterprise_total_licenses': 'G Suite Enterprise Licenses',
  'accounts:gsuite_enterprise_used_licenses': 'G Suite Enterprise Users',
  'accounts:gsuite_unlimited_total_licenses': 'G Suite Business Licenses',
  'accounts:gsuite_unlimited_used_licenses': 'G Suite Business Users',
  'accounts:vault_total_licenses': 'Google Vault Licenses',
  }

def _showCustomerLicenseInfo(customerInfo, FJQC):
  def numUsersAvailable(usage):
    if usage and 'parameters' in usage[0]:
      for item in usage[0]['parameters']:
        if item['name'] == 'accounts:num_users':
          return True
    return False

  rep = buildGAPIObject(API.REPORTS)
  parameters = ','.join(CUSTOMER_LICENSE_MAP)
  tryDate = todaysDate().strftime(YYYYMMDD_FORMAT)
  dataRequiredServices = {'accounts'}
  while True:
    try:
      result = callGAPI(rep.customerUsageReports(), 'get',
                        throwReasons=[GAPI.INVALID, GAPI.FORBIDDEN],
                        date=tryDate, customerId=customerInfo['id'], fields='warnings,usageReports', parameters=parameters)
      warnings = result.get('warnings', [])
      usage = result.get('usageReports', [])
      if numUsersAvailable(usage):
        break
      hasReports = bool(usage)
      fullData, tryDate = _checkDataRequiredServices(warnings, tryDate, dataRequiredServices, hasReports)
      if fullData < 0:
        printWarningMessage(DATA_NOT_AVALIABLE_RC, Msg.NO_USER_COUNTS_DATA_AVAILABLE)
        return
      if fullData == 0:
        continue
      break
    except GAPI.invalid as e:
      tryDate = _adjustTryDate(str(e), False)
      if not tryDate:
        return
      continue
    except GAPI.forbidden:
      return
  if not FJQC.formatJSON:
    printKeyValueList([f'User counts as of {tryDate}:'])
    Ind.Increment()
  for item in usage[0]['parameters']:
    api_name = CUSTOMER_LICENSE_MAP.get(item['name'])
    api_value = int(item.get('intValue', '0'))
    if api_name and api_value:
      if not FJQC.formatJSON:
        printKeyValueList([api_name, f'{api_value:,}'])
      else:
        customerInfo[item['name']] = api_value
  if not FJQC.formatJSON:
    Ind.Decrement()

def setTrueCustomerId(cd=None):
  if GC.Values[GC.CUSTOMER_ID] == GC.MY_CUSTOMER:
    if not cd:
      cd = buildGAPIObject(API.DIRECTORY)
    try:
      customerInfo = callGAPI(cd.customers(), 'get',
                              throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                              customerKey=GC.MY_CUSTOMER,
                              fields='id')
      GC.Values[GC.CUSTOMER_ID] = customerInfo['id']
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      pass

# gam info customer [formatjson]
def doInfoCustomer(returnCustomerInfo=None, FJQC=None):
  cd = buildGAPIObject(API.DIRECTORY)
  if FJQC is None:
    FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  try:
    customerInfo = callGAPI(cd.customers(), 'get',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerKey=GC.Values[GC.CUSTOMER_ID])
    try:
      customerInfo['verified'] = callGAPI(cd.domains(), 'get',
                                          throwReasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                          customer=customerInfo['id'], domainName=customerInfo['customerDomain'], fields='verified')['verified']
    except GAPI.domainNotFound:
      customerInfo['verified'] = False
    # From Jay Lee
    # If customer has changed primary domain, customerCreationTime is date of current primary being added, not customer create date.
    # We should get all domains and use oldest date
    customerCreationTime = formatLocalTime(customerInfo['customerCreationTime'])
    domains = callGAPIitems(cd.domains(), 'list', 'domains',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                            customer=GC.Values[GC.CUSTOMER_ID], fields='domains(creationTime)')
    for domain in domains:
      domainCreationTime = formatLocalTimestamp(domain['creationTime'])
      if domainCreationTime < customerCreationTime:
        customerCreationTime = domainCreationTime
    customerInfo['customerCreationTime'] = customerCreationTime
    if FJQC.formatJSON:
      _showCustomerLicenseInfo(customerInfo, FJQC)
      if returnCustomerInfo is not None:
        returnCustomerInfo.update(customerInfo)
        return
      printLine(json.dumps(cleanJSON(customerInfo), ensure_ascii=False, sort_keys=True))
      return
    printKeyValueList(['Customer ID', customerInfo['id']])
    printKeyValueList(['Primary Domain', customerInfo['customerDomain']])
    printKeyValueList(['Customer Creation Time', customerInfo['customerCreationTime']])
    printKeyValueList(['Primary Domain Verified', customerInfo['verified']])
    printKeyValueList(['Default Language', customerInfo.get('language', 'Unset (defaults to en)')])
    _showCustomerAddressPhoneNumber(customerInfo)
    printKeyValueList(['Admin Secondary Email', customerInfo['alternateEmail']])
    _showCustomerLicenseInfo(customerInfo, FJQC)
  except (GAPI.badRequest, GAPI.domainNotFound, GAPI.notFound, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam update customer [primary <DomainName>] [adminsecondaryemail|alternateemail <EmailAddress>] [language <LanguageCode] [phone|phonenumber <String>]
#	[contact|contactname <String>] [name|organizationname <String>]
#	[address1|addressline1 <String>] [address2|addressline2 <String>] [address3|addressline3 <String>]
#	[locality <String>] [region <String>] [postalcode <String>] [country|countrycode <String>]
def doUpdateCustomer():
  cd = buildGAPIObject(API.DIRECTORY)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADDRESS_FIELDS_ARGUMENT_MAP:
      body.setdefault('postalAddress', {})
      body['postalAddress'][ADDRESS_FIELDS_ARGUMENT_MAP[myarg]] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == 'primary':
      body['customerDomain'] = getString(Cmd.OB_DOMAIN_NAME)
    elif myarg in {'adminsecondaryemail', 'alternateemail'}:
      body['alternateEmail'] = getEmailAddress(noUid=True)
    elif myarg in {'phone', 'phonenumber'}:
      body['phoneNumber'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == 'language':
      body['language'] = getLanguageCode()
    else:
      unknownArgumentExit()
  if body:
    try:
      callGAPI(cd.customers(), 'patch',
               throwReasons=[GAPI.DOMAIN_NOT_VERIFIED_SECONDARY, GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerKey=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
      entityActionPerformed([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID]])
    except GAPI.domainNotVerifiedSecondary:
      entityActionFailedWarning([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID], Ent.DOMAIN, body['customerDomain']], Msg.DOMAIN_NOT_VERIFIED_SECONDARY)
    except (GAPI.invalid, GAPI.invalidInput) as e:
      entityActionFailedWarning([Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID]], str(e))
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      accessErrorExit(cd)

# gam info instance [formatjson]
def doInfoInstance():
  FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  customerInfo = None if not FJQC.formatJSON else {}
  doInfoCustomer(customerInfo, FJQC)
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(customerInfo), ensure_ascii=False, sort_keys=True))

DOMAIN_PRINT_ORDER = ['customerDomain', 'creationTime', 'isPrimary', 'verified']
DOMAIN_SKIP_OBJECTS = {'domainName', 'domainAliases'}

def _showDomain(result, FJQC, i=0, count=0):
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(result, timeObjects=DOMAIN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  skipObjects = DOMAIN_SKIP_OBJECTS
  printEntity([Ent.DOMAIN, result['domainName']], i, count)
  Ind.Increment()
  if 'creationTime' in result:
    result['creationTime'] = formatLocalTimestamp(result['creationTime'])
  for field in DOMAIN_PRINT_ORDER:
    if field in result:
      printKeyValueList([field, result[field]])
      skipObjects.add(field)
  field = 'domainAliases'
  aliases = result.get(field)
  if aliases:
    skipObjects.add(field)
    aliasSkipObjects = DOMAIN_ALIAS_SKIP_OBJECTS
    for alias in aliases:
      _showDomainAlias(alias, FJQC, aliasSkipObjects)
      showJSON(None, alias, aliasSkipObjects)
  showJSON(None, result, skipObjects)
  Ind.Decrement()

# gam info domain [<DomainName>] [formatjson]
def doInfoDomain():
  if (not Cmd.ArgumentsRemaining()) or (Cmd.Current().lower() == 'formatjson'):
    doInfoInstance()
    return
  cd = buildGAPIObject(API.DIRECTORY)
  domainName = getString(Cmd.OB_DOMAIN_NAME)
  FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  try:
    result = callGAPI(cd.domains(), 'get',
                      throwReasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      customer=GC.Values[GC.CUSTOMER_ID], domainName=domainName)
    _showDomain(result, FJQC)
  except GAPI.domainNotFound:
    entityActionFailedWarning([Ent.DOMAIN, domainName], Msg.DOES_NOT_EXIST)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

DOMAIN_SORT_TITLES = ['domainName', 'parentDomainName', 'creationTime', 'type', 'verified']

# gam print domains [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam show domains [formatjson]
def doPrintShowDomains():
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['domainName'], DOMAIN_SORT_TITLES) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  try:
    domains = callGAPIitems(cd.domains(), 'list', 'domains',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                            customer=GC.Values[GC.CUSTOMER_ID])
    count = len(domains)
    i = 0
    for domain in domains:
      i += 1
      if not csvPF:
        _showDomain(domain, FJQC, i, count)
      elif not FJQC.formatJSON:
        domain['type'] = 'primary' if domain.pop('isPrimary') else 'secondary'
        domainAliases = domain.pop('domainAliases', [])
        _printDomain(domain, csvPF)
        for domainAlias in domainAliases:
          domainAlias['type'] = 'alias'
          domainAlias['domainName'] = domainAlias.pop('domainAliasName')
          _printDomain(domainAlias, csvPF)
      else:
        csvPF.WriteRowNoFilter({'domainName': domain['domainName'],
                                'JSON': json.dumps(cleanJSON(domain, timeObjects=DOMAIN_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvPF:
    csvPF.writeCSVfile('Domains')

PRINT_PRIVILEGES_FIELDS = ['serviceId', 'serviceName', 'privilegeName', 'isOuScopable', 'childPrivileges']

def _listPrivileges(cd):
  fields = f'items({",".join(PRINT_PRIVILEGES_FIELDS)})'
  try:
    return callGAPIitems(cd.privileges(), 'list', 'items',
                         throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                         customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam print privileges [todrive <ToDriveAttribute>*]
# gam show privileges
def doPrintShowPrivileges():
  def _showPrivilege(privilege, i, count):
    printEntity([Ent.PRIVILEGE, privilege['privilegeName']], i, count)
    Ind.Increment()
    printKeyValueList(['serviceId', privilege['serviceId']])
    printKeyValueList(['serviceName', privilege.get('serviceName', 'Unknown')])
    printKeyValueList(['isOuScopable', privilege['isOuScopable']])
    jcount = len(privilege.get('childPrivileges', []))
    if jcount > 0:
      printKeyValueList(['childPrivileges', jcount])
      Ind.Increment()
      j = 0
      for childPrivilege in privilege['childPrivileges']:
        j += 1
        _showPrivilege(childPrivilege, j, jcount)
      Ind.Decrement()
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(PRINT_PRIVILEGES_FIELDS, 'sortall') if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  privileges = _listPrivileges(cd)
  if not csvPF:
    count = len(privileges)
    performActionNumItems(count, Ent.PRIVILEGE)
    Ind.Increment()
    i = 0
    for privilege in privileges:
      i += 1
      _showPrivilege(privilege, i, count)
    Ind.Decrement()
  else:
    for privilege in privileges:
      csvPF.WriteRowTitles(flattenJSON(privilege))
  if csvPF:
    csvPF.writeCSVfile('Privileges')

def makeRoleIdNameMap():
  GM.Globals[GM.MAKE_ROLE_ID_NAME_MAP] = False
  cd = buildGAPIObject(API.DIRECTORY)
  try:
    result = callGAPIpages(cd.roles(), 'list', 'items',
                           throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                           customer=GC.Values[GC.CUSTOMER_ID],
                           fields='nextPageToken,items(roleId,roleName)',
                           maxResults=100)
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  for role in result:
    GM.Globals[GM.MAP_ROLE_ID_TO_NAME][role['roleId']] = role['roleName']
    GM.Globals[GM.MAP_ROLE_NAME_TO_ID][role['roleName']] = role['roleId']

def role_from_roleid(roleid):
  if GM.Globals[GM.MAKE_ROLE_ID_NAME_MAP]:
    makeRoleIdNameMap()
  return GM.Globals[GM.MAP_ROLE_ID_TO_NAME].get(roleid, roleid)

def roleid_from_role(role):
  if GM.Globals[GM.MAKE_ROLE_ID_NAME_MAP]:
    makeRoleIdNameMap()
  return GM.Globals[GM.MAP_ROLE_NAME_TO_ID].get(role, None)

def getRoleId():
  role = getString(Cmd.OB_ROLE_ITEM)
  cg = UID_PATTERN.match(role)
  if cg:
    roleId = cg.group(1)
  else:
    roleId = roleid_from_role(role)
    if not roleId:
      invalidChoiceExit(role, GM.Globals[GM.MAP_ROLE_NAME_TO_ID], True)
  return (role, roleId)

# gam create adminrole <String> privileges all|all_ou|<PrivilegesList> [description <String>]
# gam update adminrole <RoleItem> [name <String>] [privileges all|all_ou|<PrivilegesList>] [description <String>]
def doCreateUpdateAdminRoles():
  cd = buildGAPIObject(API.DIRECTORY)
  updateCmd = Act.Get() == Act.UPDATE
  if not updateCmd:
    body = {'roleName': getString(Cmd.OB_STRING)}
  else:
    body = {}
    _, roleId = getRoleId()
  privileges = _listPrivileges(cd)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'privileges':
      privs = getString(Cmd.OB_PRIVILEGE_LIST).upper()
      if privs == 'ALL':
        body['rolePrivileges'] = [{'privilegeName': p['privilegeName'], 'serviceId': p['serviceId']} for p in privileges]
      elif privs == 'ALL_OU':
        body['rolePrivileges'] = [{'privilegeName': p['privilegeName'], 'serviceId': p['serviceId']} for p in privileges if p.get('isOuScopable')]
      else:
        body.setdefault('rolePrivileges', [])
        privs = privs.split(',')
        for priv in privs:
          for p in privileges:
            if priv == p['privilegeName']:
              body['rolePrivileges'].append({'privilegeName': p['privilegeName'], 'serviceId': p['serviceId']})
              break
          else:
            invalidChoiceExit(priv, [p['privilegeName'] for p in privileges], True)
    elif myarg == 'description':
      body['roleDescription'] = getString(Cmd.OB_STRING)
    elif myarg == 'name':
      body['roleName'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  if not updateCmd and not body.get('rolePrivileges'):
    missingArgumentExit('privileges')
  try:
    if not updateCmd:
      result = callGAPI(cd.roles(), 'insert',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN]+[GAPI.DUPLICATE],
                        customer=GC.Values[GC.CUSTOMER_ID], body=body, fields='roleId,roleName')
    else:
      result = callGAPI(cd.roles(), 'patch',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN]+[GAPI.NOT_FOUND],
                        customer=GC.Values[GC.CUSTOMER_ID], roleId=roleId, body=body, fields='roleId,roleName')
    entityActionPerformed([Ent.ROLE, f"{result['roleName']}({result['roleId']})"])
  except GAPI.duplicate as e:
    entityActionFailedWarning([Ent.ROLE, f"{body['roleName']}"], str(e))
  except (GAPI.notFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.ROLE, f"{roleId}"], str(e))
  except (GAPI.badRequest, GAPI.customerNotFound):
    accessErrorExit(cd)

# gam delete adminrole <RoleItem>
def doDeleteAdminRole():
  cd = buildGAPIObject(API.DIRECTORY)
  role, roleId = getRoleId()
  checkForExtraneousArguments()
  try:
    callGAPI(cd.roles(), 'delete',
             throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN]+[GAPI.NOT_FOUND],
             customer=GC.Values[GC.CUSTOMER_ID], roleId=roleId)
    entityActionPerformed([Ent.ROLE, f"{role}({roleId})"])
  except (GAPI.notFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.ROLE, f"{roleId}"], str(e))
  except (GAPI.badRequest, GAPI.customerNotFound):
    accessErrorExit(cd)

PRINT_ADMIN_ROLES_FIELDS = ['roleId', 'roleName', 'roleDescription', 'isSuperAdminRole', 'isSystemRole']

# gam print adminroles|roles [todrive <ToDriveAttribute>*] [privileges]
# gam show adminroles|roles [privileges]
def doPrintShowAdminRoles():
  cd = buildGAPIObject(API.DIRECTORY)
  fieldsList = PRINT_ADMIN_ROLES_FIELDS[:]
  csvPF = CSVPrintFile(fieldsList, PRINT_ADMIN_ROLES_FIELDS) if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'privileges':
      if csvPF:
        csvPF.AddField(myarg, {myarg: 'rolePrivileges'}, fieldsList)
      else:
        fieldsList.append('rolePrivileges')
    else:
      unknownArgumentExit()
  fields = getItemFieldsFromFieldsList('items', fieldsList)
  try:
    roles = callGAPIpages(cd.roles(), 'list', 'items',
                          throwReasons=[GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                          customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  for role in roles:
    role.setdefault('isSuperAdminRole', False)
    role.setdefault('isSystemRole', False)
  if not csvPF:
    count = len(roles)
    performActionNumItems(count, Ent.ROLE)
    Ind.Increment()
    i = 0
    for role in roles:
      i += 1
      printEntity([Ent.ROLE, role['roleName']], i, count)
      Ind.Increment()
      for field in PRINT_ADMIN_ROLES_FIELDS:
        if field != 'roleName' and field in role:
          printKeyValueList([field, role[field]])
      jcount = len(role.get('rolePrivileges', []))
      if jcount > 0:
        printKeyValueList(['rolePrivileges', jcount])
        Ind.Increment()
        j = 0
        for rolePrivilege in role['rolePrivileges']:
          j += 1
          printKeyValueList(['privilegeName', rolePrivilege['privilegeName']])
          Ind.Increment()
          printKeyValueList(['serviceId', rolePrivilege['serviceId']])
          Ind.Decrement()
        Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  else:
    for role in roles:
      csvPF.WriteRowTitles(flattenJSON(role))
  if csvPF:
    csvPF.writeCSVfile('Admin Roles')

ADMIN_SCOPE_TYPE_CHOICE_MAP = {'customer': 'CUSTOMER', 'orgunit': 'ORG_UNIT', 'org': 'ORG_UNIT', 'ou': 'ORG_UNIT'}

# gam create admin <UserItem> <RoleItem> customer|(org_unit <OrgUnitItem>)
def doCreateAdmin():
  cd = buildGAPIObject(API.DIRECTORY)
  user = getEmailAddress()
  body = {'assignedTo': convertEmailAddressToUID(user, cd)}
  role, roleId = getRoleId()
  body['roleId'] = roleId
  body['scopeType'] = getChoice(ADMIN_SCOPE_TYPE_CHOICE_MAP, mapChoice=True)
  if body['scopeType'] == 'ORG_UNIT':
    orgUnit, orgUnitId = getOrgUnitId(cd)
    body['orgUnitId'] = orgUnitId[3:]
    scope = f'ORG_UNIT {orgUnit}'
  else:
    scope = 'CUSTOMER'
  checkForExtraneousArguments()
  try:
    result = callGAPI(cd.roleAssignments(), 'insert',
                      throwReasons=[GAPI.INTERNAL_ERROR, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_ORGUNIT, GAPI.DUPLICATE],
                      customer=GC.Values[GC.CUSTOMER_ID], body=body, fields='roleAssignmentId')
    entityActionPerformedMessage([Ent.ROLE_ASSIGNMENT_ID, result['roleAssignmentId']],
                                 f'{Ent.Singular(Ent.USER)} {user}, {Ent.Singular(Ent.ROLE)} {role}, {Ent.Singular(Ent.SCOPE)} {scope}')
  except GAPI.internalError:
    pass
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  except GAPI.invalidOrgunit:
    entityActionFailedWarning([Ent.ADMINISTRATOR, user], Msg.INVALID_ORGUNIT)
  except GAPI.duplicate:
    entityActionFailedWarning([Ent.ADMINISTRATOR, user, Ent.ROLE, role], Msg.DUPLICATE)

# gam delete admin <RoleAssignmentId>
def doDeleteAdmin():
  cd = buildGAPIObject(API.DIRECTORY)
  roleAssignmentId = getString(Cmd.OB_ROLE_ASSIGNMENT_ID)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.roleAssignments(), 'delete',
             throwReasons=[GAPI.NOT_FOUND, GAPI.OPERATION_NOT_SUPPORTED, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], roleAssignmentId=roleAssignmentId)
    entityActionPerformed([Ent.ROLE_ASSIGNMENT_ID, roleAssignmentId])
  except (GAPI.notFound, GAPI.operationNotSupported, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.ROLE_ASSIGNMENT_ID, roleAssignmentId], str(e))
  except (GAPI.badRequest, GAPI.customerNotFound):
    accessErrorExit(cd)

PRINT_ADMIN_FIELDS = 'nextPageToken,items(roleAssignmentId,roleId,assignedTo,scopeType,orgUnitId)'
PRINT_ADMIN_TITLES = ['roleAssignmentId', 'roleId', 'role', 'assignedTo', 'assignedToUser', 'scopeType', 'orgUnitId', 'orgUnit']

# gam print admins [todrive <ToDriveAttribute>*] [user <UserItem>] [role <RoleItem>]
# gam show admins [user <UserItem>] [role <RoleItem>]
def doPrintShowAdmins():
  def _setNamesFromIds(admin):
    admin['assignedToUser'] = convertUserIDtoEmail(admin['assignedTo'], cd)
    admin['role'] = role_from_roleid(admin['roleId'])
    if 'orgUnitId' in admin:
      admin['orgUnit'] = convertOrgUnitIDtoPath(f'id:{admin["orgUnitId"]}', cd)

  cd = buildGAPIObject(API.DIRECTORY)
  roleId = None
  userKey = None
  csvPF = CSVPrintFile(PRINT_ADMIN_TITLES) if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'user':
      userKey = getEmailAddress()
    elif myarg == 'role':
      _, roleId = getRoleId()
    else:
      unknownArgumentExit()
  try:
    admins = callGAPIpages(cd.roleAssignments(), 'list', 'items',
                           throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.CUSTOMER_NOT_FOUND, GAPI.FORBIDDEN],
                           customer=GC.Values[GC.CUSTOMER_ID], userKey=userKey, roleId=roleId, fields=PRINT_ADMIN_FIELDS)
  except GAPI.invalid:
    entityUnknownWarning(Ent.USER, userKey)
    return
  except (GAPI.badRequest, GAPI.customerNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if not csvPF:
    count = len(admins)
    performActionNumItems(count, Ent.ROLE_ASSIGNMENT_ID)
    Ind.Increment()
    i = 0
    for admin in admins:
      i += 1
      _setNamesFromIds(admin)
      printEntity([Ent.ROLE_ASSIGNMENT_ID, admin['roleAssignmentId']], i, count)
      Ind.Increment()
      for field in PRINT_ADMIN_TITLES:
        if field != 'roleAssignmentId' and field in admin:
          printKeyValueList([field, admin[field]])
      Ind.Decrement()
    Ind.Decrement()
  else:
    for admin in admins:
      _setNamesFromIds(admin)
      csvPF.WriteRow(flattenJSON(admin))
  if csvPF:
    csvPF.writeCSVfile('Admins')

def getTransferApplications(dt):
  try:
    return callGAPIpages(dt.applications(), 'list', 'applications',
                         throwReasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                         customerId=GC.Values[GC.CUSTOMER_ID], fields='applications(id,name,transferParams)')
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)

def _convertTransferAppIDtoName(apps, appID):
  for app in apps:
    if appID == app['id']:
      return app['name']
  return f'applicationId: {appID}'

CALENDAR_APP_NAME = 'Calendar'
DRIVE_AND_DOCS_APP_NAME = 'Drive and Docs'

SERVICE_NAME_CHOICE_MAP = {
  'calendar': CALENDAR_APP_NAME,
  'drive': DRIVE_AND_DOCS_APP_NAME,
  'drive and docs': DRIVE_AND_DOCS_APP_NAME,
  'googledrive': DRIVE_AND_DOCS_APP_NAME,
  'gdrive': DRIVE_AND_DOCS_APP_NAME,
  }

def _validateTransferAppName(apps, appName):
  appName = appName.strip().lower()
  if appName in SERVICE_NAME_CHOICE_MAP:
    appName = SERVICE_NAME_CHOICE_MAP[appName].lower()
  appNameList = []
  for app in apps:
    if appName == app['name'].lower():
      return (app['name'], app['id'])
    appNameList.append(app['name'].lower())
  invalidChoiceExit(appName, appNameList, True)

PRIVACY_LEVEL_CHOICE_MAP = {
  'private': ['PRIVATE'],
  'shared': ['SHARED'],
  'all': ['PRIVATE', 'SHARED'],
  }

# gam create datatransfer|transfer <OldOwnerID> <ServiceNameList> <NewOwnerID> [private|shared|all] [release_resources] (<ParameterKey> <ParameterValue>)*
def doCreateDataTransfer():
  def _assignAppParameter(key, value, doubleBackup=False):
    for app in apps:
      for params in app.get('transferParams', []):
        if key == params['key']:
          appIndex = appIndicies.get(app['id'])
          if appIndex is not None:
            body['applicationDataTransfers'][appIndex].setdefault('applicationTransferParams', [])
            body['applicationDataTransfers'][appIndex]['applicationTransferParams'].append({'key': key, 'value': value})
            return
          break
    Cmd.Backup()
    if doubleBackup:
      Cmd.Backup()
    usageErrorExit(Msg.NO_DATA_TRANSFER_APP_FOR_PARAMETER.format(key))

  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  old_owner = getEmailAddress()
  body = {'oldOwnerUserId': convertEmailAddressToUID(old_owner)}
  appIndicies = {}
  appNameList = []
  i = 0
  body['applicationDataTransfers'] = []
  for appName in getString(Cmd.OB_SERVICE_NAME_LIST).split(','):
    appName, appId = _validateTransferAppName(apps, appName)
    body['applicationDataTransfers'].append({'applicationId': appId})
    appIndicies[appId] = i
    i += 1
    appNameList.append(appName)
  new_owner = getEmailAddress()
  body['newOwnerUserId'] = convertEmailAddressToUID(new_owner)
  if body['oldOwnerUserId'] == body['newOwnerUserId']:
    Cmd.Backup()
    usageErrorExit(Msg.NEW_OWNER_MUST_DIFFER_FROM_OLD_OWNER)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in PRIVACY_LEVEL_CHOICE_MAP:
      _assignAppParameter('PRIVACY_LEVEL', PRIVACY_LEVEL_CHOICE_MAP[myarg])
    elif myarg == 'releaseresources':
      if getBoolean():
        _assignAppParameter('RELEASE_RESOURCES', ['TRUE'])
    else:
      _assignAppParameter(Cmd.Previous().upper(), getString(Cmd.OB_PARAMETER_VALUE).upper().split(','), True)
  result = callGAPI(dt.transfers(), 'insert',
                    body=body, fields='id')
  entityActionPerformed([Ent.TRANSFER_REQUEST, None])
  Ind.Increment()
  printEntity([Ent.TRANSFER_ID, result['id']])
  printEntity([Ent.SERVICE, ','.join(appNameList)])
  printKeyValueList([Msg.FROM, old_owner])
  printKeyValueList([Msg.TO, new_owner])
  Ind.Decrement()

def _showTransfer(apps, transfer, i, count):
  printEntity([Ent.TRANSFER_ID, transfer['id']], i, count)
  Ind.Increment()
  printKeyValueList(['Request Time', formatLocalTime(transfer['requestTime'])])
  printKeyValueList(['Old Owner', convertUserIDtoEmail(transfer['oldOwnerUserId'])])
  printKeyValueList(['New Owner', convertUserIDtoEmail(transfer['newOwnerUserId'])])
  printKeyValueList(['Overall Transfer Status', transfer['overallTransferStatusCode']])
  for app in transfer['applicationDataTransfers']:
    printKeyValueList(['Application', _convertTransferAppIDtoName(apps, app['applicationId'])])
    Ind.Increment()
    printKeyValueList(['Status', app['applicationTransferStatus']])
    printKeyValueList(['Parameters'])
    Ind.Increment()
    if 'applicationTransferParams' in app:
      for param in app['applicationTransferParams']:
        key = param['key']
        value = param.get('value', [])
        if value:
          printKeyValueList([key, ','.join(value)])
        else:
          printKeyValueList([key])
    else:
      printKeyValueList(['None'])
    Ind.Decrement()
    Ind.Decrement()
  Ind.Decrement()

# gam info datatransfer|transfer <TransferID>
def doInfoDataTransfer():
  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  dtId = getString(Cmd.OB_TRANSFER_ID)
  checkForExtraneousArguments()
  try:
    transfer = callGAPI(dt.transfers(), 'get',
                        throwReasons=[GAPI.NOT_FOUND],
                        dataTransferId=dtId)
    _showTransfer(apps, transfer, 0, 0)
  except GAPI.notFound:
    entityActionFailedWarning([Ent.TRANSFER_ID, dtId], Msg.DOES_NOT_EXIST)

DATA_TRANSFER_STATUS_MAP = {
  'completed': 'completed',
  'failed': 'failed',
  'pending': 'pending',
  'inprogress': 'inProgress',
  }
DATA_TRANSFER_SORT_TITLES = ['id', 'requestTime', 'oldOwnerUserEmail', 'newOwnerUserEmail',
                             'overallTransferStatusCode', 'application', 'applicationId', 'status']

# gam print datatransfers|transfers [todrive <ToDriveAttribute>*] [olduser|oldowner <UserItem>] [newuser|newowner <UserItem>] [status <String>] [delimiter <Character>]]
# gam show datatransfers|transfers [olduser|oldowner <UserItem>] [newuser|newowner <UserItem>] [status <String>] [delimiter <Character>]]
def doPrintShowDataTransfers():
  dt = buildGAPIObject(API.DATATRANSFER)
  apps = getTransferApplications(dt)
  newOwnerUserId = None
  oldOwnerUserId = None
  status = None
  csvPF = CSVPrintFile(['id'], DATA_TRANSFER_SORT_TITLES) if Act.csvFormat() else None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'olduser', 'oldowner'}:
      oldOwnerUserId = convertEmailAddressToUID(getEmailAddress())
    elif myarg in {'newuser', 'newowner'}:
      newOwnerUserId = convertEmailAddressToUID(getEmailAddress())
    elif myarg == 'status':
      status = getChoice(DATA_TRANSFER_STATUS_MAP, mapChoice=True)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  try:
    transfers = callGAPIpages(dt.transfers(), 'list', 'dataTransfers',
                              throwReasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                              customerId=GC.Values[GC.CUSTOMER_ID], status=status,
                              newOwnerUserId=newOwnerUserId, oldOwnerUserId=oldOwnerUserId)
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)
  if not csvPF:
    count = len(transfers)
    performActionNumItems(count, Ent.TRANSFER_REQUEST)
    Ind.Increment()
    i = 0
    for transfer in sorted(transfers, key=lambda k: k['requestTime']):
      i += 1
      _showTransfer(apps, transfer, i, count)
    Ind.Decrement()
  else:
    for transfer in sorted(transfers, key=lambda k: k['requestTime']):
      row = {}
      row['id'] = transfer['id']
      row['requestTime'] = formatLocalTime(transfer['requestTime'])
      row['oldOwnerUserEmail'] = convertUserIDtoEmail(transfer['oldOwnerUserId'])
      row['newOwnerUserEmail'] = convertUserIDtoEmail(transfer['newOwnerUserId'])
      row['overallTransferStatusCode'] = transfer['overallTransferStatusCode']
      for app in transfer['applicationDataTransfers']:
        xrow = row.copy()
        xrow['application'] = _convertTransferAppIDtoName(apps, app['applicationId'])
        xrow['applicationId'] = app['applicationId']
        xrow['status'] = app['applicationTransferStatus']
        for param in app.get('applicationTransferParams', []):
          key = param['key']
          xrow[key] = delimiter.join(param.get('value', [] if key != 'RELEASE_RESOURCES' else ['TRUE']))
        csvPF.WriteRowTitles(xrow)
  if csvPF:
    csvPF.writeCSVfile('Data Transfers')

# gam show transferapps
def doShowTransferApps():
  dt = buildGAPIObject(API.DATATRANSFER)
  checkForExtraneousArguments()
  Act.Set(Act.SHOW)
  try:
    apps = callGAPIpages(dt.applications(), 'list', 'applications',
                         throwReasons=[GAPI.UNKNOWN_ERROR, GAPI.FORBIDDEN],
                         customerId=GC.Values[GC.CUSTOMER_ID], fields='applications(id,name,transferParams)')
  except (GAPI.unknownError, GAPI.forbidden):
    accessErrorExit(None)
  count = len(apps)
  performActionNumItems(count, Ent.TRANSFER_APPLICATION)
  Ind.Increment()
  i = 0
  for app in apps:
    i += 1
    printKeyValueListWithCount([app['name']], i, count)
    Ind.Increment()
    printKeyValueList(['id', app['id']])
    transferParams = app.get('transferParams', [])
    if transferParams:
      printKeyValueList(['Parameters'])
      Ind.Increment()
      for param in transferParams:
        printKeyValueList(['key', param['key']])
        Ind.Increment()
        printKeyValueList(['value', ','.join(param['value'])])
        Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  Ind.Decrement()

# gam create org|ou <String> [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)] [buildpath]
def doCreateOrg():

  def _createOrg(body, parentPath, fullPath):
    try:
      callGAPI(cd.orgunits(), 'insert',
               throwReasons=[GAPI.INVALID_PARENT_ORGUNIT, GAPI.INVALID_ORGUNIT, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, fullPath])
    except GAPI.invalidParentOrgunit:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, fullPath, Ent.PARENT_ORGANIZATIONAL_UNIT, parentPath], Msg.ENTITY_DOES_NOT_EXIST.format(Ent.Singular(Ent.PARENT_ORGANIZATIONAL_UNIT)))
      return False
    except (GAPI.invalidOrgunit, GAPI.backendError):
      entityDuplicateWarning([Ent.ORGANIZATIONAL_UNIT, fullPath])
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, fullPath)
    return True

  cd = buildGAPIObject(API.DIRECTORY)
  name = getOrgUnitItem(pathOnly=True, absolutePath=False)
  parent = ''
  body = {}
  buildPath = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'description':
      body['description'] = getStringWithCRsNLs()
    elif myarg == 'parent':
      parent = getOrgUnitItem()
    elif myarg == 'noinherit':
      body['blockInheritance'] = True
    elif myarg == 'inherit':
      body['blockInheritance'] = False
    elif myarg in {'blockinheritance', 'inheritanceblocked'}:
      body['blockInheritance'] = getBoolean()
    elif myarg == 'buildpath':
      buildPath = True
    else:
      unknownArgumentExit()
  if parent.startswith('id:'):
    parentPath = None
    try:
      parentPath = callGAPI(cd.orgunits(), 'get',
                            throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=parent, fields='orgUnitPath')['orgUnitPath']
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      pass
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      errMsg = accessErrorMessage(cd)
      if errMsg:
        systemErrorExit(INVALID_DOMAIN_RC, errMsg)
    if not parentPath and not buildPath:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, name, Ent.PARENT_ORGANIZATIONAL_UNIT, parent], Msg.ENTITY_DOES_NOT_EXIST.format(Ent.Singular(Ent.PARENT_ORGANIZATIONAL_UNIT)))
      return
    parent = parentPath
  if parent == '/':
    orgUnitPath = parent+name
  else:
    orgUnitPath = parent+'/'+name
  if orgUnitPath.count('/') > 1:
    body['parentOrgUnitPath'], body['name'] = orgUnitPath.rsplit('/', 1)
  else:
    body['parentOrgUnitPath'] = '/'
    body['name'] = orgUnitPath[1:]
  parent = body['parentOrgUnitPath']
  if _createOrg(body, parent, orgUnitPath) or not buildPath:
    return
  description = body.pop('description', None)
  fullPath = '/'
  getPath = ''
  orgNames = orgUnitPath.split('/')
  n = len(orgNames)-1
  for i in range(1, n+1):
    body['parentOrgUnitPath'] = fullPath
    if fullPath != '/':
      fullPath += '/'
    fullPath += orgNames[i]
    if getPath != '':
      getPath += '/'
    getPath += orgNames[i]
    try:
      callGAPI(cd.orgunits(), 'get',
               throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(getPath), fields='')
      printKeyValueList([Ent.Singular(Ent.ORGANIZATIONAL_UNIT), fullPath, Msg.EXISTS])
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      body['name'] = orgNames[i]
      if i == n and description:
        body['description'] = description
      if not _createOrg(body, body['parentOrgUnitPath'], fullPath):
        return
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, fullPath)

def checkOrgUnitPathExists(cd, orgUnitPath, i=0, count=0, showError=False):
  if orgUnitPath == '/':
    return (True, orgUnitPath)
  try:
    return (True, callGAPI(cd.orgunits(), 'get',
                           throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                           customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)),
                           fields='orgUnitPath')['orgUnitPath'])
  except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
    pass
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    errMsg = accessErrorMessage(cd)
    if errMsg:
      systemErrorExit(INVALID_DOMAIN_RC, errMsg)
  if showError:
    entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
  return (False, orgUnitPath)

def _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, i, count, items, quickCrOSMove):
  def _callbackMoveCrOSesToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CROS_DEVICE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityItemValueAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  jcount = len(items)
  entityPerformActionNumItems([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], jcount, Ent.CROS_DEVICE, i, count)
  Ind.Increment()
  if not quickCrOSMove:
    svcargs = dict([('customerId', GC.Values[GC.CUSTOMER_ID]), ('deviceId', None), ('body', {'orgUnitPath': orgUnitPath}), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.chromeosdevices(), 'patch')
    dbatch = cd.new_batch_http_request(callback=_callbackMoveCrOSesToOrgUnit)
    bcount = 0
    j = 0
    for deviceId in items:
      j += 1
      svcparms = svcargs.copy()
      svcparms['deviceId'] = deviceId
      dbatch.add(method(**svcparms), request_id=batchRequestID('', 0, 0, j, jcount, deviceId))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackMoveCrOSesToOrgUnit)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
  else:
    bcount = 0
    j = 0
    while bcount < jcount:
      kcount = min(jcount-bcount, GC.Values[GC.BATCH_SIZE])
      try:
        deviceIds = items[bcount:bcount+kcount]
        callGAPI(cd.chromeosdevices(), 'moveDevicesToOu',
                 throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=orgUnitPath,
                 body={'deviceIds': deviceIds})
        for deviceId in deviceIds:
          j += 1
          entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CROS_DEVICE, deviceId], j, jcount)
        bcount += kcount
      except GAPI.invalidOrgunit:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.INVALID_ORGUNIT, i, count)
        break
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath, i, count)
  Ind.Decrement()

def _batchMoveUsersToOrgUnit(cd, orgUnitPath, i, count, items):
  _MOVE_USER_REASON_TO_MESSAGE_MAP = {GAPI.USER_NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.DOMAIN_NOT_FOUND: Msg.SERVICE_NOT_APPLICABLE, GAPI.FORBIDDEN: Msg.SERVICE_NOT_APPLICABLE}
  def _callbackMoveUsersToOrgUnit(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.USER, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      errMsg = getHTTPError(_MOVE_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.USER, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  jcount = len(items)
  entityPerformActionNumItems([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], jcount, Ent.USER, i, count)
  Ind.Increment()
  svcargs = dict([('userKey', None), ('body', {'orgUnitPath': orgUnitPath}), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
  method = getattr(cd.users(), 'update')
  dbatch = cd.new_batch_http_request(callback=_callbackMoveUsersToOrgUnit)
  bcount = 0
  j = 0
  for user in items:
    j += 1
    svcparms = svcargs.copy()
    svcparms['userKey'] = normalizeEmailAddressOrUID(user)
    dbatch.add(method(**svcparms), request_id=batchRequestID('', 0, 0, j, jcount, svcparms['userKey']))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = cd.new_batch_http_request(callback=_callbackMoveUsersToOrgUnit)
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  Ind.Decrement()

def _doUpdateOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent(['move', 'add']):
    entityType, items = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, crosAllowed=True)
    orgItemLists = items if isinstance(items, dict) else None
    quickCrOSMove = False
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if entityType == Cmd.ENTITY_CROS and myarg == 'quickcrosmove':
        quickCrOSMove = getBoolean()
      else:
        unknownArgumentExit()
    Act.Set(Act.ADD)
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      if orgItemLists:
        items = orgItemLists[orgUnitPath]
      status, orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath, i, count, True)
      if not status:
        continue
      if entityType == Cmd.ENTITY_USERS:
        _batchMoveUsersToOrgUnit(cd, orgUnitPath, i, count, items)
      else:
        _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, i, count, items, quickCrOSMove)
  elif checkArgumentPresent(['sync']):
    entityType, syncMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, crosAllowed=True)
    orgItemLists = syncMembers if isinstance(syncMembers, dict) else None
    if orgItemLists is None:
      syncMembersSet = set(syncMembers)
    removeToOrgUnitPath = '/'
    quickCrOSMove = False
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if entityType == Cmd.ENTITY_CROS and myarg == 'quickcrosmove':
        quickCrOSMove = getBoolean()
      elif myarg == 'removetoou':
        status, removeToOrgUnitPath = checkOrgUnitPathExists(cd, getOrgUnitItem())
        if not status:
          entityDoesNotExistExit(Ent.ORGANIZATIONAL_UNIT, removeToOrgUnitPath)
      else:
        unknownArgumentExit()
    Act.Set(Act.ADD)
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      if orgItemLists:
        syncMembersSet = set(orgItemLists[orgUnitPath])
      status, orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath, i, count, True)
      if not status:
        continue
      currentMembersSet = set(getUsersToModify(Cmd.ENTITY_OU, orgUnitPath))
      if entityType == Cmd.ENTITY_USERS:
        _batchMoveUsersToOrgUnit(cd, orgUnitPath, i, count, list(syncMembersSet-currentMembersSet))
        _batchMoveUsersToOrgUnit(cd, removeToOrgUnitPath, i, count, list(currentMembersSet-syncMembersSet))
      else:
        _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, i, count, list(syncMembersSet-currentMembersSet), quickCrOSMove)
        _batchMoveCrOSesToOrgUnit(cd, removeToOrgUnitPath, i, count, list(currentMembersSet-syncMembersSet), quickCrOSMove)
  else:
    body = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'name':
        body['name'] = getString(Cmd.OB_STRING)
      elif myarg == 'description':
        body['description'] = getStringWithCRsNLs()
      elif myarg == 'parent':
        parent = getOrgUnitItem()
        if parent.startswith('id:'):
          body['parentOrgUnitId'] = parent
        else:
          body['parentOrgUnitPath'] = parent
      elif myarg == 'noinherit':
        body['blockInheritance'] = True
      elif myarg == 'inherit':
        body['blockInheritance'] = False
      elif myarg in {'blockinheritance', 'inheritanceblocked'}:
        body['blockInheritance'] = getBoolean()
      else:
        unknownArgumentExit()
    i = 0
    count = len(entityList)
    for orgUnitPath in entityList:
      i += 1
      try:
        callGAPI(cd.orgunits(), 'update',
                 throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.INVALID_ORGUNIT_NAME,
                               GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                 customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)), body=body, fields='')
        entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
      except GAPI.invalidOrgunitName as e:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.NAME, body['name']], str(e), i, count)
      except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam update orgs|ous <OrgUnitEntity> [name <String>] [description <String>] [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update orgs|ous <OrgUnitEntity> add|move <CrosTypeEntity> [quickcrosmove [<Boolean>]]
# gam update orgs|ous <OrgUnitEntity> add|move <UserTypeEntity>
# gam update orgs|ous <OrgUnitEntity> sync <CrosTypeEntity> [removetoou <OrgUnitItem>] [quickcrosmove [<Boolean>]]
# gam update orgs|ous <OrgUnitEntity> sync <UserTypeEntity> [removetoou <OrgUnitItem>]
def doUpdateOrgs():
  _doUpdateOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam update org|ou <OrgUnitItem> [name <String>] [description <String>]  [parent <OrgUnitItem>] [inherit|noinherit|(blockinheritance <Boolean>)]
# gam update org|ou <OrgUnitItem> add|move <CrosTypeEntity> [quickcrosmove [<Boolean>]]
# gam update org|ou <OrgUnitItem> add|move <UserTypeEntity>
# gam update org|ou <OrgUnitItem> sync <CrosTypeEntity> [removetoou <OrgUnitItem>] [quickcrosmove [<Boolean>]]
# gam update org|ou <OrgUnitItem> sync <UserTypeEntity> [removetoou <OrgUnitItem>]
def doUpdateOrg():
  _doUpdateOrgs([getOrgUnitItem()])

def _doDeleteOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      orgUnitPath = makeOrgUnitPathAbsolute(orgUnitPath)
      callGAPI(cd.orgunits(), 'delete',
               throwReasons=[GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
               customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(makeOrgUnitPathRelative(orgUnitPath)))
      entityActionPerformed([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], i, count)
    except GAPI.conditionNotMet:
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.HAS_CHILD_ORGS.format(Ent.Plural(Ent.ORGANIZATIONAL_UNIT)), i, count)
    except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
    except GAPI.invalidCustomerId as e:
### Check for my_customer
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath, Ent.CUSTOMER_ID, GC.Values[GC.CUSTOMER_ID]], str(e), i, count)
    except (GAPI.badRequest, GAPI.loginRequired):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam delete orgs|ous <OrgUnitEntity>
def doDeleteOrgs():
  _doDeleteOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam delete org|ou <OrgUnitItem>
def doDeleteOrg():
  _doDeleteOrgs([getOrgUnitItem()])

SUSPENDED_ARGUMENTS = {'notsuspended', 'suspended', 'issuspended'}
SUSPENDED_CHOICE_MAP = {'notsuspended': False, 'suspended': True}
def _getIsSuspended(myarg):
  if myarg in SUSPENDED_CHOICE_MAP:
    return SUSPENDED_CHOICE_MAP[myarg]
  return getBoolean()

def _getOptionalIsSuspended():
  isSuspended = getChoice(SUSPENDED_CHOICE_MAP, defaultChoice=None, mapChoice=True)
  if isSuspended is not None:
    return isSuspended
  if checkArgumentPresent('issuspended'):
    return getBoolean()
  return None

ORG_FIELD_INFO_ORDER = ['orgUnitId', 'name', 'description', 'parentOrgUnitPath', 'parentOrgUnitId', 'blockInheritance']
ORG_FIELDS_WITH_CRS_NLS = {'description'}

def _doInfoOrgs(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  getUsers = True
  isSuspended = None
  entityType = Ent.USER
  showChildren = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'nousers':
      getUsers = False
    elif myarg in SUSPENDED_ARGUMENTS:
      isSuspended = _getIsSuspended(myarg)
      entityType = Ent.USER_SUSPENDED if isSuspended else Ent.USER_NOT_SUSPENDED
    elif myarg in {'children', 'child'}:
      showChildren = True
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for orgUnitPath in entityList:
    i += 1
    try:
      if orgUnitPath == '/':
        orgs = callGAPI(cd.orgunits(), 'list',
                        throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], type='children',
                        fields='organizationUnits(parentOrgUnitId)')
        if orgs.get('organizationUnits', []):
          orgUnitPath = orgs['organizationUnits'][0]['parentOrgUnitId']
        else:
          topLevelOrgId = getTopLevelOrgId(cd, '/')
          if topLevelOrgId:
            orgUnitPath = topLevelOrgId
      else:
        orgUnitPath = makeOrgUnitPathRelative(orgUnitPath)
      result = callGAPI(cd.orgunits(), 'get',
                        throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR,
                                      GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                        customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=encodeOrgUnitPath(orgUnitPath))
      printEntity([Ent.ORGANIZATIONAL_UNIT, result['orgUnitPath']], i, count)
      Ind.Increment()
      for field in ORG_FIELD_INFO_ORDER:
        value = result.get(field, None)
        if value is not None:
          if field not in ORG_FIELDS_WITH_CRS_NLS:
            printKeyValueList([field, value])
          else:
            printKeyValueWithCRsNLs(field, value)
      if getUsers:
        orgUnitPath = result['orgUnitPath']
        users = callGAPIpages(cd.users(), 'list', 'users',
                              throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_INPUT, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID], query=orgUnitPathQuery(orgUnitPath, isSuspended), orderBy='email',
                              fields='nextPageToken,users(primaryEmail,orgUnitPath)', maxResults=GC.Values[GC.USER_MAX_RESULTS])
        printEntitiesCount(entityType, users)
        Ind.Increment()
        orgUnitPath = orgUnitPath.lower()
        for user in users:
          if orgUnitPath == user['orgUnitPath'].lower():
            printKeyValueList([user['primaryEmail']])
          elif showChildren:
            printKeyValueList([f'{user["primaryEmail"]} (child)'])
        Ind.Decrement()
        printKeyValueList([Msg.TOTAL_ITEMS_IN_ENTITY.format(Ent.Plural(entityType), Ent.Singular(Ent.ORGANIZATIONAL_UNIT)), len(users)])
      Ind.Decrement()
    except (GAPI.invalidInput, GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError):
      entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)

# gam info orgs|ous <OrgUnitEntity> [nousers|notsuspended|suspended] [children|child]
def doInfoOrgs():
  _doInfoOrgs(getEntityList(Cmd.OB_ORGUNIT_ENTITY, shlexSplit=True))

# gam info org|ou <OrgUnitItem> [nousers|notsuspended|suspended] [children|child]
def doInfoOrg():
  _doInfoOrgs([getOrgUnitItem()])

ORG_ARGUMENT_TO_FIELD_MAP = {
  'blockinheritance': 'blockInheritance',
  'inheritanceblocked': 'blockInheritance',
  'inherit': 'blockInheritance',
  'description': 'description',
  'id': 'orgUnitId',
  'name': 'name',
  'orgunitid': 'orgUnitId',
  'orgunitpath': 'orgUnitPath',
  'path': 'orgUnitPath',
  'parentorgunitid': 'parentOrgUnitId',
  'parentid': 'parentOrgUnitId',
  'parentorgunitpath': 'parentOrgUnitPath',
  'parent': 'parentOrgUnitPath',
  }
ORG_FIELD_PRINT_ORDER = ['orgUnitPath', 'orgUnitId', 'name', 'description', 'parentOrgUnitPath', 'parentOrgUnitId', 'blockInheritance']
PRINT_ORGS_DEFAULT_FIELDS = ['orgUnitPath', 'orgUnitId', 'name', 'parentOrgUnitId']

def _getOrgUnits(cd, orgUnitPath, fieldsList, listType, showParent, batchSubOrgs):
  def _callbackListOrgUnits(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      orgUnits.extend(response.get('organizationUnits', []))
    else:
      http_status, reason, message = checkGAPIError(exception)
      errMsg = getHTTPError({}, http_status, reason, message)
      if reason not in GAPI.DEFAULT_RETRY_REASONS:
        if reason in [GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED]:
          accessErrorExit(cd)
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, topLevelOrgUnits[int(ri[RI_I])]], errMsg)
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.orgunits(), 'list',
                            throwReasons=[GAPI.ORGUNIT_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                            customerId=GC.Values[GC.CUSTOMER_ID], type='all', orgUnitPath=topLevelOrgUnits[int(ri[RI_I])], fields=listfields)
        orgUnits.extend(response.get('organizationUnits', []))
      except GAPI.orgunitNotFound:
        entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, topLevelOrgUnits[int(ri[RI_I])]], Msg.DOES_NOT_EXIST)
      except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        accessErrorExit(cd)

  def _batchListOrgUnits():
    svcargs = dict([('customerId', GC.Values[GC.CUSTOMER_ID]), ('orgUnitPath', None), ('type', 'all'), ('fields', listfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.orgunits(), 'list')
    dbatch = cd.new_batch_http_request(callback=_callbackListOrgUnits)
    bcount = 0
    i = 0
    for orgUnitPath in topLevelOrgUnits:
      svcparms = svcargs.copy()
      svcparms['orgUnitPath'] = orgUnitPath
      dbatch.add(method(**svcparms), request_id=batchRequestID('', i, 0, 0, 0, ''))
      bcount += 1
      i += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackListOrgUnits)
        bcount = 0
    if bcount > 0:
      dbatch.execute()

  deleteOrgUnitId = deleteParentOrgUnitId = False
  if showParent:
    localFieldsList = fieldsList[:]
    if 'orgUnitId' not in fieldsList:
      localFieldsList.append('orgUnitId')
      deleteOrgUnitId = True
    if 'parentOrgUnitId' not in fieldsList:
      localFieldsList.append('parentOrgUnitId')
      deleteParentOrgUnitId = True
    fields = ','.join(set(localFieldsList))
  else:
    fields = ','.join(set(fieldsList))
  listfields = f'organizationUnits({fields})'
  printGettingAllAccountEntities(Ent.ORGANIZATIONAL_UNIT)
  if listType == 'children':
    batchSubOrgs = False
  try:
    orgs = callGAPI(cd.orgunits(), 'list',
                    throwReasons=[GAPI.ORGUNIT_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                    customerId=GC.Values[GC.CUSTOMER_ID], type=listType if not batchSubOrgs else 'children', orgUnitPath=orgUnitPath, fields=listfields)
  except GAPI.orgunitNotFound:
    entityActionFailedWarning([Ent.ORGANIZATIONAL_UNIT, orgUnitPath], Msg.DOES_NOT_EXIST)
    return None
  except (GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
    accessErrorExit(cd)
  orgUnits = orgs.get('organizationUnits', [])
  topLevelOrgUnits = [orgUnit['orgUnitPath'] for orgUnit in orgUnits]
  if batchSubOrgs:
    _batchListOrgUnits()
  if showParent:
    parentOrgIds = []
    retrievedOrgIds = []
    if not orgUnits:
      topLevelOrgId = getTopLevelOrgId(cd, orgUnitPath)
      if topLevelOrgId:
        parentOrgIds.append(topLevelOrgId)
    for orgUnit in orgUnits:
      retrievedOrgIds.append(orgUnit['orgUnitId'])
      if orgUnit['parentOrgUnitId'] not in parentOrgIds:
        parentOrgIds.append(orgUnit['parentOrgUnitId'])
    missing_parents = set(parentOrgIds)-set(retrievedOrgIds)
    for missing_parent in missing_parents:
      try:
        result = callGAPI(cd.orgunits(), 'get',
                          throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.BAD_REQUEST, GAPI.INVALID_CUSTOMER_ID, GAPI.LOGIN_REQUIRED],
                          customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=missing_parent, fields=fields)
        orgUnits.append(result)
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.backendError,
              GAPI.badRequest, GAPI.invalidCustomerId, GAPI.loginRequired):
        pass
  printGotAccountEntities(len(orgUnits))
  if deleteOrgUnitId or deleteParentOrgUnitId:
    for orgUnit in orgUnits:
      if deleteOrgUnitId:
        orgUnit.pop('orgUnitId', None)
      if deleteParentOrgUnitId:
        orgUnit.pop('parentOrgUnitId', None)
  return orgUnits

# gam print orgs|ous [todrive <ToDriveAttribute>*] [fromparent <OrgUnitItem>] [showparent] [toplevelonly]
#	[allfields|<OrgUnitFieldName>*|(fields <OrgUnitFieldNameList>)] [convertcrnl] [batchsuborgs [<Boolean>]]
#	[mincroscount <Number>] [maxcroscount <Number>]
#	[minusercount <Number>] [maxusercount <Number>]
def doPrintOrgs():
  cd = buildGAPIObject(API.DIRECTORY)
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  fieldsList = []
  csvPF = CSVPrintFile(sortTitles=ORG_FIELD_PRINT_ORDER)
  orgUnitPath = '/'
  listType = 'all'
  batchSubOrgs = showParent = False
  minCrOSCounts = maxCrOSCounts = minUserCounts = maxUserCounts = -1
  crosCounts = {}
  userCounts = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'fromparent':
      orgUnitPath = getOrgUnitItem()
    elif myarg == 'showparent':
      showParent = getBoolean()
    elif myarg == 'mincroscount':
      minCrOSCounts = getInteger(minVal=-1)
    elif myarg == 'maxcroscount':
      maxCrOSCounts = getInteger(minVal=-1)
    elif myarg == 'minusercount':
      minUserCounts = getInteger(minVal=-1)
    elif myarg == 'maxusercount':
      maxUserCounts = getInteger(minVal=-1)
    elif myarg == 'batchsuborgs':
      batchSubOrgs = getBoolean()
    elif myarg == 'toplevelonly':
      listType = 'children'
    elif myarg == 'allfields':
      fieldsList = []
      csvPF.SetTitles(fieldsList)
      for field in ORG_FIELD_PRINT_ORDER:
        csvPF.AddField(field, ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
    elif myarg in ORG_ARGUMENT_TO_FIELD_MAP:
      if not fieldsList:
        csvPF.AddField('orgUnitPath', ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
      csvPF.AddField(myarg, ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
    elif myarg == 'fields':
      if not fieldsList:
        csvPF.AddField('orgUnitPath', ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
      for field in _getFieldsList():
        if field in ORG_ARGUMENT_TO_FIELD_MAP:
          csvPF.AddField(field, ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
        else:
          invalidChoiceExit(field, list(ORG_ARGUMENT_TO_FIELD_MAP), True)
    elif myarg in {'convertcrnl', 'converttextnl'}:
      convertCRNL = True
    else:
      unknownArgumentExit()
  showCrOSCounts = (minCrOSCounts >= 0 or maxCrOSCounts >= 0)
  showUserCounts = (minUserCounts >= 0 or maxUserCounts >= 0)
  if not fieldsList:
    for field in PRINT_ORGS_DEFAULT_FIELDS:
      csvPF.AddField(field, ORG_ARGUMENT_TO_FIELD_MAP, fieldsList)
  orgUnits = _getOrgUnits(cd, orgUnitPath, fieldsList, listType, showParent, batchSubOrgs)
  if orgUnits is None:
    return
  if showUserCounts:
    for orgUnit in orgUnits:
      userCounts[orgUnit['orgUnitPath']] = [0, 0]
    qualifier = Msg.IN_THE.format(Ent.Singular(Ent.ORGANIZATIONAL_UNIT))
    printGettingAllEntityItemsForWhom(Ent.USER, orgUnitPath, qualifier=qualifier, entityType=Ent.ORGANIZATIONAL_UNIT)
    pageMessage = getPageMessage()
    pageToken = None
    totalItems = 0
    while True:
      try:
        feed = callGAPI(cd.users(), 'list',
                        throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                      GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        pageToken=pageToken,
                        customer=GC.Values[GC.CUSTOMER_ID], query=orgUnitPathQuery(orgUnitPath, None),
                        fields='nextPageToken,users(orgUnitPath,suspended)', maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.invalidInput, GAPI.badRequest, GAPI.backendError,
              GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)
        break
      pageToken, totalItems = _processGAPIpagesResult(feed, 'users', None, totalItems, pageMessage, None, Ent.USER)
      if feed:
        for user in feed.get('users', []):
          if user['orgUnitPath'] in userCounts:
            userCounts[user['orgUnitPath']][user['suspended']] += 1
        del feed
      if not pageToken:
        _finalizeGAPIpagesResult(pageMessage)
        break
  for orgUnit in sorted(orgUnits, key=lambda k: k['orgUnitPath']):
    orgUnitPath = orgUnit['orgUnitPath']
    if showCrOSCounts:
      crosCounts[orgUnit['orgUnitPath']] = {}
      printGettingAllEntityItemsForWhom(Ent.CROS_DEVICE, orgUnitPath, entityType=Ent.ORGANIZATIONAL_UNIT)
      pageMessage = getPageMessage()
      pageToken = None
      totalItems = 0
      while True:
        try:
          feed = callGAPI(cd.chromeosdevices(), 'list', 'chromeosdevices',
                          throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.ORGUNIT_NOT_FOUND,
                                        GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          pageToken=pageToken,
                          customerId=GC.Values[GC.CUSTOMER_ID], orgUnitPath=orgUnitPath,
                          fields='nextPageToken,chromeosdevices(status)', maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        except (GAPI.invalidOrgunit, GAPI.orgunitNotFound, GAPI.invalidInput, GAPI.badRequest, GAPI.backendError,
                GAPI.invalidCustomerId, GAPI.loginRequired, GAPI.resourceNotFound, GAPI.forbidden):
          checkEntityDNEorAccessErrorExit(cd, Ent.ORGANIZATIONAL_UNIT, orgUnitPath)
          break
        pageToken, totalItems = _processGAPIpagesResult(feed, 'chromeosdevices', None, totalItems, pageMessage, None, Ent.CROS_DEVICE)
        if feed:
          for cros in feed.get('chromeosdevices', []):
            crosCounts[orgUnitPath].setdefault(cros['status'], 0)
            crosCounts[orgUnitPath][cros['status']] += 1
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          break
    row = {}
    for field in fieldsList:
      if convertCRNL and field in ORG_FIELDS_WITH_CRS_NLS:
        row[field] = escapeCRsNLs(orgUnit.get(field, ''))
      else:
        row[field] = orgUnit.get(field, '')
    if showCrOSCounts or showUserCounts:
      if showCrOSCounts:
        total = 0
        for k, v in sorted(iter(crosCounts[orgUnitPath].items())):
          row[f'CrOS.{k}'] = v
          total += v
        row['CrOS.Total'] = total
        if ((minCrOSCounts != -1 and total < minCrOSCounts) or
            (maxCrOSCounts != -1 and total > maxCrOSCounts)):
          continue
      if showUserCounts:
        row['Users.NotSuspended'] = userCounts[orgUnitPath][0]
        row['Users.Suspended'] = userCounts[orgUnitPath][1]
        row['Users.Total'] = total = userCounts[orgUnitPath][0]+userCounts[orgUnitPath][1]
        if ((minUserCounts != -1 and total < minUserCounts) or
            (maxUserCounts != -1 and total > maxUserCounts)):
          continue
      csvPF.WriteRowTitles(row)
    else:
      csvPF.WriteRow(row)
  csvPF.writeCSVfile('Orgs')

# gam show orgtree [fromparent <OrgUnitItem>] [batchsuborgs [Boolean>]]
def doShowOrgTree():
  def addOrgUnitToTree(orgPathList, i, n, tree):
    if orgPathList[i] not in tree:
      tree[orgPathList[i]] = {}
    if i < n:
      addOrgUnitToTree(orgPathList, i+1, n, tree[orgPathList[i]])

  def printOrgUnit(parentOrgUnit, tree):
    printKeyValueList([parentOrgUnit])
    Ind.Increment()
    for childOrgUnit in sorted(tree[parentOrgUnit]):
      printOrgUnit(childOrgUnit, tree[parentOrgUnit])
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  orgUnitPath = '/'
  fieldsList = ['orgUnitPath']
  listType = 'all'
  batchSubOrgs = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'fromparent':
      orgUnitPath = getOrgUnitItem()
    elif myarg == 'batchsuborgs':
      batchSubOrgs = getBoolean()
    else:
      unknownArgumentExit()
  orgUnits = _getOrgUnits(cd, orgUnitPath, fieldsList, listType, False, batchSubOrgs)
  if orgUnits is None:
    return
  orgTree = {}
  for orgUnit in orgUnits:
    orgPath = orgUnit['orgUnitPath'].split('/')
    addOrgUnitToTree(orgPath, 1, len(orgPath)-1, orgTree)
  for org in sorted(orgTree):
    printOrgUnit(org, orgTree)

ALIAS_TARGET_TYPES = ['user', 'group', 'target']

# gam create aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
# gam update aliases|nicknames <EmailAddressEntity> user|group|target <UniqueID>|<EmailAddress>
def doCreateUpdateAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  updateCmd = Act.Get() == Act.UPDATE
  aliasList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  targetType = getChoice(ALIAS_TARGET_TYPES)
  targetEmails = getEntityList(Cmd.OB_GROUP_ENTITY)
  entityLists = targetEmails if isinstance(targetEmails, dict) else None
  checkForExtraneousArguments()
  i = 0
  count = len(aliasList)
  for aliasEmail in aliasList:
    i += 1
    if entityLists:
      targetEmails = entityLists[aliasEmail]
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True, noLower=True)
    body = {'alias': aliasEmail}
    jcount = len(targetEmails)
    if jcount > 0:
# Only process first target
      targetEmail = normalizeEmailAddressOrUID(targetEmails[0])
      if updateCmd:
        try:
          callGAPI(cd.users().aliases(), 'delete',
                   throwReasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                 GAPI.CONDITION_NOT_MET],
                   userKey=aliasEmail, alias=aliasEmail)
          printEntityKVList([Ent.USER_ALIAS, aliasEmail], [Act.PerformedName(Act.DELETE)], i, count)
        except GAPI.conditionNotMet as e:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail], str(e), i, count)
          continue
        except (GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
          try:
            callGAPI(cd.groups().aliases(), 'delete',
                     throwReasons=[GAPI.GROUP_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                   GAPI.CONDITION_NOT_MET],
                     groupKey=aliasEmail, alias=aliasEmail)
          except GAPI.conditionNotMet as e:
            entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail], str(e), i, count)
            continue
          except GAPI.forbidden:
            entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
            continue
          except (GAPI.groupNotFound, GAPI.badRequest, GAPI.invalid, GAPI.invalidResource):
            entityUnknownWarning(Ent.ALIAS, aliasEmail, i, count)
      if targetType != 'group':
        try:
          callGAPI(cd.users().aliases(), 'insert',
                   throwReasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST,
                                 GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.FORBIDDEN, GAPI.DUPLICATE,
                                 GAPI.CONDITION_NOT_MET, GAPI.LIMIT_EXCEEDED],
                   userKey=targetEmail, body=body, fields='')
          entityActionPerformed([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], i, count)
          continue
        except (GAPI.conditionNotMet, GAPI.limitExceeded) as e:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], str(e), i, count)
          continue
        except GAPI.duplicate:
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], Msg.DUPLICATE, i, count)
          continue
        except (GAPI.invalid, GAPI.invalidInput):
          entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail, Ent.USER, targetEmail], Msg.INVALID_ALIAS, i, count)
          continue
        except (GAPI.userNotFound, GAPI.badRequest, GAPI.forbidden):
          if targetType == 'user':
            entityUnknownWarning(Ent.ALIAS_TARGET, targetEmail, i, count)
            continue
      try:
        callGAPI(cd.groups().aliases(), 'insert',
                 throwReasons=[GAPI.GROUP_NOT_FOUND, GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST,
                               GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.FORBIDDEN, GAPI.DUPLICATE,
                               GAPI.CONDITION_NOT_MET, GAPI.LIMIT_EXCEEDED],
                 groupKey=targetEmail, body=body, fields='')
        entityActionPerformed([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], i, count)
      except (GAPI.conditionNotMet, GAPI.limitExceeded) as e:
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], str(e), i, count)
      except GAPI.duplicate:
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], Msg.DUPLICATE, i, count)
      except (GAPI.invalid, GAPI.invalidInput):
        entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail, Ent.GROUP, targetEmail], Msg.INVALID_ALIAS, i, count)
      except (GAPI.groupNotFound, GAPI.userNotFound, GAPI.badRequest, GAPI.forbidden):
        entityUnknownWarning(Ent.ALIAS_TARGET, targetEmail, i, count)

# gam delete aliases|nicknames [user|group|target] <EmailAddressEntity>
def doDeleteAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  targetType = getChoice(ALIAS_TARGET_TYPES, defaultChoice='target')
  entityList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True)
    aliasDeleted = False
    if targetType != 'group':
      try:
        result = callGAPI(cd.users().aliases(), 'list',
                          throwReasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                        GAPI.CONDITION_NOT_MET],
                          userKey=aliasEmail, fields='aliases(alias)')
        for aliasEntry in result.get('aliases', []):
          if aliasEmail == aliasEntry['alias'].lower():
            aliasEmail = aliasEntry['alias']
            callGAPI(cd.users().aliases(), 'delete',
                     throwReasons=[GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                   GAPI.CONDITION_NOT_MET],
                     userKey=aliasEmail, alias=aliasEmail)
            entityActionPerformed([Ent.USER_ALIAS, aliasEmail], i, count)
            aliasDeleted = True
            break
        if aliasDeleted:
          continue
      except GAPI.conditionNotMet as e:
        entityActionFailedWarning([Ent.USER_ALIAS, aliasEmail], str(e), i, count)
        continue
      except (GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
        pass
      if targetType == 'user':
        entityUnknownWarning(Ent.USER_ALIAS, aliasEmail, i, count)
        continue
    try:
      result = callGAPI(cd.groups().aliases(), 'list',
                        throwReasons=[GAPI.GROUP_NOT_FOUND, GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                      GAPI.CONDITION_NOT_MET],
                        groupKey=aliasEmail, fields='aliases(alias)')
      for aliasEntry in result.get('aliases', []):
        if aliasEmail == aliasEntry['alias'].lower():
          aliasEmail = aliasEntry['alias']
          callGAPI(cd.groups().aliases(), 'delete',
                   throwReasons=[GAPI.GROUP_NOT_FOUND, GAPI.USER_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_RESOURCE,
                                 GAPI.CONDITION_NOT_MET],
                   groupKey=aliasEmail, alias=aliasEmail)
          entityActionPerformed([Ent.GROUP_ALIAS, aliasEmail], i, count)
          aliasDeleted = True
          break
      if aliasDeleted:
        continue
    except GAPI.conditionNotMet as e:
      entityActionFailedWarning([Ent.GROUP_ALIAS, aliasEmail], str(e), i, count)
      continue
    except (GAPI.groupNotFound, GAPI.userNotFound, GAPI.badRequest, GAPI.invalid, GAPI.forbidden, GAPI.invalidResource):
      pass
    if targetType == 'group':
      entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
      continue
    entityUnknownWarning(Ent.ALIAS, aliasEmail, i, count)

def infoAliases(entityList):

  def _showAliasInfo(uid, email, aliasEmail, entityType, aliasEntityType, i, count):
    if email.lower() != aliasEmail:
      printEntity([aliasEntityType, aliasEmail], i, count)
      Ind.Increment()
      printEntity([entityType, email])
      printEntity([Ent.UNIQUE_ID, uid])
      Ind.Decrement()
    else:
      setSysExitRC(ENTITY_IS_NOT_AN_ALIAS_RC)
      printEntityKVList([Ent.EMAIL, aliasEmail],
                        [f'Is a {Ent.Singular(entityType)}, not a {Ent.Singular(aliasEntityType)}'],
                        i, count)

  cd = buildGAPIObject(API.DIRECTORY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
# Ignore info group/user arguments that may have come from whatis
    if (myarg in INFO_GROUP_OPTIONS) or (myarg in INFO_USER_OPTIONS):
      if myarg == 'schemas':
        getString(Cmd.OB_SCHEMA_NAME_LIST)
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for aliasEmail in entityList:
    i += 1
    aliasEmail = normalizeEmailAddressOrUID(aliasEmail, noUid=True, noLower=True)
    try:
      result = callGAPI(cd.users(), 'get',
                        throwReasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=aliasEmail, fields='id,primaryEmail')
      _showAliasInfo(result['id'], result['primaryEmail'], aliasEmail, Ent.USER_EMAIL, Ent.USER_ALIAS, i, count)
      continue
    except (GAPI.userNotFound, GAPI.badRequest):
      pass
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER_ALIAS, aliasEmail, i, count)
      continue
    try:
      result = callGAPI(cd.groups(), 'get',
                        throwReasons=GAPI.GROUP_GET_THROW_REASONS,
                        groupKey=aliasEmail, fields='id,email')
      _showAliasInfo(result['id'], result['email'], aliasEmail, Ent.GROUP_EMAIL, Ent.GROUP_ALIAS, i, count)
      continue
    except GAPI.groupNotFound:
      pass
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      entityUnknownWarning(Ent.GROUP_ALIAS, aliasEmail, i, count)
      continue
    entityUnknownWarning(Ent.EMAIL, aliasEmail, i, count)

# gam info aliases|nicknames <EmailAddressEntity>
def doInfoAliases():
  infoAliases(getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY))

# gam print aliases|nicknames [todrive <ToDriveAttribute>*]
#	[(query <QueryUser>)|(queries <QueryUserList>)]
#	[aliasmatchpattern <RegularExpression>]
#	[shownoneditable] [nogroups] [nousers]
def doPrintAliases():
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile()
  titlesList = ['Alias', 'Target', 'TargetType']
  userFields = ['primaryEmail', 'aliases']
  groupFields = ['email', 'aliases']
  getGroups = getUsers = True
  queries = [None]
  aliasMatchPattern = re.compile(r'^.*$')
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'shownoneditable':
      titlesList.insert(1, 'NonEditableAlias')
      userFields.append('nonEditableAliases')
      groupFields.append('nonEditableAliases')
    elif myarg == 'nogroups':
      getGroups = False
    elif myarg == 'nousers':
      getUsers = False
    elif myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
      getGroups = False
      getUsers = True
    elif myarg == 'aliasmatchpattern':
      aliasMatchPattern = getREPattern(re.IGNORECASE)
    else:
      unknownArgumentExit()
  csvPF.SetTitles(titlesList)
  if getUsers:
    for query in queries:
      printGettingAllAccountEntities(Ent.USER, query)
      try:
        entityList = callGAPIpages(cd.users(), 'list', 'users',
                                   pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='primaryEmail',
                                   throwReasons=[GAPI.INVALID_ORGUNIT, GAPI.INVALID_INPUT,
                                                 GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                                   customer=GC.Values[GC.CUSTOMER_ID], query=query, orderBy='email',
                                   fields=f'nextPageToken,users({",".join(userFields)})',
                                   maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.invalidOrgunit, GAPI.invalidInput):
        entityActionFailedWarning([Ent.ALIAS, None], invalidQuery(query))
        return
      except (GAPI.resourceNotFound, GAPI.forbidden, GAPI.badRequest):
        accessErrorExit(cd)
      for user in entityList:
        for alias in user.get('aliases', []):
          if aliasMatchPattern.match(alias):
            csvPF.WriteRow({'Alias': alias, 'Target': user['primaryEmail'], 'TargetType': 'User'})
        for alias in user.get('nonEditableAliases', []):
          if aliasMatchPattern.match(alias):
            csvPF.WriteRow({'NonEditableAlias': alias, 'Target': user['primaryEmail'], 'TargetType': 'User'})
  if getGroups:
    printGettingAllAccountEntities(Ent.GROUP)
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='email',
                                 throwReasons=GAPI.GROUP_LIST_THROW_REASONS,
                                 customer=GC.Values[GC.CUSTOMER_ID], orderBy='email',
                                 fields=f'nextPageToken,groups({",".join(groupFields)})')
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      accessErrorExit(cd)
    for group in entityList:
      for alias in group.get('aliases', []):
        if aliasMatchPattern.match(alias):
          csvPF.WriteRow({'Alias': alias, 'Target': group['email'], 'TargetType': 'Group'})
      for alias in group.get('nonEditableAliases', []):
        if aliasMatchPattern.match(alias):
          csvPF.WriteRow({'NonEditableAlias': alias, 'Target': group['email'], 'TargetType': 'Group'})
  csvPF.writeCSVfile('Aliases')

# gam audit uploadkey [<FileName>]
def doUploadAuditKey():
  auditObject = getEmailAuditObject()
  if Cmd.ArgumentsRemaining():
    filename = getString(Cmd.OB_FILE_NAME)
    auditkey = readFile(filename, mode='rb')
  else:
    filename = 'Read from stdin'
    auditkey = sys.stdin.read().encode(UTF8)
  checkForExtraneousArguments()
  callGData(auditObject, 'updatePGPKey',
            pgpkey=auditkey)
  entityActionPerformed([Ent.PUBLIC_KEY, filename])

# Audit activity/export command utilities
def checkDownloadResults(results):
  if results['status'] != 'COMPLETED':
    printWarningMessage(REQUEST_NOT_COMPLETED_RC, Msg.REQUEST_NOT_COMPLETE.format(results['status']))
    return False
  if int(results.get('numberOfFiles', '0')) >= 1:
    return True
  printWarningMessage(REQUEST_COMPLETED_NO_RESULTS_RC, Msg.REQUEST_COMPLETED_NO_FILES)
  return False

# Audit command utilities
def getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False):
  auditObject = getEmailAuditObject()
  emailAddress = getEmailAddress(noUid=True, optional=not emailAddressRequired)
  parameters = {}
  if emailAddress:
    parameters['auditUser'] = emailAddress
    parameters['auditUserName'], auditObject.domain = splitEmailAddress(emailAddress)
    if requestIdRequired:
      parameters['requestId'] = getString(Cmd.OB_REQUEST_ID)
    if destUserRequired:
      destEmailAddress = getEmailAddress(noUid=True)
      parameters['auditDestUser'] = destEmailAddress
      parameters['auditDestUserName'], destDomain = splitEmailAddress(destEmailAddress)
      if auditObject.domain != destDomain:
        Cmd.Backup()
        invalidArgumentExit(f'{parameters["auditDestUserName"]}@{auditObject.domain}')
  return (auditObject, parameters)

def _showFileURLs(request):
  if 'numberOfFiles' in request:
    printKeyValueList(['Number Of Files', request['numberOfFiles']])
    Ind.Increment()
    for i in range(int(request['numberOfFiles'])):
      printKeyValueList([f'Url{i}', request['fileUrl'+str(i)]])
    Ind.Decrement()

# Audit export command utilities
def _showMailboxExportRequestStatus(request, i, count, showFilter=False, showDates=False, showFiles=False):
  printEntity([Ent.REQUEST_ID, request['requestId']], i, count)
  Ind.Increment()
  printEntity([Ent.USER, request['userEmailAddress']])
  printKeyValueList(['Status', request['status']])
  printKeyValueList(['Request Date', request['requestDate']])
  printKeyValueList(['Requested By', request['adminEmailAddress']])
  printKeyValueList(['Requested Parts', request['packageContent']])
  if showFilter:
    printKeyValueList(['Request Filter', request.get('searchQuery', 'None')])
  printKeyValueList(['Include Deleted', request['includeDeleted']])
  if showDates:
    printKeyValueList(['Begin', request.get('beginDate', 'Account creation date')])
    printKeyValueList(['End', request.get('endDate', 'Export request date')])
  if showFiles:
    _showFileURLs(request)
  Ind.Decrement()

# gam audit export request <EmailAddress> [begin <DateTime>] [end <DateTime>] [search <QueryGmail>] [headersonly] [includedeleted]
def doSubmitExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  begin_date = end_date = search_query = None
  headers_only = include_deleted = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == 'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == 'search':
      search_query = getString(Cmd.OB_QUERY)
    elif myarg == 'headersonly':
      headers_only = True
    elif myarg == 'includedeleted':
      include_deleted = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, 'createMailboxExportRequest',
                        throwErrors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                        user=parameters['auditUserName'], begin_date=begin_date, end_date=end_date, include_deleted=include_deleted,
                        search_query=search_query, headers_only=headers_only)
    entityActionPerformed([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, None])
    Ind.Increment()
    _showMailboxExportRequestStatus(request, 0, 0, showFilter=False, showDates=True, showFiles=False)
    Ind.Decrement()
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters['auditUser'])
  except GDATA.invalidValue as e:
    entityActionFailedWarning([Ent.USER, parameters['auditUser']], str(e))

# gam audit export delete <EmailAddress> <RequestID>
def doDeleteExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, 'deleteMailboxExportRequest',
              throwErrors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
              user=parameters['auditUserName'], request_id=parameters['requestId'])
    entityActionPerformed([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']])
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters['auditUser'])
  except GDATA.invalidValue:
    entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']], Msg.INVALID_REQUEST)

# gam audit export download <EmailAddress> <RequestID> [targetfolder <FilePath>]
def doDownloadExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  targetFolder = GC.Values[GC.DRIVE_DIR]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      unknownArgumentExit()
  try:
    results = callGData(auditObject, 'getMailboxExportRequestStatus',
                        throwErrors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                        user=parameters['auditUserName'], request_id=parameters['requestId'])
    if not checkDownloadResults(results):
      return
    count = int(results['numberOfFiles'])
    for i in range(count):
      filename = os.path.join(targetFolder, f'export-{parameters["auditUserName"]}-{parameters["requestId"]}-{i}.mbox.gpg')
      #don't download existing files. This does not check validity of existing local
      #file so partial/corrupt downloads will need to be deleted manually.
      if not os.path.isfile(filename):
        entityPerformActionInfo([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']], filename, i+1, count)
        _, data = getHttpObj().request(results['fileUrl'+str(i)], 'GET')
        writeFile(filename, data, mode='wb')
      else:
        entityActionNotPerformedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']],
                                        f'{filename} {Msg.EXISTS}', i+1, count)
  except (GDATA.invalidDomain, GDATA.doesNotExist):
    entityUnknownWarning(Ent.USER, parameters['auditUser'])
  except GDATA.invalidValue:
    entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']], Msg.INVALID_REQUEST)

# gam audit export status [<EmailAddress> <RequestID>]
def doStatusExportRequests():
  auditObject, parameters = getAuditParameters(emailAddressRequired=False, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  if parameters:
    try:
      results = [callGData(auditObject, 'getMailboxExportRequestStatus',
                           throwErrors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                           user=parameters['auditUserName'], request_id=parameters['requestId'])]
      jcount = 1 if (results) else 0
      entityPerformActionNumItems([Ent.USER, parameters['auditUser']], jcount, Ent.AUDIT_EXPORT_REQUEST)
    except (GDATA.invalidDomain, GDATA.doesNotExist):
      entityUnknownWarning(Ent.USER, parameters['auditUser'])
      return
    except GDATA.invalidValue:
      entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']], Msg.INVALID_REQUEST)
      return
  else:
    results = callGData(auditObject, 'getAllMailboxExportRequestsStatus')
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Ent.DOMAIN, GC.Values[GC.DOMAIN]], jcount, Ent.AUDIT_EXPORT_REQUEST)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  j = 0
  for request in results:
    j += 1
    _showMailboxExportRequestStatus(request, j, jcount, showFilter=True, showDates=False, showFiles=True)
  Ind.Decrement()

# gam audit export watch <EmailAddress> <RequestID>
def doWatchExportRequest():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=True, destUserRequired=False)
  checkForExtraneousArguments()
  while True:
    try:
      results = callGData(auditObject, 'getMailboxExportRequestStatus',
                          throwErrors=[GDATA.INVALID_DOMAIN, GDATA.DOES_NOT_EXIST, GDATA.INVALID_VALUE],
                          user=parameters['auditUserName'], request_id=parameters['requestId'])
    except (GDATA.invalidDomain, GDATA.doesNotExist):
      entityUnknownWarning(Ent.USER, parameters['auditUser'])
      break
    except GDATA.invalidValue:
      entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_EXPORT_REQUEST, parameters['requestId']], Msg.INVALID_REQUEST)
      break
    if results['status'] != 'PENDING':
      printKeyValueList(['Status is', results['status'], 'Sending email.'])
      msg_txt = '\n'
      msg_txt += f'  {Ent.Singular(Ent.REQUEST_ID)}: {results["requestId"]}\n'
      msg_txt += f'  {Ent.Singular(Ent.USER)}: {results["userEmailAddress"]}\n'
      msg_txt += f'  Status: {results["status"]}\n'
      msg_txt += f'  Request Date: {results["requestDate"]}\n'
      msg_txt += f'  Requested By: {results["adminEmailAddress"]}\n'
      msg_txt += f'  Requested Parts: {results["packageContent"]}\n'
      msg_txt += f'  Request Filter: {results.get("searchQuery", "None")}\n'
      msg_txt += f'  Include Deleted: {results["includeDeleted"]}\n'
      if 'numberOfFiles' in results:
        msg_txt += f'  Number Of Files: {results["numberOfFiles"]}\n'
        for i in range(int(results['numberOfFiles'])):
          msg_txt += f'  Url{i}: {results["fileUrl"+str(i)]}\n'
      msg_subj = f'Export #{results["requestId"]} for {results["userEmailAddress"]} status is {results["status"]}'
      send_email(msg_subj, msg_txt, _getAdminEmail())
      break
    printKeyValueList(['Status still PENDING, will check again in 5 minutes...'])
    time.sleep(300)

# Audit monitor command utilities
def _showMailboxMonitorRequestStatus(request, i=0, count=0):
  printKeyValueListWithCount(['Destination', normalizeEmailAddressOrUID(request['destUserName'])], i, count)
  Ind.Increment()
  printKeyValueList(['Begin', request.get('beginDate', 'immediately')])
  printKeyValueList(['End', request['endDate']])
  printKeyValueList(['Monitor Incoming', request['outgoingEmailMonitorLevel']])
  printKeyValueList(['Monitor Outgoing', request['incomingEmailMonitorLevel']])
  printKeyValueList(['Monitor Chats', request['chatMonitorLevel']])
  printKeyValueList(['Monitor Drafts', request['draftMonitorLevel']])
  Ind.Decrement()

# gam audit monitor create <EmailAddress> <DestEmailAddress> [begin <DateTime>] [end <DateTime>] [incoming_headers] [outgoing_headers] [nochats] [nodrafts] [chat_headers] [draft_headers]
def doCreateMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  #end_date defaults to 30 days in the future...
  end_date = (GM.Globals[GM.DATETIME_NOW]+datetime.timedelta(days=30)).strftime(YYYYMMDD_HHMM_FORMAT)
  begin_date = None
  incoming_headers_only = outgoing_headers_only = drafts_headers_only = chats_headers_only = False
  drafts = chats = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'begin':
      begin_date = getYYYYMMDD_HHMM()
    elif myarg == 'end':
      end_date = getYYYYMMDD_HHMM()
    elif myarg == 'incomingheaders':
      incoming_headers_only = True
    elif myarg == 'outgoingheaders':
      outgoing_headers_only = True
    elif myarg == 'nochats':
      chats = False
    elif myarg == 'nodrafts':
      drafts = False
    elif myarg == 'chatheaders':
      chats_headers_only = True
    elif myarg == 'draftheaders':
      drafts_headers_only = True
    else:
      unknownArgumentExit()
  try:
    request = callGData(auditObject, 'createEmailMonitor',
                        throwErrors=[GDATA.INVALID_VALUE, GDATA.INVALID_INPUT, GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
                        source_user=parameters['auditUserName'], destination_user=parameters['auditDestUserName'], end_date=end_date, begin_date=begin_date,
                        incoming_headers_only=incoming_headers_only, outgoing_headers_only=outgoing_headers_only,
                        drafts=drafts, drafts_headers_only=drafts_headers_only, chats=chats, chats_headers_only=chats_headers_only)
    entityActionPerformed([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, None])
    Ind.Increment()
    _showMailboxMonitorRequestStatus(request)
    Ind.Decrement()
  except (GDATA.invalidValue, GDATA.invalidInput) as e:
    entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))
  except (GDATA.doesNotExist, GDATA.invalidDomain) as e:
    if str(e).find(parameters['auditUser']) != -1:
      entityUnknownWarning(Ent.USER, parameters['auditUser'])
    else:
      entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))

# gam audit monitor delete <EmailAddress> <DestEmailAddress>
def doDeleteMonitor():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=True)
  checkForExtraneousArguments()
  try:
    callGData(auditObject, 'deleteEmailMonitor',
              throwErrors=[GDATA.INVALID_INPUT, GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
              source_user=parameters['auditUserName'], destination_user=parameters['auditDestUserName'])
    entityActionPerformed([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, parameters['auditDestUser']])
  except GDATA.invalidInput as e:
    entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))
  except (GDATA.doesNotExist, GDATA.invalidDomain) as e:
    if str(e).find(parameters['auditUser']) != -1:
      entityUnknownWarning(Ent.USER, parameters['auditUser'])
    else:
      entityActionFailedWarning([Ent.USER, parameters['auditUser'], Ent.AUDIT_MONITOR_REQUEST, None], str(e))

# gam audit monitor list <EmailAddress>
def doShowMonitors():
  auditObject, parameters = getAuditParameters(emailAddressRequired=True, requestIdRequired=False, destUserRequired=False)
  checkForExtraneousArguments()
  try:
    results = callGData(auditObject, 'getEmailMonitors',
                        throwErrors=[GDATA.DOES_NOT_EXIST, GDATA.INVALID_DOMAIN],
                        user=parameters['auditUserName'])
    jcount = len(results) if (results) else 0
    entityPerformActionNumItems([Ent.USER, parameters['auditUser']], jcount, Ent.AUDIT_MONITOR_REQUEST)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      return
    Ind.Increment()
    j = 0
    for request in results:
      j += 1
      _showMailboxMonitorRequestStatus(request, j, jcount)
    Ind.Decrement()
  except (GDATA.doesNotExist, GDATA.invalidDomain):
    entityUnknownWarning(Ent.USER, parameters['auditUser'])

# Contact commands utilities
#
CONTACT_JSON = 'JSON'

CONTACT_ID = 'ContactID'
CONTACT_UPDATED = 'Updated'
CONTACT_NAME_PREFIX = 'Name Prefix'
CONTACT_GIVEN_NAME = 'Given Name'
CONTACT_ADDITIONAL_NAME = 'Additional Name'
CONTACT_FAMILY_NAME = 'Family Name'
CONTACT_NAME_SUFFIX = 'Name Suffix'
CONTACT_NAME = 'Name'
CONTACT_NICKNAME = 'Nickname'
CONTACT_MAIDENNAME = 'Maiden Name'
CONTACT_SHORTNAME = 'Short Name'
CONTACT_INITIALS = 'Initials'
CONTACT_BIRTHDAY = 'Birthday'
CONTACT_GENDER = 'Gender'
CONTACT_LOCATION = 'Location'
CONTACT_PRIORITY = 'Priority'
CONTACT_SENSITIVITY = 'Sensitivity'
CONTACT_SUBJECT = 'Subject'
CONTACT_LANGUAGE = 'Language'
CONTACT_NOTES = 'Notes'
CONTACT_OCCUPATION = 'Occupation'
CONTACT_BILLING_INFORMATION = 'Billing Information'
CONTACT_MILEAGE = 'Mileage'
CONTACT_DIRECTORY_SERVER = 'Directory Server'
CONTACT_ADDRESSES = 'Addresses'
CONTACT_CALENDARS = 'Calendars'
CONTACT_EMAILS = 'Emails'
CONTACT_EXTERNALIDS = 'External IDs'
CONTACT_EVENTS = 'Events'
CONTACT_HOBBIES = 'Hobbies'
CONTACT_IMS = 'IMs'
CONTACT_JOTS = 'Jots'
CONTACT_ORGANIZATIONS = 'Organizations'
CONTACT_PHONES = 'Phones'
CONTACT_RELATIONS = 'Relations'
CONTACT_USER_DEFINED_FIELDS = 'User Defined Fields'
CONTACT_WEBSITES = 'Websites'
CONTACT_GROUPS = 'ContactGroups'
CONTACT_GROUPS_LIST = 'ContactGroupsList'
CONTACT_ADD_GROUPS = 'ContactAddGroups'
CONTACT_ADD_GROUPS_LIST = 'ContactAddGroupsList'
CONTACT_REMOVE_GROUPS = 'ContactRemoveGroups'
CONTACT_REMOVE_GROUPS_LIST = 'ContactRemoveGroupsList'
#
CONTACT_GROUP_ID = 'ContactGroupID'
CONTACT_GROUP_UPDATED = 'Updated'
CONTACT_GROUP_NAME = 'ContactGroupName'
#
class ContactsManager():
  CONTACT_ARGUMENT_TO_PROPERTY_MAP = {
    'json': CONTACT_JSON,
    'name': CONTACT_NAME,
    'prefix': CONTACT_NAME_PREFIX,
    'givenname': CONTACT_GIVEN_NAME,
    'additionalname': CONTACT_ADDITIONAL_NAME,
    'familyname': CONTACT_FAMILY_NAME,
    'firstname': CONTACT_GIVEN_NAME,
    'middlename': CONTACT_ADDITIONAL_NAME,
    'lastname': CONTACT_FAMILY_NAME,
    'suffix': CONTACT_NAME_SUFFIX,
    'nickname': CONTACT_NICKNAME,
    'maidenname': CONTACT_MAIDENNAME,
    'shortname': CONTACT_SHORTNAME,
    'initials': CONTACT_INITIALS,
    'birthday': CONTACT_BIRTHDAY,
    'gender': CONTACT_GENDER,
    'location': CONTACT_LOCATION,
    'priority': CONTACT_PRIORITY,
    'sensitivity': CONTACT_SENSITIVITY,
    'subject': CONTACT_SUBJECT,
    'language': CONTACT_LANGUAGE,
    'note': CONTACT_NOTES,
    'notes': CONTACT_NOTES,
    'occupation': CONTACT_OCCUPATION,
    'billinginfo': CONTACT_BILLING_INFORMATION,
    'mileage': CONTACT_MILEAGE,
    'directoryserver': CONTACT_DIRECTORY_SERVER,
    'address': CONTACT_ADDRESSES,
    'addresses': CONTACT_ADDRESSES,
    'calendar': CONTACT_CALENDARS,
    'calendars': CONTACT_CALENDARS,
    'email': CONTACT_EMAILS,
    'emails': CONTACT_EMAILS,
    'externalid': CONTACT_EXTERNALIDS,
    'externalids': CONTACT_EXTERNALIDS,
    'event': CONTACT_EVENTS,
    'events': CONTACT_EVENTS,
    'hobby': CONTACT_HOBBIES,
    'hobbies': CONTACT_HOBBIES,
    'im': CONTACT_IMS,
    'ims': CONTACT_IMS,
    'jot': CONTACT_JOTS,
    'jots': CONTACT_JOTS,
    'organization': CONTACT_ORGANIZATIONS,
    'organizations': CONTACT_ORGANIZATIONS,
    'phone': CONTACT_PHONES,
    'phones': CONTACT_PHONES,
    'relation': CONTACT_RELATIONS,
    'relations': CONTACT_RELATIONS,
    'userdefinedfield': CONTACT_USER_DEFINED_FIELDS,
    'userdefinedfields': CONTACT_USER_DEFINED_FIELDS,
    'website': CONTACT_WEBSITES,
    'websites': CONTACT_WEBSITES,
    'contactgroup': CONTACT_GROUPS,
    'contactgroups': CONTACT_GROUPS,
    'addcontactgroup': CONTACT_ADD_GROUPS,
    'addcontactgroups': CONTACT_ADD_GROUPS,
    'removecontactgroup': CONTACT_REMOVE_GROUPS,
    'removecontactgroups': CONTACT_REMOVE_GROUPS,
    'updated': CONTACT_UPDATED,
    }

  GENDER_CHOICE_MAP = {'male': 'male', 'female': 'female'}

  PRIORITY_CHOICE_MAP = {'low': 'low', 'normal': 'normal', 'high': 'high'}

  SENSITIVITY_CHOICE_MAP = {
    'confidential': 'confidential',
    'normal': 'normal',
    'personal': 'personal',
    'private': 'private',
    }

  CONTACT_NAME_FIELDS = (
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    )

  ADDRESS_TYPE_ARGUMENT_TO_REL = {
    'work': gdata.apps.contacts.REL_WORK,
    'home': gdata.apps.contacts.REL_HOME,
    'other': gdata.apps.contacts.REL_OTHER,
    }

  ADDRESS_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: 'work',
    gdata.apps.contacts.REL_HOME: 'home',
    gdata.apps.contacts.REL_OTHER: 'other',
    }

  ADDRESS_ARGUMENT_TO_FIELD_MAP = {
    'streetaddress': 'street',
    'pobox': 'pobox',
    'neighborhood': 'neighborhood',
    'locality': 'city',
    'region': 'region',
    'postalcode': 'postcode',
    'country': 'country',
    'formatted': 'value', 'unstructured': 'value',
    }

  ADDRESS_FIELD_TO_ARGUMENT_MAP = {
    'street': 'streetaddress',
    'pobox': 'pobox',
    'neighborhood': 'neighborhood',
    'city': 'locality',
    'region': 'region',
    'postcode': 'postalcode',
    'country': 'country',
    }

  ADDRESS_FIELD_PRINT_ORDER = [
    'street',
    'pobox',
    'neighborhood',
    'city',
    'region',
    'postcode',
    'country',
    ]

  CALENDAR_TYPE_ARGUMENT_TO_REL = {
    'work': 'work',
    'home': 'home',
    'free-busy': 'free-busy',
    }

  CALENDAR_REL_TO_TYPE_ARGUMENT = {
    'work': 'work',
    'home': 'home',
    'free-busy': 'free-busy',
    }

  EMAIL_TYPE_ARGUMENT_TO_REL = {
    'work': gdata.apps.contacts.REL_WORK,
    'home': gdata.apps.contacts.REL_HOME,
    'other': gdata.apps.contacts.REL_OTHER,
    }

  EMAIL_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: 'work',
    gdata.apps.contacts.REL_HOME: 'home',
    gdata.apps.contacts.REL_OTHER: 'other',
    }

  EVENT_TYPE_ARGUMENT_TO_REL = {
    'anniversary': 'anniversary',
    'other': 'other',
    }

  EVENT_REL_TO_TYPE_ARGUMENT = {
    'anniversary': 'anniversary',
    'other': 'other',
    }

  EXTERNALID_TYPE_ARGUMENT_TO_REL = {
    'account': 'account',
    'customer': 'customer',
    'network': 'network',
    'organization': 'organization',
    }

  EXTERNALID_REL_TO_TYPE_ARGUMENT = {
    'account': 'account',
    'customer': 'customer',
    'network': 'network',
    'organization': 'organization',
    }

  IM_TYPE_ARGUMENT_TO_REL = {
    'work': gdata.apps.contacts.REL_WORK,
    'home': gdata.apps.contacts.REL_HOME,
    'other': gdata.apps.contacts.REL_OTHER,
    }

  IM_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: 'work',
    gdata.apps.contacts.REL_HOME: 'home',
    gdata.apps.contacts.REL_OTHER: 'other',
    }

  IM_PROTOCOL_TO_REL_MAP = {
    'aim': gdata.apps.contacts.IM_AIM,
    'gtalk': gdata.apps.contacts.IM_GOOGLE_TALK,
    'icq': gdata.apps.contacts.IM_ICQ,
    'jabber': gdata.apps.contacts.IM_JABBER,
    'msn': gdata.apps.contacts.IM_MSN,
    'netmeeting': gdata.apps.contacts.IM_NETMEETING,
    'qq': gdata.apps.contacts.IM_QQ,
    'skype': gdata.apps.contacts.IM_SKYPE,
    'xmpp': gdata.apps.contacts.IM_JABBER,
    'yahoo': gdata.apps.contacts.IM_YAHOO,
    }

  IM_REL_TO_PROTOCOL_MAP = {
    gdata.apps.contacts.IM_AIM: 'aim',
    gdata.apps.contacts.IM_GOOGLE_TALK: 'gtalk',
    gdata.apps.contacts.IM_ICQ: 'icq',
    gdata.apps.contacts.IM_JABBER: 'jabber',
    gdata.apps.contacts.IM_MSN: 'msn',
    gdata.apps.contacts.IM_NETMEETING: 'netmeeting',
    gdata.apps.contacts.IM_QQ: 'qq',
    gdata.apps.contacts.IM_SKYPE: 'skype',
    gdata.apps.contacts.IM_YAHOO: 'yahoo',
    }

  JOT_TYPE_ARGUMENT_TO_REL = {
    'work': 'work',
    'home': 'home',
    'other': 'other',
    'keywords': 'keywords',
    'user': 'user',
    }

  JOT_REL_TO_TYPE_ARGUMENT = {
    'work': 'work',
    'home': 'home',
    'other': 'other',
    'keywords': 'keywords',
    'user': 'user',
    }

  ORGANIZATION_TYPE_ARGUMENT_TO_REL = {
    'work': gdata.apps.contacts.REL_WORK,
    'other': gdata.apps.contacts.REL_OTHER,
    }

  ORGANIZATION_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.REL_WORK: 'work',
    gdata.apps.contacts.REL_OTHER: 'other',
    }

  ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
    'location': 'where',
    'department': 'department',
    'title': 'title',
    'jobdescription': 'jobdescription',
    'symbol': 'symbol',
    }

  ORGANIZATION_FIELD_TO_ARGUMENT_MAP = {
    'where': 'location',
    'department': 'department',
    'title': 'title',
    'jobdescription': 'jobdescription',
    'symbol': 'symbol',
    }

  ORGANIZATION_FIELD_PRINT_ORDER = [
    'where',
    'department',
    'title',
    'jobdescription',
    'symbol',
    ]

  PHONE_TYPE_ARGUMENT_TO_REL = {
    'work': gdata.apps.contacts.PHONE_WORK,
    'home': gdata.apps.contacts.PHONE_HOME,
    'other': gdata.apps.contacts.PHONE_OTHER,
    'fax': gdata.apps.contacts.PHONE_HOME_FAX,
    'home_fax': gdata.apps.contacts.PHONE_HOME_FAX,
    'work_fax': gdata.apps.contacts.PHONE_WORK_FAX,
    'other_fax': gdata.apps.contacts.PHONE_OTHER_FAX,
    'main': gdata.apps.contacts.PHONE_MAIN,
    'company_main': gdata.apps.contacts.PHONE_COMPANY_MAIN,
    'assistant': gdata.apps.contacts.PHONE_ASSISTANT,
    'mobile': gdata.apps.contacts.PHONE_MOBILE,
    'work_mobile': gdata.apps.contacts.PHONE_WORK_MOBILE,
    'pager': gdata.apps.contacts.PHONE_PAGER,
    'work_pager': gdata.apps.contacts.PHONE_WORK_PAGER,
    'car': gdata.apps.contacts.PHONE_CAR,
    'radio': gdata.apps.contacts.PHONE_RADIO,
    'callback': gdata.apps.contacts.PHONE_CALLBACK,
    'isdn': gdata.apps.contacts.PHONE_ISDN,
    'telex': gdata.apps.contacts.PHONE_TELEX,
    'tty_tdd': gdata.apps.contacts.PHONE_TTY_TDD,
    }

  PHONE_REL_TO_TYPE_ARGUMENT = {
    gdata.apps.contacts.PHONE_WORK: 'work',
    gdata.apps.contacts.PHONE_HOME: 'home',
    gdata.apps.contacts.PHONE_OTHER: 'other',
    gdata.apps.contacts.PHONE_HOME_FAX: 'fax',
    gdata.apps.contacts.PHONE_HOME_FAX: 'home_fax',
    gdata.apps.contacts.PHONE_WORK_FAX: 'work_fax',
    gdata.apps.contacts.PHONE_OTHER_FAX: 'other_fax',
    gdata.apps.contacts.PHONE_MAIN: 'main',
    gdata.apps.contacts.PHONE_COMPANY_MAIN: 'company_main',
    gdata.apps.contacts.PHONE_ASSISTANT: 'assistant',
    gdata.apps.contacts.PHONE_MOBILE: 'mobile',
    gdata.apps.contacts.PHONE_WORK_MOBILE: 'work_mobile',
    gdata.apps.contacts.PHONE_PAGER: 'pager',
    gdata.apps.contacts.PHONE_WORK_PAGER: 'work_pager',
    gdata.apps.contacts.PHONE_CAR: 'car',
    gdata.apps.contacts.PHONE_RADIO: 'radio',
    gdata.apps.contacts.PHONE_CALLBACK: 'callback',
    gdata.apps.contacts.PHONE_ISDN: 'isdn',
    gdata.apps.contacts.PHONE_TELEX: 'telex',
    gdata.apps.contacts.PHONE_TTY_TDD: 'tty_tdd',
    }

  RELATION_TYPE_ARGUMENT_TO_REL = {
    'spouse': 'spouse',
    'child': 'child',
    'mother': 'mother',
    'father': 'father',
    'parent': 'parent',
    'brother': 'brother',
    'sister': 'sister',
    'friend': 'friend',
    'relative': 'relative',
    'manager': 'manager',
    'assistant': 'assistant',
    'referredby': 'referred-by',
    'partner': 'partner',
    'domesticpartner': 'domestic-partner',
    }

  RELATION_REL_TO_TYPE_ARGUMENT = {
    'spouse' : 'spouse',
    'child' : 'child',
    'mother' : 'mother',
    'father' : 'father',
    'parent' : 'parent',
    'brother' : 'brother',
    'sister' : 'sister',
    'friend' : 'friend',
    'relative' : 'relative',
    'manager' : 'manager',
    'assistant' : 'assistant',
    'referred-by' : 'referred_by',
    'partner' : 'partner',
    'domestic-partner' : 'domestic_partner',
    }

  WEBSITE_TYPE_ARGUMENT_TO_REL = {
    'home-page': 'home-page',
    'blog': 'blog',
    'profile': 'profile',
    'work': 'work',
    'home': 'home',
    'other': 'other',
    'ftp': 'ftp',
    'reservations': 'reservations',
    'app-install-page': 'app-install-page',
    }

  WEBSITE_REL_TO_TYPE_ARGUMENT = {
    'home-page': 'home-page',
    'blog': 'blog',
    'profile': 'profile',
    'work': 'work',
    'home': 'home',
    'other': 'other',
    'ftp': 'ftp',
    'reservations': 'reservations',
    'app-install-page': 'app-install-page',
    }

  CONTACT_NAME_PROPERTY_PRINT_ORDER = [
    CONTACT_UPDATED,
    CONTACT_NAME,
    CONTACT_NAME_PREFIX,
    CONTACT_GIVEN_NAME,
    CONTACT_ADDITIONAL_NAME,
    CONTACT_FAMILY_NAME,
    CONTACT_NAME_SUFFIX,
    CONTACT_NICKNAME,
    CONTACT_MAIDENNAME,
    CONTACT_SHORTNAME,
    CONTACT_INITIALS,
    CONTACT_BIRTHDAY,
    CONTACT_GENDER,
    CONTACT_LOCATION,
    CONTACT_PRIORITY,
    CONTACT_SENSITIVITY,
    CONTACT_SUBJECT,
    CONTACT_LANGUAGE,
    CONTACT_NOTES,
    CONTACT_OCCUPATION,
    CONTACT_BILLING_INFORMATION,
    CONTACT_MILEAGE,
    CONTACT_DIRECTORY_SERVER,
    ]

  CONTACT_ARRAY_PROPERTY_PRINT_ORDER = [
    CONTACT_ADDRESSES,
    CONTACT_EMAILS,
    CONTACT_IMS,
    CONTACT_PHONES,
    CONTACT_CALENDARS,
    CONTACT_ORGANIZATIONS,
    CONTACT_EXTERNALIDS,
    CONTACT_EVENTS,
    CONTACT_HOBBIES,
    CONTACT_JOTS,
    CONTACT_RELATIONS,
    CONTACT_WEBSITES,
    CONTACT_USER_DEFINED_FIELDS,
    ]

  CONTACT_ARRAY_PROPERTIES = {
    CONTACT_ADDRESSES: {'relMap': ADDRESS_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'formatted', 'primary': True},
    CONTACT_EMAILS: {'relMap': EMAIL_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'address', 'primary': True},
    CONTACT_IMS: {'relMap': IM_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'address', 'primary': True},
    CONTACT_PHONES: {'relMap': PHONE_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'value', 'primary': True},
    CONTACT_CALENDARS: {'relMap': CALENDAR_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'address', 'primary': True},
    CONTACT_ORGANIZATIONS: {'relMap': ORGANIZATION_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'name', 'primary': True},
    CONTACT_EXTERNALIDS: {'relMap': EXTERNALID_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'value', 'primary': False},
    CONTACT_EVENTS: {'relMap': EVENT_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'date', 'primary': False},
    CONTACT_HOBBIES: {'relMap': None, 'infoTitle': 'value', 'primary': False},
    CONTACT_JOTS: {'relMap': JOT_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'value', 'primary': False},
    CONTACT_RELATIONS: {'relMap': RELATION_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'value', 'primary': False},
    CONTACT_USER_DEFINED_FIELDS: {'relMap': None, 'infoTitle': 'value', 'primary': False},
    CONTACT_WEBSITES: {'relMap': WEBSITE_REL_TO_TYPE_ARGUMENT, 'infoTitle': 'value', 'primary': True},
    }

  CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP = {
    'json': CONTACT_JSON,
    'name': CONTACT_GROUP_NAME,
    }

  @staticmethod
  def GetContactShortId(contactEntry):
    full_id = contactEntry.id.text
    return full_id[full_id.rfind('/')+1:]

  @staticmethod
  def GetContactFields(entityType):

    fields = {}

    def CheckClearFieldsList(fieldName):
      if checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
        fields.pop(fieldName, None)
        fields[fieldName] = []
        return True
      return False

    def InitArrayItem(choices):
      item = {}
      rel = getChoice(choices, mapChoice=True, defaultChoice=None)
      if rel:
        item['rel'] = rel
        item['label'] = None
      else:
        item['rel'] = None
        item['label'] = getString(Cmd.OB_STRING)
      return item

    def PrimaryNotPrimary(pnp, entry):
      if pnp == 'notprimary':
        entry['primary'] = 'false'
        return True
      if pnp == 'primary':
        entry['primary'] = 'true'
        primary['location'] = Cmd.Location()
        return True
      return False

    def GetPrimaryNotPrimaryChoice(entry):
      if not getChoice({'primary': True, 'notprimary': False}, mapChoice=True):
        entry['primary'] = 'false'
      else:
        entry['primary'] = 'true'
        primary['location'] = Cmd.Location()

    def AppendItemToFieldsList(fieldName, fieldValue, checkBlankField=None):
      fields.setdefault(fieldName, [])
      if checkBlankField is None or fieldValue[checkBlankField]:
        if isinstance(fieldValue, dict) and fieldValue.get('primary', 'false') == 'true':
          for citem in fields[fieldName]:
            if citem.get('primary', 'false') == 'true':
              Cmd.SetLocation(primary['location']-1)
              usageErrorExit(Msg.MULTIPLE_ITEMS_MARKED_PRIMARY.format(fieldName))
        fields[fieldName].append(fieldValue)

    primary = {}
    while Cmd.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_JSON:
        if entityType == Ent.USER:
          fields.update(getJSON(['ContactID']))
        else:
          fields.update(getJSON(['ContactID', 'ContactGroups']))
      elif fieldName == CONTACT_BIRTHDAY:
        fields[fieldName] = getYYYYMMDD(minLen=0)
      elif fieldName == CONTACT_GENDER:
        fields[fieldName] = getChoice(ContactsManager.GENDER_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_PRIORITY:
        fields[fieldName] = getChoice(ContactsManager.PRIORITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_SENSITIVITY:
        fields[fieldName] = getChoice(ContactsManager.SENSITIVITY_CHOICE_MAP, mapChoice=True)
      elif fieldName == CONTACT_LANGUAGE:
        fields[fieldName] = getLanguageCode()
      elif fieldName == CONTACT_NOTES:
        fields[fieldName] = getStringWithCRsNLsOrFile()
      elif fieldName == CONTACT_ADDRESSES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.ADDRESS_TYPE_ARGUMENT_TO_REL)
        entry['primary'] = 'false'
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value.replace('\\n', '\n')
          elif PrimaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry)
      elif fieldName == CONTACT_CALENDARS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.CALENDAR_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        GetPrimaryNotPrimaryChoice(entry)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_EMAILS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EMAIL_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getEmailAddress(noUid=True, minLen=0)
        GetPrimaryNotPrimaryChoice(entry)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_EVENTS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EVENT_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getYYYYMMDD(minLen=0)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_EXTERNALIDS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.EXTERNALID_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_HOBBIES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {'value': getString(Cmd.OB_STRING, minLen=0)}
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_IMS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.IM_TYPE_ARGUMENT_TO_REL)
        entry['protocol'] = getChoice(ContactsManager.IM_PROTOCOL_TO_REL_MAP, mapChoice=True)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        GetPrimaryNotPrimaryChoice(entry)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_JOTS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {'rel': getChoice(ContactsManager.JOT_TYPE_ARGUMENT_TO_REL, mapChoice=True)}
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_ORGANIZATIONS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.ORGANIZATION_TYPE_ARGUMENT_TO_REL)
        entry['primary'] = 'false'
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ContactsManager.ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif PrimaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_PHONES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.PHONE_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        GetPrimaryNotPrimaryChoice(entry)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_RELATIONS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.RELATION_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_USER_DEFINED_FIELDS:
        if CheckClearFieldsList(fieldName):
          continue
        entry = {'rel': getString(Cmd.OB_STRING, minLen=0), 'value': getString(Cmd.OB_STRING, minLen=0)}
        if not entry['rel'] or entry['rel'].lower() == 'none':
          entry['rel'] = None
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_WEBSITES:
        if CheckClearFieldsList(fieldName):
          continue
        entry = InitArrayItem(ContactsManager.WEBSITE_TYPE_ARGUMENT_TO_REL)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        GetPrimaryNotPrimaryChoice(entry)
        AppendItemToFieldsList(fieldName, entry, 'value')
      elif fieldName == CONTACT_GROUPS:
        if entityType != Ent.USER:
          Cmd.Backup()
          unknownArgumentExit()
        AppendItemToFieldsList(CONTACT_GROUPS_LIST, getString(Cmd.OB_STRING))
      elif fieldName == CONTACT_ADD_GROUPS:
        if entityType != Ent.USER:
          Cmd.Backup()
          unknownArgumentExit()
        AppendItemToFieldsList(CONTACT_ADD_GROUPS_LIST, getString(Cmd.OB_STRING))
      elif fieldName == CONTACT_REMOVE_GROUPS:
        if entityType != Ent.USER:
          Cmd.Backup()
          unknownArgumentExit()
        AppendItemToFieldsList(CONTACT_REMOVE_GROUPS_LIST, getString(Cmd.OB_STRING))
      else:
        fields[fieldName] = getString(Cmd.OB_STRING, minLen=0)
    return fields

  @staticmethod
  def FieldsToContact(fields):
    def GetField(fieldName):
      return fields.get(fieldName)

    def SetClassAttribute(value, fieldClass, processNLs, attr):
      if value:
        if processNLs:
          value = value.replace('\\n', '\n')
        if attr == 'text':
          return fieldClass(text=value)
        if attr == 'code':
          return fieldClass(code=value)
        if attr == 'rel':
          return fieldClass(rel=value)
        if attr == 'value':
          return fieldClass(value=value)
        if attr == 'value_string':
          return fieldClass(value_string=value)
        if attr == 'when':
          return fieldClass(when=value)
      return None

    def GetContactField(fieldName, fieldClass, processNLs=False, attr='text'):
      return SetClassAttribute(fields.get(fieldName), fieldClass, processNLs, attr)

    def GetListEntryField(entry, fieldName, fieldClass, processNLs=False, attr='text'):
      return SetClassAttribute(entry.get(fieldName), fieldClass, processNLs, attr)

    contactEntry = gdata.apps.contacts.ContactEntry()
    value = GetField(CONTACT_NAME)
    if not value:
      value = ' '.join([fields[fieldName] for fieldName in ContactsManager.CONTACT_NAME_FIELDS if fieldName in fields])
    contactEntry.name = gdata.apps.contacts.Name(full_name=gdata.apps.contacts.FullName(text=value))
    contactEntry.name.name_prefix = GetContactField(CONTACT_NAME_PREFIX, gdata.apps.contacts.NamePrefix)
    contactEntry.name.given_name = GetContactField(CONTACT_GIVEN_NAME, gdata.apps.contacts.GivenName)
    contactEntry.name.additional_name = GetContactField(CONTACT_ADDITIONAL_NAME, gdata.apps.contacts.AdditionalName)
    contactEntry.name.family_name = GetContactField(CONTACT_FAMILY_NAME, gdata.apps.contacts.FamilyName)
    contactEntry.name.name_suffix = GetContactField(CONTACT_NAME_SUFFIX, gdata.apps.contacts.NameSuffix)
    contactEntry.nickname = GetContactField(CONTACT_NICKNAME, gdata.apps.contacts.Nickname)
    contactEntry.maidenName = GetContactField(CONTACT_MAIDENNAME, gdata.apps.contacts.MaidenName)
    contactEntry.shortName = GetContactField(CONTACT_SHORTNAME, gdata.apps.contacts.ShortName)
    contactEntry.initials = GetContactField(CONTACT_INITIALS, gdata.apps.contacts.Initials)
    contactEntry.birthday = GetContactField(CONTACT_BIRTHDAY, gdata.apps.contacts.Birthday, attr='when')
    contactEntry.gender = GetContactField(CONTACT_GENDER, gdata.apps.contacts.Gender, attr='value')
    contactEntry.where = GetContactField(CONTACT_LOCATION, gdata.apps.contacts.Where, attr='value_string')
    contactEntry.priority = GetContactField(CONTACT_PRIORITY, gdata.apps.contacts.Priority, attr='rel')
    contactEntry.sensitivity = GetContactField(CONTACT_SENSITIVITY, gdata.apps.contacts.Sensitivity, attr='rel')
    contactEntry.subject = GetContactField(CONTACT_SUBJECT, gdata.apps.contacts.Subject)
    contactEntry.language = GetContactField(CONTACT_LANGUAGE, gdata.apps.contacts.Language, attr='code')
    contactEntry.content = GetContactField(CONTACT_NOTES, gdata.apps.contacts.Content, processNLs=True)
    contactEntry.occupation = GetContactField(CONTACT_OCCUPATION, gdata.apps.contacts.Occupation)
    contactEntry.billingInformation = GetContactField(CONTACT_BILLING_INFORMATION, gdata.apps.contacts.BillingInformation, processNLs=True)
    contactEntry.mileage = GetContactField(CONTACT_MILEAGE, gdata.apps.contacts.Mileage)
    contactEntry.directoryServer = GetContactField(CONTACT_DIRECTORY_SERVER, gdata.apps.contacts.DirectoryServer)
    value = GetField(CONTACT_ADDRESSES)
    if value:
      for address in value:
        street = GetListEntryField(address, 'street', gdata.apps.contacts.Street)
        pobox = GetListEntryField(address, 'pobox', gdata.apps.contacts.PoBox)
        neighborhood = GetListEntryField(address, 'neighborhood', gdata.apps.contacts.Neighborhood)
        city = GetListEntryField(address, 'city', gdata.apps.contacts.City)
        region = GetListEntryField(address, 'region', gdata.apps.contacts.Region)
        postcode = GetListEntryField(address, 'postcode', gdata.apps.contacts.Postcode)
        country = GetListEntryField(address, 'country', gdata.apps.contacts.Country)
        formatted_address = GetListEntryField(address, 'value', gdata.apps.contacts.FormattedAddress, processNLs=True)
        contactEntry.structuredPostalAddress.append(gdata.apps.contacts.StructuredPostalAddress(street=street, pobox=pobox, neighborhood=neighborhood,
                                                                                                city=city, region=region,
                                                                                                postcode=postcode, country=country,
                                                                                                formatted_address=formatted_address,
                                                                                                rel=address['rel'], label=address['label'], primary=address['primary']))
    value = GetField(CONTACT_CALENDARS)
    if value:
      for calendarLink in value:
        contactEntry.calendarLink.append(gdata.apps.contacts.CalendarLink(href=calendarLink['value'], rel=calendarLink['rel'], label=calendarLink['label'], primary=calendarLink['primary']))
    value = GetField(CONTACT_EMAILS)
    if value:
      for emailaddr in value:
        contactEntry.email.append(gdata.apps.contacts.Email(address=emailaddr['value'], rel=emailaddr['rel'], label=emailaddr['label'], primary=emailaddr['primary']))
    value = GetField(CONTACT_EXTERNALIDS)
    if value:
      for externalid in value:
        contactEntry.externalId.append(gdata.apps.contacts.ExternalId(value=externalid['value'], rel=externalid['rel'], label=externalid['label']))
    value = GetField(CONTACT_EVENTS)
    if value:
      for event in value:
        contactEntry.event.append(gdata.apps.contacts.Event(rel=event['rel'], label=event['label'],
                                                            when=gdata.apps.contacts.When(startTime=event['value'])))
    value = GetField(CONTACT_HOBBIES)
    if value:
      for hobby in value:
        contactEntry.hobby.append(gdata.apps.contacts.Hobby(text=hobby['value']))
    value = GetField(CONTACT_IMS)
    if value:
      for im in value:
        contactEntry.im.append(gdata.apps.contacts.IM(address=im['value'], protocol=im['protocol'], rel=im['rel'], label=im['label'], primary=im['primary']))
    value = GetField(CONTACT_JOTS)
    if value:
      for jot in value:
        contactEntry.jot.append(gdata.apps.contacts.Jot(text=jot['value'], rel=jot['rel']))
    value = GetField(CONTACT_ORGANIZATIONS)
    if value:
      for organization in value:
        org_name = gdata.apps.contacts.OrgName(text=organization['value'])
        department = GetListEntryField(organization, 'department', gdata.apps.contacts.OrgDepartment)
        title = GetListEntryField(organization, 'title', gdata.apps.contacts.OrgTitle)
        job_description = GetListEntryField(organization, 'jobdescription', gdata.apps.contacts.OrgJobDescription)
        symbol = GetListEntryField(organization, 'symbol', gdata.apps.contacts.OrgSymbol)
        where = GetListEntryField(organization, 'where', gdata.apps.contacts.Where, attr='value_string')
        contactEntry.organization.append(gdata.apps.contacts.Organization(name=org_name, department=department,
                                                                          title=title, job_description=job_description,
                                                                          symbol=symbol, where=where,
                                                                          rel=organization['rel'], label=organization['label'], primary=organization['primary']))
    value = GetField(CONTACT_PHONES)
    if value:
      for phone in value:
        contactEntry.phoneNumber.append(gdata.apps.contacts.PhoneNumber(text=phone['value'], rel=phone['rel'], label=phone['label'], primary=phone['primary']))
    value = GetField(CONTACT_RELATIONS)
    if value:
      for relation in value:
        contactEntry.relation.append(gdata.apps.contacts.Relation(text=relation['value'], rel=relation['rel'], label=relation['label']))
    value = GetField(CONTACT_USER_DEFINED_FIELDS)
    if value:
      for userdefinedfield in value:
        contactEntry.userDefinedField.append(gdata.apps.contacts.UserDefinedField(key=userdefinedfield['rel'], value=userdefinedfield['value']))
    value = GetField(CONTACT_WEBSITES)
    if value:
      for website in value:
        contactEntry.website.append(gdata.apps.contacts.Website(href=website['value'], rel=website['rel'], label=website['label'], primary=website['primary']))
    return contactEntry

  @staticmethod
  def AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user):
    contactEntry.groupMembershipInfo = []
    for groupId in contactGroupsList:
      if groupId != 'clear':
        contactEntry.groupMembershipInfo.append(gdata.apps.contacts.GroupMembershipInfo(deleted='false',
                                                                                        href=contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)))
      else:
        contactEntry.groupMembershipInfo = []

  @staticmethod
  def AddFilteredContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user, contactRemoveGroupsList):
    contactEntry.groupMembershipInfo = []
    for groupId in contactGroupsList:
      if groupId not in contactRemoveGroupsList:
        contactEntry.groupMembershipInfo.append(gdata.apps.contacts.GroupMembershipInfo(deleted='false',
                                                                                        href=contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)))
  @staticmethod
  def AddAdditionalContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user):
    for groupId in contactGroupsList:
      contactEntry.groupMembershipInfo.append(gdata.apps.contacts.GroupMembershipInfo(deleted='false',
                                                                                      href=contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)))
  @staticmethod
  def ContactToFields(contactEntry):
    fields = {}
    def GetContactField(fieldName, attrlist):
      objAttr = contactEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def GetListEntryField(entry, attrlist):
      objAttr = entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    fields[CONTACT_ID] = ContactsManager.GetContactShortId(contactEntry)
    GetContactField(CONTACT_UPDATED, ['updated', 'text'])
    if not contactEntry.deleted:
      GetContactField(CONTACT_NAME, ['title', 'text'])
    else:
      fields[CONTACT_NAME] = 'Deleted'
    GetContactField(CONTACT_NAME_PREFIX, ['name', 'name_prefix', 'text'])
    GetContactField(CONTACT_GIVEN_NAME, ['name', 'given_name', 'text'])
    GetContactField(CONTACT_ADDITIONAL_NAME, ['name', 'additional_name', 'text'])
    GetContactField(CONTACT_FAMILY_NAME, ['name', 'family_name', 'text'])
    GetContactField(CONTACT_NAME_SUFFIX, ['name', 'name_suffix', 'text'])
    GetContactField(CONTACT_NICKNAME, ['nickname', 'text'])
    GetContactField(CONTACT_MAIDENNAME, ['maidenName', 'text'])
    GetContactField(CONTACT_SHORTNAME, ['shortName', 'text'])
    GetContactField(CONTACT_INITIALS, ['initials', 'text'])
    GetContactField(CONTACT_BIRTHDAY, ['birthday', 'when'])
    GetContactField(CONTACT_GENDER, ['gender', 'value'])
    GetContactField(CONTACT_SUBJECT, ['subject', 'text'])
    GetContactField(CONTACT_LANGUAGE, ['language', 'code'])
    GetContactField(CONTACT_PRIORITY, ['priority', 'rel'])
    GetContactField(CONTACT_SENSITIVITY, ['sensitivity', 'rel'])
    GetContactField(CONTACT_NOTES, ['content', 'text'])
    GetContactField(CONTACT_LOCATION, ['where', 'value_string'])
    GetContactField(CONTACT_OCCUPATION, ['occupation', 'text'])
    GetContactField(CONTACT_BILLING_INFORMATION, ['billingInformation', 'text'])
    GetContactField(CONTACT_MILEAGE, ['mileage', 'text'])
    GetContactField(CONTACT_DIRECTORY_SERVER, ['directoryServer', 'text'])
    for address in contactEntry.structuredPostalAddress:
      AppendItemToFieldsList(CONTACT_ADDRESSES,
                             {'rel': address.rel,
                              'label': address.label,
                              'value': GetListEntryField(address, ['formatted_address', 'text']),
                              'street': GetListEntryField(address, ['street', 'text']),
                              'pobox': GetListEntryField(address, ['pobox', 'text']),
                              'neighborhood': GetListEntryField(address, ['neighborhood', 'text']),
                              'city': GetListEntryField(address, ['city', 'text']),
                              'region': GetListEntryField(address, ['region', 'text']),
                              'postcode': GetListEntryField(address, ['postcode', 'text']),
                              'country': GetListEntryField(address, ['country', 'text']),
                              'primary': address.primary})
    for calendarLink in contactEntry.calendarLink:
      AppendItemToFieldsList(CONTACT_CALENDARS,
                             {'rel': calendarLink.rel,
                              'label': calendarLink.label,
                              'value': calendarLink.href,
                              'primary': calendarLink.primary})
    for emailaddr in contactEntry.email:
      AppendItemToFieldsList(CONTACT_EMAILS,
                             {'rel': emailaddr.rel,
                              'label': emailaddr.label,
                              'value': emailaddr.address,
                              'primary': emailaddr.primary})
    for externalid in contactEntry.externalId:
      AppendItemToFieldsList(CONTACT_EXTERNALIDS,
                             {'rel': externalid.rel,
                              'label': externalid.label,
                              'value': externalid.value})
    for event in contactEntry.event:
      AppendItemToFieldsList(CONTACT_EVENTS,
                             {'rel': event.rel,
                              'label': event.label,
                              'value': GetListEntryField(event, ['when', 'startTime'])})
    for hobby in contactEntry.hobby:
      AppendItemToFieldsList(CONTACT_HOBBIES,
                             {'value': hobby.text})
    for im in contactEntry.im:
      AppendItemToFieldsList(CONTACT_IMS,
                             {'rel': im.rel,
                              'label': im.label,
                              'value': im.address,
                              'protocol': im.protocol,
                              'primary': im.primary})
    for jot in contactEntry.jot:
      AppendItemToFieldsList(CONTACT_JOTS,
                             {'rel': jot.rel,
                              'value': jot.text})
    for organization in contactEntry.organization:
      AppendItemToFieldsList(CONTACT_ORGANIZATIONS,
                             {'rel': organization.rel,
                              'label': organization.label,
                              'value': GetListEntryField(organization, ['name', 'text']),
                              'department': GetListEntryField(organization, ['department', 'text']),
                              'title': GetListEntryField(organization, ['title', 'text']),
                              'symbol': GetListEntryField(organization, ['symbol', 'text']),
                              'jobdescription': GetListEntryField(organization, ['job_description', 'text']),
                              'where': GetListEntryField(organization, ['where', 'value_string']),
                              'primary': organization.primary})
    for phone in contactEntry.phoneNumber:
      AppendItemToFieldsList(CONTACT_PHONES,
                             {'rel': phone.rel,
                              'label': phone.label,
                              'value': phone.text,
                              'primary': phone.primary})
    for relation in contactEntry.relation:
      AppendItemToFieldsList(CONTACT_RELATIONS,
                             {'rel': relation.rel,
                              'label': relation.label,
                              'value': relation.text})
    for userdefinedfield in contactEntry.userDefinedField:
      AppendItemToFieldsList(CONTACT_USER_DEFINED_FIELDS,
                             {'rel': userdefinedfield.key,
                              'value': userdefinedfield.value})
    for website in contactEntry.website:
      AppendItemToFieldsList(CONTACT_WEBSITES,
                             {'rel': website.rel,
                              'label': website.label,
                              'value': website.href,
                              'primary': website.primary})
    for group in contactEntry.groupMembershipInfo:
      AppendItemToFieldsList(CONTACT_GROUPS, group.href[group.href.rfind('/')+1:])
    return fields

  @staticmethod
  def GetContactGroupFields():

    fields = {}
    while Cmd.ArgumentsRemaining():
      fieldName = getChoice(ContactsManager.CONTACT_GROUP_ARGUMENT_TO_PROPERTY_MAP, mapChoice=True)
      if fieldName == CONTACT_JSON:
        fields.update(getJSON(['ContactGroupID']))
      elif fieldName == CONTACT_GROUP_NAME:
        fields[fieldName] = getString(Cmd.OB_STRING)
      else:
        fields[fieldName] = getString(Cmd.OB_STRING, minLen=0)
    if not fields.get(CONTACT_GROUP_NAME):
      missingArgumentExit('name')
    return fields

  @staticmethod
  def FieldsToContactGroup(fields):
    groupEntry = gdata.apps.contacts.GroupEntry(title=atom.Title(text=fields[CONTACT_GROUP_NAME]))
    return groupEntry

  @staticmethod
  def ContactGroupToFields(groupEntry):
    fields = {}

    def GetGroupField(fieldName, attrlist):
      objAttr = groupEntry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    fields[CONTACT_GROUP_ID] = ContactsManager.GetContactShortId(groupEntry)
    GetGroupField(CONTACT_GROUP_UPDATED, ['updated', 'text'])
    if not groupEntry.deleted:
      GetGroupField(CONTACT_GROUP_NAME, ['title', 'text'])
    else:
      fields[CONTACT_GROUP_NAME] = 'Deleted'
    return fields

CONTACTS_PROJECTION_CHOICE_MAP = {'basic': 'thin', 'thin': 'thin', 'full': 'full'}
CONTACTS_ORDERBY_CHOICE_MAP = {'lastmodified': 'lastmodified'}

def normalizeContactId(contactId):
  if contactId.startswith('id:'):
    return contactId[3:]
  return contactId

def _initContactQueryAttributes():
  return {'query': None, 'projection': 'full', 'url_params': {'max-results': str(GC.Values[GC.CONTACT_MAX_RESULTS])},
          'contactGroup': None, 'group': None, 'otherContacts': False, 'emailMatchPattern': None, 'emailMatchType': None}

def _getContactQueryAttributes(contactQuery, myarg, entityType, unknownAction, allowOutputAttributes):
  if myarg == 'query':
    contactQuery['query'] = getString(Cmd.OB_QUERY)
  elif myarg in {'contactgroup', 'selectcontactgroup'}:
    if entityType == Ent.USER:
      contactQuery['contactGroup'] = getString(Cmd.OB_CONTACT_GROUP_ITEM)
      contactQuery['otherContacts'] = False
    else:
      unknownArgumentExit()
  elif myarg in {'othercontacts', 'selectothercontacts'}:
    if entityType == Ent.USER:
      contactQuery['otherContacts'] = True
      contactQuery['contactGroup'] = None
    else:
      unknownArgumentExit()
  elif myarg == 'emailmatchpattern':
    contactQuery['emailMatchPattern'] = getREPattern(re.IGNORECASE)
  elif myarg == 'emailmatchtype':
    contactQuery['emailMatchType'] = getString(Cmd.OB_CONTACT_EMAIL_TYPE)
  elif myarg == 'updatedmin':
    contactQuery['url_params']['updated-min'] = getYYYYMMDD()
  elif myarg == 'endquery':
    return False
  elif not allowOutputAttributes:
    if unknownAction < 0:
      unknownArgumentExit()
    if unknownAction > 0:
      Cmd.Backup()
    return False
  elif myarg == 'orderby':
    contactQuery['url_params']['orderby'], contactQuery['url_params']['sortorder'] = getOrderBySortOrder(CONTACTS_ORDERBY_CHOICE_MAP, 'ascending', False)
  elif myarg in CONTACTS_PROJECTION_CHOICE_MAP:
    contactQuery['projection'] = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
  elif myarg == 'showdeleted':
    contactQuery['url_params']['showdeleted'] = 'true'
  else:
    if unknownAction < 0:
      unknownArgumentExit()
    if unknownAction > 0:
      Cmd.Backup()
    return False
  return True

CONTACT_SELECT_ARGUMENTS = {'query', 'contactgroup', 'selectcontactgroup', 'othercontacts', 'selectothercontacts',
                            'emailmatchpattern', 'emailmatchtype', 'updatedmin'}

def _getContactEntityList(entityType, unknownAction, allowOutputAttributes):
  contactQuery = _initContactQueryAttributes()
  if Cmd.PeekArgumentPresent(CONTACT_SELECT_ARGUMENTS):
    entityList = None
    queriedContacts = True
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if not _getContactQueryAttributes(contactQuery, myarg, entityType, unknownAction, allowOutputAttributes):
        break
  else:
    entityList = getEntityList(Cmd.OB_CONTACT_ENTITY)
    queriedContacts = False
    if unknownAction < 0:
      checkForExtraneousArguments()
  return (entityList, entityList if isinstance(entityList, dict) else None, contactQuery, queriedContacts)

def queryContacts(contactsObject, contactQuery, entityType, user, i=0, count=0):
  if contactQuery['query'] or contactQuery['group']:
    uri = getContactsQuery(feed=contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery['projection']),
                           text_query=contactQuery['query'], group=contactQuery['group']).ToUri()
  else:
    uri = contactsObject.GetContactFeedUri(contact_list=user, projection=contactQuery['projection'])
  printGettingAllEntityItemsForWhom(Ent.CONTACT, user, i, count, query=contactQuery['query'])
  try:
    entityList = callGDataPages(contactsObject, 'GetContactsFeed',
                                pageMessage=getPageMessage(),
                                throwErrors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                                retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                                uri=uri, url_params=contactQuery['url_params'])
    return entityList
  except GDATA.badRequest as e:
    entityActionFailedWarning([entityType, user, Ent.CONTACT, ''], str(e), i, count)
  except GDATA.forbidden:
    entityServiceNotApplicableWarning(entityType, user, i, count)
  except GDATA.serviceNotApplicable:
    entityUnknownWarning(entityType, user, i, count)
  return None

def localContactSelects(contactsManager, contactQuery, fields):
  if contactQuery['otherContacts']:
    if fields.get(CONTACT_GROUPS):
      return False
  if contactQuery['emailMatchPattern']:
    emailMatchType = contactQuery['emailMatchType']
    for item in fields.get(CONTACT_EMAILS, []):
      if contactQuery['emailMatchPattern'].match(item['value']):
        if (not emailMatchType or
            emailMatchType == item.get('label') or
            emailMatchType == contactsManager.CONTACT_ARRAY_PROPERTIES[CONTACT_EMAILS]['relMap'].get(item['rel'], 'custom')):
          break
    else:
      return False
  return True

def clearEmailAddressMatches(contactsManager, contactClear, fields):
  savedAddresses = []
  updateRequired = False
  emailMatchType = contactClear['emailClearType']
  for item in fields.get(CONTACT_EMAILS, []):
    if (contactClear['emailClearPattern'].match(item['value']) and
        (not emailMatchType or
         emailMatchType == item.get('label') or
         emailMatchType == contactsManager.CONTACT_ARRAY_PROPERTIES[CONTACT_EMAILS]['relMap'].get(item['rel'], 'custom'))):
      updateRequired = True
    else:
      savedAddresses.append(item)
  if updateRequired:
    fields[CONTACT_EMAILS] = savedAddresses
  return updateRequired

def dedupEmailAddressMatches(contactsManager, emailMatchType, fields):
  sai = -1
  savedAddresses = []
  matches = {}
  updateRequired = False
  for item in fields.get(CONTACT_EMAILS, []):
    emailAddr = item['value']
    emailType = item.get('label')
    if emailType is None:
      emailType = contactsManager.CONTACT_ARRAY_PROPERTIES[CONTACT_EMAILS]['relMap'].get(item['rel'], 'custom')
    if (emailAddr in matches) and (not emailMatchType or emailType in matches[emailAddr]['types']):
      if item['primary'] == 'true':
        savedAddresses[matches[emailAddr]['sai']]['primary'] = 'true'
      updateRequired = True
    else:
      savedAddresses.append(item)
      sai += 1
      matches.setdefault(emailAddr, {'types': set(), 'sai': sai})
      matches[emailAddr]['types'].add(emailType)
  if updateRequired:
    fields[CONTACT_EMAILS] = savedAddresses
  return updateRequired

def getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count):
  uri = contactsObject.GetContactGroupFeedUri(contact_list=entityName)
  contactGroupIDs = {}
  contactGroupNames = {}
  try:
    groups = callGDataPages(contactsObject, 'GetGroupsFeed',
                            throwErrors=[GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                            retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                            uri=uri)
    if groups:
      for group in groups:
        fields = contactsManager.ContactGroupToFields(group)
        contactGroupIDs[fields[CONTACT_GROUP_ID]] = fields[CONTACT_GROUP_NAME]
        contactGroupNames.setdefault(fields[CONTACT_GROUP_NAME], [])
        contactGroupNames[fields[CONTACT_GROUP_NAME]].append(fields[CONTACT_GROUP_ID])
  except GDATA.forbidden:
    entityServiceNotApplicableWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  except GDATA.serviceNotApplicable:
    entityUnknownWarning(entityType, entityName, i, count)
    return (contactGroupIDs, False)
  return (contactGroupIDs, contactGroupNames)

def validateContactGroup(contactsManager, contactsObject, contactGroupName,
                         contactGroupIDs, contactGroupNames, entityType, entityName, i, count):
  if not contactGroupNames:
    contactGroupIDs, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, entityName, i, count)
    if contactGroupNames is False:
      return (None, contactGroupIDs, contactGroupNames)
  if contactGroupName == 'clear':
    return (contactGroupName, contactGroupIDs, contactGroupNames)
  cg = UID_PATTERN.match(contactGroupName)
  if cg:
    if cg.group(1) in contactGroupIDs:
      return (cg.group(1), contactGroupIDs, contactGroupNames)
  else:
    if contactGroupName in contactGroupNames:
      return (contactGroupNames[contactGroupName][0], contactGroupIDs, contactGroupNames)
    sgContactGroupName = 'System Group: '+contactGroupName
    if sgContactGroupName in contactGroupNames:
      return (contactGroupNames[sgContactGroupName][0], contactGroupIDs, contactGroupNames)
  return (None, contactGroupIDs, contactGroupNames)

def validateContactGroupsList(contactsManager, contactsObject, contactId,
                              fields, groupsListField, entityType, entityName, i, count):
  result = True
  contactGroupIDs = contactGroupNames = None
  contactGroupsList = []
  for contactGroup in fields[groupsListField]:
    groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup,
                                                                       contactGroupIDs, contactGroupNames, entityType, entityName, i, count)
    if groupId:
      contactGroupsList.append(groupId)
    else:
      if contactGroupNames:
        entityActionNotPerformedWarning([entityType, entityName, Ent.CONTACT, contactId],
                                        Ent.TypeNameMessage(Ent.CONTACT_GROUP, contactGroup, Msg.DOES_NOT_EXIST))
      result = False
  return (result, contactGroupsList)

def _createContact(users, entityType):
  contactsManager = ContactsManager()
  fields = contactsManager.GetContactFields(entityType)
  contactEntry = contactsManager.FieldsToContact(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if fields.get(CONTACT_GROUPS_LIST):
      result, contactGroupsList = validateContactGroupsList(contactsManager, contactsObject, '',
                                                            fields, CONTACT_GROUPS_LIST, entityType, user, i, count)
      if not result:
        continue
      contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList, user)
    try:
      contact = callGData(contactsObject, 'CreateContact',
                          throwErrors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                          new_contact=contactEntry, insert_uri=contactsObject.GetContactFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Ent.CONTACT, contactsManager.GetContactShortId(contact)], i, count)
    except GDATA.badRequest as e:
      entityActionFailedWarning([entityType, user, Ent.CONTACT, ''], str(e), i, count)
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> create contact [contactgroup <ContactGroupItem>] <ContactAttribute>+
def createUserContact(users):
  _createContact(users, Ent.USER)

# gam create contact <ContactAttribute>+
def doCreateDomainContact():
  _createContact([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _clearUpdateContacts(users, entityType, updateContacts):
  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, 1, False)
  if updateContacts:
    update_fields = contactsManager.GetContactFields(entityType)
  else:
    contactClear = {'emailClearPattern': contactQuery['emailMatchPattern'], 'emailClearType': contactQuery['emailMatchType']}
    deleteClearedContactsWithNoEmails = False
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'emailclearpattern':
        contactClear['emailClearPattern'] = getREPattern(re.IGNORECASE)
      elif myarg == 'emailcleartype':
        contactClear['emailClearType'] = getString(Cmd.OB_CONTACT_EMAIL_TYPE)
      elif myarg == 'deleteclearedcontactswithnoemails':
        deleteClearedContactsWithNoEmails = True
      else:
        unknownArgumentExit()
    if not contactClear['emailClearPattern']:
      missingArgumentExit('emailClearPattern')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery['contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery['contactGroup'],
                                                           None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery['contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery['group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
      if entityList is None:
        continue
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    contactGroupsList = {
      CONTACT_GROUPS_LIST: [],
      CONTACT_ADD_GROUPS_LIST: [],
      CONTACT_REMOVE_GROUPS_LIST: []
      }
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, 'GetContact',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
          fields = contactsManager.ContactToFields(contact)
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if not localContactSelects(contactsManager, contactQuery, fields):
            continue
        if updateContacts:
          groupError = False
          for field in [CONTACT_GROUPS_LIST, CONTACT_ADD_GROUPS_LIST, CONTACT_REMOVE_GROUPS_LIST]:
            if update_fields.get(field) and not contactGroupsList[field]:
              result, contactGroupsList[field] = validateContactGroupsList(contactsManager, contactsObject, contactId,
                                                                           update_fields, field, entityType, user, i, count)
              if not result:
                groupError = True
          if groupError:
            break
          for field in update_fields:
            fields[field] = update_fields[field]
          contactEntry = contactsManager.FieldsToContact(fields)
          if contactGroupsList[CONTACT_GROUPS_LIST]:
            contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, contactGroupsList[CONTACT_GROUPS_LIST], user)
          elif contactGroupsList[CONTACT_ADD_GROUPS_LIST] or contactGroupsList[CONTACT_REMOVE_GROUPS_LIST]:
            contactEntry.groupMembershipInfo = []
            if fields.get(CONTACT_GROUPS):
              contactsManager.AddFilteredContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user,
                                                                contactGroupsList[CONTACT_REMOVE_GROUPS_LIST])
            if contactGroupsList[CONTACT_ADD_GROUPS_LIST]:
              contactsManager.AddAdditionalContactGroupsToContact(contactsObject, contactEntry, contactGroupsList[CONTACT_ADD_GROUPS_LIST], user)
          elif fields.get(CONTACT_GROUPS):
            contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user)
        else:
          if not clearEmailAddressMatches(contactsManager, contactClear, fields):
            continue
          if deleteClearedContactsWithNoEmails and not fields[CONTACT_EMAILS]:
            Act.Set(Act.DELETE)
            callGData(contactsObject, 'DeleteContact',
                      throwErrors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                      edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), extra_headers={'If-Match': contact.etag})
            entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
            continue
          contactEntry = contactsManager.FieldsToContact(fields)
          if fields.get(CONTACT_GROUPS):
            contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user)
        contactEntry.category = contact.category
        contactEntry.link = contact.link
        contactEntry.etag = contact.etag
        contactEntry.id = contact.id
        Act.Set(Act.UPDATE)
        callGData(contactsObject, 'UpdateContact',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.PRECONDITION_FAILED, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), updated_contact=contactEntry, extra_headers={'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
      except (GDATA.notFound, GDATA.badRequest, GDATA.preconditionFailed) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> clear contacts <ContactEntity>|<UserContactSelection>
#	[clearmatchpattern <RegularExpression>] [clearmatchtype work|home|other|<String>]
#	[deleteclearedcontactswithnoemails]
def clearUserContacts(users):
  _clearUpdateContacts(users, Ent.USER, False)

# gam clear contacts <ContactEntity>|<ContactSelection>
#	[clearmatchpattern <RegularExpression>] [clearmatchtype work|home|other|<String>]
#	[deleteclearedcontactswithnoemails]
def doClearDomainContacts():
  _clearUpdateContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

# gam <UserTypeEntity> update contacts <ContactEntity>|(<UserContactSelection> [endquery]) [contactgroup <ContactGroupItem>] <ContactAttribute>+
def updateUserContacts(users):
  _clearUpdateContacts(users, Ent.USER, True)

# gam update contacts <ContactEntity>|<ContactSelection> <ContactAttribute>+
def doUpdateDomainContacts():
  _clearUpdateContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, True)

def _dedupContacts(users, entityType):
  contactsManager = ContactsManager()
  contactQuery = _initContactQueryAttributes()
  emailMatchType = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matchtype':
      emailMatchType = getBoolean()
    else:
      _getContactQueryAttributes(contactQuery, myarg, entityType, -1, False)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery['contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery['contactGroup'],
                                                           None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery['contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery['group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)
    contacts = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    if contacts is None:
      continue
    j = 0
    jcount = len(contacts)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in contacts:
      j += 1
      try:
        fields = contactsManager.ContactToFields(contact)
        if not localContactSelects(contactsManager, contactQuery, fields):
          continue
        if not dedupEmailAddressMatches(contactsManager, emailMatchType, fields):
          continue
        contactId = fields[CONTACT_ID]
        contactEntry = contactsManager.FieldsToContact(fields)
        if fields.get(CONTACT_GROUPS):
          contactsManager.AddContactGroupsToContact(contactsObject, contactEntry, fields[CONTACT_GROUPS], user)
        contactEntry.category = contact.category
        contactEntry.link = contact.link
        contactEntry.etag = contact.etag
        contactEntry.id = contact.id
        Act.Set(Act.UPDATE)
        callGData(contactsObject, 'UpdateContact',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.PRECONDITION_FAILED, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), updated_contact=contactEntry, extra_headers={'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
      except (GDATA.notFound, GDATA.badRequest, GDATA.preconditionFailed) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> dedup contacts <ContactEntity>|<UserContactSelection> [matchType [<Boolean>]]
def dedupUserContacts(users):
  _dedupContacts(users, Ent.USER)

# gam dedup contacts <ContactEntity>|<ContactSelection> [matchType [<Boolean>]]
def doDedupDomainContacts():
  _dedupContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _deleteContacts(users, entityType):
  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, -1, False)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    if contactQuery['contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery['contactGroup'],
                                                           None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery['contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery['group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
      if entityList is None:
        continue
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, 'GetContact',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if not localContactSelects(contactsManager, contactQuery, fields):
            continue
        callGData(contactsObject, 'DeleteContact',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId), extra_headers={'If-Match': contact.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT, contactId], j, jcount)
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete contacts <ContactEntity>|<UserContactSelection>
def deleteUserContacts(users):
  _deleteContacts(users, Ent.USER)

# gam delete contacts <ContactEntity>|<ContactSelection>
def doDeleteDomainContacts():
  _deleteContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

CONTACT_TIME_OBJECTS = {CONTACT_UPDATED}
CONTACT_FIELDS_WITH_CRS_NLS = {CONTACT_NOTES, CONTACT_BILLING_INFORMATION}

def _showContact(contactsManager, fields, displayFieldsList, contactGroupIDs, j, jcount, FJQC):
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(fields, timeObjects=CONTACT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.CONTACT, fields[CONTACT_ID]], j, jcount)
  Ind.Increment()
  for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      if key in CONTACT_TIME_OBJECTS:
        printKeyValueList([key, formatLocalTime(fields[key])])
      elif key not in CONTACT_FIELDS_WITH_CRS_NLS:
        printKeyValueList([key, fields[key]])
      else:
        printKeyValueWithCRsNLs(key, fields[key])
  for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
    if displayFieldsList and key not in displayFieldsList:
      continue
    if key in fields:
      keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
      printKeyValueList([key, None])
      Ind.Increment()
      for item in fields[key]:
        fn = item.get('label')
        if keymap['relMap']:
          if not fn:
            fn = keymap['relMap'].get(item['rel'], 'custom')
          printKeyValueList(['type', fn])
          Ind.Increment()
        if keymap['primary']:
          printKeyValueList(['rank', ['notprimary', 'primary'][item['primary'] == 'true']])
        value = item['value']
        if value is None:
          value = ''
        if key == CONTACT_IMS:
          printKeyValueList(['protocol', contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item['protocol'], item['protocol'])])
          printKeyValueList([keymap['infoTitle'], value])
        elif key == CONTACT_ADDRESSES:
          printKeyValueWithCRsNLs(keymap['infoTitle'], value)
          for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key], item[org_key]])
        elif key == CONTACT_ORGANIZATIONS:
          printKeyValueList([keymap['infoTitle'], value])
          for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
            if item[org_key]:
              printKeyValueList([contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key], item[org_key]])
        elif key == CONTACT_USER_DEFINED_FIELDS:
          printKeyValueList([item.get('rel') or 'None', value])
        else:
          printKeyValueList([keymap['infoTitle'], value])
        if keymap['relMap']:
          Ind.Decrement()
      Ind.Decrement()
  if contactGroupIDs is not None and CONTACT_GROUPS in fields:
    printEntitiesCount(Ent.CONTACT_GROUP, None)
    Ind.Increment()
    for group in fields[CONTACT_GROUPS]:
      if group in contactGroupIDs:
        printKeyValueList([contactGroupIDs[group]])
        Ind.Increment()
        printKeyValueList(['id', group])
        Ind.Decrement()
      else:
        printKeyValueList(['id', group])
    Ind.Decrement()
  Ind.Decrement()

def _getContactFieldsList(contactsManager, displayFieldsList):
  for field in _getFieldsList():
    if field in contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP:
      displayFieldsList.append(contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP[field])
    else:
      invalidChoiceExit(field, contactsManager.CONTACT_ARGUMENT_TO_PROPERTY_MAP, True)

def _infoContacts(users, entityType, contactFeed=True):
  contactsManager = ContactsManager()
  entityList = getEntityList(Cmd.OB_CONTACT_ENTITY)
  contactIdLists = entityList if isinstance(entityList, dict) else None
  contactQuery = _initContactQueryAttributes()
  showContactGroups = False
  FJQC = FormatJSONQuoteChar()
  displayFieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in CONTACTS_PROJECTION_CHOICE_MAP:
      contactQuery['projection'] = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
    elif myarg == 'showgroups':
      showContactGroups = True
    elif myarg == 'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    else:
      FJQC.GetFormatJSON(myarg)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = None
    j = 0
    jcount = len(entityList)
    if not FJQC.formatJSON:
      entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        contactId = normalizeContactId(contact)
        contact = callGData(contactsObject, 'GetContact',
                            bailOnInternalServerError=True,
                            throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE,
                                         GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED, GDATA.INTERNAL_SERVER_ERROR],
                            retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                            uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId, projection=contactQuery['projection']))
        fields = contactsManager.ContactToFields(contact)
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount, FJQC)
      except (GDATA.notFound, GDATA.badRequest, GDATA.forbidden, GDATA.notImplemented, GDATA.internalServerError) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info contacts <ContactEntity>
#	[basic|full] [showgroups]
#	[fields <ContactFieldNameList>] [formatjson]
def infoUserContacts(users):
  _infoContacts(users, Ent.USER)

# gam info contacts <ContactEntity>
#	[basic|full] [showgroups]
#	[fields <ContactFieldNameList>] [formatjson]
def doInfoDomainContacts():
  _infoContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

# gam info gal <ContactEntity>
#	[basic|full]
#	[fields <ContactFieldNameList>] [formatjson]
def doInfoGAL():
  _infoContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

def _printShowContacts(users, entityType, contactFeed=True):
  contactsManager = ContactsManager()
  csvPF = CSVPrintFile([Ent.Singular(entityType), CONTACT_ID, CONTACT_NAME], 'sortall',
                       contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  contactQuery = _initContactQueryAttributes()
  countsOnly = showContactGroups = False
  displayFieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif contactFeed and myarg == 'showgroups':
      showContactGroups = True
    elif myarg == 'fields':
      _getContactFieldsList(contactsManager, displayFieldsList)
      if contactFeed and CONTACT_GROUPS in displayFieldsList:
        showContactGroups = True
    elif myarg == 'countsonly':
      countsOnly = True
      contactQuery['projection'] = CONTACTS_PROJECTION_CHOICE_MAP['basic']
      if csvPF:
        csvPF.SetTitles([Ent.Singular(entityType), 'Contacts'])
    elif _getContactQueryAttributes(contactQuery, myarg, entityType, 0, True):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=contactFeed)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    if contactQuery['contactGroup']:
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery['contactGroup'],
                                                                         None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery['contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery['group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)
    contacts = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
    jcount = len(contacts) if contacts is not None else 0
    if countsOnly:
      if csvPF:
        csvPF.WriteRowTitles({Ent.Singular(entityType): user, 'Contacts': jcount})
      else:
        printEntityKVList([entityType, user], ['Contacts', jcount], i, count)
      continue
    if contacts is None:
      continue
    if not csvPF:
      if not FJQC.formatJSON:
        entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.CONTACT, i, count)
      Ind.Increment()
      j = 0
      for contact in contacts:
        j += 1
        fields = contactsManager.ContactToFields(contact)
        if not localContactSelects(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        _showContact(contactsManager, fields, displayFieldsList, [None, contactGroupIDs][showContactGroups], j, jcount, FJQC)
      Ind.Decrement()
    elif contacts:
      for contact in contacts:
        fields = contactsManager.ContactToFields(contact)
        if not localContactSelects(contactsManager, contactQuery, fields):
          continue
        if showContactGroups and CONTACT_GROUPS in fields and not contactGroupIDs:
          contactGroupIDs, _ = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
        contactRow = {Ent.Singular(entityType): user, CONTACT_ID: fields[CONTACT_ID]}
        for key in contactsManager.CONTACT_NAME_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            if key == CONTACT_UPDATED:
              contactRow[key] = formatLocalTime(fields[key])
            elif key not in (CONTACT_NOTES, CONTACT_BILLING_INFORMATION):
              contactRow[key] = fields[key]
            else:
              contactRow[key] = escapeCRsNLs(fields[key])
        for key in contactsManager.CONTACT_ARRAY_PROPERTY_PRINT_ORDER:
          if displayFieldsList and key not in displayFieldsList:
            continue
          if key in fields:
            keymap = contactsManager.CONTACT_ARRAY_PROPERTIES[key]
            contactRow[f'{key}.0.count'] = len(fields[key])
            j = 0
            for item in fields[key]:
              j += 1
              fn = f'{key}.{j}.'
              fnt = item.get('label')
              if fnt:
                contactRow[fn+'type'] = fnt
              elif keymap['relMap']:
                contactRow[fn+'type'] = keymap['relMap'].get(item['rel'], 'custom')
              if keymap['primary']:
                contactRow[fn+'rank'] = 'primary' if item['primary'] == 'true' else 'notprimary'
              value = item['value']
              if value is None:
                value = ''
              if key == CONTACT_IMS:
                contactRow[fn+'protocol'] = contactsManager.IM_REL_TO_PROTOCOL_MAP.get(item['protocol'], item['protocol'])
                contactRow[fn+keymap['infoTitle']] = value
              elif key == CONTACT_ADDRESSES:
                contactRow[fn+keymap['infoTitle']] = escapeCRsNLs(value)
                for org_key in contactsManager.ADDRESS_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ADDRESS_FIELD_TO_ARGUMENT_MAP[org_key]] = escapeCRsNLs(item[org_key])
              elif key == CONTACT_ORGANIZATIONS:
                contactRow[fn+keymap['infoTitle']] = value
                for org_key in contactsManager.ORGANIZATION_FIELD_PRINT_ORDER:
                  if item[org_key]:
                    contactRow[fn+contactsManager.ORGANIZATION_FIELD_TO_ARGUMENT_MAP[org_key]] = item[org_key]
              elif key == CONTACT_USER_DEFINED_FIELDS:
                contactRow[fn+'type'] = item.get('rel') or 'None'
                contactRow[fn+keymap['infoTitle']] = value
              else:
                contactRow[fn+keymap['infoTitle']] = value
        if showContactGroups and CONTACT_GROUPS in fields:
          contactRow[f'{CONTACT_GROUPS}.0.count'] = len(fields[CONTACT_GROUPS])
          j = 0
          for group in fields[CONTACT_GROUPS]:
            j += 1
            fn = f'{CONTACT_GROUPS}.{j}.'
            contactRow[fn+CONTACT_GROUP_ID] = f'id:{group}'
            if group in contactGroupIDs:
              contactRow[fn+CONTACT_GROUP_NAME] = contactGroupIDs[group]
        if not FJQC.formatJSON:
          csvPF.WriteRowTitles(contactRow)
        elif csvPF.CheckRowTitles(contactRow):
          csvPF.WriteRowNoFilter({Ent.Singular(entityType): user, CONTACT_ID: fields[CONTACT_ID],
                                  CONTACT_NAME: fields.get(CONTACT_NAME, ''),
                                  'JSON': json.dumps(cleanJSON(fields, timeObjects=CONTACT_TIME_OBJECTS),
                                                     ensure_ascii=False, sort_keys=True)})
    elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and entityType == Ent.USER:
      csvPF.WriteRowNoFilter({Ent.Singular(entityType): user})
  if csvPF:
    csvPF.writeCSVfile('Contacts')

# gam <UserTypeEntity> print contacts [todrive <ToDriveAttribute>*] <UserContactSelection>
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson [quotechar <Character>]]
# gam <UserTypeEntity> show contacts <UserContactSelection>
#	[basic|full|countsonly] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def printShowUserContacts(users):
  _printShowContacts(users, Ent.USER)

# gam print contacts [todrive <ToDriveAttribute>*] <ContactSelection>
#	[basic|full] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson [quotechar <Character>]]
# gam show contacts <ContactSelection>
#	[basic|full|countsonly] [showgroups] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def doPrintShowDomainContacts():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

# gam print gal [todrive <ToDriveAttribute>*] <ContactSelection>
#	[basic|full] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson [quotechar <Character>]]
# gam show gal <ContactSelection>
#	[basic|full|countsonly] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[fields <ContactFieldNameList>] [formatjson]
def doPrintShowGAL():
  _printShowContacts([GC.Values[GC.DOMAIN]], Ent.DOMAIN, False)

def _processContactPhotos(users, entityType, function):
  def _makeFilenameFromPattern():
    filename = filenamePattern[:]
    if subForContactId:
      filename = filename.replace('#contactid#', contactId)
    if subForEmail:
      for email in fields.get('Emails', []):
        if email.get('primary', 'false') == 'true':
          filename = filename.replace('#email#', email['value'])
          break
      else:
        filename = filename.replace('#email#', contactId)
    return filename

  contactsManager = ContactsManager()
  entityList, contactIdLists, contactQuery, queriedContacts = _getContactEntityList(entityType, 1, False)
  if function in {'ChangePhoto', 'GetPhoto'}:
    targetFolder = os.getcwd()
    filenamePattern = '#contactid#.jpg'
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'drivedir':
        targetFolder = GC.Values[GC.DRIVE_DIR]
      elif myarg in {'sourcefolder', 'targetfolder'}:
        targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
        if function == 'GetPhoto' and not os.path.isdir(targetFolder):
          os.makedirs(targetFolder)
      elif myarg == 'filename':
        filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
      else:
        unknownArgumentExit()
    subForContactId = filenamePattern.find('#contactid#') != -1
    subForEmail = filenamePattern.find('#email#') != -1
    if not subForContactId and not subForEmail:
      filename = filenamePattern
  else: #elif function == 'DeletePhoto':
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactIdLists:
      entityList = contactIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count, contactFeed=True)
    if not contactsObject:
      continue
    if contactQuery['contactGroup']:
      groupId, _, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactQuery['contactGroup'],
                                                           None, None, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactQuery['contactGroup']], Msg.DOES_NOT_EXIST, i, count)
        continue
      contactQuery['group'] = contactsObject.GetContactGroupFeedUri(contact_list=user, projection='base', groupId=groupId)
    if queriedContacts:
      entityList = queryContacts(contactsObject, contactQuery, entityType, user, i, count)
      if entityList is None:
        continue
    j = 0
    jcount = len(entityList)
    entityPerformActionModifierNumItems([entityType, user], Msg.MAXIMUM_OF, jcount, Ent.PHOTO, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contact in entityList:
      j += 1
      try:
        if not queriedContacts:
          contactId = normalizeContactId(contact)
          contact = callGData(contactsObject, 'GetContact',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=contactsObject.GetContactFeedUri(contact_list=user, contactId=contactId))
          fields = contactsManager.ContactToFields(contact)
        else:
          contactId = contactsManager.GetContactShortId(contact)
          fields = contactsManager.ContactToFields(contact)
          if not localContactSelects(contactsManager, contactQuery, fields):
            continue
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId], str(e), j, jcount)
        break
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
      try:
        if function == 'ChangePhoto':
          if subForContactId or subForEmail:
            filename = _makeFilenameFromPattern()
          callGData(contactsObject, function,
                    throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                    retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                    media=filename, contact_entry_or_url=contact,
                    content_type='image/*', content_length=os.path.getsize(filename), extra_headers={'If-Match': '*'})
          entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
        elif function == 'GetPhoto':
          if subForContactId or subForEmail:
            filename = _makeFilenameFromPattern()
          filename = os.path.join(targetFolder, filename)
          photo_data = callGData(contactsObject, function,
                                 throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                                 retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                                 contact_entry_or_url=contact)
          if photo_data:
            status, e = writeFileReturnError(filename, eval(photo_data), mode='wb') #pylint: disable=eval-used
            if status:
              entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
            else:
              entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], str(e), i, count)
          else:
            entityDoesNotHaveItemWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, ''], i, count)
        else: #elif function == 'DeletePhoto':
          filename = ''
          callGData(contactsObject, function,
                    throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN, GDATA.NOT_IMPLEMENTED],
                    retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                    contact_entry_or_url=contact, extra_headers={'If-Match': '*'})
          entityActionPerformed([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], i, count)
      except GDATA.notFound:
        entityDoesNotHaveItemWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, ''], i, count)
      except (GDATA.badRequest, OSError, IOError) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT, contactId, Ent.PHOTO, filename], str(e), j, jcount)
      except (GDATA.forbidden, GDATA.notImplemented):
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> update contactphotos <ContactEntity>|<UserContactSelection>
#	[drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
def updateUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, 'ChangePhoto')

# gam update contactphotos <ContactEntity>|<ContactSelection>
#	[drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
def doUpdateDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, 'ChangePhoto')

# gam <UserTypeEntity> get contactphotos <ContactEntity>|<UserContactSelection>
#	[drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]
def getUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, 'GetPhoto')

# gam get contactphotos <ContactEntity>|<ContactSelection>
#	[drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]
def doGetDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, 'GetPhoto')

# gam <UserTypeEntity> delete contactphotos <ContactEntity>|<UserContactSelection>
def deleteUserContactPhoto(users):
  _processContactPhotos(users, Ent.USER, 'DeletePhoto')

# gam delete contactphotos <ContactEntity>|<ContactSelection>
def doDeleteDomainContactPhoto():
  _processContactPhotos([GC.Values[GC.DOMAIN]], Ent.DOMAIN, 'DeletePhoto')

# gam <UserTypeEntity> create contactgroup <ContactGroupAttribute>+
def createUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  fields = contactsManager.GetContactGroupFields()
  contactGroup = contactsManager.FieldsToContactGroup(fields)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    _, contactGroupNames = getContactGroupsInfo(contactsManager, contactsObject, entityType, user, i, count)
    if contactGroupNames is False:
      continue
    if fields[CONTACT_GROUP_NAME] in contactGroupNames:
      entityActionFailedWarning([entityType, user], Ent.TypeNameMessage(Ent.CONTACT_GROUP_NAME, fields[CONTACT_GROUP_NAME], Msg.DUPLICATE), i, count)
      continue
    try:
      group = callGData(contactsObject, 'CreateGroup',
                        throwErrors=[GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                        retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                        new_group=contactGroup, insert_uri=contactsObject.GetContactGroupFeedUri(contact_list=user))
      entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactsManager.GetContactShortId(group)], i, count)
    except GDATA.badRequest as e:
      entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, ''], str(e), i, count)
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)

# gam <UserTypeEntity> update contactgroups <ContactGroupItem> <ContactAttribute>+
def updateUserContactGroup(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getStringReturnInList(Cmd.OB_CONTACT_GROUP_ITEM)
  update_fields = contactsManager.GetContactGroupFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup,
                                                                         contactGroupIDs, contactGroupNames, entityType, user, i, count)
      if not groupId:
        if contactGroupNames:
          entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
          continue
        break
      if update_fields[CONTACT_GROUP_NAME] in contactGroupNames and groupId not in contactGroupNames[update_fields[CONTACT_GROUP_NAME]]:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Ent.TypeNameMessage(Ent.CONTACT_GROUP_NAME, update_fields[CONTACT_GROUP_NAME], Msg.DUPLICATE), i, count)
        continue
      contactGroup = contactGroupIDs.get(groupId, contactGroup)
      try:
        group = callGData(contactsObject, 'GetGroup',
                          throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        fields = contactsManager.ContactGroupToFields(group)
        for field in update_fields:
          fields[field] = update_fields[field]
        groupEntry = contactsManager.FieldsToContactGroup(fields)
        groupEntry.category = group.category
        groupEntry.link = group.link
        groupEntry.etag = group.etag
        groupEntry.id = group.id
        callGData(contactsObject, 'UpdateGroup',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), updated_group=groupEntry, extra_headers={'If-Match': group.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactGroup], j, jcount)
      except (GDATA.notFound, GDATA.badRequest) as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete contactgroups <ContactGroupEntity>
def deleteUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getEntityList(Cmd.OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup,
                                                                           contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, 'GetGroup',
                          throwErrors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        callGData(contactsObject, 'DeleteGroup',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                  edit_uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId), extra_headers={'If-Match': group.etag})
        entityActionPerformed([entityType, user, Ent.CONTACT_GROUP, contactGroup], j, jcount)
      except GDATA.notFound as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

CONTACT_GROUP_TIME_OBJECTS = {CONTACT_GROUP_UPDATED}

def _showContactGroup(contactsManager, group, j, jcount, FJQC):
  fields = contactsManager.ContactGroupToFields(group)
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(fields, timeObjects=CONTACT_GROUP_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.CONTACT_GROUP, fields[CONTACT_GROUP_NAME]], j, jcount)
  Ind.Increment()
  printKeyValueList(['updated', formatLocalTime(fields[CONTACT_GROUP_UPDATED])])
  printKeyValueList(['id', fields[CONTACT_GROUP_ID]])
  Ind.Decrement()

# gam <UserTypeEntity> info contactgroups <ContactGroupEntity>
#	[formatjson]
def infoUserContactGroups(users):
  contactsManager = ContactsManager()
  entityType = Ent.USER
  entityList = getEntityList(Cmd.OB_CONTACT_GROUP_ENTITY, shlexSplit=True)
  contactGroupIdLists = entityList if isinstance(entityList, dict) else None
  FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if contactGroupIdLists:
      entityList = contactGroupIdLists[user]
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    contactGroupIDs = contactGroupNames = None
    j = 0
    jcount = len(entityList)
    if not FJQC.formatJSON:
      entityPerformActionNumItems([entityType, user], jcount, Ent.CONTACT_GROUP, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    for contactGroup in entityList:
      j += 1
      try:
        groupId, contactGroupIDs, contactGroupNames = validateContactGroup(contactsManager, contactsObject, contactGroup,
                                                                           contactGroupIDs, contactGroupNames, entityType, user, i, count)
        if not groupId:
          if contactGroupNames:
            entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], Msg.DOES_NOT_EXIST, j, jcount)
            continue
          break
        contactGroup = contactGroupIDs.get(groupId, contactGroup)
        group = callGData(contactsObject, 'GetGroup',
                          throwErrors=[GDATA.NOT_FOUND, GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                          retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                          uri=contactsObject.GetContactGroupFeedUri(contact_list=user, groupId=groupId))
        _showContactGroup(contactsManager, group, j, jcount, FJQC)
      except GDATA.notFound as e:
        entityActionFailedWarning([entityType, user, Ent.CONTACT_GROUP, contactGroup], str(e), j, jcount)
      except GDATA.forbidden:
        entityServiceNotApplicableWarning(entityType, user, i, count)
        break
      except GDATA.serviceNotApplicable:
        entityUnknownWarning(entityType, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> print contactgroups [todrive <ToDriveAttribute>*] [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[formatjson [quotechar <Character>]]
# gam <UserTypeEntity> show contactgroups [updated_min <Date>]
#	[basic|full] [showdeleted] [orderby <ContactOrderByFieldName> [ascending|descending]]
#	[formatjson]
def printShowUserContactGroups(users):
  entityType = Ent.USER
  csvPF = CSVPrintFile([Ent.Singular(entityType), CONTACT_GROUP_ID, CONTACT_GROUP_NAME]) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  projection = 'full'
  url_params = {'max-results': str(GC.Values[GC.CONTACT_MAX_RESULTS])}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'orderby':
      url_params['orderby'], url_params['sortorder'] = getOrderBySortOrder(CONTACTS_ORDERBY_CHOICE_MAP, 'ascending', False)
    elif myarg in CONTACTS_PROJECTION_CHOICE_MAP:
      projection = CONTACTS_PROJECTION_CHOICE_MAP[myarg]
    elif myarg == 'showdeleted':
      url_params['showdeleted'] = 'true'
    elif myarg == 'updatedmin':
      url_params['updated-min'] = getYYYYMMDD()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  contactsManager = ContactsManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, contactsObject = getContactsObject(entityType, user, i, count)
    if not contactsObject:
      continue
    printGettingAllEntityItemsForWhom(Ent.CONTACT_GROUP, user, i, count)
    uri = contactsObject.GetContactGroupFeedUri(contact_list=user, projection=projection)
    try:
      groups = callGDataPages(contactsObject, 'GetGroupsFeed',
                              pageMessage=getPageMessage(),
                              throwErrors=[GDATA.SERVICE_NOT_APPLICABLE, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              uri=uri, url_params=url_params)
      if not csvPF:
        jcount = len(groups)
        if not FJQC.formatJSON:
          entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CONTACT_GROUP, i, count)
        Ind.Increment()
        j = 0
        for group in groups:
          j += 1
          _showContactGroup(contactsManager, group, j, jcount, FJQC)
        Ind.Decrement()
      else:
        if groups:
          for group in groups:
            fields = contactsManager.ContactGroupToFields(group)
            contactRow = {Ent.Singular(entityType): user, CONTACT_GROUP_ID: f'id:{fields[CONTACT_GROUP_ID]}',
                          CONTACT_GROUP_NAME: fields[CONTACT_GROUP_NAME], CONTACT_GROUP_UPDATED: formatLocalTime(fields[CONTACT_GROUP_UPDATED])}
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(contactRow)
            elif csvPF.CheckRowTitles(contactRow):
              csvPF.WriteRowNoFilter({Ent.Singular(entityType): user, CONTACT_GROUP_ID: f'id:{fields[CONTACT_GROUP_ID]}',
                                      CONTACT_GROUP_NAME: fields[CONTACT_GROUP_NAME],
                                      'JSON': json.dumps(cleanJSON(fields, timeObjects=CONTACT_GROUP_TIME_OBJECTS),
                                                         ensure_ascii=False, sort_keys=True)})
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and entityType == Ent.USER:
          csvPF.WriteRowNoFilter({Ent.Singular(entityType): user})
    except GDATA.forbidden:
      entityServiceNotApplicableWarning(entityType, user, i, count)
    except GDATA.serviceNotApplicable:
      entityUnknownWarning(entityType, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Contact Groups')

# CrOS commands utilities
def getCrOSDeviceEntity():
  if checkArgumentPresent('crossn'):
    return getUsersToModify(Cmd.ENTITY_CROS_SN, getString(Cmd.OB_SERIAL_NUMBER_LIST))
  if checkArgumentPresent('query'):
    return getUsersToModify(Cmd.ENTITY_CROS_QUERY, getString(Cmd.OB_QUERY))
  deviceId = getString(Cmd.OB_CROS_DEVICE_ENTITY)
  if deviceId[:6].lower() == 'query:':
    query = deviceId[6:]
    if query[:12].lower() == 'orgunitpath:':
      return getUsersToModify(Cmd.ENTITY_CROS_OU, query[12:])
    return getUsersToModify(Cmd.ENTITY_CROS_QUERY, query)
  Cmd.Backup()
  return getEntityList(Cmd.OB_CROS_ENTITY)

UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP = {
  'annotatedassetid': 'annotatedAssetId',
  'annotatedlocation': 'annotatedLocation',
  'annotateduser': 'annotatedUser',
  'asset': 'annotatedAssetId',
  'assetid': 'annotatedAssetId',
  'location': 'annotatedLocation',
  'notes': 'notes',
  'org': 'orgUnitPath',
  'orgunitpath': 'orgUnitPath',
  'ou': 'orgUnitPath',
  'tag': 'annotatedAssetId',
  'updatenotes': 'notes',
  'user': 'annotatedUser',
  }

CROS_ACTION_CHOICE_MAP = {
  'deprovisionsamemodelreplace': ('deprovision', 'same_model_replacement'),
  'deprovisionsamemodelreplacement': ('deprovision', 'same_model_replacement'),
  'deprovisiondifferentmodelreplace': ('deprovision', 'different_model_replacement'),
  'deprovisiondifferentmodelreplacement': ('deprovision', 'different_model_replacement'),
  'deprovisionupgradetransfer': ('deprovision', 'upgrade_transfer'),
  'deprovisionretiringdevice': ('deprovision', 'retiring_device'),
  'disable': ('disable', None),
  'reenable': ('reenable', None)
  }

CROS_ACTION_NAME_MAP = {
  'deprovision': Act.DEPROVISION,
  'disable': Act.DISABLE,
  'reenable': Act.REENABLE,
  }

# gam <CrOSTypeEntity> update (<CrOSAttribute>+ [quickcrosmove [<Boolean>]])|(action <CrOSAction> [acknowledge_device_touch_requirement])
def updateCrOSDevices(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  update_body = {}
  action_body = {}
  orgUnitPath = updateNotes = None
  ackWipe = quickCrOSMove = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_CROS_ARGUMENT_TO_PROPERTY_MAP[myarg]
      if up == 'orgUnitPath':
        orgUnitPath = getOrgUnitItem()
      elif up == 'notes':
        update_body[up] = getStringWithCRsNLs()
        updateNotes = update_body[up] if myarg == 'updatenotes' and update_body[up].find('#notes#') != -1 else None
      else:
        update_body[up] = getString(Cmd.OB_STRING, minLen=[0, 1][up == 'annotatedAssetId'])
    elif myarg == 'action':
      actionLocation = Cmd.Location()
      action_body['action'], deprovisionReason = getChoice(CROS_ACTION_CHOICE_MAP, mapChoice=True)
      if deprovisionReason:
        action_body['deprovisionReason'] = deprovisionReason
      Act.Set(CROS_ACTION_NAME_MAP[action_body['action']])
    elif myarg == 'acknowledgedevicetouchrequirement':
      ackWipe = True
    elif myarg == 'quickcrosmove':
      quickCrOSMove = getBoolean()
    else:
      unknownArgumentExit()
  if action_body and update_body:
    Cmd.SetLocation(actionLocation-1)
    usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format('action', '<CrOSAttribute>'))
  if orgUnitPath:
    status, orgUnitPath = checkOrgUnitPathExists(cd, orgUnitPath)
    if not status:
      entityActionFailedWarning([Ent.CROS_DEVICE, ''], f'{Ent.Singular(Ent.ORGANIZATIONAL_UNIT)}: {orgUnitPath}, {Msg.DOES_NOT_EXIST}')
      return
  i, count, entityList = getEntityArgument(entityList)
  function = None
  if action_body:
    if action_body['action'] == 'deprovision' and not ackWipe:
      stderrWarningMsg(Msg.REFUSING_TO_DEPROVISION_DEVICES.format(count))
      systemErrorExit(ACTION_NOT_PERFORMED_RC, None)
    function = 'action'
    parmId = 'resourceId'
    kwargs = {parmId: None, 'body': action_body}
  else:
    if update_body:
      if orgUnitPath and not quickCrOSMove:
        update_body['orgUnitPath'] = orgUnitPath
        orgUnitPath = None
      function = 'update'
      parmId = 'deviceId'
      kwargs = {parmId: None, 'body': update_body, 'fields': ''}
    if orgUnitPath:
      Act.Set(Act.ADD)
      _batchMoveCrOSesToOrgUnit(cd, orgUnitPath, 0, 0, entityList, quickCrOSMove)
      Act.Set(Act.UPDATE)
  if function is None:
    return
  for deviceId in entityList:
    i += 1
    kwargs[parmId] = deviceId
    try:
      if updateNotes:
        oldNotes = callGAPI(cd.chromeosdevices(), 'get',
                            throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=GC.Values[GC.CUSTOMER_ID], deviceId=deviceId, fields='notes')['notes']
        update_body['notes'] = updateNotes.replace('#notes#', oldNotes)
      callGAPI(cd.chromeosdevices(), function,
               throwReasons=[GAPI.INVALID, GAPI.CONDITION_NOT_MET, GAPI.INVALID_ORGUNIT,
                             GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerId=GC.Values[GC.CUSTOMER_ID], **kwargs)
      entityActionPerformed([Ent.CROS_DEVICE, deviceId], i, count)
    except (GAPI.invalid, GAPI.conditionNotMet) as e:
      entityActionFailedWarning([Ent.CROS_DEVICE, deviceId], str(e), i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.CROS_DEVICE, deviceId], Msg.INVALID_ORGUNIT, i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)

# gam update cros|croses <CrOSEntity> (<CrOSAttribute>+ [quickcrosmove [<Boolean>]])|(action <CrOSAction> [acknowledge_device_touch_requirement])
def doUpdateCrOSDevices():
  updateCrOSDevices(getCrOSDeviceEntity())

# From https://www.chromium.org/chromium-os/tpm_firmware_update
CROS_TPM_VULN_VERSIONS = ['41f', '420', '628', '8520']
CROS_TPM_FIXED_VERSIONS = ['422', '62b', '8521']

def checkTPMVulnerability(cros):
  if 'tpmVersionInfo' in cros and 'firmwareVersion' in cros['tpmVersionInfo']:
    if cros['tpmVersionInfo']['firmwareVersion'] in CROS_TPM_VULN_VERSIONS:
      cros['tpmVersionInfo']['tpmVulnerability'] = 'VULNERABLE'
    elif cros['tpmVersionInfo']['firmwareVersion'] in CROS_TPM_FIXED_VERSIONS:
      cros['tpmVersionInfo']['tpmVulnerability'] = 'UPDATED'
    else:
      cros['tpmVersionInfo']['tpmVulnerability'] = 'NOT IMPACTED'

def _filterActiveTimeRanges(cros, selected, listLimit, startDate, endDate, activeTimeRangesOrder):
  if not selected:
    cros.pop('activeTimeRanges', None)
    return []
  filteredItems = []
  activeTimeRanges = cros.get('activeTimeRanges', [])
  if activeTimeRangesOrder == 'DESCENDING':
    activeTimeRanges.reverse()
  i = 0
  for item in activeTimeRanges:
    activityDate = datetime.datetime.strptime(item['date'], YYYYMMDD_FORMAT)
    if ((startDate is None) or (activityDate >= startDate)) and ((endDate is None) or (activityDate <= endDate)):
      item['duration'] = formatMilliSeconds(item['activeTime'])
      item['minutes'] = item['activeTime']//60000
      item['activeTime'] = str(item['activeTime'])
      filteredItems.append(item)
      i += 1
      if listLimit and i == listLimit:
        break
  cros['activeTimeRanges'] = filteredItems
  return cros['activeTimeRanges']

def _filterDeviceFiles(cros, selected, listLimit, startTime, endTime):
  if not selected:
    cros.pop('deviceFiles', None)
    return []
  filteredItems = []
  i = 0
  for item in cros.get('deviceFiles', []):
    timeValue, _ = iso8601.parse_date(item['createTime'])
    if ((startTime is None) or (timeValue >= startTime)) and ((endTime is None) or (timeValue <= endTime)):
      item['createTime'] = formatLocalTime(item['createTime'])
      filteredItems.append(item)
      i += 1
      if listLimit and i == listLimit:
        break
  cros['deviceFiles'] = filteredItems
  return cros['deviceFiles']

def _filterCPUStatusReports(cros, selected, listLimit, startTime, endTime):
  if not selected:
    cros.pop('cpuStatusReports', None)
    return []
  filteredItems = []
  i = 0
  for item in cros.get('cpuStatusReports', []):
    timeValue, _ = iso8601.parse_date(item['reportTime'])
    if ((startTime is None) or (timeValue >= startTime)) and ((endTime is None) or (timeValue <= endTime)):
      item['reportTime'] = formatLocalTime(item['reportTime'])
      for tempInfo in item.get('cpuTemperatureInfo', []):
        tempInfo['label'] = tempInfo['label'].strip()
      item['cpuUtilizationPercentageInfo'] = ','.join([str(x) for x in item['cpuUtilizationPercentageInfo']])
      filteredItems.append(item)
      i += 1
      if listLimit and i == listLimit:
        break
  cros['cpuStatusReports'] = filteredItems
  return cros['cpuStatusReports']

def _filterSystemRamFreeReports(cros, selected, listLimit, startTime, endTime):
  if not selected:
    cros.pop('systemRamFreeReports', None)
    return []
  filteredItems = []
  i = 0
  for item in cros.get('systemRamFreeReports', []):
    timeValue, _ = iso8601.parse_date(item['reportTime'])
    if ((startTime is None) or (timeValue >= startTime)) and ((endTime is None) or (timeValue <= endTime)):
      item['reportTime'] = formatLocalTime(item['reportTime'])
      item['systemRamFreeInfo'] = ','.join([str(x) for x in item['systemRamFreeInfo']])
      filteredItems.append(item)
      i += 1
      if listLimit and i == listLimit:
        break
  cros['systemRamFreeReports'] = filteredItems
  return cros['systemRamFreeReports']

def _filterRecentUsers(cros, selected, listLimit):
  if not selected:
    cros.pop('recentUsers', None)
    return []
  filteredItems = []
  i = 0
  for item in cros.get('recentUsers', []):
    item['email'] = item.get('email', ['Unknown', 'UnmanagedUser'][item['type'] == 'USER_TYPE_UNMANAGED'])
    filteredItems.append(item)
    i += 1
    if listLimit and i == listLimit:
      break
  cros['recentUsers'] = filteredItems
  return cros['recentUsers']

def _filterDiskVolumeReports(cros, selected, listLimit):
  if not selected:
    cros.pop('diskVolumeReports', None)
    return []
  if listLimit:
    filteredItems = []
    i = 0
    for item in cros.get('diskVolumeReports', []):
      filteredItems.append(item)
      i += 1
      if listLimit and i == listLimit:
        break
    cros['diskVolumeReports'] = filteredItems
    return cros['diskVolumeReports']
  return cros.get('diskVolumeReports', [])

def _getFilterDateTime():
  filterDate = getYYYYMMDD(returnDateTime=True)
  return (filterDate, filterDate.replace(tzinfo=iso8601.UTC))

CROS_FIELDS_CHOICE_MAP = {
  'activetimeranges': ['activeTimeRanges.activeTime', 'activeTimeRanges.date'],
  'annotatedassetid': 'annotatedAssetId',
  'annotatedlocation': 'annotatedLocation',
  'annotateduser': 'annotatedUser',
  'asset': 'annotatedAssetId',
  'assetid': 'annotatedAssetId',
  'autoupdateexpiration': 'autoUpdateExpiration',
  'bootmode': 'bootMode',
  'cpustatusreports': 'cpuStatusReports',
  'devicefiles': ['deviceFiles.type', 'deviceFiles.createTime'],
  'deviceid': 'deviceId',
  'diskvolumereports': 'diskVolumeReports',
  'dockmacaddress': 'dockMacAddress',
  'ethernetmacaddress': 'ethernetMacAddress',
  'ethernetmacaddress0': 'ethernetMacAddress0',
  'firmwareversion': 'firmwareVersion',
  'lastenrollmenttime': 'lastEnrollmentTime',
  'lastsync': 'lastSync',
  'location': 'annotatedLocation',
  'macaddress': 'macAddress',
  'manufacturedate': 'manufactureDate',
  'meid': 'meid',
  'model': 'model',
  'notes': 'notes',
  'ordernumber': 'orderNumber',
  'org': 'orgUnitPath',
  'orgunitpath': 'orgUnitPath',
  'osversion': 'osVersion',
  'ou': 'orgUnitPath',
  'platformversion': 'platformVersion',
  'recentusers': ['recentUsers.email', 'recentUsers.type'],
  'serialnumber': 'serialNumber',
  'status': 'status',
  'supportenddate': 'supportEndDate',
  'systemramtotal': 'systemRamTotal',
  'systemramfreereports': 'systemRamFreeReports',
  'tag': 'annotatedAssetId',
  'timeranges': ['activeTimeRanges.activeTime', 'activeTimeRanges.date'],
  'times': ['activeTimeRanges.activeTime', 'activeTimeRanges.date'],
  'tpmversioninfo': 'tpmVersionInfo',
  'user': 'annotatedUser',
  'users': ['recentUsers.email', 'recentUsers.type'],
  'willautorenew': 'willAutoRenew',
  }
CROS_BASIC_FIELDS_LIST = ['deviceId', 'annotatedAssetId', 'annotatedLocation', 'annotatedUser', 'lastSync', 'notes', 'serialNumber', 'status']

CROS_SCALAR_PROPERTY_PRINT_ORDER = [
  'orgUnitPath',
  'annotatedAssetId',
  'annotatedLocation',
  'annotatedUser',
  'lastSync',
  'notes',
  'serialNumber',
  'status',
  'model',
  'firmwareVersion',
  'platformVersion',
  'osVersion',
  'bootMode',
  'meid',
  'dockMacAddress',
  'ethernetMacAddress',
  'ethernetMacAddress0',
  'macAddress',
  'systemRamTotal',
  'lastEnrollmentTime',
  'orderNumber',
  'manufactureDate',
  'supportEndDate',
  'autoUpdateExpiration',
  'willAutoRenew',
  ]

CROS_TIME_OBJECTS = {'lastSync', 'lastEnrollmentTime', 'supportEndDate', 'createTime', 'reportTime'}
CROS_FIELDS_WITH_CRS_NLS = {'notes'}
CROS_ACTIVE_TIME_RANGES_ARGUMENTS = ['timeranges', 'activetimeranges', 'times']
CROS_RECENT_USERS_ARGUMENTS = ['recentusers', 'users']
CROS_DEVICE_FILES_ARGUMENTS = ['devicefiles', 'files']
CROS_CPU_STATUS_REPORTS_ARGUMENTS = ['cpustatusreports']
CROS_DISK_VOLUME_REPORTS_ARGUMENTS = ['diskvolumereports']
CROS_SYSTEM_RAM_FREE_REPORTS_ARGUMENTS = ['systemramfreereports']
CROS_LISTS_ARGUMENTS = (CROS_ACTIVE_TIME_RANGES_ARGUMENTS+CROS_RECENT_USERS_ARGUMENTS+CROS_DEVICE_FILES_ARGUMENTS+
                        CROS_CPU_STATUS_REPORTS_ARGUMENTS+CROS_DISK_VOLUME_REPORTS_ARGUMENTS+CROS_SYSTEM_RAM_FREE_REPORTS_ARGUMENTS)
CROS_START_ARGUMENTS = ['start', 'startdate', 'oldestdate']
CROS_END_ARGUMENTS = ['end', 'enddate']

# gam <CrOSTypeEntity> info [nolists] [listlimit <Number>] [start <Date>] [end <Date>] [timerangeorder ascending|descending]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>] [downloadfile latest|<Time>] [targetfolder <FilePath>] [formatjson]
def infoCrOSDevices(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  downloadfile = None
  targetFolder = GC.Values[GC.DRIVE_DIR]
  projection = None
  fieldsList = []
  noLists = False
  FJQC = FormatJSONQuoteChar()
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  activeTimeRangesOrder = 'ASCENDING'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'nolists':
      noLists = True
    elif myarg == 'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg == 'timerangeorder':
      activeTimeRangesOrder = getChoice(SORTORDER_CHOICE_MAP, mapChoice=True)
    elif myarg == 'allfields':
      projection = 'FULL'
      fieldsList = []
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = PROJECTION_CHOICE_MAP[myarg]
      if projection == 'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg in CROS_FIELDS_CHOICE_MAP:
      addFieldToFieldsList(myarg, CROS_FIELDS_CHOICE_MAP, fieldsList)
    elif myarg == 'fields':
      for field in _getFieldsList():
        if field in CROS_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, CROS_FIELDS_CHOICE_MAP, fieldsList)
          if field in CROS_LISTS_ARGUMENTS:
            projection = 'FULL'
            noLists = False
        else:
          invalidChoiceExit(field, CROS_FIELDS_CHOICE_MAP, True)
    elif myarg == 'downloadfile':
      downloadfile = getString(Cmd.OB_STRING).lower()
      if downloadfile != 'latest':
        Cmd.Backup()
        downloadfile = formatLocalTime(getTimeOrDeltaFromNow())
    elif myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      FJQC.GetFormatJSON(myarg)
  if fieldsList:
    fieldsList.append('deviceId')
    if downloadfile:
      fieldsList.append('deviceFiles.downloadUrl')
  fields = getFieldsFromFieldsList(fieldsList)
  i, count, entityList = getEntityArgument(entityList)
  for deviceId in entityList:
    i += 1
    try:
      cros = callGAPI(cd.chromeosdevices(), 'get',
                      throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      customerId=GC.Values[GC.CUSTOMER_ID], deviceId=deviceId, projection=projection, fields=fields)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)
      continue
    checkTPMVulnerability(cros)
    if 'autoUpdateExpiration' in cros:
      cros['autoUpdateExpiration'] = formatLocalDatestamp(cros['autoUpdateExpiration'])
    if FJQC.formatJSON:
      printLine(json.dumps(cleanJSON(cros, timeObjects=CROS_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
      continue
    printEntity([Ent.CROS_DEVICE, deviceId], i, count)
    Ind.Increment()
    for up in CROS_SCALAR_PROPERTY_PRINT_ORDER:
      if up in cros:
        if up not in CROS_TIME_OBJECTS:
          if up not in CROS_FIELDS_WITH_CRS_NLS:
            printKeyValueList([up, cros[up]])
          else:
            printKeyValueWithCRsNLs(up, cros[up])
        else:
          printKeyValueList([up, formatLocalTime(cros[up])])
    up = 'tpmVersionInfo'
    if up in cros:
      printKeyValueList([up, ''])
      Ind.Increment()
      for key, value in sorted(iter(cros[up].items())):
        printKeyValueList([key, value])
      Ind.Decrement()
    if not noLists:
      activeTimeRanges = _filterActiveTimeRanges(cros, True, listLimit, startDate, endDate, activeTimeRangesOrder)
      if activeTimeRanges:
        printKeyValueList(['activeTimeRanges'])
        Ind.Increment()
        for activeTimeRange in activeTimeRanges:
          printKeyValueList(['date', activeTimeRange['date']])
          Ind.Increment()
          for key in ['activeTime', 'duration', 'minutes']:
            printKeyValueList([key, activeTimeRange[key]])
          Ind.Decrement()
        Ind.Decrement()
      recentUsers = _filterRecentUsers(cros, True, listLimit)
      if recentUsers:
        printKeyValueList(['recentUsers'])
        Ind.Increment()
        for recentUser in recentUsers:
          printKeyValueList(['type', recentUser['type']])
          Ind.Increment()
          printKeyValueList(['email', recentUser['email']])
          Ind.Decrement()
        Ind.Decrement()
      deviceFiles = _filterDeviceFiles(cros, True, listLimit, startTime, endTime)
      if deviceFiles:
        printKeyValueList(['deviceFiles'])
        Ind.Increment()
        for deviceFile in deviceFiles:
          printKeyValueList([deviceFile['type'], deviceFile['createTime']])
        Ind.Decrement()
        if downloadfile:
          if downloadfile == 'latest':
            deviceFile = deviceFiles[-1]
          else:
            for deviceFile in deviceFiles:
              if deviceFile['createTime'] == downloadfile:
                break
            else:
              deviceFile = None
          if deviceFile:
            downloadfilename = os.path.join(targetFolder, f'cros-logs-{deviceId}-{deviceFile["createTime"]}.zip')
            _, content = cd._http.request(deviceFile['downloadUrl'])
            writeFile(downloadfilename, content, mode='wb', continueOnError=True)
            printKeyValueList(['Downloaded', downloadfilename])
          else:
            Act.Set(Act.DOWNLOAD)
            entityActionFailedWarning([Ent.CROS_DEVICE, deviceId, Ent.DEVICE_FILE, downloadfile],
                                      Msg.DOES_NOT_EXIST, i, count)
            Act.Set(Act.INFO)
      elif downloadfile:
        Act.Set(Act.DOWNLOAD)
        entityActionNotPerformedWarning([Ent.CROS_DEVICE, deviceId, Ent.DEVICE_FILE, downloadfile],
                                        Msg.NO_ENTITIES_FOUND.format(Ent.Plural(Ent.DEVICE_FILE)), i, count)
        Act.Set(Act.INFO)
      cpuStatusReports = _filterCPUStatusReports(cros, True, listLimit, startTime, endTime)
      if cpuStatusReports:
        printKeyValueList(['cpuStatusReports'])
        Ind.Increment()
        for cpuStatusReport in cpuStatusReports:
          printKeyValueList(['reportTime', formatLocalTime(cpuStatusReport['reportTime'])])
          Ind.Increment()
          printKeyValueList(['cpuTemperatureInfo'])
          Ind.Increment()
          for tempInfo in cpuStatusReport.get('cpuTemperatureInfo', []):
            printKeyValueList([tempInfo['label'], tempInfo['temperature']])
          Ind.Decrement()
          printKeyValueList(['cpuUtilizationPercentageInfo', cpuStatusReport['cpuUtilizationPercentageInfo']])
          Ind.Decrement()
        Ind.Decrement()
      diskVolumeReports = _filterDiskVolumeReports(cros, True, listLimit)
      if diskVolumeReports:
        printKeyValueList(['diskVolumeReports'])
        Ind.Increment()
        printKeyValueList(['volumeInfo'])
        for diskVolumeReport in diskVolumeReports:
          volumeInfo = diskVolumeReport['volumeInfo']
          Ind.Increment()
          for volume in volumeInfo:
            printKeyValueList(['volumeId', volume['volumeId']])
            Ind.Increment()
            printKeyValueList(['storageFree', volume['storageFree']])
            printKeyValueList(['storageTotal', volume['storageTotal']])
            Ind.Decrement()
          Ind.Decrement()
        Ind.Decrement()
      systemRamFreeReports = _filterSystemRamFreeReports(cros, True, listLimit, startTime, endTime)
      if systemRamFreeReports:
        printKeyValueList(['systemRamFreeReports'])
        Ind.Increment()
        for systemRamFreeReport in systemRamFreeReports:
          printKeyValueList(['reportTime', systemRamFreeReport['reportTime']])
          Ind.Increment()
          printKeyValueList(['systemRamFreeInfo', systemRamFreeReport['systemRamFreeInfo']])
          Ind.Decrement()
        Ind.Decrement()
    Ind.Decrement()

# gam info cros|croses <CrOSEntity> [nolists] [listlimit <Number>] [start <Date>] [end <Date>]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
#	[downloadfile latest|<Time>] [targetfolder <FilePath>]
#	[formatjson]
def doInfoCrOSDevices():
  infoCrOSDevices(getCrOSDeviceEntity())

def getDeviceFilesEntity():

  deviceFilesEntity = {'list': [], 'dict': None, 'count': None, 'time': None, 'range': None}
  startEndTime = StartEndTime()
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      deviceFilesEntity['dict'] = entityList
    else:
      deviceFilesEntity['list'] = entityList
  else:
    myarg = getString(Cmd.OB_DEVICE_FILE_ENTITY, checkBlank=True)
    mycmd = myarg.lower()
    if mycmd in {'first', 'last', 'allexceptfirst', 'allexceptlast'}:
      deviceFilesEntity['count'] = (mycmd, getInteger(minVal=1))
    elif mycmd in {'before', 'after'}:
      dateTime, _, _ = getTimeOrDeltaFromNow(True)
      deviceFilesEntity['time'] = (mycmd, dateTime)
    elif mycmd == 'range':
      startEndTime.Get(mycmd)
      deviceFilesEntity['range'] = (mycmd, startEndTime.startDateTime, startEndTime.endDateTime)
    else:
      for timeItem in myarg.split(','):
        try:
          timestamp, _ = iso8601.parse_date(timeItem)
          deviceFilesEntity['list'].append(ISOformatTimeStamp(timestamp.astimezone(GC.Values[GC.TIMEZONE])))
        except (iso8601.ParseError, OverflowError):
          Cmd.Backup()
          invalidArgumentExit(YYYYMMDDTHHMMSS_FORMAT_REQUIRED)
  return deviceFilesEntity

def _selectDeviceFiles(deviceId, deviceFiles, deviceFilesEntity):
  numDeviceFiles = len(deviceFiles)
  if numDeviceFiles == 0:
    return deviceFiles
  for deviceFile in deviceFiles:
    deviceFile['createTime'] = formatLocalTime(deviceFile['createTime'])
  if deviceFilesEntity['count']:
    countType = deviceFilesEntity['count'][0]
    count = deviceFilesEntity['count'][1]
    if countType == 'first':
      return deviceFiles[:count]
    if countType == 'last':
      return deviceFiles[-count:]
    if countType == 'allexceptfirst':
      return deviceFiles[count:]
#   if countType == 'allexceptlast':
    return deviceFiles[:-count]
  if deviceFilesEntity['time']:
    dateTime = deviceFilesEntity['time'][1]
    count = 0
    if deviceFilesEntity['time'][0] == 'before':
      for deviceFile in deviceFiles:
        createTime, _ = iso8601.parse_date(deviceFile['createTime'])
        if createTime >= dateTime:
          break
        count += 1
      return deviceFiles[:count]
#   if deviceFilesEntity['time'][0] == 'after':
    for deviceFile in deviceFiles:
      createTime, _ = iso8601.parse_date(deviceFile['createTime'])
      if createTime >= dateTime:
        break
      count += 1
    return deviceFiles[count:]
  if deviceFilesEntity['range']:
    dateTime = deviceFilesEntity['range'][1]
    spos = 0
    for deviceFile in deviceFiles:
      createTime, _ = iso8601.parse_date(deviceFile['createTime'])
      if createTime >= dateTime:
        break
      spos += 1
    dateTime = deviceFilesEntity['range'][2]
    epos = spos
    for deviceFile in deviceFiles[spos:]:
      createTime, _ = iso8601.parse_date(deviceFile['createTime'])
      if createTime >= dateTime:
        break
      epos += 1
    return deviceFiles[spos:epos]
#  if deviceFilesEntity['range'] or deviceFilesEntity['dict']:
  if deviceFilesEntity['dict']:
    deviceFileCreateTimes = deviceFilesEntity['dict'][deviceId]
  else:
    deviceFileCreateTimes = deviceFilesEntity['list']
  return [deviceFile for deviceFile in deviceFiles if deviceFile['createTime'] in deviceFileCreateTimes]

# gam <CrOSTypeEntity> get devicefile [select <DeviceFileEntity>] [targetfolder <FilePath>]
def getCrOSDeviceFiles(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  targetFolder = GC.Values[GC.DRIVE_DIR]
  deviceFilesEntity = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'select':
      deviceFilesEntity = getDeviceFilesEntity()
    elif myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      unknownArgumentExit()
  fields = 'deviceFiles(type,createTime,downloadUrl)'
  i, count, entityList = getEntityArgument(entityList)
  for deviceId in entityList:
    i += 1
    try:
      deviceFiles = callGAPIitems(cd.chromeosdevices(), 'get', 'deviceFiles',
                                  throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                  customerId=GC.Values[GC.CUSTOMER_ID], deviceId=deviceId, fields=fields)
      if deviceFilesEntity:
        deviceFiles = _selectDeviceFiles(deviceId, deviceFiles, deviceFilesEntity)
      jcount = len(deviceFiles)
      entityPerformActionNumItems([Ent.CROS_DEVICE, deviceId], jcount, Ent.DEVICE_FILE, i, count)
      Ind.Increment()
      j = 0
      for deviceFile in deviceFiles:
        j += 1
        downloadfilename = os.path.join(targetFolder, f'cros-logs-{deviceId}-{deviceFile["createTime"]}.zip')
        _, content = cd._http.request(deviceFile['downloadUrl'])
        writeFile(downloadfilename, content, mode='wb', continueOnError=True)
        entityActionPerformed([Ent.DEVICE_FILE, downloadfilename], j, jcount)
      Ind.Decrement()
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, deviceId, i, count)

# gam get devicefile <CrOSEntity> [select <DeviceFileEntity>] [targetfolder <FilePath>]
def doGetCrOSDeviceFiles():
  getCrOSDeviceFiles(getCrOSDeviceEntity())

CROS_ORDERBY_CHOICE_MAP = {
  'lastsync': 'lastSync',
  'location': 'annotatedLocation',
  'notes': 'notes',
  'serialnumber': 'serialNumber',
  'status': 'status',
  'supportenddate': 'supportEndDate',
  'user': 'annotatedUser',
  }

CROS_INDEXED_TITLES = ['activeTimeRanges', 'recentUsers', 'deviceFiles',
                       'cpuStatusReports', 'diskVolumeReports', 'systemRamFreeReports']

# gam print cros [todrive <ToDriveAttribute>*]
#	[(query <QueryCrOS>)|(queries <QueryCrOSList>)|(select <CrOSTypeEntity>)] [limittoou <OrgUnitItem>]
#	[querytime.* <Time>] [start <Date>] [end <Date>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]]
#	[nolists|(<DrOSListFieldName>* [onerow])] [listlimit <Number>] [timerangeorder ascending|descending]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
#	[sortheaders] [formatjson [quotechar <Character>]]
#
# gam <CrOSTypeEntity> print cros [todrive <ToDriveAttribute>*]
#	[start <Date>] [end <Date>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]]
#	[nolists|(<DrOSListFieldName>* [onerow])] [listlimit <Number>] [timerangeorder ascending|descending]
#	[basic|full|allfields] <CrOSFieldName>* [fields <CrOSFieldNameList>]
#	[sortheaders] [formatjson [quotechar <Character>]]
def doPrintCrOSDevices(entityList=None):
  def _getSelectedLists(myarg):
    if myarg in CROS_ACTIVE_TIME_RANGES_ARGUMENTS:
      selectedLists['activeTimeRanges'] = True
    elif myarg in CROS_RECENT_USERS_ARGUMENTS:
      selectedLists['recentUsers'] = True
    elif myarg in CROS_DEVICE_FILES_ARGUMENTS:
      selectedLists['deviceFiles'] = True
    elif myarg in CROS_CPU_STATUS_REPORTS_ARGUMENTS:
      selectedLists['cpuStatusReports'] = True
    elif myarg in CROS_DISK_VOLUME_REPORTS_ARGUMENTS:
      selectedLists['diskVolumeReports'] = True
    elif myarg in CROS_SYSTEM_RAM_FREE_REPORTS_ARGUMENTS:
      selectedLists['systemRamFreeReports'] = True

  def _printCrOS(cros):
    checkTPMVulnerability(cros)
    if 'autoUpdateExpiration' in cros:
      cros['autoUpdateExpiration'] = formatLocalDatestamp(cros['autoUpdateExpiration'])
    if FJQC.formatJSON:
      if not csvPF.rowFilter or csvPF.CheckRowTitles(flattenJSON(cros, listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS)):
        csvPF.WriteRowNoFilter({'deviceId': cros['deviceId'],
                                'JSON': json.dumps(cleanJSON(cros, listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})
      return
    if 'notes' in cros:
      cros['notes'] = escapeCRsNLs(cros['notes'])
    for cpuStatusReport in cros.get('cpuStatusReports', []):
      for tempInfo in cpuStatusReport.get('cpuTemperatureInfo', []):
        tempInfo['label'] = tempInfo['label'].strip()
    if not noLists and not selectedLists:
      csvPF.WriteRowTitles(flattenJSON(cros, listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS))
      return
    attrib = 'tpmVersionInfo'
    if attrib in cros:
      for key, value in sorted(iter(cros[attrib].items())):
        attribKey = f'{attrib}.{key}'
        cros[attribKey] = value
      cros.pop(attrib)
    activeTimeRanges = _filterActiveTimeRanges(cros, selectedLists.get('activeTimeRanges', False), listLimit, startDate, endDate, activeTimeRangesOrder)
    recentUsers = _filterRecentUsers(cros, selectedLists.get('recentUsers', False), listLimit)
    deviceFiles = _filterDeviceFiles(cros, selectedLists.get('deviceFiles', False), listLimit, startTime, endTime)
    cpuStatusReports = _filterCPUStatusReports(cros, selectedLists.get('cpuStatusReports', False), listLimit, startTime, endTime)
    diskVolumeReports = _filterDiskVolumeReports(cros, selectedLists.get('diskVolumeReports', False), listLimit)
    systemRamFreeReports = _filterSystemRamFreeReports(cros, selectedLists.get('systemRamFreeReports', False), listLimit, startTime, endTime)
    if oneRow:
      csvPF.WriteRowTitles(flattenJSON(cros, listLimit=listLimit, timeObjects=CROS_TIME_OBJECTS))
      return
    row = {}
    for attrib in cros:
      if attrib not in {'kind', 'etag', 'tpmVersionInfo', 'recentUsers', 'activeTimeRanges',
                        'deviceFiles', 'cpuStatusReports', 'diskVolumeReports', 'systemRamFreeReports'}:
        if attrib not in CROS_TIME_OBJECTS:
          row[attrib] = cros[attrib]
        else:
          row[attrib] = formatLocalTime(cros[attrib])
    if noLists or (not activeTimeRanges and not recentUsers and not deviceFiles and
                   not cpuStatusReports and not diskVolumeReports and not systemRamFreeReports):
      csvPF.WriteRowTitles(row)
      return
    lenATR = len(activeTimeRanges)
    lenRU = len(recentUsers)
    lenDF = len(deviceFiles)
    lenCSR = len(cpuStatusReports)
    lenDVR = len(diskVolumeReports)
    lenSRFR = len(systemRamFreeReports)
    new_row = row
    for i in range(min(max(lenATR, lenRU, lenDF, lenCSR, lenDVR, lenSRFR), listLimit or max(lenATR, lenRU, lenDF, lenCSR, lenDVR, lenSRFR))):
      new_row = row.copy()
      if i < lenATR:
        for key in ['date', 'activeTime', 'duration', 'minutes']:
          new_row[f'activeTimeRanges.{key}'] = activeTimeRanges[i][key]
      if i < lenRU:
        for key in ['email', 'type']:
          new_row[f'recentUsers.{key}'] = recentUsers[i][key]
      if i < lenDF:
        for key in ['type', 'createTime']:
          new_row[f'deviceFiles.{key}'] = deviceFiles[i][key]
      if i < lenCSR:
        new_row['cpuStatusReports.reportTime'] = cpuStatusReports[i]['reportTime']
        for tempInfo in cpuStatusReports[i].get('cpuTemperatureInfo', []):
          new_row[f'cpuStatusReports.cpuTemperatureInfo.{tempInfo["label"]}'] = tempInfo['temperature']
        new_row['cpuStatusReports.cpuUtilizationPercentageInfo'] = cpuStatusReports[i]['cpuUtilizationPercentageInfo']
      if i < lenDVR:
        j = 0
        for volume in diskVolumeReports[i]['volumeInfo']:
          new_row[f'diskVolumeReports.volumeInfo.{j}.volumeId'] = volume['volumeId']
          new_row[f'diskVolumeReports.volumeInfo.{j}.storageFree'] = volume['storageFree']
          new_row[f'diskVolumeReports.volumeInfo.{j}.storageTotal'] = volume['storageTotal']
          j += 1
      if i < lenSRFR:
        for key in ['reportTime', 'systemRamFreeInfo']:
          new_row[f'systemRamFreeReports.{key}'] = systemRamFreeReports[i][key]
      csvPF.WriteRowTitles(new_row)

  def _callbackPrintCrOS(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printCrOS(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(API.DIRECTORY)
  fieldsList = ['deviceId']
  csvPF = CSVPrintFile(fieldsList, indexedTitles=CROS_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  orgUnitPath = projection = orderBy = sortOrder = None
  queries = [None]
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  selectedLists = {}
  queryTimes = {}
  allFields = noLists = oneRow = sortHeaders = False
  activeTimeRangesOrder = 'ASCENDING'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif entityList is None and myarg == 'limittoou':
      orgUnitPath = getOrgUnitItem()
    elif entityList is None and myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
    elif entityList is None and myarg.startswith('querytime'):
      queryTimes[myarg] = getTimeOrDeltaFromNow()[0:19]
    elif entityList is None and myarg == 'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_CROS, crosAllowed=True, userAllowed=False)
    elif myarg == 'orderby':
      orderBy, sortOrder = getOrderBySortOrder(CROS_ORDERBY_CHOICE_MAP, 'DESCENDING', True)
    elif myarg == 'onerow':
      oneRow = True
    elif myarg == 'nolists':
      noLists = True
      selectedLists = {}
    elif myarg == 'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg == 'timerangeorder':
      activeTimeRangesOrder = getChoice(SORTORDER_CHOICE_MAP, mapChoice=True)
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = PROJECTION_CHOICE_MAP[myarg]
      sortHeaders = True
      if projection == 'FULL':
        fieldsList = []
      else:
        fieldsList = CROS_BASIC_FIELDS_LIST[:]
    elif myarg == 'allfields':
      projection = 'FULL'
      allFields = sortHeaders = True
      fieldsList = []
    elif myarg == 'sortheaders':
      sortHeaders = getBoolean()
    elif myarg in CROS_LISTS_ARGUMENTS:
      _getSelectedLists(myarg)
    elif myarg in CROS_FIELDS_CHOICE_MAP:
      csvPF.AddField(myarg, CROS_FIELDS_CHOICE_MAP, fieldsList)
    elif myarg == 'fields':
      for field in _getFieldsList():
        if field in CROS_FIELDS_CHOICE_MAP:
          if field in CROS_LISTS_ARGUMENTS:
            _getSelectedLists(field)
          else:
            csvPF.AddField(field, CROS_FIELDS_CHOICE_MAP, fieldsList)
        else:
          invalidChoiceExit(field, CROS_FIELDS_CHOICE_MAP, True)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if selectedLists:
    noLists = False
    projection = 'FULL'
    for selectList in selectedLists:
      addFieldToFieldsList(selectList, CROS_FIELDS_CHOICE_MAP, fieldsList)
  if fieldsList:
    fieldsList.append('deviceId')
  _, _, entityList = getEntityArgument(entityList)
  if FJQC.formatJSON:
    sortHeaders = False
    csvPF.SetJSONTitles(['deviceId', 'JSON'])
  if entityList is None:
    sortRows = False
    fields = getItemFieldsFromFieldsList('chromeosdevices', fieldsList)
    for query in queries:
      if queryTimes and query is not None:
        for queryTimeName, queryTimeValue in iter(queryTimes.items()):
          query = query.replace(f'#{queryTimeName}#', queryTimeValue)
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      pageMessage = getPageMessage()
      pageToken = None
      totalItems = 0
      while True:
        try:
          feed = callGAPI(cd.chromeosdevices(), 'list',
                          throwReasons=[GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          pageToken=pageToken,
                          customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=projection, orgUnitPath=orgUnitPath,
                          orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        except GAPI.invalidInput:
          entityActionFailedWarning([Ent.CROS_DEVICE, None], invalidQuery(query))
          return
        except GAPI.invalidOrgunit as e:
          entityActionFailedWarning([Ent.CROS_DEVICE, None], str(e))
          return
        except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          accessErrorExit(cd)
        pageToken, totalItems = _processGAPIpagesResult(feed, 'chromeosdevices', None, totalItems, pageMessage, None, Ent.CROS_DEVICE)
        if feed:
          for cros in feed.get('chromeosdevices', []):
            _printCrOS(cros)
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          printGotAccountEntities(totalItems)
          break
  else:
    sortRows = True
    if allFields or len(set(fieldsList)) > 1:
      jcount = len(entityList)
      fields = getFieldsFromFieldsList(fieldsList)
      svcargs = dict([('customerId', GC.Values[GC.CUSTOMER_ID]), ('deviceId', None), ('projection', projection), ('fields', fields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
      method = getattr(cd.chromeosdevices(), 'get')
      dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
      bcount = 0
      j = 0
      for deviceId in entityList:
        j += 1
        svcparms = svcargs.copy()
        svcparms['deviceId'] = deviceId
        dbatch.add(method(**svcparms), request_id=batchRequestID('', 0, 0, j, jcount, deviceId))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
          bcount = 0
      if bcount > 0:
        dbatch.execute()
# The only field specified was deviceId, just list the CrOS devices
    else:
      for cros in entityList:
        _printCrOS({'deviceId': cros})
  if sortRows and orderBy:
    csvPF.SortRows(orderBy, reverse=sortOrder == 'DESCENDING')
  if sortHeaders:
    csvPF.SetSortTitles(['deviceId'])
  csvPF.writeCSVfile('CrOS')

CROS_ACTIVITY_TIME_OBJECTS = {'createTime'}

# gam print crosactivity [todrive <ToDriveAttribute>*]
#	[(query <QueryCrOS>)|(queries <QueryCrOSList>)|(select <CrOSTypeEntity>)] [limittoou <OrgUnitItem>]
#	[querytime.* <Time>]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]] [recentusers] [timeranges] [both] [devicefiles] [all]
#	[listlimit <Number>] [start <Date>] [end <Date>] [timerangeorder ascending|descending]
#	[delimiter <Character>] [formatjson [quotechar <Character>]]
#
# gam <CrOSTypeEntity> print crosactivity [todrive <ToDriveAttribute>*]
#	[orderby <CrOSOrderByFieldName> [ascending|descending]] [recentusers] [timeranges] [both] [devicefiles] [all]
#	[listlimit <Number>] [start <Date>] [end <Date>] [timerangeorder ascending|descending]
#	[delimiter <Character>] [formatjson [quotechar <Character>]]
def doPrintCrOSActivity(entityList=None):
  def _printCrOS(cros):
    row = {}
    if FJQC.formatJSON:
      if not csvPF.rowFilter or csvPF.CheckRowTitles(flattenJSON(cros, listLimit=listLimit, timeObjects=CROS_ACTIVITY_TIME_OBJECTS)):
        csvPF.WriteRowNoFilter({'deviceId': cros['deviceId'],
                                'JSON': json.dumps(cleanJSON(cros, timeObjects=CROS_ACTIVITY_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})
      return
    for attrib in cros:
      if attrib not in {'recentUsers', 'activeTimeRanges', 'deviceFiles'}:
        row[attrib] = cros[attrib]
    for activeTimeRange in _filterActiveTimeRanges(cros, selectActiveTimeRanges, listLimit, startDate, endDate, activeTimeRangesOrder):
      new_row = row.copy()
      for key in ['date', 'duration', 'minutes']:
        new_row[f'activeTimeRanges.{key}'] = activeTimeRange[key]
      csvPF.WriteRow(new_row)
    recentUsers = _filterRecentUsers(cros, selectRecentUsers, listLimit)
    if recentUsers:
      new_row = row.copy()
      new_row['recentUsers.email'] = delimiter.join([recentUser['email'] for recentUser in recentUsers])
      csvPF.WriteRow(new_row)
    for deviceFile in _filterDeviceFiles(cros, selectDeviceFiles, listLimit, startTime, endTime):
      new_row = row.copy()
      for key in ['type', 'createTime']:
        new_row[f'deviceFiles.{key}'] = deviceFile[key]
      csvPF.WriteRow(new_row)

  def _callbackPrintCrOS(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printCrOS(response)
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in [GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN]:
        checkEntityAFDNEorAccessErrorExit(cd, Ent.CROS_DEVICE, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.CROS_DEVICE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  cd = buildGAPIObject(API.DIRECTORY)
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  fieldsList = ['deviceId', 'annotatedAssetId', 'annotatedLocation', 'serialNumber', 'orgUnitPath']
  csvPF = CSVPrintFile(fieldsList)
  FJQC = FormatJSONQuoteChar(csvPF)
  projection = 'FULL'
  orgUnitPath = orderBy = sortOrder = None
  queries = [None]
  listLimit = 0
  startDate = endDate = startTime = endTime = None
  queryTimes = {}
  selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = False
  activeTimeRangesOrder = 'ASCENDING'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif entityList is None and myarg == 'limittoou':
      orgUnitPath = getOrgUnitItem()
    elif entityList is None and myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
    elif entityList is None and myarg.startswith('querytime'):
      queryTimes[myarg] = getTimeOrDeltaFromNow()[0:19]
    elif entityList is None and myarg == 'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_CROS, crosAllowed=True, userAllowed=False)
    elif myarg == 'listlimit':
      listLimit = getInteger(minVal=0)
    elif myarg in CROS_START_ARGUMENTS:
      startDate, startTime = _getFilterDateTime()
    elif myarg in CROS_END_ARGUMENTS:
      endDate, endTime = _getFilterDateTime()
    elif myarg == 'timerangeorder':
      activeTimeRangesOrder = getChoice(SORTORDER_CHOICE_MAP, mapChoice=True)
    elif myarg in CROS_ACTIVE_TIME_RANGES_ARGUMENTS:
      selectActiveTimeRanges = True
    elif myarg in CROS_DEVICE_FILES_ARGUMENTS:
      selectDeviceFiles = True
    elif myarg in CROS_RECENT_USERS_ARGUMENTS:
      selectRecentUsers = True
    elif myarg == 'both':
      selectActiveTimeRanges = selectRecentUsers = True
    elif myarg == 'all':
      selectActiveTimeRanges = selectDeviceFiles = selectRecentUsers = True
    elif myarg == 'orderby':
      orderBy, sortOrder = getOrderBySortOrder(CROS_ORDERBY_CHOICE_MAP, 'DESCENDING', True)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if not selectActiveTimeRanges and not selectDeviceFiles and not selectRecentUsers:
    selectActiveTimeRanges = selectRecentUsers = True
  if selectRecentUsers:
    fieldsList.append('recentUsers')
    csvPF.AddTitles('recentUsers.email')
  if selectActiveTimeRanges:
    fieldsList.append('activeTimeRanges')
    csvPF.AddTitles(['activeTimeRanges.date', 'activeTimeRanges.duration', 'activeTimeRanges.minutes'])
  if selectDeviceFiles:
    fieldsList.append('deviceFiles')
    csvPF.AddTitles(['deviceFiles.type', 'deviceFiles.createTime'])
  _, _, entityList = getEntityArgument(entityList)
  if FJQC.formatJSON:
    csvPF.SetJSONTitles(['deviceId', 'JSON'])
  if entityList is None:
    sortRows = False
    fields = getItemFieldsFromFieldsList('chromeosdevices', fieldsList)
    for query in queries:
      if queryTimes and query is not None:
        for queryTimeName, queryTimeValue in iter(queryTimes.items()):
          query = query.replace(f'#{queryTimeName}#', queryTimeValue)
      printGettingAllAccountEntities(Ent.CROS_DEVICE, query)
      pageMessage = getPageMessage()
      pageToken = None
      totalItems = 0
      while True:
        try:
          feed = callGAPI(cd.chromeosdevices(), 'list',
                          throwReasons=[GAPI.INVALID_INPUT, GAPI.INVALID_ORGUNIT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          pageToken=pageToken,
                          customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=projection, orgUnitPath=orgUnitPath,
                          orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.DEVICE_MAX_RESULTS])
        except GAPI.invalidInput:
          entityActionFailedWarning([Ent.CROS_DEVICE, None], invalidQuery(query))
          return
        except GAPI.invalidOrgunit as e:
          entityActionFailedWarning([Ent.CROS_DEVICE, None], str(e))
          return
        except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          accessErrorExit(cd)
        pageToken, totalItems = _processGAPIpagesResult(feed, 'chromeosdevices', None, totalItems, pageMessage, None, Ent.CROS_DEVICE)
        if feed:
          for cros in feed.get('chromeosdevices', []):
            _printCrOS(cros)
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          printGotAccountEntities(totalItems)
          break
  else:
    sortRows = True
    jcount = len(entityList)
    fields = ','.join(set(fieldsList))
    svcargs = dict([('customerId', GC.Values[GC.CUSTOMER_ID]), ('deviceId', None), ('projection', projection), ('fields', fields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.chromeosdevices(), 'get')
    dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
    bcount = 0
    j = 0
    for deviceId in entityList:
      j += 1
      svcparms = svcargs.copy()
      svcparms['deviceId'] = deviceId
      dbatch.add(method(**svcparms), request_id=batchRequestID('', 0, 0, j, jcount, deviceId))
      bcount += 1
      if bcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = cd.new_batch_http_request(callback=_callbackPrintCrOS)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
  if sortRows and orderBy:
    csvPF.SortRows(orderBy, reverse=sortOrder == 'DESCENDING')
  csvPF.writeCSVfile('CrOS Activity')

# gam <CrOSTypeEntity> print [cros|croses|crosactivity]
def doPrintCrOSEntity(entityList):
  if getChoice([Cmd.ARG_CROS, Cmd.ARG_CROSES, Cmd.ARG_CROSACTIVITY], defaultChoice=None) != Cmd.ARG_CROSACTIVITY:
    if not Cmd.ArgumentsRemaining():
      writeEntityNoHeaderCSVFile(Ent.CROS_DEVICE, entityList)
    else:
      doPrintCrOSDevices(entityList)
  else:
    doPrintCrOSActivity(entityList)

# Mobile command utilities
MOBILE_ACTION_CHOICE_MAP = {
  'accountwipe': 'admin_account_wipe',
  'adminaccountwipe': 'admin_account_wipe',
  'wipeaccount': 'admin_account_wipe',
  'adminremotewipe': 'admin_remote_wipe',
  'wipe': 'admin_remote_wipe',
  'approve': 'approve',
  'block': 'action_block',
  'cancelremotewipethenactivate': 'cancel_remote_wipe_then_activate',
  'cancelremotewipethenblock': 'cancel_remote_wipe_then_block',
  }

def getMobileDeviceEntity():
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent('query'):
    query = getString(Cmd.OB_QUERY)
  else:
    resourceId = getString(Cmd.OB_MOBILE_DEVICE_ENTITY)
    if resourceId[:6].lower() == 'query:':
      query = resourceId[6:]
    else:
      Cmd.Backup()
      query = None
  if not query:
    return ([{'resourceId': device, 'email': []} for device in getEntityList(Cmd.OB_MOBILE_ENTITY)], cd, True)
  try:
    printGettingAllAccountEntities(Ent.MOBILE_DEVICE, query)
    devices = callGAPIpages(cd.mobiledevices(), 'list', 'mobiledevices',
                            pageMessage=getPageMessage(),
                            throwReasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=GC.Values[GC.CUSTOMER_ID], query=query,
                            fields='nextPageToken,mobiledevices(resourceId,email)')
  except GAPI.invalidInput:
    Cmd.Backup()
    usageErrorExit(Msg.INVALID_QUERY)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  return ([{'resourceId': device['resourceId'], 'email': device.get('email', [])} for device in devices], cd, False)

def _getUpdateDeleteMobileOptions(myarg, options):
  if myarg in {'matchusers', 'ifusers'}:
    _, matchUsers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    options['matchUsers'] = {normalizeEmailAddressOrUID(user) for user in matchUsers}
  elif myarg == 'doit':
    options['doit'] = True
  else:
    unknownArgumentExit()

def _getMobileDeviceUser(mobileDevice, options):
  if options['matchUsers']:
    if mobileDevice['email']:
      for deviceUser in mobileDevice['email']:
        if deviceUser.lower() in options['matchUsers']:
          return (deviceUser, True)
      return (mobileDevice['email'][0], False)
    return ('Unknown', False)
  if mobileDevice['email']:
    return (mobileDevice['email'][0], True)
  return ('Unknown', True)

# gam update mobile|mobiles <MobileDeviceEntity> action <MobileAction>
#	[doit] [matchusers <UserTypeEntity>]
def doUpdateMobileDevices():
  entityList, cd, doit = getMobileDeviceEntity()
  body = {}
  options = {'doit': doit, 'matchUsers': set()}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'action':
      body['action'] = getChoice(MOBILE_ACTION_CHOICE_MAP, mapChoice=True)
    else:
      _getUpdateDeleteMobileOptions(myarg, options)
  if not body:
    entityActionNotPerformedWarning([Ent.MOBILE_DEVICE, None], Msg.NO_ACTION_SPECIFIED)
    return
  i = 0
  count = len(entityList)
  for device in entityList:
    i += 1
    resourceId = device['resourceId']
    deviceUser, status = _getMobileDeviceUser(device, options)
    if not status:
      entityActionNotPerformedWarning([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser], Msg.USER_NOT_IN_MATCHUSERS, i, count)
    elif not options['doit']:
      entityActionNotPerformedWarning([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser], Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
    else:
      try:
        callGAPI(cd.mobiledevices(), 'action',
                 bailOnInternalError=True, throwReasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                 customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId, body=body)
        printEntityKVList([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser],
                          [Msg.ACTION_APPLIED, body['action']], i, count)
      except GAPI.internalError:
        entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
      except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

# gam delete mobile|mobiles <MobileDeviceEntity>
#	[doit] [matchusers <UserTypeEntity>]
def doDeleteMobileDevices():
  entityList, cd, doit = getMobileDeviceEntity()
  options = {'doit': doit, 'matchUsers': set()}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    _getUpdateDeleteMobileOptions(myarg, options)
  i = 0
  count = len(entityList)
  for device in entityList:
    i += 1
    resourceId = device['resourceId']
    deviceUser, status = _getMobileDeviceUser(device, options)
    if not status:
      entityActionNotPerformedWarning([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser], Msg.USER_NOT_IN_MATCHUSERS, i, count)
    elif not options['doit']:
      entityActionNotPerformedWarning([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser], Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
    else:
      try:
        callGAPI(cd.mobiledevices(), 'delete',
                 bailOnInternalError=True, throwReasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                 customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId)
        entityActionPerformed([Ent.MOBILE_DEVICE, resourceId, Ent.USER, deviceUser], i, count)
      except GAPI.internalError:
        entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
      except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

MOBILE_FIELDS_CHOICE_MAP = {
  'adbstatus': 'adbStatus',
  'applications': 'applications',
  'basebandversion': 'basebandVersion',
  'bootloaderversion': 'bootloaderVersion',
  'brand': 'brand',
  'buildnumber': 'buildNumber',
  'defaultlanguage': 'defaultLanguage',
  'developeroptionsstatus': 'developerOptionsStatus',
  'devicecompromisedstatus': 'deviceCompromisedStatus',
  'deviceid': 'deviceId',
  'devicepasswordstatus': 'devicePasswordStatus',
  'email': 'email',
  'encryptionstatus': 'encryptionStatus',
  'firstsync': 'firstSync',
  'hardware': 'hardware',
  'hardwareid': 'hardwareId',
  'imei': 'imei',
  'kernelversion': 'kernelVersion',
  'lastsync': 'lastSync',
  'managedaccountisonownerprofile': 'managedAccountIsOnOwnerProfile',
  'manufacturer': 'manufacturer',
  'meid': 'meid',
  'model': 'model',
  'name': 'name',
  'networkoperator': 'networkOperator',
  'os': 'os',
  'otheraccountsinfo': 'otherAccountsInfo',
  'privilege': 'privilege',
  'releaseversion': 'releaseVersion',
  'resourceid': 'resourceId',
  'securitypatchlevel': 'securityPatchLevel',
  'serialnumber': 'serialNumber',
  'status': 'status',
  'supportsworkprofile': 'supportsWorkProfile',
  'type': 'type',
  'unknownsourcesstatus': 'unknownSourcesStatus',
  'useragent': 'userAgent',
  'wifimacaddress': 'wifiMacAddress',
  }

MOBILE_TIME_OBJECTS = {'firstSync', 'lastSync'}

def _initMobileFieldsParameters():
  return {'fieldsList': [], 'projection': None}

def _getMobileFieldsArguments(myarg, parameters):
  if myarg == 'allfields':
    parameters['projection'] = 'FULL'
    parameters['fieldsList'] = []
  elif myarg in PROJECTION_CHOICE_MAP:
    parameters['projection'] = PROJECTION_CHOICE_MAP[myarg]
    parameters['fieldsList'] = []
  elif getFieldsList(myarg, MOBILE_FIELDS_CHOICE_MAP, parameters['fieldsList'], initialField='resourceId'):
    pass
  else:
    return False
  return True

# gam info mobile|mobiles <MobileDeviceEntity>
#	[basic|full|allfields] <MobileFieldName>* [fields <MobileFieldNameList>] [formatjson]
def doInfoMobileDevices():
  entityList, cd, _ = getMobileDeviceEntity()
  parameters = _initMobileFieldsParameters()
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getMobileFieldsArguments(myarg, parameters):
      pass
    else:
      FJQC.GetFormatJSON(myarg)
  fields = getFieldsFromFieldsList(parameters['fieldsList'])
  i = 0
  count = len(entityList)
  for device in entityList:
    i += 1
    resourceId = device['resourceId']
    try:
      mobile = callGAPI(cd.mobiledevices(), 'get',
                        bailOnInternalError=True, throwReasons=[GAPI.INTERNAL_ERROR, GAPI.RESOURCE_ID_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        customerId=GC.Values[GC.CUSTOMER_ID], resourceId=resourceId, projection=parameters['projection'], fields=fields)
      if FJQC.formatJSON:
        printLine(json.dumps(cleanJSON(mobile, timeObjects=MOBILE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
      else:
        printEntity([Ent.MOBILE_DEVICE, resourceId], i, count)
        Ind.Increment()
        attrib = 'deviceId'
        if attrib in mobile:
          mobile[attrib] = mobile[attrib].encode('unicode-escape').decode(UTF8)
        attrib = 'securityPatchLevel'
        if attrib in mobile and int(mobile[attrib]):
          mobile[attrib] = formatLocalTimestamp(mobile[attrib])
        showJSON(None, mobile, timeObjects=MOBILE_TIME_OBJECTS)
        Ind.Decrement()
    except GAPI.internalError:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.resourceIdNotFound, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.MOBILE_DEVICE, resourceId], str(e), i, count)

MOBILE_ORDERBY_CHOICE_MAP = {
  'deviceid': 'deviceId',
  'email': 'email',
  'lastsync': 'lastSync',
  'model': 'model',
  'name': 'name',
  'os': 'os',
  'status': 'status',
  'type': 'type',
  }

# gam print mobile [todrive <ToDriveAttribute>*] [(query <QueryMobile>)|(queries <QueryMobileList>)]
#	[querytime.* <Time>]
#	[orderby <MobileOrderByFieldName> [ascending|descending]]
#	[basic|full|allfields] <MobileFieldName>* [fields <MobileFieldNameList>]
#	[delimiter <Character>] [appslimit <Number>] [oneappperrow] [listlimit <Number>]
#	[formatjson [quotechar <Character>]]
def doPrintMobileDevices():
  def _appDetails(app):
    appDetails = []
    for field in ['displayName', 'packageName', 'versionName']:
      appDetails.append(app.get(field, '<None>'))
    appDetails.append(str(app.get('versionCode', '<None>')))
    permissions = app.get('permission', [])
    if permissions:
      appDetails.append('/'.join(permissions))
    else:
      appDetails.append('<None>')
    return '-'.join(appDetails)

  def _printMobile(mobile):
    if FJQC.formatJSON:
      if not csvPF.rowFilter or csvPF.CheckRowTitles(flattenJSON(mobile, listLimit=listLimit, skipObjects=DEFAULT_SKIP_OBJECTS, timeObjects=MOBILE_TIME_OBJECTS)):
        csvPF.WriteRow({'resourceId': mobile['resourceId'],
                        'JSON': json.dumps(cleanJSON(mobile, listLimit=listLimit, skipObjects=DEFAULT_SKIP_OBJECTS, timeObjects=MOBILE_TIME_OBJECTS),
                                           ensure_ascii=False, sort_keys=True)})
      return
    row = {}
    for attrib in mobile:
      if attrib in DEFAULT_SKIP_OBJECTS:
        pass
      elif attrib in {'name', 'email', 'otherAccountsInfo'}:
        if listLimit > 0:
          row[attrib] = delimiter.join(mobile[attrib][0:listLimit])
        elif listLimit == 0:
          row[attrib] = delimiter.join(mobile[attrib])
      elif attrib == 'deviceId':
        row[attrib] = mobile[attrib].encode('unicode-escape').decode(UTF8)
      elif attrib in MOBILE_TIME_OBJECTS:
        row[attrib] = formatLocalTime(mobile[attrib])
      elif attrib == 'securityPatchLevel' and int(mobile[attrib]):
        row[attrib] = formatLocalTimestamp(mobile[attrib])
      elif attrib != 'applications':
        row[attrib] = mobile[attrib]
    attrib = 'applications'
    if not oneAppPerRow or attrib not in mobile or appsLimit < 0:
      if attrib in mobile and appsLimit >= 0:
        applications = []
        j = 0
        for app in mobile[attrib]:
          j += 1
          if appsLimit and (j > appsLimit):
            break
          applications.append(_appDetails(app))
        row[attrib] = delimiter.join(applications)
      csvPF.WriteRowTitles(row)
    else:
      j = 0
      for app in mobile[attrib]:
        j += 1
        if appsLimit and (j > appsLimit):
          break
        appRow = row.copy()
        appRow[attrib] = _appDetails(app)
        csvPF.WriteRowTitles(appRow)

  cd = buildGAPIObject(API.DIRECTORY)
  parameters = _initMobileFieldsParameters()
  csvPF = CSVPrintFile('resourceId')
  FJQC = FormatJSONQuoteChar(csvPF)
  orderBy = sortOrder = None
  oneAppPerRow = False
  queryTimes = {}
  queries = [None]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  listLimit = 1
  appsLimit = -1
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
    elif myarg.startswith('querytime'):
      queryTimes[myarg] = getTimeOrDeltaFromNow()[0:19]
    elif myarg == 'orderby':
      orderBy, sortOrder = getOrderBySortOrder(MOBILE_ORDERBY_CHOICE_MAP)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'listlimit':
      listLimit = getInteger(minVal=-1)
    elif myarg == 'appslimit':
      appsLimit = getInteger(minVal=-1)
    elif myarg == 'oneappperrow':
      oneAppPerRow = True
    elif _getMobileFieldsArguments(myarg, parameters):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if not FJQC.formatJSON:
    csvPF.SetSortTitles(['resourceId', 'deviceId', 'serialNumber', 'name', 'email', 'status'])
  if appsLimit >= 0:
    parameters['projection'] = 'FULL'
  fields = getItemFieldsFromFieldsList('mobiledevices', parameters['fieldsList'])
  for query in queries:
    if queryTimes and query is not None:
      for queryTimeName, queryTimeValue in iter(queryTimes.items()):
        query = query.replace(f'#{queryTimeName}#', queryTimeValue)
    printGettingAllAccountEntities(Ent.MOBILE_DEVICE, query)
    pageMessage = getPageMessage()
    pageToken = None
    totalItems = 0
    while True:
      try:
        feed = callGAPI(cd.mobiledevices(), 'list',
                        throwReasons=[GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        pageToken=pageToken,
                        customerId=GC.Values[GC.CUSTOMER_ID], query=query, projection=parameters['projection'],
                        orderBy=orderBy, sortOrder=sortOrder, fields=fields, maxResults=GC.Values[GC.MOBILE_MAX_RESULTS])
      except GAPI.invalidInput:
        entityActionFailedWarning([Ent.MOBILE_DEVICE, None], invalidQuery(query))
        return
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
      pageToken, totalItems = _processGAPIpagesResult(feed, 'mobiledevices', None, totalItems, pageMessage, None, Ent.MOBILE_DEVICE)
      if feed:
        for mobile in feed.get('mobiledevices', []):
          _printMobile(mobile)
        del feed
      if not pageToken:
        _finalizeGAPIpagesResult(pageMessage)
        printGotAccountEntities(totalItems)
        break
  csvPF.writeCSVfile('Mobile')

GROUP_DISCOVER_CHOICES = {
  'allmemberscandiscover': 'ALL_MEMBERS_CAN_DISCOVER',
  'allindomaincandiscover': 'ALL_IN_DOMAIN_CAN_DISCOVER',
  'anyonecandiscover': 'ANYONE_CAN_DISCOVER',
  }
GROUP_ASSIST_CONTENT_CHOICES = {
  'allmembers': 'ALL_MEMBERS',
  'ownersandmanagers': 'OWNERS_AND_MANAGERS',
  'managersonly': 'MANAGERS_ONLY',
  'ownersonly': 'OWNERS_ONLY',
  'none': 'NONE',
  }
GROUP_MODERATE_CONTENT_CHOICES = {
  'allmembers': 'ALL_MEMBERS',
  'ownersandmanagers': 'OWNERS_AND_MANAGERS',
  'ownersonly': 'OWNERS_ONLY',
  'none': 'NONE',
  }
GROUP_MODERATE_MEMBERS_CHOICES = {
  'allmembers': 'ALL_MEMBERS',
  'ownersandmanagers': 'OWNERS_AND_MANAGERS',
  'ownersonly': 'OWNERS_ONLY',
  'none': 'NONE',
  }
GROUP_DEPRECATED_ATTRIBUTES = {
  'allowgooglecommunication': ['allowGoogleCommunication', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'favoriterepliesontop': ['favoriteRepliesOnTop', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'maxmessagebytes': ['maxMessageBytes', {GC.VAR_TYPE: GC.TYPE_INTEGER, GC.VAR_LIMITS: (ONE_KILO_BYTES, ONE_MEGA_BYTES)}],
  'messagedisplayfont': ['messageDisplayFont', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                'choices': {'defaultfont': 'DEFAULT_FONT', 'fixedwidthfont': 'FIXED_WIDTH_FONT'}}],
  'whocanaddreferences': ['whoCanAddReferences', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmarkfavoritereplyonowntopic': ['whoCanMarkFavoriteReplyOnOwnTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  }
GROUP_DISCOVER_ATTRIBUTES = {
  'showingroupdirectory': ['showInGroupDirectory', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  }
GROUP_ASSIST_CONTENT_ATTRIBUTES = {
  'whocanassigntopics': ['whoCanAssignTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanenterfreeformtags': ['whoCanEnterFreeFormTags', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanhideabuse': ['whoCanHideAbuse', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmaketopicssticky': ['whoCanMakeTopicsSticky', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmarkduplicate': ['whoCanMarkDuplicate', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmarkfavoritereplyonanytopic': ['whoCanMarkFavoriteReplyOnAnyTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmarknoresponseneeded': ['whoCanMarkNoResponseNeeded', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmodifytagsandcategories': ['whoCanModifyTagsAndCategories', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocantaketopics': ['whoCanTakeTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanunassigntopic': ['whoCanUnassignTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanunmarkfavoritereplyonanytopic': ['whoCanUnmarkFavoriteReplyOnAnyTopic', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  }
GROUP_MODERATE_CONTENT_ATTRIBUTES = {
  'whocanapprovemessages': ['whoCanApproveMessages', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocandeleteanypost': ['whoCanDeleteAnyPost', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocandeletetopics': ['whoCanDeleteTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocanlocktopics': ['whoCanLockTopics', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocanmovetopicsin': ['whoCanMoveTopicsIn', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocanmovetopicsout': ['whoCanMoveTopicsOut', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocanpostannouncements': ['whoCanPostAnnouncements', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  }
GROUP_MODERATE_MEMBERS_ATTRIBUTES = {
  'whocanadd': ['whoCanAdd', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                              'choices': {'allmanagerscanadd': 'ALL_MANAGERS_CAN_ADD', 'allownerscanadd': 'ALL_OWNERS_CAN_ADD',
                                          'allmemberscanadd': 'ALL_MEMBERS_CAN_ADD', 'nonecanadd': 'NONE_CAN_ADD'}}],
  'whocanapprovemembers': ['whoCanApproveMembers', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                    'choices': {'allownerscanapprove': 'ALL_OWNERS_CAN_APPROVE', 'allmanagerscanapprove': 'ALL_MANAGERS_CAN_APPROVE',
                                                                'allmemberscanapprove': 'ALL_MEMBERS_CAN_APPROVE', 'nonecanapprove': 'NONE_CAN_APPROVE'}}],
  'whocanbanusers': ['whoCanBanUsers', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_MEMBERS_CHOICES}],
  'whocaninvite': ['whoCanInvite', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                    'choices': {'allmemberscaninvite': 'ALL_MEMBERS_CAN_INVITE', 'allmanagerscaninvite': 'ALL_MANAGERS_CAN_INVITE',
                                                'allownerscaninvite': 'ALL_OWNERS_CAN_INVITE', 'nonecaninvite': 'NONE_CAN_INVITE'}}],
  'whocanmodifymembers': ['whoCanModifyMembers', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_MEMBERS_CHOICES}],
  }
GROUP_BASIC_ATTRIBUTES = {
  'description': ['description', {GC.VAR_TYPE: GC.TYPE_STRING}],
  'name': ['name', {GC.VAR_TYPE: GC.TYPE_STRING}],
  }
GROUP_SETTINGS_ATTRIBUTES = {
  'allowexternalmembers': ['allowExternalMembers', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'allowwebposting': ['allowWebPosting', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'archiveonly': ['archiveOnly', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'customfootertext': ['customFooterText', {GC.VAR_TYPE: GC.TYPE_STRING}],
  'customreplyto': ['customReplyTo', {GC.VAR_TYPE: GC.TYPE_EMAIL_OPTIONAL}],
  'customrolesenabledforsettingstobemerged': ['customRolesEnabledForSettingsToBeMerged', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'defaultmessagedenynotificationtext': ['defaultMessageDenyNotificationText', {GC.VAR_TYPE: GC.TYPE_STRING}],
  'enablecollaborativeinbox': ['enableCollaborativeInbox', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'includecustomfooter': ['includeCustomFooter', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'includeinglobaladdresslist': ['includeInGlobalAddressList', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'isarchived': ['isArchived', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'memberscanpostasthegroup': ['membersCanPostAsTheGroup', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'messagemoderationlevel': ['messageModerationLevel', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                        'choices': {'moderateallmessages': 'MODERATE_ALL_MESSAGES', 'moderatenonmembers': 'MODERATE_NON_MEMBERS',
                                                                    'moderatenewmembers': 'MODERATE_NEW_MEMBERS', 'moderatenone': 'MODERATE_NONE'}}],
  'primarylanguage': ['primaryLanguage', {GC.VAR_TYPE: GC.TYPE_LANGUAGE}],
  'replyto': ['replyTo', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                          'choices': {'replytocustom': 'REPLY_TO_CUSTOM', 'replytosender': 'REPLY_TO_SENDER', 'replytolist': 'REPLY_TO_LIST',
                                      'replytoowner': 'REPLY_TO_OWNER', 'replytoignore': 'REPLY_TO_IGNORE', 'replytomanagers': 'REPLY_TO_MANAGERS'}}],
  'sendmessagedenynotification': ['sendMessageDenyNotification', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'spammoderationlevel': ['spamModerationLevel', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                  'choices': {'allow': 'ALLOW', 'moderate': 'MODERATE', 'silentlymoderate': 'SILENTLY_MODERATE', 'reject': 'REJECT'}}],
  'whocancontactowner': ['whoCanContactOwner', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                'choices': {'anyonecancontact': 'ANYONE_CAN_CONTACT', 'allindomaincancontact': 'ALL_IN_DOMAIN_CAN_CONTACT',
                                                            'allmemberscancontact': 'ALL_MEMBERS_CAN_CONTACT', 'allmanagerscancontact': 'ALL_MANAGERS_CAN_CONTACT'}}],
  'whocanjoin': ['whoCanJoin', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                'choices': {'anyonecanjoin': 'ANYONE_CAN_JOIN', 'allindomaincanjoin': 'ALL_IN_DOMAIN_CAN_JOIN',
                                            'invitedcanjoin': 'INVITED_CAN_JOIN', 'canrequesttojoin': 'CAN_REQUEST_TO_JOIN'}}],
  'whocanleavegroup': ['whoCanLeaveGroup', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                            'choices': {'allmanagerscanleave': 'ALL_MANAGERS_CAN_LEAVE', 'allownerscanleave': 'ALL_OWNERS_CAN_LEAVE',
                                                        'allmemberscanleave': 'ALL_MEMBERS_CAN_LEAVE', 'nonecanleave': 'NONE_CAN_LEAVE'}}],
  'whocanpostmessage': ['whoCanPostMessage', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                              'choices': {'nonecanpost': 'NONE_CAN_POST', 'allmanagerscanpost': 'ALL_MANAGERS_CAN_POST',
                                                          'allmemberscanpost': 'ALL_MEMBERS_CAN_POST', 'allownerscanpost': 'ALL_OWNERS_CAN_POST',
                                                          'allindomaincanpost': 'ALL_IN_DOMAIN_CAN_POST', 'anyonecanpost': 'ANYONE_CAN_POST'}}],
  'whocanviewgroup': ['whoCanViewGroup', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                          'choices': {'anyonecanview': 'ANYONE_CAN_VIEW', 'allindomaincanview': 'ALL_IN_DOMAIN_CAN_VIEW',
                                                      'allmemberscanview': 'ALL_MEMBERS_CAN_VIEW', 'allmanagerscanview': 'ALL_MANAGERS_CAN_VIEW',
                                                      'allownerscanview': 'ALL_OWNERS_CAN_VIEW'}}],
  'whocanviewmembership': ['whoCanViewMembership', {GC.VAR_TYPE: GC.TYPE_CHOICE,
                                                    'choices': {'allindomaincanview': 'ALL_IN_DOMAIN_CAN_VIEW', 'allmemberscanview': 'ALL_MEMBERS_CAN_VIEW',
                                                                'allmanagerscanview': 'ALL_MANAGERS_CAN_VIEW', 'allownerscanview': 'ALL_OWNERS_CAN_VIEW'}}],
  }
GROUP_ALIAS_ATTRIBUTES = {
  'collaborative': ['enableCollaborativeInbox', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  'gal': ['includeInGlobalAddressList', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}],
  }
GROUP_MERGED_ATTRIBUTES = {
  'whocandiscovergroup': ['whoCanDiscoverGroup', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_DISCOVER_CHOICES}],
  'whocanassistcontent': ['whoCanAssistContent', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_ASSIST_CONTENT_CHOICES}],
  'whocanmoderatecontent': ['whoCanModerateContent', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_CONTENT_CHOICES}],
  'whocanmoderatemembers': ['whoCanModerateMembers', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': GROUP_MODERATE_MEMBERS_CHOICES}],
  }
GROUP_MERGED_ATTRIBUTES_PRINT_ORDER = ['whoCanDiscoverGroup', 'whoCanAssistContent', 'whoCanModerateContent', 'whoCanModerateMembers']
GROUP_MERGED_TO_COMPONENT_MAP = {
  'whoCanDiscoverGroup': GROUP_DISCOVER_ATTRIBUTES,
  'whoCanAssistContent': GROUP_ASSIST_CONTENT_ATTRIBUTES,
  'whoCanModerateContent': GROUP_MODERATE_CONTENT_ATTRIBUTES,
  'whoCanModerateMembers': GROUP_MODERATE_MEMBERS_ATTRIBUTES,
  }
GROUP_ATTRIBUTES_SET = set(list(GROUP_BASIC_ATTRIBUTES)+list(GROUP_SETTINGS_ATTRIBUTES)+list(GROUP_ALIAS_ATTRIBUTES)+
                           list(GROUP_ASSIST_CONTENT_ATTRIBUTES)+list(GROUP_MODERATE_CONTENT_ATTRIBUTES)+list(GROUP_MODERATE_MEMBERS_ATTRIBUTES)+
                           list(GROUP_MERGED_ATTRIBUTES)+list(GROUP_DEPRECATED_ATTRIBUTES))
GROUP_FIELDS_WITH_CRS_NLS = {'customFooterText', 'defaultMessageDenyNotificationText', 'description'}

def getGroupAttrProperties(myarg):
  attrProperties = GROUP_BASIC_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_SETTINGS_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_ALIAS_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_DISCOVER_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_ASSIST_CONTENT_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_MODERATE_CONTENT_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_MODERATE_MEMBERS_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_MERGED_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  attrProperties = GROUP_DEPRECATED_ATTRIBUTES.get(myarg)
  if attrProperties is not None:
    return attrProperties
  return None

def getGroupAttrValue(argument, gs_body):
  if argument == 'copyfrom':
    gs_body[argument] = getEmailAddress()
    return
  attrProperties = getGroupAttrProperties(argument)
  if attrProperties is None:
    unknownArgumentExit()
  attrName = attrProperties[0]
  attribute = attrProperties[1]
  attrType = attribute[GC.VAR_TYPE]
  if attrType == GC.TYPE_BOOLEAN:
    gs_body[attrName] = str(getBoolean()).lower()
  elif attrType == GC.TYPE_STRING:
    if attrName in GROUP_FIELDS_WITH_CRS_NLS:
      gs_body[attrName] = getStringWithCRsNLs()
    else:
      gs_body[attrName] = getString(Cmd.OB_STRING, minLen=0)
  elif attrType == GC.TYPE_CHOICE:
    gs_body[attrName] = getChoice(attribute['choices'], mapChoice=True)
  elif attrType in [GC.TYPE_EMAIL, GC.TYPE_EMAIL_OPTIONAL]:
    gs_body[attrName] = getEmailAddress(noUid=True, optional=attrType == GC.TYPE_EMAIL_OPTIONAL)
    if attrType == GC.TYPE_EMAIL_OPTIONAL and gs_body[attrName] is None:
      gs_body[attrName] = ''
  elif attrType == GC.TYPE_LANGUAGE:
    gs_body[attrName] = getLanguageCode()
  else: # GC.TYPE_INTEGER
    minVal, maxVal = attribute[GC.VAR_LIMITS]
    if attrName == 'maxMessageBytes':
      gs_body[attrName] = getMaxMessageBytes(minVal, maxVal)
    else:
      gs_body[attrName] = getInteger(minVal, maxVal)

def GroupIsAbuseOrPostmaster(emailAddr):
  return emailAddr.startswith('abuse@') or emailAddr.startswith('postmaster@')

def getSettingsFromGroup(cd, group, gs, gs_body):
  if gs_body:
    copySettingsFromGroup = gs_body.pop('copyfrom', None)
    if copySettingsFromGroup:
      try:
        if copySettingsFromGroup.find('@') == -1: # group settings API won't take uid so we make sure cd API is used so that we can grab real email.
          copySettingsFromGroup = callGAPI(cd.groups(), 'get',
                                           throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                                           groupKey=copySettingsFromGroup, fields='email')['email']
        settings = callGAPI(gs.groups(), 'get',
                            throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=copySettingsFromGroup, fields='*')
        if settings is not None:
          for field in ['email', 'name', 'description']:
            settings.pop(field, None)
          settings.update(gs_body)
          return settings
        entityItemValueListActionNotPerformedWarning([Ent.GROUP, group], [Ent.COPYFROM_GROUP, copySettingsFromGroup], Msg.API_ERROR_SETTINGS)
        return None
      except GAPI.notFound:
        entityItemValueListActionNotPerformedWarning([Ent.GROUP, group], [Ent.COPYFROM_GROUP, copySettingsFromGroup], Msg.DOES_NOT_EXIST)
        return None
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
              GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
              GAPI.systemError, GAPI.serviceLimit) as e:
        entityItemValueListActionNotPerformedWarning([Ent.GROUP, group], [Ent.COPYFROM_GROUP, copySettingsFromGroup], str(e))
        return None
  return gs_body

def convertGroupEmailToCloudID(ci, group, i=0, count=0):
  group = normalizeEmailAddressOrUID(group)
  try:
    return callGAPI(ci.groups(), 'lookup',
                    throwReasons=GAPI.CIGROUP_GET_THROW_REASONS,
                    retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                    groupKey_id=group, fields='name').get('name')
  except (GAPI.notFound, GAPI.domainNotFound, GAPI.domainCannotUseApis,
          GAPI.forbidden, GAPI.badRequest, GAPI.invalid,
          GAPI.systemError, GAPI.permissionDenied) as e:
    action = Act.Get()
    Act.Set(Act.LOOKUP)
    entityActionFailedWarning([Ent.GROUP, group, Ent.CLOUD_IDENTITY_GROUP, None], str(e), i, count)
    Act.Set(action)
    return None

def checkReplyToCustom(group, settings, i=0, count=0):
  if settings.get('replyTo') != 'REPLY_TO_CUSTOM' or settings.get('customReplyTo', ''):
    return True
  entityActionNotPerformedWarning([Ent.GROUP, group], Msg.REPLY_TO_CUSTOM_REQUIRES_EMAIL_ADDRESS, i, count)
  return False

GROUP_JSON_SKIP_FIELDS = ['email', 'adminCreated', 'directMembersCount', 'members', 'aliases', 'nonEditableAliases']

# gam create group <EmailAddress> [copyfrom <GroupItem>] <GroupAttribute>
def doCreateGroup():
  cd = buildGAPIObject(API.DIRECTORY)
  getBeforeUpdate = False
  body = {'email': getEmailAddress(noUid=True)}
  gs_body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'getbeforeupdate':
      getBeforeUpdate = True
    elif myarg == 'json':
      gs_body.update(getJSON(GROUP_JSON_SKIP_FIELDS))
    else:
      getGroupAttrValue(myarg, gs_body)
  if gs_body:
    gs_body.setdefault('name', body['email'])
    gs = buildGAPIObject(API.GROUPSSETTINGS)
    gs_body = getSettingsFromGroup(cd, body['email'], gs, gs_body)
    if not gs_body or not checkReplyToCustom(body['email'], gs_body):
      return
    if not getBeforeUpdate:
      settings = gs_body
  try:
    callGAPI(cd.groups(), 'insert',
             throwReasons=GAPI.GROUP_CREATE_THROW_REASONS,
             body=body, fields='')
    if gs_body and not GroupIsAbuseOrPostmaster(body['email']):
      if getBeforeUpdate:
        settings = callGAPI(gs.groups(), 'get',
                            throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS,
                            retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS+[GAPI.NOT_FOUND],
                            groupUniqueId=body['email'], fields='*')
        settings.update(gs_body)
      callGAPI(gs.groups(), 'update',
               throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS,
               retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS+[GAPI.NOT_FOUND],
               groupUniqueId=body['email'], body=settings, fields='')
    entityActionPerformed([Ent.GROUP, body['email']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.GROUP, body['email']])
  except GAPI.notFound:
    entityActionFailedWarning([Ent.GROUP, body['email']], Msg.DOES_NOT_EXIST)
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
          GAPI.backendError, GAPI.invalid, GAPI.invalidAttributeValue, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
          GAPI.systemError, GAPI.serviceLimit) as e:
    entityActionFailedWarning([Ent.GROUP, body['email']], str(e))
  except GAPI.required:
    entityActionFailedWarning([Ent.GROUP, body['email']], Msg.INVALID_JSON_SETTING)

def checkGroupExists(cd, group, i=0, count=0):
  group = normalizeEmailAddressOrUID(group)
  try:
    return callGAPI(cd.groups(), 'get',
                    throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                    groupKey=group, fields='email')['email']
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
    entityUnknownWarning(Ent.GROUP, group, i, count)
    return None

UPDATE_GROUP_SUBCMDS = ['add', 'create', 'delete', 'remove', 'clear', 'sync', 'update']
GROUP_PREVIEW_TITLES = ['group', 'email', 'role', 'action', 'message']

# gam update groups <GroupEntity> [email <EmailAddress>]
#	[copyfrom <GroupItem>] <GroupAttribute>*
#	[makesecuritygroup]
#	[admincreated <Boolean>]
# gam update groups <GroupEntity> create|add [<GroupRole>]
#	[usersonly|groupsonly] [notsuspended|suspended]
#	[delivery <DeliverySetting>] [preview] [actioncsv]
#	<UserTypeEntity>
# gam update groups <GroupEntity> delete|remove [<GroupRole>]
#	[usersonly|groupsonly] [notsuspended|suspended] [preview] [actioncsv]
#	<UserTypeEntity>
# gam update groups <GroupEntity> sync [<GroupRole>]
#	[usersonly|groupsonly] [addonly|removeonly] [notsuspended|suspended]
#	[removedomainnostatusmembers]
#	[delivery <DeliverySetting>] [preview] [actioncsv]
#	<UserTypeEntity>
# gam update groups <GroupEntity> update [<GroupRole>]
#	[usersonly|groupsonly] [notsuspended|suspended]
#	[delivery <DeliverySetting>] [preview] [actioncsv] [createifnotfound]
#	<UserTypeEntity>
# gam update groups <GroupEntity> clear [member] [manager] [owner]
#	[usersonly|groupsonly] [notsuspended|suspended]
#	[emailclearpattern|emailretainpattern <RegularExpression>]
#	[removedomainnostatusmembers] [preview] [actioncsv]
def doUpdateGroups():

  def _getPreviewActionCSV():
    preview = checkArgumentPresent('preview')
    if checkArgumentPresent('actioncsv'):
      csvPF = CSVPrintFile(GROUP_PREVIEW_TITLES)
    else:
      csvPF = None
    return (preview, csvPF)

  def _validateSubkeyRoleGetMembers(group, role, origGroup, groupMemberLists, i, count):
    roleLower = role.lower()
    if roleLower in GROUP_ROLES_MAP:
      return (GROUP_ROLES_MAP[roleLower], groupMemberLists[origGroup][role])
    entityActionNotPerformedWarning([Ent.GROUP, group, Ent.ROLE, role], Msg.INVALID_ROLE.format(','.join(sorted(GROUP_ROLES_MAP))), i, count)
    return (None, None)

  def _getRoleGroupMemberType(defaultRole=Ent.ROLE_MEMBER):
    role = getChoice(GROUP_ROLES_MAP, defaultChoice=defaultRole, mapChoice=True)
    groupMemberType = getChoice({'usersonly': Ent.TYPE_USER, 'groupsonly': Ent.TYPE_GROUP}, defaultChoice='ALL', mapChoice=True)
    return (role, groupMemberType)

  def _getMemberEmailStatus(member):
    if member['type'] == Ent.TYPE_CUSTOMER:
      return (member['id'], member.get('status', 'UNKNOWN'))
    email = member['email'].lower()
    if not removeDomainNoStatusMembers or 'status' in member:
      return (email, member.get('status', 'UNKNOWN'))
    _, domain = splitEmailAddress(email)
    if domain != GC.Values[GC.DOMAIN]:
      return (email, 'UNKNOWN')
    return (email, 'NONE')

  def _executeBatch(dbatch, batchParms):
    dbatch.execute()
    if batchParms['wait'] > 0:
      time.sleep(batchParms['wait'])

# Convert foo@googlemail.com to foo@gmail.com; eliminate periods in name for foo.bar@gmail.com
  def _cleanConsumerAddress(emailAddress, mapCleanToOriginal):
    atLoc = emailAddress.find('@')
    if atLoc > 0:
      if emailAddress[atLoc+1:] in {'gmail.com', 'googlemail.com'}:
        cleanEmailAddress = emailAddress[:atLoc].replace('.', '')+'@gmail.com'
        if cleanEmailAddress != emailAddress:
          mapCleanToOriginal[cleanEmailAddress] = emailAddress
          return cleanEmailAddress
    return emailAddress

  def _previewAction(group, members, role, jcount, action):
    Ind.Increment()
    j = 0
    for member in members:
      j += 1
      entityActionPerformed([Ent.GROUP, group, role, member], j, jcount)
    Ind.Decrement()
    if csvPF:
      for member in members:
        csvPF.WriteRow({'group': group, 'email': member, 'role': role, 'action': Act.PerformedName(action), 'message': Act.PREVIEW})

  def _showSuccess(group, member, role, delivery_settings, j, jcount, optMsg=None):
    kvList = []
    if role is not None and role != 'None':
      kvList.append(f'{Ent.Singular(Ent.ROLE)}: {role}')
    if delivery_settings != DELIVERY_SETTINGS_UNDEFINED:
      kvList.append(f'{Ent.Singular(Ent.DELIVERY)}: {delivery_settings}')
    if optMsg:
      kvList.append(optMsg)
    entityActionPerformedMessage([Ent.GROUP, group, Ent.MEMBER, member], ', '.join(kvList), j, jcount)
    if csvPF:
      csvPF.WriteRow({'group': group, 'email': member, 'role': role, 'action': Act.Performed(), 'message': 'Success'})

  def _showFailure(group, member, role, errMsg, j, jcount):
    entityActionFailedWarning([Ent.GROUP, group, Ent.MEMBER, member], errMsg, j, jcount)
    if csvPF:
      csvPF.WriteRow({'group': group, 'email': member, 'role': role, 'action': Act.Failed(), 'message': errMsg})

  def _addMember(group, i, count, role, delivery_settings, member, j, jcount):
    body = {'role': role}
    if member.find('@') != -1:
      body['email'] = member
    else:
      body['id'] = member
    if delivery_settings != DELIVERY_SETTINGS_UNDEFINED:
      body['delivery_settings'] = delivery_settings
    try:
      callGAPI(cd.members(), 'insert',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.DUPLICATE, GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND,
                                                        GAPI.INVALID_MEMBER, GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED,
                                                        GAPI.CONDITION_NOT_MET, GAPI.CONFLICT],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, body=body, fields='')
      _showSuccess(group, member, role, delivery_settings, j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, i, count)
    except (GAPI.duplicate, GAPI.memberNotFound, GAPI.resourceNotFound,
            GAPI.invalidMember, GAPI.cyclicMembershipsNotAllowed, GAPI.conditionNotMet) as e:
      _showFailure(group, member, role, str(e), j, jcount)
    except GAPI.conflict:
      _showSuccess(group, member, role, delivery_settings, j, jcount, Msg.ACTION_MAY_BE_DELAYED)

  def _handleDuplicateAdd(group, i, count, role, delivery_settings, member, j, jcount):
    try:
      result = callGAPI(cd.members(), 'get',
                        throwReasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
                        groupKey=group, memberKey=member, fields='role')
      _showFailure(group, member, role, Msg.DUPLICATE_ALREADY_A_ROLE.format(Ent.Singular(result['role'])), j, jcount)
      return
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      pass
    printEntityKVList([Ent.GROUP, group, Ent.MEMBER, member], [Msg.MEMBERSHIP_IS_PENDING_WILL_DELETE_ADD_TO_ACCEPT], j, jcount)
    try:
      callGAPI(cd.members(), 'delete',
               throwReasons=[GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               groupKey=group, memberKey=member)
    except (GAPI.memberNotFound, GAPI.resourceNotFound):
      _showFailure(group, member, role, Msg.DUPLICATE, j, jcount)
      return
    _addMember(group, i, count, role, delivery_settings, member, j, jcount)

  _ADD_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.DUPLICATE: Msg.DUPLICATE,
                                       GAPI.CONDITION_NOT_MET: Msg.DUPLICATE,
                                       GAPI.MEMBER_NOT_FOUND: Msg.DOES_NOT_EXIST,
                                       GAPI.RESOURCE_NOT_FOUND: Msg.DOES_NOT_EXIST,
                                       GAPI.INVALID_MEMBER: Msg.INVALID_MEMBER,
                                       GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED: Msg.WOULD_MAKE_MEMBERSHIP_CYCLE}

  def _callbackAddGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _showSuccess(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], ri[RI_OPTION], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      elif reason == GAPI.CONFLICT:
        _showSuccess(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], ri[RI_OPTION], int(ri[RI_J]), int(ri[RI_JCOUNT]), Msg.ACTION_MAY_BE_DELAYED)
      elif reason in [GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET]:
        _handleDuplicateAdd(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_OPTION], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      elif reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError(_ADD_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        _showFailure(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        if addBatchParms['adjust']:
          addBatchParms['adjust'] = False
          addBatchParms['wait'] += 0.25
          writeStderr(f'{WARNING_PREFIX}{Msg.INTER_BATCH_WAIT_INCREASED.format(addBatchParms["wait"])}\n')
        time.sleep(0.1)
        _addMember(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_OPTION], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchAddGroupMembers(group, i, count, addMembers, role, delivery_settings):
    Act.Set([Act.ADD, Act.ADD_PREVIEW][preview])
    jcount = len(addMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    if preview:
      _previewAction(group, addMembers, role, jcount, Act.ADD)
      return
    if addBatchParms['size'] == 1 or jcount <= addBatchParms['size']:
      Ind.Increment()
      j = 0
      for member in addMembers:
        j += 1
        _addMember(group, i, count, role, delivery_settings, member, j, jcount)
      Ind.Decrement()
      return
    body = {'role': role}
    if delivery_settings != DELIVERY_SETTINGS_UNDEFINED:
      body['delivery_settings'] = delivery_settings
    svcargs = dict([('groupKey', group), ('body', body), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), 'insert')
    dbatch = cd.new_batch_http_request(callback=_callbackAddGroupMembers)
    bcount = 0
    Ind.Increment()
    j = 0
    for member in addMembers:
      j += 1
      svcparms = svcargs.copy()
      if member.find('@') != -1:
        svcparms['body']['email'] = member
        svcparms['body'].pop('id', None)
      else:
        svcparms['body']['id'] = member
        svcparms['body'].pop('email', None)
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, member, role, delivery_settings))
      bcount += 1
      if bcount >= addBatchParms['size']:
        addBatchParms['adjust'] = True
        _executeBatch(dbatch, addBatchParms)
        dbatch = cd.new_batch_http_request(callback=_callbackAddGroupMembers)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Ind.Decrement()

  def _removeMember(group, i, count, role, member, j, jcount):
    try:
      callGAPI(cd.members(), 'delete',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER,
                                                        GAPI.CONDITION_NOT_MET, GAPI.CONFLICT],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, memberKey=member)
      _showSuccess(group, member, role, DELIVERY_SETTINGS_UNDEFINED, j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, i, count)
    except (GAPI.memberNotFound, GAPI.invalidMember, GAPI.conditionNotMet) as e:
      _showFailure(group, member, role, str(e), j, jcount)
    except GAPI.conflict:
      _showSuccess(group, member, role, DELIVERY_SETTINGS_UNDEFINED, j, jcount, Msg.ACTION_MAY_BE_DELAYED)

  _REMOVE_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.MEMBER_NOT_FOUND: f'{Msg.NOT_A} {Ent.Singular(Ent.MEMBER)}',
                                          GAPI.CONDITION_NOT_MET: f'{Msg.NOT_A} {Ent.Singular(Ent.MEMBER)}',
                                          GAPI.INVALID_MEMBER: Msg.DOES_NOT_EXIST}

  def _callbackRemoveGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _showSuccess(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], DELIVERY_SETTINGS_UNDEFINED, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      elif reason == GAPI.CONFLICT:
        _showSuccess(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], DELIVERY_SETTINGS_UNDEFINED, int(ri[RI_J]), int(ri[RI_JCOUNT]), Msg.ACTION_MAY_BE_DELAYED)
      elif reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError(_REMOVE_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        _showFailure(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        if remBatchParms['adjust']:
          remBatchParms['adjust'] = False
          remBatchParms['wait'] += 0.25
          writeStderr(f'{WARNING_PREFIX}{Msg.INTER_BATCH_WAIT_INCREASED.format(remBatchParms["wait"])}\n')
        time.sleep(0.1)
        _removeMember(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchRemoveGroupMembers(group, i, count, removeMembers, role):
    Act.Set([Act.REMOVE, Act.REMOVE_PREVIEW][preview])
    jcount = len(removeMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, role, i, count)
    if jcount == 0:
      return
    if preview:
      _previewAction(group, removeMembers, role, jcount, Act.REMOVE)
      return
    if remBatchParms['size'] == 1 or jcount <= remBatchParms['size']:
      Ind.Increment()
      j = 0
      for member in removeMembers:
        j += 1
        _removeMember(group, i, count, role, member, j, jcount)
      Ind.Decrement()
      return
    svcargs = dict([('groupKey', group), ('memberKey', None)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), 'delete')
    dbatch = cd.new_batch_http_request(callback=_callbackRemoveGroupMembers)
    bcount = 0
    Ind.Increment()
    j = 0
    for member in removeMembers:
      j += 1
      svcparms = svcargs.copy()
      svcparms['memberKey'] = member
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, svcparms['memberKey'], role))
      bcount += 1
      if bcount >= remBatchParms['size']:
        remBatchParms['adjust'] = True
        _executeBatch(dbatch, remBatchParms)
        dbatch = cd.new_batch_http_request(callback=_callbackRemoveGroupMembers)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Ind.Decrement()

  _UPDATE_MEMBER_REASON_TO_MESSAGE_MAP = {GAPI.MEMBER_NOT_FOUND: f'{Msg.NOT_A} {Ent.Singular(Ent.MEMBER)}',
                                          GAPI.INVALID_MEMBER: Msg.DOES_NOT_EXIST}

  def _getUpdateBody(role, delivery_settings):
    body = {}
    if role is not None:
      body['role'] = role
    else:
      if delivery_settings == DELIVERY_SETTINGS_UNDEFINED:
        # Backwards compatability; if neither role or delivery is specified, role = MEMBER
        role = Ent.ROLE_MEMBER
        body['role'] = role
    if delivery_settings != DELIVERY_SETTINGS_UNDEFINED:
      body['delivery_settings'] = delivery_settings
    return (body, role)

  def _updateMember(group, i, count, role, delivery_settings, member, j, jcount):
    body, role = _getUpdateBody(role, delivery_settings)
    try:
      callGAPI(cd.members(), 'patch',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, memberKey=member, body=body, fields='')
      _showSuccess(group, member, role, delivery_settings, j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, i, count)
    except GAPI.memberNotFound as e:
      if createIfNotFound:
        Act.Set(Act.ADD)
        _addMember(group, i, count, role, delivery_settings, member, j, jcount)
        Act.Set(Act.UPDATE)
      else:
        _showFailure(group, member, role, str(e), j, jcount)
    except GAPI.invalidMember as e:
      _showFailure(group, member, role, str(e), j, jcount)

  def _callbackUpdateGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _showSuccess(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], ri[RI_OPTION], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason == GAPI.MEMBER_NOT_FOUND and createIfNotFound:
        Act.Set(Act.ADD)
        _addMember(ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]), ri[RI_ROLE], ri[RI_OPTION], ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        Act.Set(Act.UPDATE)
      elif reason in GAPI.MEMBERS_THROW_REASONS:
        entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))
      else:
        errMsg = getHTTPError(_UPDATE_MEMBER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        _showFailure(ri[RI_ENTITY], ri[RI_ITEM], ri[RI_ROLE], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _batchUpdateGroupMembers(group, i, count, updateMembers, role, delivery_settings):
    Act.Set([Act.UPDATE, Act.UPDATE_PREVIEW][preview])
    jcount = len(updateMembers)
    entityPerformActionNumItems([Ent.GROUP, group], jcount, Ent.MEMBER, i, count)
    if jcount == 0:
      return
    if preview:
      _previewAction(group, updateMembers, role or Ent.ROLE_USER, jcount, Act.UPDATE)
      return
    if updBatchParms['size'] == 1 or jcount <= updBatchParms['size']:
      Ind.Increment()
      j = 0
      for member in updateMembers:
        j += 1
        _updateMember(group, i, count, role, delivery_settings, member, j, jcount)
      Ind.Decrement()
      return
    body, role = _getUpdateBody(role, delivery_settings)
    svcargs = dict([('groupKey', group), ('memberKey', None), ('body', body), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(cd.members(), 'patch')
    dbatch = cd.new_batch_http_request(callback=_callbackUpdateGroupMembers)
    bcount = 0
    Ind.Increment()
    j = 0
    for member in updateMembers:
      j += 1
      svcparms = svcargs.copy()
      svcparms['memberKey'] = member
      dbatch.add(method(**svcparms), request_id=batchRequestID(group, i, count, j, jcount, svcparms['memberKey'], role, delivery_settings))
      bcount += 1
      if bcount >= updBatchParms['size']:
        updBatchParms['adjust'] = True
        _executeBatch(dbatch, updBatchParms)
        dbatch = cd.new_batch_http_request(callback=_callbackUpdateGroupMembers)
        bcount = 0
    if bcount > 0:
      dbatch.execute()
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = None
  getBeforeUpdate = preview = False
  entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
  CL_subCommand = getChoice(UPDATE_GROUP_SUBCMDS, defaultChoice=None)
  addBatchParms = {'size': GC.Values[GC.BATCH_SIZE], 'wait': GC.Values[GC.INTER_BATCH_WAIT], 'adjust': True}
  remBatchParms = {'size': GC.Values[GC.BATCH_SIZE], 'wait': GC.Values[GC.INTER_BATCH_WAIT], 'adjust': True}
  updBatchParms = {'size': GC.Values[GC.BATCH_SIZE], 'wait': GC.Values[GC.INTER_BATCH_WAIT], 'adjust': True}
  if not CL_subCommand:
    body = {}
    gs_body = {}
    ci_body = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'email':
        body['email'] = getEmailAddress(noUid=True)
      elif myarg == 'admincreated':
        body['adminCreated'] = getBoolean()
      elif myarg == 'makesecuritygroup':
        ci_body['labels'] = {'cloudidentity.googleapis.com/groups.discussion_forum': '',
                             'cloudidentity.googleapis.com/groups.security': ''}
      elif myarg == 'getbeforeupdate':
        getBeforeUpdate = True
      elif myarg == 'json':
        gs_body.update(getJSON(GROUP_JSON_SKIP_FIELDS))
      else:
        getGroupAttrValue(myarg, gs_body)
    if gs_body:
      gs = buildGAPIObject(API.GROUPSSETTINGS)
      gs_body = getSettingsFromGroup(cd, ','.join(entityList), gs, gs_body)
      if not gs_body:
        return
      if not getBeforeUpdate:
        settings = gs_body
    elif ci_body:
      ci = buildGAPIObject(API.CLOUDIDENTITY_GROUPS)
    elif not body:
      return
    Act.Set(Act.UPDATE)
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      if gs_body and not GroupIsAbuseOrPostmaster(group):
        try:
          if group.find('@') == -1: # group settings API won't take uid so we make sure cd API is used so that we can grab real email.
            group = callGAPI(cd.groups(), 'get',
                             throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                             groupKey=group, fields='email')['email']
          if getBeforeUpdate:
            settings = callGAPI(gs.groups(), 'get',
                                throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                                groupUniqueId=group, fields='*')
            settings.update(gs_body)
          if not checkReplyToCustom(group, settings, i, count):
            continue
        except GAPI.notFound:
          entityActionFailedWarning([Ent.GROUP, group], Msg.DOES_NOT_EXIST, i, count)
          continue
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
                GAPI.backendError, GAPI.invalid, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
                GAPI.systemError, GAPI.serviceLimit) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      if body:
        try:
          group = callGAPI(cd.groups(), 'update',
                           throwReasons=GAPI.GROUP_UPDATE_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                           groupKey=group, body=body, fields='email')['email']
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.backendError, GAPI.badRequest, GAPI.invalid, GAPI.invalidInput, GAPI.systemError) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      if gs_body and not GroupIsAbuseOrPostmaster(group):
        try:
          callGAPI(gs.groups(), 'update',
                   throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                   groupUniqueId=group, body=settings, fields='')
        except GAPI.notFound:
          entityActionFailedWarning([Ent.GROUP, group], Msg.DOES_NOT_EXIST, i, count)
          continue
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
                GAPI.backendError, GAPI.invalid, GAPI.invalidAttributeValue, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
                GAPI.systemError, GAPI.serviceLimit) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
        except GAPI.required:
          entityActionFailedWarning([Ent.GROUP, group], Msg.INVALID_JSON_SETTING, i, count)
          continue
      if ci_body:
        name = convertGroupEmailToCloudID(ci, group, i, count)
        if not name:
          continue
        try:
          result = callGAPI(ci.groups(), 'patch',
                            throwReasons=GAPI.CIGROUP_UPDATE_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                            name=name, body=ci_body, updateMask=','.join(list(ci_body.keys())))
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.backendError, GAPI.badRequest, GAPI.invalid, GAPI.invalidInput,
                GAPI.systemError, GAPI.permissionDenied, GAPI.failedPrecondition) as e:
          entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
          continue
      entityActionPerformed([Ent.GROUP, group], i, count)
  elif CL_subCommand in {'create', 'add'}:
    baseRole, groupMemberType = _getRoleGroupMemberType()
    isSuspended = _getOptionalIsSuspended()
    delivery_settings = getDeliverySettings()
    preview, csvPF = _getPreviewActionCSV()
    _, addMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, isSuspended=isSuspended, groupMemberType=groupMemberType)
    groupMemberLists = addMembers if isinstance(addMembers, dict) else None
    subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      roleList = [baseRole]
      if groupMemberLists:
        if not subkeyRoleField:
          addMembers = groupMemberLists[group]
        else:
          roleList = groupMemberLists[group]
      origGroup = group
      group = checkGroupExists(cd, group, i, count)
      if group:
        for role in roleList:
          if groupMemberLists and subkeyRoleField:
            role, addMembers = _validateSubkeyRoleGetMembers(group, role, origGroup, groupMemberLists, i, count)
            if role is None:
              continue
          _batchAddGroupMembers(group, i, count,
                                [convertUIDtoEmailAddress(member, cd=cd, emailTypes='any',
                                                          checkForCustomerId=True) for member in addMembers],
                                role, delivery_settings)
  elif CL_subCommand in {'delete', 'remove'}:
    baseRole, groupMemberType = _getRoleGroupMemberType()
    isSuspended = _getOptionalIsSuspended()
    preview, csvPF = _getPreviewActionCSV()
    _, removeMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, isSuspended=isSuspended, groupMemberType=groupMemberType)
    groupMemberLists = removeMembers if isinstance(removeMembers, dict) else None
    subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      roleList = [baseRole]
      if groupMemberLists:
        if not subkeyRoleField:
          removeMembers = groupMemberLists[group]
        else:
          roleList = groupMemberLists[group]
      origGroup = group
      group = checkGroupExists(cd, group, i, count)
      if group:
        for role in roleList:
          if groupMemberLists and subkeyRoleField:
            role, removeMembers = _validateSubkeyRoleGetMembers(group, role, origGroup, groupMemberLists, i, count)
            if role is None:
              continue
          _batchRemoveGroupMembers(group, i, count,
                                   [convertUIDtoEmailAddress(member, cd=cd, emailTypes='any',
                                                             checkForCustomerId=True) for member in removeMembers],
                                   role)
  elif CL_subCommand == 'sync':
    baseRole, groupMemberType = _getRoleGroupMemberType()
    syncOperation = getChoice(['addonly', 'removeonly'], defaultChoice='addremove')
    isSuspended = _getOptionalIsSuspended()
    removeDomainNoStatusMembers = checkArgumentPresent('removedomainnostatusmembers')
    delivery_settings = getDeliverySettings()
    preview, csvPF = _getPreviewActionCSV()
    _, syncMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, isSuspended=isSuspended, groupMemberType=groupMemberType)
    groupMemberLists = syncMembers if isinstance(syncMembers, dict) else None
    subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
    syncMembersSets = {}
    syncMembersMaps = {}
    currentMembersSets = {}
    currentMembersMaps = {}
    domainNoStatusMembersSets = {}
    if groupMemberLists is None:
      syncMembersSets[baseRole] = set()
      syncMembersMaps[baseRole] = {}
      for member in syncMembers:
        syncMembersSets[baseRole].add(_cleanConsumerAddress(convertUIDtoEmailAddress(member, cd=cd, emailTypes='any',
                                                                                     checkForCustomerId=True), syncMembersMaps[baseRole]))
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      origGroup = group
      group = checkGroupExists(cd, group, i, count)
      if group:
        if groupMemberLists is None:
          roleList = [baseRole]
        else:
          if not subkeyRoleField:
            roleList = [baseRole]
          else:
            roleList = groupMemberLists[origGroup]
          for role in roleList:
            role = role.upper()
            syncMembersSets[role] = set()
            syncMembersMaps[role] = {}
        rolesSet = set()
        for role in roleList:
          origRole = role
          role = role.upper()
          if groupMemberLists is None:
            rolesSet.add(role)
          else:
            if not subkeyRoleField:
              rolesSet.add(role)
              syncMembers = groupMemberLists[origGroup]
            else:
              role, syncMembers = _validateSubkeyRoleGetMembers(group, origRole, origGroup, groupMemberLists, i, count)
              if role is None:
                continue
              rolesSet.add(role)
            for member in syncMembers:
              syncMembersSets[role].add(_cleanConsumerAddress(convertUIDtoEmailAddress(member, cd=cd, emailTypes='any',
                                                                                       checkForCustomerId=True), syncMembersMaps[role]))
        if not rolesSet:
          continue
        memberRoles = ','.join(sorted(rolesSet))
        printGettingAllEntityItemsForWhom(memberRoles, group, entityType=Ent.GROUP)
        try:
          result = callGAPIpages(cd.members(), 'list', 'members',
                                 pageMessage=getPageMessageForWhom(),
                                 throwReasons=GAPI.MEMBERS_THROW_REASONS,
                                 groupKey=group, roles=None if Ent.ROLE_MEMBER in rolesSet else memberRoles,
                                 fields='nextPageToken,members(email,id,type,status,role)',
                                 maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
        except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
          entityUnknownWarning(Ent.GROUP, group, i, count)
          continue
        for role in rolesSet:
          currentMembersSets[role] = set()
          currentMembersMaps[role] = {}
          domainNoStatusMembersSets[role] = set()
        for member in result:
          role = member.get('role', Ent.ROLE_MEMBER)
          email, memberStatus = _getMemberEmailStatus(member)
          if groupMemberType in ('ALL', member['type']) and role in rolesSet:
            if not removeDomainNoStatusMembers or memberStatus != 'NONE':
              if isSuspended is None or (not isSuspended and memberStatus != 'SUSPENDED') or (isSuspended and memberStatus == 'SUSPENDED'):
                currentMembersSets[role].add(_cleanConsumerAddress(email, currentMembersMaps[role]))
            else:
              domainNoStatusMembersSets[role].add(member['id'])
        if syncOperation != 'addonly':
          for role in rolesSet:
            if domainNoStatusMembersSets[role]:
              _batchRemoveGroupMembers(group, i, count,
                                       domainNoStatusMembersSets[role],
                                       role)
            _batchRemoveGroupMembers(group, i, count,
                                     [currentMembersMaps[role].get(emailAddress, emailAddress) for emailAddress in currentMembersSets[role]-syncMembersSets[role]],
                                     role)
        if syncOperation != 'removeonly':
          for role in [Ent.ROLE_OWNER, Ent.ROLE_MANAGER, Ent.ROLE_MEMBER]:
            if role in rolesSet:
              _batchAddGroupMembers(group, i, count,
                                    [syncMembersMaps[role].get(emailAddress, emailAddress) for emailAddress in syncMembersSets[role]-currentMembersSets[role]],
                                    role, delivery_settings)
  elif CL_subCommand == 'update':
    baseRole, groupMemberType = _getRoleGroupMemberType(defaultRole=None)
    isSuspended = _getOptionalIsSuspended()
    delivery_settings = getDeliverySettings()
    preview, csvPF = _getPreviewActionCSV()
    createIfNotFound = checkArgumentPresent('createifnotfound')
    _, updateMembers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, isSuspended=isSuspended, groupMemberType=groupMemberType)
    groupMemberLists = updateMembers if isinstance(updateMembers, dict) else None
    subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
    checkForExtraneousArguments()
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      roleList = [baseRole]
      if groupMemberLists:
        if not subkeyRoleField:
          updateMembers = groupMemberLists[group]
        else:
          roleList = groupMemberLists[group]
      origGroup = group
      group = checkGroupExists(cd, group, i, count)
      if group:
        for role in roleList:
          if groupMemberLists and subkeyRoleField:
            role, updateMembers = _validateSubkeyRoleGetMembers(group, role, origGroup, groupMemberLists, i, count)
            if role is None:
              continue
          _batchUpdateGroupMembers(group, i, count,
                                   [convertUIDtoEmailAddress(member, cd=cd, emailTypes='any', checkForCustomerId=True) for member in updateMembers],
                                   role, delivery_settings)
  else: #clear
    rolesSet = set()
    groupMemberType = 'ALL'
    isSuspended = None
    removeDomainNoStatusMembers = False
    emailMatchPattern = None
    clearMatch = True
    qualifier = ''
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in GROUP_ROLES_MAP:
        rolesSet.add(GROUP_ROLES_MAP[myarg])
      elif myarg == 'usersonly':
        groupMemberType = Ent.TYPE_USER
      elif myarg == 'groupsonly':
        groupMemberType = Ent.TYPE_GROUP
      elif myarg in SUSPENDED_ARGUMENTS:
        isSuspended = _getIsSuspended(myarg)
      elif myarg == 'removedomainnostatusmembers':
        removeDomainNoStatusMembers = True
      elif myarg in {'emailclearpattern', 'emailretainpattern'}:
        emailMatchPattern = getREPattern(re.IGNORECASE)
        clearMatch = myarg == 'emailclearpattern'
      elif myarg == 'preview':
        preview = True
      elif myarg == 'actioncsv':
        csvPF = CSVPrintFile(GROUP_PREVIEW_TITLES)
      else:
        unknownArgumentExit()
    if isSuspended is not None:
      qualifier += ' (Suspended)' if isSuspended else ' (Non-suspended)'
    if removeDomainNoStatusMembers:
      qualifier += ' (Domain members with no status)'
    Act.Set(Act.REMOVE)
    if not rolesSet:
      rolesSet.add(Ent.ROLE_MEMBER)
    memberRoles = ','.join(sorted(rolesSet))
    i = 0
    count = len(entityList)
    for group in entityList:
      i += 1
      group = normalizeEmailAddressOrUID(group)
      printGettingAllEntityItemsForWhom(memberRoles, group, qualifier=qualifier, entityType=Ent.GROUP)
      try:
        result = callGAPIpages(cd.members(), 'list', 'members',
                               pageMessage=getPageMessageForWhom(),
                               throwReasons=GAPI.MEMBERS_THROW_REASONS,
                               groupKey=group, roles=None if Ent.ROLE_MEMBER in rolesSet else memberRoles,
                               fields='nextPageToken,members(email,id,type,status,role)',
                               maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
        entityUnknownWarning(Ent.GROUP, group, i, count)
        continue
      removeMembers = {}
      for role in rolesSet:
        removeMembers[role] = set()
      for member in result:
        role = member.get('role', Ent.ROLE_MEMBER)
        email, memberStatus = _getMemberEmailStatus(member)
        if groupMemberType in ('ALL', member['type']) and role in rolesSet:
          if not removeDomainNoStatusMembers:
            if isSuspended is None or (not isSuspended and memberStatus != 'SUSPENDED') or (isSuspended and memberStatus == 'SUSPENDED'):
              if emailMatchPattern is None:
                removeMembers[role].add(email if memberStatus != 'UNKNOWN' else member['id'])
              elif member['type'] == Ent.TYPE_CUSTOMER:
                pass
              elif emailMatchPattern.match(email):
                if clearMatch:
                  removeMembers[role].add(email if memberStatus != 'UNKNOWN' else member['id'])
              else:
                if not clearMatch:
                  removeMembers[role].add(email if memberStatus != 'UNKNOWN' else member['id'])
          elif memberStatus == 'NONE':
            removeMembers[role].add(member['id'])
      for role in rolesSet:
        _batchRemoveGroupMembers(group, i, count, removeMembers[role], role)
  if csvPF:
    csvPF.writeCSVfile('Group Updates')

# gam delete groups <GroupEntity>
def doDeleteGroups():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      callGAPI(cd.groups(), 'delete',
               throwReasons=[GAPI.GROUP_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
               groupKey=group)
      entityActionPerformed([Ent.GROUP, group], i, count)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.invalid):
      entityUnknownWarning(Ent.GROUP, group, i, count)

def getGroupRoles(myarg, rolesSet):
  if myarg in {'role', 'roles'}:
    for role in getString(Cmd.OB_GROUP_ROLE_LIST).lower().replace(',', ' ').split():
      if role in GROUP_ROLES_MAP:
        rolesSet.add(GROUP_ROLES_MAP[role])
      else:
        invalidChoiceExit(role, GROUP_ROLES_MAP, True)
  elif myarg in GROUP_ROLES_MAP:
    rolesSet.add(GROUP_ROLES_MAP[myarg])
  else:
    return False
  return True

def getGroupTypes(myarg, typesSet):
  if myarg in {'type', 'types'}:
    for gtype in getString(Cmd.OB_GROUP_TYPE_LIST).lower().replace(',', ' ').split():
      if gtype in GROUP_TYPES_MAP:
        typesSet.add(GROUP_TYPES_MAP[gtype])
      else:
        invalidChoiceExit(gtype, GROUP_TYPES_MAP, True)
  else:
    return False
  return True

MEMBEROPTION_MEMBERNAMES = 0
MEMBEROPTION_NODUPLICATES = 1
MEMBEROPTION_RECURSIVE = 2
MEMBEROPTION_GETDELIVERYSETTINGS = 3
MEMBEROPTION_ISSUSPENDED = 4
MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP = 5
MEMBEROPTION_MATCHPATTERN = 6
MEMBEROPTION_DISPLAYMATCH = 7

def initMemberOptions():
  return [False, False, False, False, None, False, None, True]

def getMemberMatchOptions(myarg, memberOptions):
  if myarg in {'memberemaildisplaypattern', 'memberemailskippattern'}:
    memberOptions[MEMBEROPTION_MATCHPATTERN] = getREPattern(re.IGNORECASE)
    memberOptions[MEMBEROPTION_DISPLAYMATCH] = myarg == 'memberemaildisplaypattern'
  else:
    return False
  return True

def checkMemberMatch(member, memberOptions):
  if not memberOptions[MEMBEROPTION_MATCHPATTERN]:
    return True
  if member['type'] != Ent.TYPE_CUSTOMER:
    if memberOptions[MEMBEROPTION_MATCHPATTERN].match(member['email']):
      return memberOptions[MEMBEROPTION_DISPLAYMATCH]
    return not memberOptions[MEMBEROPTION_DISPLAYMATCH]
  if memberOptions[MEMBEROPTION_MATCHPATTERN].match(member['id']):
    return memberOptions[MEMBEROPTION_DISPLAYMATCH]
  return not memberOptions[MEMBEROPTION_DISPLAYMATCH]

GROUP_FIELDS_CHOICE_MAP = {
  'admincreated': 'adminCreated',
  'aliases': ['aliases', 'nonEditableAliases'],
  'description': 'description',
  'directmemberscount': 'directMembersCount',
  'email': 'email',
  'id': 'id',
  'name': 'name',
  }
GROUP_INFO_PRINT_ORDER = ['id', 'name', 'description', 'directMembersCount', 'adminCreated']
INFO_GROUP_OPTIONS = {'nousers', 'groups'}

CIGROUP_FIELDS_CHOICE_MAP = {
  'additionalgroupkeys': 'additionalGroupKeys',
  'createtime': 'createTime',
  'description': 'description',
  'displayname': 'displayName',
  'dynamicgroupmetadata': 'dynamicGroupMetadata',
  'groupkey': 'groupKey',
  'labels': 'labels',
  'name': 'name',
  'parent': 'parent',
  'updatetime': 'updateTime',
  }
CIGROUP_FIELDS_WITH_CRS_NLS = {'description'}
CIGROUP_INFO_PRINT_ORDER = ['groupKey', 'name', 'displayName', 'description', 'createTime', 'updateTime',
                            'additionalGroupKeys', 'labels', 'parent', 'dynamicGroupMetadata']
CIGROUP_TIME_OBJECTS = {'createTime', 'updateTime', 'statusTime'}

def infoGroups(entityList):
  def initGroupFieldsLists():
    if not groupFieldsLists['cd']:
      groupFieldsLists['cd'] = ['email']
    if not groupFieldsLists['ci']:
      groupFieldsLists['ci'] = []
    if not groupFieldsLists['gs']:
      groupFieldsLists['gs'] = []

  cd = buildGAPIObject(API.DIRECTORY)
  getAliases = getUsers = True
  getCloudIdentity = getGroups = getSettings = False
  showDeprecatedAttributes = True
  FJQC = FormatJSONQuoteChar()
  groups = []
  members = []
  groupFieldsLists = {'cd': None, 'ci': None, 'gs': None}
  isSuspended = None
  entityType = Ent.MEMBER
  rolesSet = set()
  typesSet = set()
  memberOptions = initMemberOptions()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'quick':
      getAliases = getUsers = False
    elif myarg == 'nousers':
      getUsers = False
    elif myarg == 'nodeprecated':
      showDeprecatedAttributes = not getBoolean()
    elif myarg in SUSPENDED_ARGUMENTS:
      isSuspended = _getIsSuspended(myarg)
      entityType = Ent.MEMBER_SUSPENDED if isSuspended else Ent.MEMBER_NOT_SUSPENDED
    elif myarg == 'noaliases':
      getAliases = False
    elif myarg == 'groups':
      getGroups = True
    elif getGroupRoles(myarg, rolesSet):
      getUsers = True
    elif getGroupTypes(myarg, typesSet):
      pass
    elif getMemberMatchOptions(myarg, memberOptions):
      pass
    elif myarg == 'basic':
      initGroupFieldsLists()
      for field in GROUP_FIELDS_CHOICE_MAP:
        addFieldToFieldsList(field, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
    elif myarg == 'ciallfields':
      if not groupFieldsLists['ci']:
        groupFieldsLists['ci'] = []
      for field in CIGROUP_FIELDS_CHOICE_MAP:
        addFieldToFieldsList(field, CIGROUP_FIELDS_CHOICE_MAP, groupFieldsLists['ci'])
    elif myarg in GROUP_FIELDS_CHOICE_MAP:
      initGroupFieldsLists()
      addFieldToFieldsList(myarg, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
    elif myarg in GROUP_ATTRIBUTES_SET:
      initGroupFieldsLists()
      attrProperties = getGroupAttrProperties(myarg)
      groupFieldsLists['gs'].extend([attrProperties[0]])
    elif myarg == 'fields':
      initGroupFieldsLists()
      for field in _getFieldsList():
        if field in GROUP_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
        else:
          attrProperties = getGroupAttrProperties(field)
          if attrProperties is None:
            invalidChoiceExit(field, list(GROUP_FIELDS_CHOICE_MAP)+list(GROUP_ATTRIBUTES_SET), True)
          groupFieldsLists['gs'].extend([attrProperties[0]])
    elif myarg == 'cifields':
      initGroupFieldsLists()
      for field in _getFieldsList():
        if field in CIGROUP_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, CIGROUP_FIELDS_CHOICE_MAP, groupFieldsLists['ci'])
        else:
          invalidChoiceExit(field, list(CIGROUP_FIELDS_CHOICE_MAP), True)
# Ignore info user arguments that may have come from whatis
    elif myarg in INFO_USER_OPTIONS:
      if myarg == 'schemas':
        getString(Cmd.OB_SCHEMA_NAME_LIST)
    else:
      FJQC.GetFormatJSON(myarg)
  if not typesSet:
    typesSet = ALL_GROUP_TYPES
  cdfields = getFieldsFromFieldsList(groupFieldsLists['cd'])
  memberRoles = ','.join(sorted(rolesSet)) if rolesSet else None
  if groupFieldsLists['gs'] is None:
    getSettings = True
    gsfields = None
  elif groupFieldsLists['gs']:
    getSettings = True
    gsfields = getFieldsFromFieldsList(groupFieldsLists['gs'])
  else:
    gsfields = None
  if getSettings:
    gs = buildGAPIObject(API.GROUPSSETTINGS)
  if groupFieldsLists['ci']:
    getCloudIdentity = True
    cifields = getFieldsFromFieldsList(groupFieldsLists['ci'])
    ci = buildGAPIObject(API.CLOUDIDENTITY_GROUPS)
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      basic_info = callGAPI(cd.groups(), 'get',
                            throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                            groupKey=group, fields=cdfields)
      group = basic_info['email']
      if getCloudIdentity:
        name = convertGroupEmailToCloudID(ci, group, i, count)
        if not name:
          continue
        ci_info = callGAPI(ci.groups(), 'get',
                           throwReasons=GAPI.CIGROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                           name=name, fields=cifields)
      else:
        ci_info = {}
      settings = {}
      if getSettings and not GroupIsAbuseOrPostmaster(group):
        settings = callGAPI(gs.groups(), 'get',
                            throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=group, fields=gsfields) # Use email address retrieved from cd since GS API doesn't support uid
      if getGroups:
        groups = callGAPIpages(cd.groups(), 'list', 'groups',
                               throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                               userKey=group, orderBy='email', fields='nextPageToken,groups(name,email)')
      if getUsers:
        validRoles, listRoles, listFields = _getRoleVerification(memberRoles, 'nextPageToken,members(email,id,role,status,type)')
        result = callGAPIpages(cd.members(), 'list', 'members',
                               throwReasons=GAPI.MEMBERS_THROW_REASONS, retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                               groupKey=group, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
        members = []
        for member in result:
          if member['type'] in typesSet and _checkMemberRoleIsSuspended(member, validRoles, isSuspended) and checkMemberMatch(member, memberOptions):
            members.append(member)
      if FJQC.formatJSON:
        basic_info.update(settings)
        basic_info['cloudIdentity'] = ci_info
        if getGroups:
          basic_info['groups'] = groups
        if getUsers:
          basic_info['members'] = members
        printLine(json.dumps(cleanJSON(basic_info), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.GROUP, group], i, count)
      Ind.Increment()
      if ci_info:
        printEntity([Ent.CLOUD_IDENTITY_GROUP, None])
        Ind.Increment()
        for key in CIGROUP_INFO_PRINT_ORDER:
          if key not in ci_info:
            continue
          value = ci_info[key]
          if isinstance(value, (list, dict)):
            showJSON(key, value, timeObjects=CIGROUP_TIME_OBJECTS)
          elif key not in CIGROUP_FIELDS_WITH_CRS_NLS:
            if key not in CIGROUP_TIME_OBJECTS:
              printKeyValueList([key, value])
            else:
              printKeyValueList([key, formatLocalTime(value)])
          else:
            printKeyValueWithCRsNLs(key, value)
        Ind.Decrement()
      printEntity([Ent.GROUP_SETTINGS, None])
      Ind.Increment()
      for key in GROUP_INFO_PRINT_ORDER:
        if key not in basic_info:
          continue
        value = basic_info[key]
        if isinstance(value, list):
          printKeyValueList([key, None])
          Ind.Increment()
          for val in value:
            printKeyValueList([val])
          Ind.Decrement()
        elif key not in GROUP_FIELDS_WITH_CRS_NLS:
          printKeyValueList([key, value])
        else:
          printKeyValueWithCRsNLs(key, value)
      if settings:
        for key, attr in sorted(iter(GROUP_SETTINGS_ATTRIBUTES.items())):
          key = attr[0]
          if key in settings:
            if key not in GROUP_FIELDS_WITH_CRS_NLS:
              printKeyValueList([key, settings[key]])
            else:
              printKeyValueWithCRsNLs(key, settings[key])
        for key in GROUP_MERGED_ATTRIBUTES_PRINT_ORDER:
          if key in settings:
            printKeyValueList([key, settings[key]])
            Ind.Increment()
            showTitle = False
          else:
            showTitle = True
          if showDeprecatedAttributes:
            for subkey, subattr in sorted(iter(GROUP_MERGED_TO_COMPONENT_MAP[key].items())):
              subkey = subattr[0]
              if subkey in settings:
                if showTitle:
                  printKeyValueList([key, ''])
                  Ind.Increment()
                  showTitle = False
                printKeyValueList([subkey, settings[subkey]])
          if not showTitle:
            Ind.Decrement()
        if showDeprecatedAttributes:
          showTitle = True
          for subkey, attr in sorted(iter(GROUP_DEPRECATED_ATTRIBUTES.items())):
            subkey = attr[0]
            if subkey in settings:
              if showTitle:
                printKeyValueList(['Deprecated', ''])
                Ind.Increment()
                showTitle = False
              if subkey != 'maxMessageBytes':
                printKeyValueList([subkey, settings[subkey]])
              else:
                printKeyValueList([subkey, formatMaxMessageBytes(settings[subkey], ONE_KILO_BYTES, ONE_MEGA_BYTES)])
          if not showTitle:
            Ind.Decrement()
      Ind.Decrement()
      if getAliases:
        for up in ['aliases', 'nonEditableAliases']:
          aliases = basic_info.get(up, [])
          if aliases:
            printEntitiesCount([Ent.NONEDITABLE_ALIAS, Ent.EMAIL_ALIAS][up == 'aliases'], aliases)
            Ind.Increment()
            for alias in aliases:
              printKeyValueList(['alias', alias])
            Ind.Decrement()
      if getGroups:
        printEntitiesCount(Ent.GROUP, groups)
        Ind.Increment()
        for groupm in groups:
          printKeyValueList([groupm['name'], groupm['email']])
        Ind.Decrement()
      if getUsers:
        printEntitiesCount(entityType, members)
        Ind.Increment()
        for member in members:
          printKeyValueList([member.get('role', Ent.ROLE_MEMBER).lower(), f'{member.get("email", member["id"])} ({member["type"].lower()})'])
        Ind.Decrement()
        printKeyValueList([Msg.TOTAL_ITEMS_IN_ENTITY.format(Ent.Plural(entityType), Ent.Singular(Ent.GROUP)), len(members)])
      Ind.Decrement()
    except GAPI.notFound:
      entityActionFailedWarning([Ent.GROUP, group], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.groupNotFound, GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.backendError,
            GAPI.invalid, GAPI.invalidMember, GAPI.invalidParameter, GAPI.invalidInput, GAPI.forbidden, GAPI.badRequest,
            GAPI.permissionDenied, GAPI.systemError, GAPI.serviceLimit) as e:
      entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)

# gam info groups <GroupEntity>
#	[nousers] [quick] [noaliases] [groups]
#	[basic] <GroupFieldName>* [fields <GroupFieldNameList>] [nodeprecated]
#	[ciallfields|(cifields <CIGroupFieldNameList>)]
#	[roles <GroupRoleList>] [members] [managers] [owners]
#	[notsuspended|suspended]
#	[types <GroupTypeList>]
#	[memberemaildisplaypattern|memberemailskippattern <RegularExpression>]
#	[formatjson]
def doInfoGroups():
  infoGroups(getEntityList(Cmd.OB_GROUP_ENTITY))

def groupFilters(kwargs):
  queryTitle = ''
  if kwargs.get('domain'):
    queryTitle += f'{Ent.Singular(Ent.DOMAIN)}={kwargs["domain"]}, '
  if kwargs.get('userKey'):
    queryTitle += f'{Ent.Singular(Ent.MEMBER)}={kwargs["userKey"]}, '
  if kwargs.get('query'):
    queryTitle += f'query="{kwargs["query"]}", '
  if queryTitle:
    return queryTitle[:-2]
  return queryTitle

def getGroupFilters(myarg, kwargs):
  if myarg == 'domain':
    kwargs['domain'] = getString(Cmd.OB_DOMAIN_NAME).lower()
    kwargs.pop('customer', None)
  elif myarg in {'member', 'showownedby'}:
    kwargs['userKey'] = getEmailAddress()
    kwargs.pop('customer', None)
  elif myarg == 'query':
    kwargs['query'] = getString(Cmd.OB_QUERY)
  else:
    return False
  if kwargs.get('userKey') and kwargs.get('query'):
    usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format('member', 'query'))
  return True

def setGroupShowOwnedBy(kwargs):
  return ('email' if kwargs['userKey'].find('@') != -1 else 'id', kwargs['userKey'])

def checkGroupShowOwnedBy(showOwnedBy, members):
  for member in members:
    if (member.get('role', Ent.ROLE_MEMBER) == Ent.ROLE_OWNER) and (member.get(showOwnedBy[0], '').lower() == showOwnedBy[1]):
      return True
  return False

def getGroupMatchPatterns(myarg, matchPatterns):
  if myarg == 'emailmatchpattern':
    matchPatterns['email'] = getREPattern(re.IGNORECASE)
  elif myarg == 'namematchpattern':
    matchPatterns['name'] = getREPattern(re.IGNORECASE|re.UNICODE)
  elif myarg == 'descriptionmatchpattern':
    matchPatterns['description'] = getREPattern(re.IGNORECASE|re.UNICODE)
  elif myarg == 'admincreatedmatch':
    matchPatterns['adminCreated'] = getBoolean(None)
  else:
    return False
  return True

def updateFieldsForGroupMatchPatterns(matchPatterns, fieldsList, csvPF=None):
  for field in ['name', 'description', 'adminCreated']:
    if field in matchPatterns:
      if csvPF is not None:
        csvPF.AddField(field, GROUP_FIELDS_CHOICE_MAP, fieldsList)
      else:
        fieldsList.append(field)

def clearUnneededGroupMatchPatterns(matchPatterns):
  for field in ['name', 'description', 'adminCreated']:
    matchPatterns.pop(field, None)

def checkGroupMatchPatterns(groupEmail, group, matchPatterns):
  for field, pattern in iter(matchPatterns.items()):
    if field == 'email':
      if not pattern.match(groupEmail):
        return False
    elif field == 'adminCreated':
      if pattern != group[field]:
        return False
    elif not pattern.match(group[field]):
      return False
  return True

PRINT_GROUPS_JSON_TITLES = ['email', 'JSON']

# gam print groups [todrive <ToDriveAttribute>*]
#	[([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|
#	 (select <GroupEntity>)]
#	[showownedby <UserItem>]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>]
#	[descriptionmatchpattern <RegularExpression>] (matchsetting [not] <GroupAttribute>)*
#	[admincreatedmatch <Boolean>]
#	[maxresults <Number>]
#	[allfields|([basic] [settings] <GroupFieldName>* [fields <GroupFieldNameList>])]
#	[ciallfields|(cifields <CIGroupFieldNameList>)]
#	[nodeprecated]
#	[roles <GroupRoleList>]
#	[members|memberscount] [managers|managerscount] [owners|ownerscount] [totalcount] [countsonly]
#	[includederivedmembership]
#	[notsuspended|suspended]
#	[types <GroupTypeList>]
#	[memberemaildisplaypattern|memberemailskippattern <RegularExpression>]
#	[convertcrnl] [delimiter <Character>] [sortheaders]
#	[formatjson [quotechar <Character>]]
def doPrintGroups():
  def _printGroupRow(groupEntity, groupSettings, groupMembers):
    row = {}
    if matchSettings:
      if not isinstance(groupSettings, dict):
        return
      for key, match in iter(matchSettings.items()):
        gvalue = groupSettings.get(key)
        if match['notvalues'] and gvalue in match['notvalues']:
          return
        if match['values'] and gvalue not in match['values']:
          return
    if showOwnedBy and not checkGroupShowOwnedBy(showOwnedBy, groupMembers):
      return
    if deprecatedAttributesSet and isinstance(groupSettings, dict):
      deprecatedKeys = []
      for key in groupSettings:
        if key in deprecatedAttributesSet:
          deprecatedKeys.append(key)
      for key in deprecatedKeys:
        groupSettings.pop(key)
    if FJQC.formatJSON:
      row['email'] = groupEntity['email']
      row['JSON'] = json.dumps(groupEntity, ensure_ascii=False, sort_keys=True)
      if memberRoles and groupMembers is not None:
        row['JSON-members'] = json.dumps(groupMembers, ensure_ascii=False, sort_keys=True)
      if isinstance(groupSettings, dict):
        row['JSON-settings'] = json.dumps(groupSettings, ensure_ascii=False, sort_keys=True)
      groupCloudIdentity = ciGroups.get(row['email'], {})
      if groupCloudIdentity:
        row['JSON-cloudIdentity'] = json.dumps(groupCloudIdentity, ensure_ascii=False, sort_keys=True)
      csvPF.WriteRowNoFilter(row)
      return
    for field in groupFieldsLists['cd']:
      if field in groupEntity:
        if isinstance(groupEntity[field], list):
          row[field] = delimiter.join(groupEntity[field])
        elif convertCRNL and field in GROUP_FIELDS_WITH_CRS_NLS:
          row[field] = escapeCRsNLs(groupEntity[field])
        else:
          row[field] = groupEntity[field]
    if groupMembers is not None:
      membersCount = managersCount = ownersCount = 0
      if members:
        membersList = []
      if managers:
        managersList = []
      if owners:
        ownersList = []
      for member in groupMembers:
        member_email = member.get('email', member.get('id', None))
        if not member_email:
          writeStderr(f' Not sure what to do with: {member}\n')
          continue
        if member['type'] in typesSet and _checkMemberIsSuspended(member, isSuspended) and checkMemberMatch(member, memberOptions):
          role = member.get('role', Ent.ROLE_MEMBER)
          if role == Ent.ROLE_MEMBER:
            if members:
              membersCount += 1
              if not membersCountOnly:
                membersList.append(member_email)
          elif role == Ent.ROLE_MANAGER:
            if managers:
              managersCount += 1
              if not managersCountOnly:
                managersList.append(member_email)
          elif role == Ent.ROLE_OWNER:
            if owners:
              ownersCount += 1
              if not ownersCountOnly:
                ownersList.append(member_email)
          elif members:
            membersCount += 1
            if not membersCountOnly:
              membersList.append(member_email)
      if totalCount:
        row['TotalCount'] = membersCount+managersCount+ownersCount
      if members:
        row['MembersCount'] = membersCount
        if not membersCountOnly:
          row['Members'] = delimiter.join(membersList)
      if managers:
        row['ManagersCount'] = managersCount
        if not managersCountOnly:
          row['Managers'] = delimiter.join(managersList)
      if owners:
        row['OwnersCount'] = ownersCount
        if not ownersCountOnly:
          row['Owners'] = delimiter.join(ownersList)
    if isinstance(groupSettings, dict):
      for key, value in iter(groupSettings.items()):
        if key not in {'kind', 'etag', 'email', 'name', 'description'}:
          if value is None:
            value = ''
          csvPF.AddTitles(key)
          if convertCRNL and key in GROUP_FIELDS_WITH_CRS_NLS:
            row[key] = escapeCRsNLs(value)
          else:
            row[key] = value
    groupCloudIdentity = ciGroups.get(row['email'], {})
    if groupCloudIdentity:
      labels = groupCloudIdentity.pop('labels', {})
      if labels:
        groupCloudIdentity['labels'] = []
        for k, v in iter(labels.items()):
          if not v:
            groupCloudIdentity['labels'].append(k)
          else:
            groupCloudIdentity['labels'].append(f'{k}:{v}')
      for key, value in sorted(iter(flattenJSON({'cloudIdentity': groupCloudIdentity}, flattened={}, timeObjects=CIGROUP_TIME_OBJECTS).items())):
        csvPF.AddTitles(key)
        row[key] = value
    csvPF.WriteRow(row)

  def _callbackProcessGroupBasic(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.GROUP_GET_RETRY_REASONS:
        if reason in GAPI.GROUP_GET_THROW_REASONS:
          entityUnknownWarning(Ent.GROUP, ri[RI_ENTITY], i, int(ri[RI_COUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP, None], errMsg, i, int(ri[RI_COUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.groups(), 'get',
                            throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                            groupKey=ri[RI_ENTITY], fields=cdfields)
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP, None], str(e), i, int(ri[RI_COUNT]))
        return
    entityList.append(response)

  def _callbackProcessGroupMembers(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    totalItems = 0
    items = 'members'
    pageMessage = getPageMessageForWhom(forWhom=ri[RI_ENTITY], showFirstLastItems=True)
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.MEMBERS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], errMsg, i, int(ri[RI_COUNT]))
        groupData[i]['required'] -= 1
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(cd.members(), 'list',
                            throwReasons=GAPI.MEMBERS_THROW_REASONS, retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                            includeDerivedMembership=memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP],
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields='nextPageToken,members(email,id,role,type,status)',
                            maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.invalid, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], str(e), i, int(ri[RI_COUNT]))
        groupData[i]['required'] -= 1
        return
    while True:
      pageToken, totalItems = _processGAPIpagesResult(response, items, groupData[i][items], totalItems, pageMessage, 'email', ri[RI_ROLE])
      if not pageToken:
        break
      try:
        response = callGAPI(cd.members(), 'list',
                            throwReasons=GAPI.MEMBERS_THROW_REASONS, retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                            pageToken=pageToken,
                            includeDerivedMembership=memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP],
                            groupKey=ri[RI_ENTITY], roles=ri[RI_ROLE], fields='nextPageToken,members(email,id,role,type,status)',
                            maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.invalid, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], ri[RI_ROLE], None], str(e), i, int(ri[RI_COUNT]))
        break
    groupData[i]['required'] -= 1

  def _callbackProcessGroupSettings(request_id, response, exception):
    ri = request_id.splitlines()
    i = int(ri[RI_I])
    if exception is not None:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+GAPI.GROUP_SETTINGS_RETRY_REASONS:
        errMsg = getHTTPError({}, http_status, reason, message)
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP_SETTINGS, None], errMsg, i, int(ri[RI_COUNT]))
        groupData[i]['required'] -= 1
        return
      waitOnFailure(1, 10, reason, message)
      try:
        response = callGAPI(gs.groups(), 'get',
                            throwReasons=GAPI.GROUP_SETTINGS_THROW_REASONS, retryReasons=GAPI.GROUP_SETTINGS_RETRY_REASONS,
                            groupUniqueId=ri[RI_ENTITY], fields=gsfields)
      except GAPI.notFound:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP_SETTINGS, None], Msg.DOES_NOT_EXIST, i, int(ri[RI_COUNT]))
        response = {}
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
              GAPI.backendError, GAPI.invalid, GAPI.invalidParameter, GAPI.invalidInput, GAPI.badRequest, GAPI.permissionDenied,
              GAPI.systemError, GAPI.serviceLimit) as e:
        entityActionFailedWarning([Ent.GROUP, ri[RI_ENTITY], Ent.GROUP_SETTINGS, None], str(e), i, int(ri[RI_COUNT]))
        response = {}
    groupData[i]['settings'] = response
    groupData[i]['required'] -= 1

  def _writeCompleteRows():
    complete = [k for k in groupData if groupData[k]['required'] == 0]
    for k in complete:
      _printGroupRow(groupData[k]['entity'], groupData[k]['settings'], groupData[k]['members'])
      del groupData[k]

  cd = buildGAPIObject(API.DIRECTORY)
  kwargs = {'customer': GC.Values[GC.CUSTOMER_ID]}
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  getCloudIdentity = getSettings = members = membersCountOnly = managers = managersCountOnly = owners = ownersCountOnly = showCIgroupKey = sortHeaders = totalCount = False
  maxResults = None
  groupFieldsLists = {'cd': ['email'], 'ci': [], 'gs': []}
  csvPF = CSVPrintFile(groupFieldsLists['cd'])
  FJQC = FormatJSONQuoteChar(csvPF)
  rolesSet = set()
  typesSet = set()
  memberOptions = initMemberOptions()
  entitySelection = isSuspended = showOwnedBy = None
  matchPatterns = {}
  matchSettings = {}
  deprecatedAttributesSet = set()
  ciGroups = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif getGroupFilters(myarg, kwargs):
      if myarg == 'showownedby':
        showOwnedBy = setGroupShowOwnedBy(kwargs)
        rolesSet.add(Ent.ROLE_OWNER)
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg == 'select':
      entitySelection = getEntityList(Cmd.OB_GROUP_ENTITY)
    elif myarg in SUSPENDED_ARGUMENTS:
      isSuspended = _getIsSuspended(myarg)
    elif myarg == 'maxresults':
      maxResults = getInteger(minVal=1, maxVal=200)
    elif myarg == 'nodeprecated':
      deprecatedAttributesSet.update([attr[0] for attr in iter(GROUP_DISCOVER_ATTRIBUTES.values())])
      deprecatedAttributesSet.update([attr[0] for attr in iter(GROUP_ASSIST_CONTENT_ATTRIBUTES.values())])
      deprecatedAttributesSet.update([attr[0] for attr in iter(GROUP_MODERATE_CONTENT_ATTRIBUTES.values())])
      deprecatedAttributesSet.update([attr[0] for attr in iter(GROUP_MODERATE_MEMBERS_ATTRIBUTES.values())])
      deprecatedAttributesSet.update([attr[0] for attr in iter(GROUP_DEPRECATED_ATTRIBUTES.values())])
    elif myarg in {'convertcrnl', 'converttextnl', 'convertfooternl'}:
      convertCRNL = True
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'basic':
      sortHeaders = True
      for field in GROUP_FIELDS_CHOICE_MAP:
        csvPF.AddField(field, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
    elif myarg == 'ciallfields':
      sortHeaders = True
      groupFieldsLists['ci'] = []
      for field in CIGROUP_FIELDS_CHOICE_MAP:
        addFieldToFieldsList(field, CIGROUP_FIELDS_CHOICE_MAP, groupFieldsLists['ci'])
    elif myarg == 'settings':
      getSettings = sortHeaders = True
    elif myarg == 'allfields':
      getSettings = sortHeaders = True
      groupFieldsLists['cd'] = []
      groupFieldsLists['gs'] = []
      for field in GROUP_FIELDS_CHOICE_MAP:
        csvPF.AddField(field, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
    elif myarg == 'sortheaders':
      sortHeaders = getBoolean()
    elif myarg in GROUP_FIELDS_CHOICE_MAP:
      csvPF.AddField(myarg, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
    elif myarg in GROUP_ATTRIBUTES_SET:
      attrProperties = getGroupAttrProperties(myarg)
      csvPF.AddField(myarg, {myarg: attrProperties[0]}, groupFieldsLists['gs'])
    elif myarg == 'fields':
      for field in _getFieldsList():
        if field in GROUP_FIELDS_CHOICE_MAP:
          csvPF.AddField(field, GROUP_FIELDS_CHOICE_MAP, groupFieldsLists['cd'])
        else:
          attrProperties = getGroupAttrProperties(field)
          if attrProperties is None:
            invalidChoiceExit(field, list(GROUP_FIELDS_CHOICE_MAP)+list(GROUP_ATTRIBUTES_SET), True)
          csvPF.AddField(field, {field: attrProperties[0]}, groupFieldsLists['gs'])
    elif myarg == 'cifields':
      for field in _getFieldsList():
        if field in CIGROUP_FIELDS_CHOICE_MAP:
          addFieldToFieldsList(field, CIGROUP_FIELDS_CHOICE_MAP, groupFieldsLists['ci'])
        else:
          invalidChoiceExit(field, list(CIGROUP_FIELDS_CHOICE_MAP), True)
    elif myarg == 'matchsetting':
      valueList = getChoice({'not': 'notvalues'}, mapChoice=True, defaultChoice='values')
      matchBody = {}
      getGroupAttrValue(getString(Cmd.OB_FIELD_NAME).lower(), matchBody)
      for key, value in iter(matchBody.items()):
        matchSettings.setdefault(key, {'notvalues': [], 'values': []})
        matchSettings[key][valueList].append(value)
    elif getGroupRoles(myarg, rolesSet):
      if Ent.ROLE_MEMBER in rolesSet:
        members = True
      if Ent.ROLE_MANAGER in rolesSet:
        managers = True
      if Ent.ROLE_OWNER in rolesSet:
        owners = True
    elif myarg in {'members', 'memberscount'}:
      rolesSet.add(Ent.ROLE_MEMBER)
      members = True
      if myarg == 'memberscount':
        membersCountOnly = True
    elif myarg in {'managers', 'managerscount'}:
      rolesSet.add(Ent.ROLE_MANAGER)
      managers = True
      if myarg == 'managerscount':
        managersCountOnly = True
    elif myarg in {'owners', 'ownerscount'}:
      rolesSet.add(Ent.ROLE_OWNER)
      owners = True
      if myarg == 'ownerscount':
        ownersCountOnly = True
    elif getGroupTypes(myarg, typesSet):
      pass
    elif getMemberMatchOptions(myarg, memberOptions):
      pass
    elif myarg == 'totalcount':
      totalCount = True
    elif myarg == 'countsonly':
      membersCountOnly = managersCountOnly = ownersCountOnly = True
    elif myarg == 'includederivedmembership':
      memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP] = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if not typesSet:
    typesSet = ALL_GROUP_TYPES
  updateFieldsForGroupMatchPatterns(matchPatterns, groupFieldsLists['cd'], csvPF)
  if groupFieldsLists['cd']:
    cdfields = ','.join(set(groupFieldsLists['cd']))
    cdfieldsnp = f'nextPageToken,groups({cdfields})'
  else:
    cdfields = cdfieldsnp = None
  if matchSettings:
    groupFieldsLists['gs'].extend(list(matchSettings))
  if groupFieldsLists['gs']:
    getSettings = True
    gsfields = ','.join(set(groupFieldsLists['gs']))
  else:
    gsfields = None
  if getSettings:
    gs = buildGAPIObject(API.GROUPSSETTINGS)
  if groupFieldsLists['ci']:
    setTrueCustomerId(cd)
    getCloudIdentity = True
    showCIgroupKey = 'groupKey' in groupFieldsLists['ci']
    groupFieldsLists['ci'].append('groupKey(id)')
    cifields = ','.join(set(groupFieldsLists['ci']))
    cifieldsnp = f'nextPageToken,groups({cifields})'
    ci = buildGAPIObject(API.CLOUDIDENTITY_GROUPS)
  memberRoles = ','.join(sorted(rolesSet)) if rolesSet else None
  showDetails = memberRoles or getSettings or getCloudIdentity
  if memberRoles:
    if totalCount:
      csvPF.AddTitles('TotalCount')
    if members:
      csvPF.AddTitles('MembersCount')
      if not membersCountOnly:
        csvPF.AddTitles('Members')
    if managers:
      csvPF.AddTitles('ManagersCount')
      if not managersCountOnly:
        csvPF.AddTitles('Managers')
    if owners:
      csvPF.AddTitles('OwnersCount')
      if not ownersCountOnly:
        csvPF.AddTitles('Owners')
  if FJQC.formatJSON:
    sortHeaders = False
    csvPF.SetJSONTitles(PRINT_GROUPS_JSON_TITLES)
    if memberRoles:
      csvPF.AddJSONTitle('JSON-members')
    if getSettings:
      csvPF.AddJSONTitle('JSON-settings')
    if getCloudIdentity:
      csvPF.AddJSONTitle('JSON-cloudIdentity')
  if entitySelection is None:
    printGettingAllAccountEntities(Ent.GROUP, groupFilters(kwargs))
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='email',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 orderBy='email', fields=cdfieldsnp, maxResults=maxResults, **kwargs)
    except (GAPI.invalidMember, GAPI.invalidInput):
      invalidMember(kwargs)
      entityList = []
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get('domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs['domain'])
        entityList = []
      else:
        accessErrorExit(cd)
    if getCloudIdentity:
      printGettingAllAccountEntities(Ent.CLOUD_IDENTITY_GROUP)
      try:
        ciGroupList = callGAPIpages(ci.groups(), 'list', 'groups',
                                    pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute=['groupKey', 'id'],
                                    throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                    parent=f'customers/{GC.Values[GC.CUSTOMER_ID]}', view='FULL',
                                    fields=cifieldsnp, pageSize=500)
      except (GAPI.forbidden, GAPI.badRequest):
        accessErrorExit(cd)
      for ciGroup in ciGroupList:
        key = ciGroup['groupKey']['id']
        if not showCIgroupKey:
          ciGroup.pop('groupKey')
        ciGroups[key] = ciGroup.copy()
      del ciGroupList
  else:
    svcargs = dict([('groupKey', None), ('fields', cdfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    cdmethod = getattr(cd.groups(), 'get')
    cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupBasic)
    cdbcount = 0
    entityList = []
    i = 0
    count = len(entitySelection)
    for groupEntity in entitySelection:
      i += 1
      groupEmail = normalizeEmailAddressOrUID(groupEntity)
      svcparms = svcargs.copy()
      svcparms['groupKey'] = groupEmail
      printGettingEntityItem(Ent.GROUP, groupEmail, i, count)
      cdbatch.add(cdmethod(**svcparms), request_id=batchRequestID(groupEmail, i, count, 0, 0, None))
      cdbcount += 1
      if cdbcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(cdbatch)
        cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupBasic)
        cdbcount = 0
      if getCloudIdentity:
        printGettingEntityItemForWhom(Ent.CLOUD_IDENTITY_GROUP, groupEmail, i, count)
        name = convertGroupEmailToCloudID(ci, groupEmail, i, count)
        if name:
          try:
            ciGroup = callGAPI(ci.groups(), 'get',
                               throwReasons=GAPI.CIGROUP_GET_THROW_REASONS,
                               retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                               name=name, fields=cifields)
            key = ciGroup['groupKey']['id']
            if not showCIgroupKey:
              ciGroup.pop('groupKey')
            ciGroups[key] = ciGroup
          except (GAPI.notFound, GAPI.domainNotFound, GAPI.domainCannotUseApis,
                  GAPI.forbidden, GAPI.badRequest, GAPI.invalid,
                  GAPI.systemError, GAPI.permissionDenied) as e:
            entityActionFailedWarning([Ent.GROUP, groupEmail, Ent.CLOUD_IDENTITY_GROUP, None], str(e), i, count)
    if cdbcount > 0:
      cdbatch.execute()
  required = 0
  if memberRoles:
    required += 1
    svcargs = dict([('groupKey', None), ('roles', memberRoles), ('fields', 'nextPageToken,members(email,id,role,type,status)'),
                    ('includeDerivedMembership', memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP]),
                    ('maxResults', GC.Values[GC.MEMBER_MAX_RESULTS])]+GM.Globals[GM.EXTRA_ARGS_LIST])
  if getSettings:
    required += 1
    svcargsgs = dict([('groupUniqueId', None), ('fields', gsfields)]+GM.Globals[GM.EXTRA_ARGS_LIST])
  cdmethod = getattr(cd.members(), 'list')
  cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupMembers)
  cdbcount = 0
  if getSettings:
    gsmethod = getattr(gs.groups(), 'get')
    gsbatch = gs.new_batch_http_request(callback=_callbackProcessGroupSettings)
    gsbcount = 0
  groupData = {}
  i = 0
  count = len(entityList)
  for groupEntity in entityList:
    i += 1
    groupEmail = groupEntity['email']
    if not checkGroupMatchPatterns(groupEmail, groupEntity, matchPatterns):
      continue
    if not showDetails:
      _printGroupRow(groupEntity, None, None)
      continue
    groupData[i] = {'entity': groupEntity, 'cloudIdentity': {}, 'settings': getSettings, 'members': [], 'required': required}
    if memberRoles:
      printGettingEntityItemForWhom(memberRoles, groupEmail, i, count)
      svcparms = svcargs.copy()
      svcparms['groupKey'] = groupEmail
      cdbatch.add(cdmethod(**svcparms), request_id=batchRequestID(groupEmail, i, count, 0, 0, None, memberRoles))
      cdbcount += 1
      if cdbcount >= GC.Values[GC.BATCH_SIZE]:
        executeBatch(cdbatch)
        cdbatch = cd.new_batch_http_request(callback=_callbackProcessGroupMembers)
        cdbcount = 0
        _writeCompleteRows()
    if getSettings:
      if not GroupIsAbuseOrPostmaster(groupEmail):
        printGettingEntityItemForWhom(Ent.GROUP_SETTINGS, groupEmail, i, count)
        svcparmsgs = svcargsgs.copy()
        svcparmsgs['groupUniqueId'] = groupEmail
        gsbatch.add(gsmethod(**svcparmsgs), request_id=batchRequestID(groupEmail, i, count, 0, 0, None))
        gsbcount += 1
        if gsbcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(gsbatch)
          gsbatch = gs.new_batch_http_request(callback=_callbackProcessGroupSettings)
          gsbcount = 0
          _writeCompleteRows()
      else:
        groupData[i]['settings'] = False
        groupData[i]['required'] -= 1
  if cdbcount > 0:
    cdbatch.execute()
  if getSettings and gsbcount > 0:
    gsbatch.execute()
  _writeCompleteRows()
  if sortHeaders:
    sortTitles = ['email']+GROUP_INFO_PRINT_ORDER+['aliases', 'nonEditableAliases']
    if getSettings:
      sortTitles += sorted([attr[0] for attr in iter(GROUP_SETTINGS_ATTRIBUTES.values())])
      for key in GROUP_MERGED_ATTRIBUTES_PRINT_ORDER:
        sortTitles.append(key)
        if not deprecatedAttributesSet:
          sortTitles += sorted([attr[0] for attr in iter(GROUP_MERGED_TO_COMPONENT_MAP[key].values())])
      if not deprecatedAttributesSet:
        sortTitles += sorted([attr[0] for attr in iter(GROUP_DEPRECATED_ATTRIBUTES.values())])
    if memberRoles:
      if totalCount:
        sortTitles.append('TotalCount')
      if members:
        sortTitles.append('MembersCount')
        if not membersCountOnly:
          sortTitles.append('Members')
      if managers:
        sortTitles.append('ManagersCount')
        if not managersCountOnly:
          sortTitles.append('Managers')
      if owners:
        sortTitles.append('OwnersCount')
        if not ownersCountOnly:
          sortTitles.append('Owners')
    csvPF.SetSortTitles(sortTitles)
  csvPF.writeCSVfile('Groups')

INFO_GROUPMEMBERS_FIELDS = ['role', 'type', 'status', 'delivery_settings']

# gam <UserTypeEntity> info member <GroupEntity>
def infoGroupMembers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  groups = getEntityList(Cmd.OB_GROUP_ENTITY)
  checkForExtraneousArguments()
  fields = ','.join(INFO_GROUPMEMBERS_FIELDS)
  groupsLists = groups if isinstance(groups, dict) else None
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    memberKey = normalizeEmailAddressOrUID(user)
    if groupsLists:
      groups = groupsLists[user]
    jcount = len(groups)
    entityPerformActionNumItems([Ent.MEMBER, memberKey], jcount, Ent.GROUP, i, count)
    Ind.Increment()
    j = 0
    for group in groups:
      j += 1
      groupKey = normalizeEmailAddressOrUID(group)
      try:
        result = callGAPI(cd.members(), 'get',
                          throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND], retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                          groupKey=groupKey, memberKey=memberKey, fields=fields)
        result.setdefault('role', Ent.ROLE_MEMBER)
        printEntity([Ent.GROUP, groupKey], j, jcount)
        Ind.Increment()
        for field in INFO_GROUPMEMBERS_FIELDS:
          printKeyValueList([field, result[field]])
        Ind.Decrement()
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.GROUP, group], str(e), j, jcount)
      except GAPI.memberNotFound:
        entityActionFailedWarning([Ent.GROUP, group], Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.MEMBER)), j, jcount)
    Ind.Decrement()

# gam info member <UserTypeEntity> <GroupEntity>
def doInfoGroupMembers():
  infoGroupMembers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1])

def getGroupMembers(cd, groupEmail, memberRoles, membersList, membersSet, i, count, memberOptions, level, typesSet):
  def _getMemberDeliverySettings(member):
    if 'delivery_settings' not in member:
      try:
        member['delivery_settings'] = callGAPI(cd.members(), 'get',
                                               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND], retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                                               groupKey=groupEmail, memberKey=member['id'], fields='delivery_settings')['delivery_settings']
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
        pass
      except GAPI.memberNotFound:
        pass
    else:
      memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS] = False

  printGettingAllEntityItemsForWhom(memberRoles if memberRoles else Ent.ROLE_MANAGER_MEMBER_OWNER, groupEmail, i, count)
  validRoles, listRoles, listFields = _getRoleVerification(memberRoles, 'nextPageToken,members(email,id,role,status,type,delivery_settings)')
  try:
    groupMembers = callGAPIpages(cd.members(), 'list', 'members',
                                 throwReasons=GAPI.MEMBERS_THROW_REASONS, retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                                 includeDerivedMembership=memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP],
                                 groupKey=groupEmail, roles=listRoles, fields=listFields, maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
  except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
    entityUnknownWarning(Ent.GROUP, groupEmail, i, count)
    return
  if not memberOptions[MEMBEROPTION_RECURSIVE]:
    if memberOptions[MEMBEROPTION_NODUPLICATES]:
      for member in groupMembers:
        if _checkMemberRoleIsSuspended(member, validRoles, memberOptions[MEMBEROPTION_ISSUSPENDED]) and member['id'] not in membersSet:
          if memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS]:
            _getMemberDeliverySettings(member)
          membersSet.add(member['id'])
          if member['type'] in typesSet and checkMemberMatch(member, memberOptions):
            membersList.append(member)
    else:
      for member in groupMembers:
        if _checkMemberRoleIsSuspended(member, validRoles, memberOptions[MEMBEROPTION_ISSUSPENDED]):
          if memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS]:
            _getMemberDeliverySettings(member)
          if member['type'] in typesSet and checkMemberMatch(member, memberOptions):
            membersList.append(member)
  elif memberOptions[MEMBEROPTION_NODUPLICATES]:
    groupMemberList = []
    for member in groupMembers:
      if member['type'] == Ent.TYPE_USER:
        if (member['type'] in typesSet and checkMemberMatch(member, memberOptions) and
            _checkMemberRoleIsSuspended(member, validRoles, memberOptions[MEMBEROPTION_ISSUSPENDED]) and
            member['id'] not in membersSet):
          if memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS]:
            _getMemberDeliverySettings(member)
          membersSet.add(member['id'])
          member['level'] = level
          member['subgroup'] = groupEmail
          membersList.append(member)
      elif member['type'] == Ent.TYPE_GROUP:
        if member['id'] not in membersSet:
          if memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS]:
            _getMemberDeliverySettings(member)
          membersSet.add(member['id'])
          if member['type'] in typesSet and checkMemberMatch(member, memberOptions):
            member['level'] = level
            member['subgroup'] = groupEmail
            membersList.append(member)
          groupMemberList.append(member['email'])
    for member in groupMemberList:
      getGroupMembers(cd, member, memberRoles, membersList, membersSet, i, count, memberOptions, level+1, typesSet)
  else:
    for member in groupMembers:
      if member['type'] == Ent.TYPE_USER:
        if (member['type'] in typesSet and checkMemberMatch(member, memberOptions) and
            _checkMemberRoleIsSuspended(member, validRoles, memberOptions[MEMBEROPTION_ISSUSPENDED])):
          if memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS]:
            _getMemberDeliverySettings(member)
          member['level'] = level
          member['subgroup'] = groupEmail
          membersList.append(member)
      elif member['type'] == Ent.TYPE_GROUP:
        if member['type'] in typesSet and checkMemberMatch(member, memberOptions):
          member['level'] = level
          member['subgroup'] = groupEmail
          membersList.append(member)
        getGroupMembers(cd, member['email'], memberRoles, membersList, membersSet, i, count, memberOptions, level+1, typesSet)

GROUPMEMBERS_FIELDS_CHOICE_MAP = {
  'delivery': 'delivery_settings',
  'deliverysettings': 'delivery_settings',
  'email': 'email',
  'group': 'group',
  'groupemail': 'group',
  'id': 'id',
  'name': 'name',
  'role': 'role',
  'status': 'status',
  'type': 'type',
  'useremail': 'email',
  }

GROUPMEMBERS_DEFAULT_FIELDS = ['group', 'type', 'role', 'id', 'status', 'email']

# gam print group-members [todrive <ToDriveAttribute>*]
#	[([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|
#	 (group|group_ns|group_susp <GroupItem>)|
#	 (select <GroupEntity>)] [notsuspended|suspended]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>]
#	[descriptionmatchpattern <RegularExpression>]
#	[showownedby <UserItem>]
#	[roles <GroupRoleList>] [members] [managers] [owners] [membernames] <MembersFieldName>* [fields <MembersFieldNameList>]
#	[types <GroupTypeList>]
#	[memberemaildisplaypattern|memberemailskippattern <RegularExpression>]
#	[userfields <UserFieldNameList>] [recursive [noduplicates]] [nogroupemail]
#	[peoplelookup|(peoplelookupuser <EmailAddress>)]
#	[includederivedmembership]
def doPrintGroupMembers():
  def getNameFromPeople(memberId):
    try:
      info = callGAPI(people.people(), 'get',
                      throwReasons=[GAPI.NOT_FOUND],
                      resourceName=f'people/{memberId}', personFields='names')
      if 'names' in info:
        for sourceType in ['PROFILE', 'CONTACT']:
          for name in info['names']:
            if name['metadata']['source']['type'] == sourceType:
              return name['displayName']
    except GAPI.notFound:
      pass
    return ''

  cd = buildGAPIObject(API.DIRECTORY)
  people = None
  peopleNames = {}
  memberOptions = initMemberOptions()
  groupColumn = True
  kwargs = {'customer': GC.Values[GC.CUSTOMER_ID]}
  subTitle = f'{Msg.ALL} {Ent.Plural(Ent.GROUP)}'
  fieldsList = []
  csvPF = CSVPrintFile('group')
  entityList = showOwnedBy = None
  cdfieldsList = ['email']
  userFieldsList = []
  rolesSet = set()
  typesSet = set()
  matchPatterns = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif getGroupFilters(myarg, kwargs):
      if myarg == 'showownedby':
        showOwnedBy = setGroupShowOwnedBy(kwargs)
        rolesSet.add(Ent.ROLE_OWNER)
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg in {'group', 'groupns', 'groupsusp'}:
      entityList = [getEmailAddress()]
      subTitle = f'{Ent.Singular(Ent.GROUP)}={entityList[0]}'
      if myarg == 'groupns':
        memberOptions[MEMBEROPTION_ISSUSPENDED] = False
      elif myarg == 'groupsusp':
        memberOptions[MEMBEROPTION_ISSUSPENDED] = True
    elif myarg == 'select':
      entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
      subTitle = f'{Msg.SELECTED} {Ent.Plural(Ent.GROUP)}'
    elif myarg in SUSPENDED_ARGUMENTS:
      memberOptions[MEMBEROPTION_ISSUSPENDED] = _getIsSuspended(myarg)
    elif getGroupRoles(myarg, rolesSet):
      pass
    elif getGroupTypes(myarg, typesSet):
      pass
    elif getMemberMatchOptions(myarg, memberOptions):
      pass
    elif csvPF.GetFieldsListTitles(myarg, GROUPMEMBERS_FIELDS_CHOICE_MAP, fieldsList):
      pass
    elif myarg == 'membernames':
      memberOptions[MEMBEROPTION_MEMBERNAMES] = True
    elif myarg == 'userfields':
      for field in _getFieldsList():
        if field in USER_FIELDS_CHOICE_MAP:
          csvPF.AddField(field, USER_FIELDS_CHOICE_MAP, userFieldsList)
        else:
          invalidChoiceExit(field, USER_FIELDS_CHOICE_MAP, True)
    elif myarg == 'noduplicates':
      memberOptions[MEMBEROPTION_NODUPLICATES] = True
    elif myarg == 'recursive':
      memberOptions[MEMBEROPTION_RECURSIVE] = True
    elif myarg == 'nogroupemail':
      groupColumn = False
    elif myarg == 'peoplelookup':
      people = buildGAPIObject(API.PEOPLE)
    elif myarg == 'peoplelookupuser':
      _, people = buildGAPIServiceObject(API.PEOPLE, getEmailAddress())
      if not people:
        return
    elif myarg == 'includederivedmembership':
      memberOptions[MEMBEROPTION_INCLUDEDERIVEDMEMBERSHIP] = True
    else:
      unknownArgumentExit()
  if not typesSet:
    typesSet = {Ent.TYPE_USER} if memberOptions[MEMBEROPTION_RECURSIVE] else ALL_GROUP_TYPES
  if entityList is None:
    updateFieldsForGroupMatchPatterns(matchPatterns, cdfieldsList)
    subTitle = groupFilters(kwargs)
    printGettingAllAccountEntities(Ent.GROUP, subTitle)
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='email',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 orderBy='email', fields=f'nextPageToken,groups({",".join(set(cdfieldsList))})', **kwargs)
    except (GAPI.invalidMember, GAPI.invalidInput):
      invalidMember(kwargs)
      entityList = []
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get('domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs['domain'])
        entityList = []
      else:
        accessErrorExit(cd)
  else:
    clearUnneededGroupMatchPatterns(matchPatterns)
  if not fieldsList:
    for field in GROUPMEMBERS_DEFAULT_FIELDS:
      csvPF.AddField(field, {field: field}, fieldsList)
  elif 'name'in fieldsList:
    memberOptions[MEMBEROPTION_MEMBERNAMES] = True
    fieldsList.remove('name')
  if 'group' in fieldsList:
    fieldsList.remove('group')
  if not groupColumn:
    csvPF.RemoveTitles(['group'])
  if userFieldsList:
    if not memberOptions[MEMBEROPTION_MEMBERNAMES] and 'name.fullName' in userFieldsList:
      memberOptions[MEMBEROPTION_MEMBERNAMES] = True
  if memberOptions[MEMBEROPTION_MEMBERNAMES]:
    if 'name.fullName' not in userFieldsList:
      userFieldsList.append('name.fullName')
    csvPF.AddTitles('name')
    csvPF.RemoveTitles(['name.fullName'])
  memberOptions[MEMBEROPTION_GETDELIVERYSETTINGS] = 'delivery_settings' in fieldsList
  userFields = getFieldsFromFieldsList(userFieldsList)
  memberRoles = ','.join(sorted(rolesSet)) if rolesSet else None
  level = 0
  customerKey = GC.Values[GC.CUSTOMER_ID]
  setCustomerMemberEmail = 'email' in fieldsList
  i = 0
  count = len(entityList)
  for group in entityList:
    i += 1
    if isinstance(group, dict):
      groupEmail = group['email']
    else:
      groupEmail = convertUIDtoEmailAddress(group, cd, 'group')
    if not checkGroupMatchPatterns(groupEmail, group, matchPatterns):
      continue
    membersList = []
    membersSet = set()
    getGroupMembers(cd, groupEmail, memberRoles, membersList, membersSet, i, count, memberOptions, level, typesSet)
    if showOwnedBy and not checkGroupShowOwnedBy(showOwnedBy, membersList):
      continue
    for member in membersList:
      memberId = member['id']
      row = {}
      if groupColumn:
        row['group'] = groupEmail
      if memberOptions[MEMBEROPTION_RECURSIVE]:
        row['level'] = member['level']
        row['subgroup'] = member['subgroup']
      for title in fieldsList:
        row[title] = member.get(title, '')
      if setCustomerMemberEmail and (memberId == customerKey):
        row['email'] = memberId
      memberType = member.get('type')
      if userFieldsList:
        if memberOptions[MEMBEROPTION_MEMBERNAMES]:
          row['name'] = 'Unknown'
        if memberType == Ent.TYPE_USER:
          try:
            mbinfo = callGAPI(cd.users(), 'get',
                              throwReasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=memberId, fields=userFields)
            if memberOptions[MEMBEROPTION_MEMBERNAMES]:
              row['name'] = mbinfo['name'].pop('fullName')
              if not mbinfo['name']:
                mbinfo.pop('name')
            csvPF.WriteRowTitles(flattenJSON(mbinfo, flattened=row))
            continue
          except GAPI.userNotFound:
            if memberOptions[MEMBEROPTION_MEMBERNAMES] and people:
              if memberId not in peopleNames:
                peopleNames[memberId] = getNameFromPeople(memberId)
              if peopleNames[memberId]:
                row['name'] = peopleNames[memberId]
          except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
            pass
        elif memberType == Ent.TYPE_GROUP:
          if memberOptions[MEMBEROPTION_MEMBERNAMES]:
            try:
              row['name'] = callGAPI(cd.groups(), 'get',
                                     throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                                     groupKey=memberId, fields='name')['name']
            except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.systemError):
              pass
        elif memberType == Ent.TYPE_CUSTOMER:
          if memberOptions[MEMBEROPTION_MEMBERNAMES]:
            try:
              row['name'] = callGAPI(cd.customers(), 'get',
                                     throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                     customerKey=memberId, fields='customerDomain')['customerDomain']
            except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
              pass
      csvPF.WriteRow(row)
  csvPF.SetSortTitles(GROUPMEMBERS_DEFAULT_FIELDS)
  csvPF.SortTitles()
  csvPF.SetSortTitles([])
  if memberOptions[MEMBEROPTION_RECURSIVE]:
    csvPF.MoveTitlesToEnd(['level', 'subgroup'])
  csvPF.writeCSVfile(f'Group Members ({subTitle})')

# gam show group-members
#	[([domain <DomainName>] ([member <UserItem>]|[query <QueryGroup>]))|
#	 (group|group_ns|group_susp <GroupItem>)|
#	 (select <GroupEntity>)] [notsuspended|suspended]
#	[showownedby <UserItem>]
#	[emailmatchpattern <RegularExpression>] [namematchpattern <RegularExpression>]
#	[descriptionmatchpattern <RegularExpression>]
#	[roles <GroupRoleList>] [members] [managers] [owners] [depth <Number>]
#	[types <GroupTypeList>]
#	[memberemaildisplaypattern|memberemailskippattern <RegularExpression>]
#	[includederivedmembership]
def doShowGroupMembers():
  def _roleOrder(key):
    return {Ent.ROLE_OWNER: 0, Ent.ROLE_MANAGER: 1, Ent.ROLE_MEMBER: 2}.get(key, 3)

  def _typeOrder(key):
    return {Ent.TYPE_CUSTOMER: 0, Ent.TYPE_USER: 1, Ent.TYPE_GROUP: 2, Ent.TYPE_EXTERNAL: 3}.get(key, 4)

  def _statusOrder(key):
    return {'ACTIVE': 0, 'SUSPENDED': 1, 'UNKNOWN': 2}.get(key, 3)

  def _showGroup(groupEmail, depth):
    try:
      membersList = callGAPIpages(cd.members(), 'list', 'members',
                                  throwReasons=GAPI.MEMBERS_THROW_REASONS, retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                                  includeDerivedMembership=includeDerivedMembership,
                                  groupKey=groupEmail, fields='nextPageToken,members(email,id,role,status,type)', maxResults=GC.Values[GC.MEMBER_MAX_RESULTS])
      if showOwnedBy and not checkGroupShowOwnedBy(showOwnedBy, membersList):
        return
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      if depth == 0:
        entityUnknownWarning(Ent.GROUP, groupEmail, i, count)
      return
    if depth == 0:
      printEntity([Ent.GROUP, groupEmail], i, count)
    if depth == 0 or Ent.TYPE_GROUP in typesSet:
      Ind.Increment()
    for member in sorted(membersList, key=lambda k: (_roleOrder(k.get('role', Ent.ROLE_MEMBER)), _typeOrder(k['type']), _statusOrder(k.get('status', '')))):
      if _checkMemberIsSuspended(member, memberOptions[MEMBEROPTION_ISSUSPENDED]):
        if member.get('role', Ent.ROLE_MEMBER) in rolesSet and member['type'] in typesSet and checkMemberMatch(member, memberOptions):
          printKeyValueList([f'{member.get("role", Ent.ROLE_MEMBER)}, {member["type"]}, {member.get("email", member["id"])}, {member.get("status", "")}'])
        if not includeDerivedMembership and (member['type'] == Ent.TYPE_GROUP) and (maxdepth == -1 or depth < maxdepth):
          _showGroup(member['email'], depth+1)
    if depth == 0 or Ent.TYPE_GROUP in typesSet:
      Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  customerKey = GC.Values[GC.CUSTOMER_ID]
  kwargs = {'customer': customerKey}
  entityList = showOwnedBy = None
  cdfieldsList = ['email']
  rolesSet = set()
  typesSet = set()
  memberOptions = initMemberOptions()
  matchPatterns = {}
  maxdepth = -1
  includeDerivedMembership = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if getGroupFilters(myarg, kwargs):
      if myarg == 'showownedby':
        showOwnedBy = setGroupShowOwnedBy(kwargs)
        rolesSet.add(Ent.ROLE_OWNER)
    elif getGroupMatchPatterns(myarg, matchPatterns):
      pass
    elif myarg in {'group', 'groupns', 'groupsusp'}:
      entityList = [getEmailAddress()]
      if myarg == 'groupns':
        memberOptions[MEMBEROPTION_ISSUSPENDED] = False
      elif myarg == 'groupsusp':
        memberOptions[MEMBEROPTION_ISSUSPENDED] = True
    elif myarg == 'select':
      entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
    elif myarg in SUSPENDED_ARGUMENTS:
      memberOptions[MEMBEROPTION_ISSUSPENDED] = _getIsSuspended(myarg)
    elif getGroupRoles(myarg, rolesSet):
      pass
    elif getGroupTypes(myarg, typesSet):
      pass
    elif getMemberMatchOptions(myarg, memberOptions):
      pass
    elif myarg == 'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == 'includederivedmembership':
      includeDerivedMembership = True
    else:
      unknownArgumentExit()
  if not rolesSet:
    rolesSet = ALL_GROUP_ROLES
  if not typesSet:
    typesSet = ALL_GROUP_TYPES
  if entityList is None:
    updateFieldsForGroupMatchPatterns(matchPatterns, cdfieldsList)
    printGettingAllAccountEntities(Ent.GROUP, groupFilters(kwargs))
    try:
      groupsList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='email',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 orderBy='email', fields=f'nextPageToken,groups({",".join(set(cdfieldsList))})', **kwargs)
    except (GAPI.invalidMember, GAPI.invalidInput):
      invalidMember(kwargs)
      return
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get('domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs['domain'])
        return
      accessErrorExit(cd)
  else:
    clearUnneededGroupMatchPatterns(matchPatterns)
    groupsList = []
    for group in entityList:
      if isinstance(group, dict):
        groupsList.append({'email': group['email']})
      else:
        groupsList.append({'email': convertUIDtoEmailAddress(group, cd, 'group')})
  i = 0
  count = len(groupsList)
  for group in groupsList:
    i += 1
    groupEmail = group['email']
    if checkGroupMatchPatterns(groupEmail, group, matchPatterns):
      _showGroup(groupEmail, 0)

# gam print grouptree <GroupEntity> [todrive <ToDriveAttribute>*]
# gam show grouptree <GroupEntity>
def doPrintShowGroupTree():
  def getGroupParents(groupEmail, groupName):
    groupParents[groupEmail] = {'name': groupName, 'parents': []}
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=groupEmail, orderBy='email', fields='nextPageToken,groups(email,name)')
      for parentGroup in entityList:
        groupParents[groupEmail]['parents'].append(parentGroup['email'])
        if parentGroup['email'] not in groupParents:
          getGroupParents(parentGroup['email'], parentGroup['name'])
    except (GAPI.invalidMember, GAPI.invalidInput):
      badRequestWarning(Ent.GROUP, Ent.MEMBER, groupEmail)
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      accessErrorExit(cd)

  def showGroupParents(groupEmail, i, count):
    printKeyValueListWithCount([f'{groupEmail}: {groupParents[groupEmail]["name"]}'], i, count)
    Ind.Increment()
    for parentEmail in groupParents[groupEmail]['parents']:
      showGroupParents(parentEmail, 0, 0)
    Ind.Decrement()

  def printGroupParents(groupEmail, row):
    if groupParents[groupEmail]['parents']:
      for parentEmail in groupParents[groupEmail]['parents']:
        row['parents'].append({'email': parentEmail, 'name': groupParents[parentEmail]['name']})
        printGroupParents(parentEmail, row)
        del row['parents'][-1]
    else:
      csvPF.WriteRowTitles(flattenJSON(row))

  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['email', 'name'], 'sortall', ['parents']) if Act.csvFormat() else None
  entityList = getEntityList(Cmd.OB_GROUP_ENTITY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  groupParents = {}
  i = 0
  count = len(entityList)
  if not csvPF:
    performActionNumItems(count, Ent.GROUP_TREE)
  for group in entityList:
    i += 1
    group = normalizeEmailAddressOrUID(group)
    try:
      basicInfo = callGAPI(cd.groups(), 'get',
                           throwReasons=GAPI.GROUP_GET_THROW_REASONS, retryReasons=GAPI.GROUP_GET_RETRY_REASONS,
                           groupKey=group, fields='email,name')
      group = basicInfo['email']
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest,
            GAPI.invalid, GAPI.systemError) as e:
      entityActionFailedWarning([Ent.GROUP, group], str(e), i, count)
      continue
    getGroupParents(group, basicInfo['name'])
    if not csvPF:
      showGroupParents(group, i, count)
    else:
      row = {'email': group, 'name': groupParents[group]['name'], 'parents': []}
      printGroupParents(group, row)
  if csvPF:
    csvPF.writeCSVfile('Group Tree')

# gam print licenses [todrive <ToDriveAttribute>*] [(products|product <ProductIDList>)|(skus|sku <SKUIDList>)|allskus|gsuite] [countsonly]
def doPrintLicenses(returnFields=None, skus=None, countsOnly=False, returnCounts=False):
  lic = buildGAPIObject(API.LICENSING)
  csvPF = CSVPrintFile()
  products = []
  feed = []
  licenseCounts = []
  if not returnFields:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if not returnCounts and myarg == 'todrive':
        csvPF.GetTodriveParameters()
      elif myarg in {'products', 'product'}:
        products = getGoogleProductList()
        skus = []
      elif myarg in {'skus', 'sku'}:
        skus = getGoogleSKUList()
        products = []
      elif myarg == 'allskus':
        skus = SKU.getSortedSKUList()
        products = []
      elif myarg == 'gsuite':
        skus = SKU.getGSuiteSKUs()
        products = []
      elif myarg == 'countsonly':
        countsOnly = True
      else:
        unknownArgumentExit()
    if not countsOnly:
      fields = getItemFieldsFromFieldsList('items', ['productId', 'skuId', 'userId'])
      csvPF.SetTitles(['userId', 'productId', 'productDisplay', 'skuId', 'skuDisplay'])
    else:
      fields = getItemFieldsFromFieldsList('items', ['userId'])
      if not returnCounts:
        if skus:
          csvPF.SetTitles(['productId', 'productDisplay', 'skuId', 'skuDisplay', 'licenses'])
        else:
          csvPF.SetTitles(['productId', 'productDisplay', 'licenses'])
  else:
    fields = getItemFieldsFromFieldsList('items', returnFields)
  if skus:
    for skuId in skus:
      Ent.SetGetting(Ent.LICENSE)
      productId, skuId = SKU.getProductAndSKU(skuId)
      productDisplay = SKU.formatProductIdDisplayName(productId)
      skuIdDisplay = SKU.formatSKUIdDisplayName(skuId)
      try:
        feed += callGAPIpages(lic.licenseAssignments(), 'listForProductAndSku', 'items',
                              pageMessage=getPageMessageForWhom(forWhom=skuIdDisplay),
                              throwReasons=[GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_ARGUMENT],
                              customerId=GC.Values[GC.DOMAIN], productId=productId, skuId=skuId, fields=fields)
        if countsOnly:
          licenseCounts.append([Ent.PRODUCT, productId, Ent.SKU, [skuId, skuIdDisplay][returnCounts], Ent.LICENSE, len(feed)])
          feed = []
      except (GAPI.invalid, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionNotPerformedWarning([Ent.PRODUCT, productDisplay, Ent.SKU, skuIdDisplay], str(e))
  else:
    suppressErrorMsg = False
    if not products:
      suppressErrorMsg = True
      products = SKU.getSortedProductList()
    for productId in products:
      Ent.SetGetting(Ent.LICENSE)
      productDisplay = SKU.formatProductIdDisplayName(productId)
      try:
        feed += callGAPIpages(lic.licenseAssignments(), 'listForProduct', 'items',
                              pageMessage=getPageMessageForWhom(forWhom=productDisplay),
                              throwReasons=[GAPI.INVALID, GAPI.FORBIDDEN, GAPI.INVALID_ARGUMENT],
                              customerId=GC.Values[GC.DOMAIN], productId=productId, fields=fields)
        if countsOnly:
          licenseCounts.append([Ent.PRODUCT, [productId, productDisplay][returnCounts], Ent.LICENSE, len(feed)])
          feed = []
      except (GAPI.invalid, GAPI.forbidden, GAPI.invalidArgument) as e:
        if not suppressErrorMsg:
          entityActionNotPerformedWarning([Ent.PRODUCT, productDisplay], str(e))
  if countsOnly:
    if returnCounts:
      return licenseCounts
    if skus:
      for u_license in licenseCounts:
        csvPF.WriteRow({'productId': u_license[1], 'productDisplay': SKU.productIdToDisplayName(u_license[1]),
                        'skuId': u_license[3], 'skuDisplay': SKU.skuIdToDisplayName(u_license[3]), 'licenses': u_license[5]})
    else:
      for u_license in licenseCounts:
        csvPF.WriteRow({'productId': u_license[1], 'productDisplay': SKU.productIdToDisplayName(u_license[1]), 'licenses': u_license[3]})
    csvPF.writeCSVfile('Licenses')
    return
  if returnFields:
    if returnFields == 'userId':
      userIds = []
      for u_license in feed:
        userId = u_license.get('userId', '').lower()
        if userId:
          userIds.append(userId)
      return userIds
    userSkuIds = {}
    for u_license in feed:
      userId = u_license.get('userId', '').lower()
      skuId = u_license.get('skuId')
      if userId and skuId:
        userSkuIds.setdefault(userId, [])
        userSkuIds[userId].append(skuId)
    return userSkuIds
  for u_license in feed:
    userId = u_license.get('userId', '').lower()
    productId = u_license.get('productId', '')
    skuId = u_license.get('skuId', '')
    csvPF.WriteRow({'userId': userId,
                    'productId': productId, 'productDisplay': SKU.productIdToDisplayName(productId),
                    'skuId': skuId, 'skuDisplay': SKU.skuIdToDisplayName(skuId)})
  csvPF.writeCSVfile('Licenses')

# gam show licenses [(products|product <ProductIDList>)|(skus|sku <SKUIDList>)|allskus|gsuite]
def doShowLicenses():
  licenseCounts = doPrintLicenses(countsOnly=True, returnCounts=True)
  for u_license in licenseCounts:
    printEntityKVList(u_license[:-2], [Ent.Plural(u_license[-2]), u_license[-1]])

# gam delete alert <AlertID>
# gam undelete alert <AlertID>
def doDeleteOrUndeleteAlert():
  alertId = getString(Cmd.OB_ALERT_ID)
  if Act.Get() == Act.DELETE:
    action = 'delete'
    kwargs = {}
  else:
    action = 'undelete'
    kwargs = {'body': {}}
  user, ac = buildGAPIServiceObject(API.ALERTCENTER, _getAdminEmail())
  if not ac:
    return
  try:
    callGAPI(ac.alerts(), action,
             throwReasons=GAPI.ALERT_THROW_REASONS+[GAPI.NOT_FOUND],
             alertId=alertId, **kwargs)
    entityActionPerformed([Ent.ALERT, alertId])
  except GAPI.notFound as e:
    entityActionFailedWarning([Ent.ALERT_ID, alertId], str(e))
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user)

ALERT_TIME_OBJECTS = {'createTime', 'startTime', 'endTime'}

def _showAlert(alert, FJQC, i=0, count=0):
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(alert, timeObjects=ALERT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.ALERT_ID, alert['alertId']], i, count)
  Ind.Increment()
  for field in ['createTime', 'startTime', 'endTime']:
    if field in alert:
      printKeyValueList([field, formatLocalTime(alert[field])])
  for field in ['customerId', 'type', 'source', 'deleted', 'securityInvestigationToolLink']:
    if field in alert:
      printKeyValueList([field, alert[field]])
  if 'data' in alert:
    showJSON('data', alert['data'])
  Ind.Decrement()

# gam info alert <AlertID> [formatjson]
def doInfoAlert():
  alertId = getString(Cmd.OB_ALERT_ID)
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    FJQC.GetFormatJSONQuoteChar(myarg, False)
  user, ac = buildGAPIServiceObject(API.ALERTCENTER, _getAdminEmail())
  if not ac:
    return
  try:
    alert = callGAPI(ac.alerts(), 'get',
                     throwReasons=GAPI.ALERT_THROW_REASONS+[GAPI.NOT_FOUND],
                     alertId=alertId)
    _showAlert(alert, FJQC)
  except GAPI.notFound as e:
    entityActionFailedWarning([Ent.ALERT_ID, alertId], str(e))
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user)

ALERT_ORDERBY_CHOICE_MAP = {
  'createdate': 'create_time',
  'createtime': 'create_time',
  }

# gam show alerts [filter <String>] [orderby createtime [ascending|descending]]
#	[formatjson]
# gam print alerts [todrive <ToDriveAttribute>*] [filter <String>] [orderby createtime [ascending|descending]]
#	[formatjson [quotechar <Character>]]
def doPrintShowAlerts():
  csvPF = CSVPrintFile(['alertId', 'createTime']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  kwargs = {}
  OBY = OrderBy(ALERT_ORDERBY_CHOICE_MAP)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'filter':
      kwargs['filter'] = getString(Cmd.OB_STRING).replace("'", '"')
    elif myarg == 'orderby':
      OBY.GetChoice()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if csvPF and not FJQC.formatJSON:
    csvPF.SetSortTitles(['alertId', 'createTime', 'startTime', 'endTime', 'customerId', 'type', 'source', 'deleted'])
  user, ac = buildGAPIServiceObject(API.ALERTCENTER, _getAdminEmail())
  if not ac:
    return
  try:
    alerts = callGAPIpages(ac.alerts(), 'list', 'alerts',
                           throwReasons=GAPI.ALERT_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID_ARGUMENT],
                           orderBy=OBY.orderBy, **kwargs)
  except (GAPI.badRequest, GAPI.invalidArgument) as e:
    entityActionFailedWarning([Ent.ALERT, None], str(e))
    return
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user)
    return
  if not csvPF:
    jcount = len(alerts)
    if not FJQC.formatJSON:
      performActionNumItems(jcount, Ent.ALERT)
    Ind.Increment()
    j = 0
    for alert in alerts:
      j += 1
      _showAlert(alert, FJQC, j, jcount)
    Ind.Decrement()
  else:
    for alert in alerts:
      row = flattenJSON(alert, timeObjects=ALERT_TIME_OBJECTS)
      if not FJQC.formatJSON:
        csvPF.WriteRowTitles(row)
      elif csvPF.CheckRowTitles(row):
        csvPF.WriteRowNoFilter({'alertId': alert['alertId'],
                                'createTime': formatLocalTime(alert['createTime']),
                                'JSON': json.dumps(cleanJSON(alert, timeObjects=ALERT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
  if csvPF:
    csvPF.writeCSVfile('Alerts')

ALERT_TYPE_MAP = {
  'notuseful': 'NOT_USEFUL',
  'somewhatuseful': 'SOMEWHAT_USEFUL',
  'veryuseful': 'VERY_USEFUL',
  }

# gam create alertfeedback <AlertID> not_useful|somewhat_useful|very_useful
def doCreateAlertFeedback():
  user, ac = buildGAPIServiceObject(API.ALERTCENTER, _getAdminEmail())
  if not ac:
    return
  alertId = getString(Cmd.OB_ALERT_ID)
  body = {'type': getChoice(ALERT_TYPE_MAP, mapChoice=True)}
  try:
    result = callGAPI(ac.alerts().feedback(), 'create',
                      throwReasons=GAPI.ALERT_THROW_REASONS+[GAPI.NOT_FOUND],
                      alertId=alertId, body=body)
    entityActionPerformed([Ent.ALERT, alertId, Ent.ALERT_FEEDBACK_ID, result['feedbackId']])
  except GAPI.notFound as e:
    entityActionFailedWarning([Ent.ALERT_ID, alertId], str(e))
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user)

def _showAlertFeedback(feedback, FJQC, i=0, count=0):
  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(feedback, timeObjects=ALERT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.ALERT_FEEDBACK_ID, feedback['feedbackId']], i, count)
  Ind.Increment()
  for field in ['createTime']:
    if field in feedback:
      printKeyValueList([field, formatLocalTime(feedback[field])])
  for field in ['alertId', 'customerId', 'type', 'email']:
    if field in feedback:
      printKeyValueList([field, feedback[field]])
  Ind.Decrement()

ALERT_FEEDBACK_ORDERBY_CHOICE_MAP = {
  'createdate': 'createTime',
  'createtime': 'createTime',
  }

# gam show alertfeedback [alert <AlertID>] [filter <String>] [orderby createtime [ascending|descending]]
#	[formatjson]
# gam print alertfeedback [todrive <ToDriveAttribute>*] [alert <AlertID>] [filter <String>] [orderby createtime [ascending|descending]]
#	[formatjson [quotechar <Character>]]
def doPrintShowAlertFeedback():
  csvPF = CSVPrintFile(['feedbackId', 'createTime']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  kwargs = {}
  alertId = '-'
  OBY = OrderBy(ALERT_FEEDBACK_ORDERBY_CHOICE_MAP)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'alertid':
      alertId = getString(Cmd.OB_ALERT_ID)
    elif myarg == 'filter':
      kwargs['filter'] = getString(Cmd.OB_STRING).replace("'", '"')
    elif myarg == 'orderby':
      OBY.GetChoice()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if csvPF and not FJQC.formatJSON:
    csvPF.SetSortTitles(['feedbackId', 'createTime', 'alertId', 'customerId', 'type', 'email'])
  user, ac = buildGAPIServiceObject(API.ALERTCENTER, _getAdminEmail())
  if not ac:
    return
  try:
    feedbacks = callGAPIpages(ac.alerts().feedback(), 'list', 'feedback',
                              throwReasons=GAPI.ALERT_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.BAD_REQUEST],
                              alertId=alertId, **kwargs)
  except (GAPI.notFound, GAPI.badRequest) as e:
    entityActionFailedWarning([Ent.ALERT_ID, alertId], str(e))
    return
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user)
    return
  for sk in OBY.items:
    if sk.endswith(' desc'):
      field, _ = sk.split(' ')
      reverse = True
    else:
      field = sk
      reverse = False
    feedbacks = sorted(feedbacks, key=lambda k: k[field], reverse=reverse) #pylint: disable=cell-var-from-loop
  if not csvPF:
    jcount = len(feedbacks)
    if not FJQC.formatJSON:
      performActionNumItems(jcount, Ent.ALERT_FEEDBACK)
    Ind.Increment()
    j = 0
    for feedback in feedbacks:
      j += 1
      _showAlertFeedback(feedback, FJQC, j, jcount)
    Ind.Decrement()
  else:
    for feedback in feedbacks:
      row = flattenJSON(feedback, timeObjects=ALERT_TIME_OBJECTS)
      if not FJQC.formatJSON:
        csvPF.WriteRowTitles(row)
      elif csvPF.CheckRowTitles(row):
        csvPF.WriteRowNoFilter({'feedbackId': feedback['feedbackId'],
                                'createTime': formatLocalTime(feedback['createTime']),
                                'JSON': json.dumps(cleanJSON(feedback, timeObjects=ALERT_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})
  if csvPF:
    csvPF.writeCSVfile('Alert Feedbacks')

def ACLRuleDict(rule):
  if rule['scope']['type'] != 'default':
    return {'Scope': f'{rule["scope"]["type"]}:{rule["scope"]["value"]}', 'Role': rule['role']}
  return {'Scope': f'{rule["scope"]["type"]}', 'Role': rule['role']}

def ACLRuleKeyValueList(rule):
  if rule['scope']['type'] != 'default':
    return ['Scope', f'{rule["scope"]["type"]}:{rule["scope"]["value"]}', 'Role', rule['role']]
  return ['Scope', f'{rule["scope"]["type"]}', 'Role', rule['role']]

def formatACLRule(rule):
  return formatKeyValueList('(', ACLRuleKeyValueList(rule), ')')

def formatACLScopeRole(scope, role):
  if role:
    return formatKeyValueList('(', ['Scope', scope, 'Role', role], ')')
  return formatKeyValueList('(', ['Scope', scope], ')')

def normalizeRuleId(ruleId):
  ruleIdParts = ruleId.split(':', 1)
  if (len(ruleIdParts) == 1) or not ruleIdParts[1]:
    if ruleIdParts[0] == 'default':
      return ruleId
    if ruleIdParts[0] == 'domain':
      return f'domain:{GC.Values[GC.DOMAIN]}'
    return f'user:{normalizeEmailAddressOrUID(ruleIdParts[0], noUid=True)}'
  if ruleIdParts[0] in {'user', 'group'}:
    return f'{ruleIdParts[0]}:{normalizeEmailAddressOrUID(ruleIdParts[1], noUid=True)}'
  return ruleId

def makeRoleRuleIdBody(role, ruleId):
  ruleIdParts = ruleId.split(':', 1)
  if len(ruleIdParts) == 1:
    if ruleIdParts[0] == 'default':
      return {'role': role, 'scope': {'type': ruleIdParts[0]}}
    if ruleIdParts[0] == 'domain':
      return {'role': role, 'scope': {'type': ruleIdParts[0], 'value': GC.Values[GC.DOMAIN]}}
    return {'role': role, 'scope': {'type': 'user', 'value': ruleIdParts[0]}}
  return {'role': role, 'scope': {'type': ruleIdParts[0], 'value': ruleIdParts[1]}}

BUILDING_ADDRESS_FIELD_MAP = {
  'address': 'addressLines',
  'addresslines': 'addressLines',
  'administrativearea': 'administrativeArea',
  'city': 'locality',
  'country': 'regionCode',
  'language': 'languageCode',
  'languagecode': 'languageCode',
  'locality': 'locality',
  'postalcode': 'postalCode',
  'regioncode': 'regionCode',
  'state': 'administrativeArea',
  'sublocality': 'sublocality',
  'zipcode': 'postalCode',
  }

def _getBuildingAttributes(body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'id':
      body['buildingId'] = getString(Cmd.OB_BUILDING_ID, maxLen=100)
    elif myarg == 'name':
      body['buildingName'] = getString(Cmd.OB_STRING, maxLen=100)
    elif myarg in {'lat', 'latitude'}:
      body.setdefault('coordinates', {})
      body['coordinates']['latitude'] = getFloat(minVal=-180.0, maxVal=180.0)
    elif myarg in {'long', 'lng', 'longitude'}:
      body.setdefault('coordinates', {})
      body['coordinates']['longitude'] = getFloat(minVal=-180.0, maxVal=180.0)
    elif myarg == 'description':
      body['description'] = getString(Cmd.OB_STRING)
    elif myarg == 'floors':
      body['floorNames'] = getString(Cmd.OB_STRING).split(',')
    elif myarg in BUILDING_ADDRESS_FIELD_MAP:
      myarg = BUILDING_ADDRESS_FIELD_MAP[myarg]
      body.setdefault('address', {})
      if myarg == 'addressLines':
        body['address'][myarg] = getStringWithCRsNLs().split('\n')
      elif myarg == 'languageCode':
        body['address'][myarg] = getLanguageCode()
      else:
        body['address'][myarg] = getString(Cmd.OB_STRING, minLen=0)
    else:
      unknownArgumentExit()
  return body

# gam create|add building <Name> <BuildingAttribute>*
def doCreateBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getBuildingAttributes({'buildingId': str(uuid.uuid4()),
                                 'buildingName': getString(Cmd.OB_NAME, maxLen=100),
                                 'floorNames': ['1']})
  try:
    callGAPI(cd.resources().buildings(), 'insert',
             throwReasons=[GAPI.DUPLICATE, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body)
    entityActionPerformed([Ent.BUILDING_ID, body['buildingId'], Ent.BUILDING, body['buildingName']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.BUILDING_ID, body['buildingId'], Ent.BUILDING, body['buildingName']])
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.BUILDING_ID, body['buildingId'], Ent.BUILDING, body['buildingName']], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

def _makeBuildingIdNameMap(cd=None):
  GM.Globals[GM.MAKE_BUILDING_ID_NAME_MAP] = False
  if cd is None:
    cd = buildGAPIObject(API.DIRECTORY)
  try:
    buildings = callGAPIpages(cd.resources().buildings(), 'list', 'buildings',
                              throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID],
                              fields='nextPageToken,buildings(buildingId,buildingName)')
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  for building in buildings:
    GM.Globals[GM.MAP_BUILDING_ID_TO_NAME][building['buildingId']] = building['buildingName']
    GM.Globals[GM.MAP_BUILDING_NAME_TO_ID][building['buildingName']] = building['buildingId']

def _getBuildingByNameOrId(cd, minLen=1):
  which_building = getString(Cmd.OB_BUILDING_ID, minLen=minLen)
  if not which_building or (minLen == 0 and which_building in {'id:', 'uid:'}):
    return ''
  cg = UID_PATTERN.match(which_building)
  if cg:
    return cg.group(1)
  if GM.Globals[GM.MAKE_BUILDING_ID_NAME_MAP]:
    _makeBuildingIdNameMap(cd)
# Exact name match, return ID
  if which_building in GM.Globals[GM.MAP_BUILDING_NAME_TO_ID]:
    return GM.Globals[GM.MAP_BUILDING_NAME_TO_ID][which_building]
# No exact name match, check for case insensitive name matches
  which_building_lower = which_building.lower()
  ci_matches = []
  for buildingName, buildingId in iter(GM.Globals[GM.MAP_BUILDING_NAME_TO_ID].items()):
    if buildingName.lower() == which_building_lower:
      ci_matches.append({'buildingName': buildingName, 'buildingId': buildingId})
# One match, return ID
  if len(ci_matches) == 1:
    return ci_matches[0]['buildingId']
# No or multiple name matches, try ID
# Exact ID match, return ID
  if which_building in GM.Globals[GM.MAP_BUILDING_ID_TO_NAME]:
    return which_building
# No exact ID match, check for case insensitive id match
  for buildingId in GM.Globals[GM.MAP_BUILDING_ID_TO_NAME]:
# Match, return ID
    if buildingId.lower() == which_building_lower:
      return buildingId
# Multiple name  matches
  if len(ci_matches) > 1:
    printErrorMessage(1, Msg.MULTIPLE_BUILDINGS_SAME_NAME.format(len(ci_matches), Ent.Plural(Ent.BUILDING)))
    Ind.Increment()
    for building in ci_matches:
      printEntity([Ent.BUILDING, building['buildingName'], Ent.BUILDING_ID, building['buildingId']])
    Ind.Decrement()
    Cmd.Backup()
    usageErrorExit(Msg.PLEASE_SPECIFY_BUILDING_EXACT_CASE_NAME_OR_ID)
# No matches
  entityDoesNotExistExit(Ent.BUILDING, which_building)

def _getBuildingNameById(cd, buildingId):
  if GM.Globals[GM.MAKE_BUILDING_ID_NAME_MAP]:
    _makeBuildingIdNameMap(cd)
  return GM.Globals[GM.MAP_BUILDING_ID_TO_NAME].get(buildingId, 'UNKNOWN')

# gam update building <BuildIngID> <BuildingAttribute>*
def doUpdateBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  body = _getBuildingAttributes({})
  try:
    callGAPI(cd.resources().buildings(), 'patch',
             throwReasons=[GAPI.DUPLICATE, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId, body=body)
    entityActionPerformed([Ent.BUILDING_ID, buildingId])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.BUILDING, body['buildingName']])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.BUILDING_ID, buildingId], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete building <BuildIngID>
def doDeleteBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().buildings(), 'delete',
             throwReasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId)
    entityActionPerformed([Ent.BUILDING_ID, buildingId])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

BUILDING_ADDRESS_PRINT_ORDER = ['addressLines', 'sublocality', 'locality', 'administrativeArea', 'postalCode', 'regionCode', 'languageCode']

def _showBuilding(building, delimiter=',', i=0, count=0):
  if 'buildingName' in building:
    printEntity([Ent.BUILDING, building['buildingName']], i, count)
    Ind.Increment()
    printKeyValueList(['buildingId', f'id:{building["buildingId"]}'])
  else:
    printEntity([Ent.BUILDING_ID, f'id:{building["buildingId"]}'], i, count)
    Ind.Increment()
  if 'description' in building:
    printKeyValueList(['description', building['description']])
  if 'floorNames' in building:
    printKeyValueList(['floorNames', delimiter.join(building['floorNames'])])
  if 'coordinates' in building:
    printKeyValueList(['coordinates', None])
    Ind.Increment()
    printKeyValueList(['latitude', f'{building["coordinates"].get("latitude", 0):4.7f}'])
    printKeyValueList(['longitude', f'{building["coordinates"].get("longitude", 0):4.7f}'])
    Ind.Decrement()
  if 'address' in building:
    printKeyValueList(['address', None])
    Ind.Increment()
    for field in BUILDING_ADDRESS_PRINT_ORDER:
      if field in building['address']:
        if field != 'addressLines':
          printKeyValueList([field, building['address'][field]])
        else:
          printKeyValueList([field, None])
          Ind.Increment()
          for line in building['address'][field]:
            printKeyValueList([line])
          Ind.Decrement()
    Ind.Decrement()
  Ind.Decrement()

# gam info building <BuildingID>
def doInfoBuilding():
  cd = buildGAPIObject(API.DIRECTORY)
  buildingId = _getBuildingByNameOrId(cd)
  checkForExtraneousArguments()
  try:
    building = callGAPI(cd.resources().buildings(), 'get',
                        throwReasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                        customer=GC.Values[GC.CUSTOMER_ID], buildingId=buildingId)
    _showBuilding(building)
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.BUILDING_ID, buildingId)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

BUILDINGS_FIELDS_CHOICE_MAP = {
  'address': 'address',
  'buildingid': 'buildingId',
  'buildingname': 'buildingName',
  'coordinates': 'coordinates',
  'description': 'description',
  'floors': 'floorNames',
  'floornames': 'floorNames',
  'id': 'buildingId',
  'name': 'buildingName',
  }
BUILDINGS_SORT_TITLES = ['buildingId', 'buildingName', 'description', 'floorNames']

# gam print buildings [todrive <ToDriveAttribute>*] [allfields|<BuildingFildName>*|(fields <BuildingFieldNameList>)]
#	[delimiter <Character>]
# gam show buildings [allfields|<BuildingFildName>*|(fields <BuildingFieldNameList>)]
def doPrintShowBuildings():
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['buildingId'], BUILDINGS_SORT_TITLES) if Act.csvFormat() else None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER] if csvPF else ','
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif csvPF and myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'allfields':
      fieldsList = []
    elif getFieldsList(myarg, BUILDINGS_FIELDS_CHOICE_MAP, fieldsList, initialField='buildingId'):
      pass
    else:
      unknownArgumentExit()
  fields = getItemFieldsFromFieldsList('buildings', fieldsList)
  try:
    buildings = callGAPIpages(cd.resources().buildings(), 'list', 'buildings',
                              throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                              customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if not csvPF:
    jcount = len(buildings)
    performActionNumItems(jcount, Ent.BUILDING)
    Ind.Increment()
    j = 0
    for building in buildings:
      j += 1
      _showBuilding(building, delimiter, j, jcount)
    Ind.Decrement()
  else:
    for building in buildings:
      if 'buildingId' in building:
        building['buildingId'] = f'id:{building["buildingId"]}'
      if 'floorNames' in building:
        building['floorNames'] = delimiter.join(building['floorNames'])
      if 'address' in building and 'addressLines' in building['address']:
        building['address']['addressLines'] = '\n'.join(building['address']['addressLines'])
      if 'coordinates' in building:
        building['coordinates']['latitude'] = f'{building["coordinates"].get("latitude", 0):4.7f}'
        building['coordinates']['longitude'] = f'{building["coordinates"].get("longitude", 0):4.7f}'
      csvPF.WriteRowTitles(flattenJSON(building))
  if csvPF:
    csvPF.writeCSVfile('Buildings')

def _getFeatureAttributes(body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return body

# gam create|add feature <Name>
def doCreateFeature():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getFeatureAttributes({})
  try:
    callGAPI(cd.resources().features(), 'insert',
             throwReasons=[GAPI.DUPLICATE, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body)
    entityActionPerformed([Ent.BUILDING, body['name']])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.FEATURE, body['name']])
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.FEATURE, body['name']], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

#gam update feature <Name> name <Name>
def doUpdateFeature():
  # update does not work for name and name is only field to be updated
  # if additional writable fields are added to feature in the future
  # we'll add support for update as well as rename
  cd = buildGAPIObject(API.DIRECTORY)
  oldName = getString(Cmd.OB_STRING)
  getChoice(['name'])
  body = {'newName': getString(Cmd.OB_STRING)}
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().features(), 'rename',
             throwReasons=[GAPI.DUPLICATE, GAPI.RESOURCE_NOT_FOUND, GAPI.INVALID_INPUT, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], oldName=oldName, body=body)
    entityActionPerformed([Ent.FEATURE, oldName])
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.FEATURE, body['newName']])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.FEATURE, oldName)
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.FEATURE, oldName], str(e))
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

# gam delete feature <eName>
def doDeleteFeature():
  cd = buildGAPIObject(API.DIRECTORY)
  featureKey = getString(Cmd.OB_NAME)
  checkForExtraneousArguments()
  try:
    callGAPI(cd.resources().features(), 'delete',
             throwReasons=[GAPI.RESOURCE_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], featureKey=featureKey)
    entityActionPerformed([Ent.FEATURE, featureKey])
  except GAPI.resourceNotFound:
    entityUnknownWarning(Ent.FEATURE, featureKey)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)

FEATURE_FIELDS_CHOICE_MAP = {
  'name': 'name',
  }

# gam print features [todrive <ToDriveAttribute>*]
# gam show features
def doPrintShowFeatures():
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile('name') if Act.csvFormat() else None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'allfields':
      fieldsList = []
    elif getFieldsList(myarg, FEATURE_FIELDS_CHOICE_MAP, fieldsList):
      pass
    else:
      unknownArgumentExit()
  fields = getItemFieldsFromFieldsList('features', fieldsList)
  try:
    features = callGAPIpages(cd.resources().features(), 'list', 'features',
                             throwReasons=[GAPI.BAD_REQUEST, GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                             customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
  except (GAPI.badRequest, GAPI.notFound, GAPI.forbidden):
    accessErrorExit(cd)
  if not csvPF:
    jcount = len(features)
    performActionNumItems(jcount, Ent.FEATURE)
    Ind.Increment()
    j = 0
    for feature in features:
      j += 1
      printEntity([Ent.FEATURE, feature['name']], j, jcount)
  else:
    for feature in features:
      csvPF.WriteRowTitles(flattenJSON(feature))
  if csvPF:
    csvPF.writeCSVfile('Features')

RESOURCE_CATEGORY_MAP = {
  'conference': 'CONFERENCE_ROOM',
  'conferenceroom': 'CONFERENCE_ROOM',
  'room': 'CONFERENCE_ROOM',
  'other': 'OTHER',
  'categoryunknown': 'CATEGORY_UNKNOWN',
  'unknown': 'CATEGORY_UNKNOWN',
  }

def _getResourceCalendarAttributes(cd, body):
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'name', 'resourcename'}:
      body['resourceName'] = getString(Cmd.OB_STRING)
    elif myarg in {'description', 'resourcedescription'}:
      body['resourceDescription'] = getStringWithCRsNLs()
    elif myarg in {'type', 'resourcetype'}:
      body['resourceType'] = getString(Cmd.OB_STRING)
    elif myarg in {'building', 'buildingid'}:
      body['buildingId'] = _getBuildingByNameOrId(cd, minLen=0)
    elif myarg == 'capacity':
      body['capacity'] = getInteger(minVal=0)
    elif myarg in {'feature', 'features', 'featureinstances'}:
      features = getString(Cmd.OB_STRING).split(',')
      body['featureInstances'] = []
      for feature in features:
        body['featureInstances'].append({'feature': {'name': feature}})
    elif myarg in {'floor', 'floorname'}:
      body['floorName'] = getString(Cmd.OB_STRING)
    elif myarg == 'floorsection':
      body['floorSection'] = getString(Cmd.OB_STRING)
    elif myarg in {'category', 'resourcecategory'}:
      body['resourceCategory'] = getChoice(RESOURCE_CATEGORY_MAP, mapChoice=True)
    elif myarg in {'userdescription', 'uservisibledescription'}:
      body['userVisibleDescription'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  return body

# gam create|add resource <ResourceID> <Name> <ResourceAttribute>*
def doCreateResourceCalendar():
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getResourceCalendarAttributes(cd, {'resourceId': getString(Cmd.OB_RESOURCE_ID), 'resourceName': getString(Cmd.OB_NAME)})
  try:
    callGAPI(cd.resources().calendars(), 'insert',
             throwReasons=[GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.REQUIRED, GAPI.DUPLICATE, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
             customer=GC.Values[GC.CUSTOMER_ID], body=body, fields='')
    entityActionPerformed([Ent.RESOURCE_CALENDAR, body['resourceId']])
  except (GAPI.invalid, GAPI.invalidInput, GAPI.required) as e:
    entityActionFailedWarning([Ent.RESOURCE_CALENDAR, body['resourceId']], str(e))
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.RESOURCE_CALENDAR, body['resourceId']])
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)

def _doUpdateResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  body = _getResourceCalendarAttributes(cd, {})
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), 'patch',
               throwReasons=[GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.REQUIRED, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, body=body, fields='')
      entityActionPerformed([Ent.RESOURCE_CALENDAR, resourceId], i, count)
    except (GAPI.invalid, GAPI.invalidInput, GAPI.required)  as e:
      entityActionFailedWarning([Ent.RESOURCE_CALENDAR, resourceId], str(e), i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam update resources <ResourceEntity> <ResourceAttribute>*
def doUpdateResourceCalendars():
  _doUpdateResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam update resource <ResourceID> <ResourceAttribute>*
def doUpdateResourceCalendar():
  _doUpdateResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

def _doDeleteResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      callGAPI(cd.resources().calendars(), 'delete',
               throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId)
      entityActionPerformed([Ent.RESOURCE_CALENDAR, resourceId], i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam delete resources <ResourceEntity>
def doDeleteResourceCalendars():
  _doDeleteResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam delete resource <ResourceID>
def doDeleteResourceCalendar():
  _doDeleteResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

def _getResourceACLsCalSettings(cal, resource, getCalSettings, getCalPermissions, i, count):
  calId = resource['resourceEmail']
  try:
    if getCalPermissions:
      acls = callGAPIpages(cal.acl(), 'list', 'items',
                           throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.AUTH_ERROR],
                           calendarId=calId, fields='nextPageToken,items(id,role,scope)')
    else:
      acls = {}
    if getCalSettings:
      settings = callGAPI(cal.calendars(), 'get',
                          throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
                          calendarId=calId)
      settings.pop('etag', None)
      settings.pop('kind', None)
      resource.update({'calendar': settings})
    return (True, acls)
  except (GAPI.forbidden, GAPI.serviceNotAvailable, GAPI.authError, GAPI.notACalendarUser) as e:
    entityActionFailedWarning([Ent.RESOURCE_CALENDAR, calId], str(e), i, count)
  except GAPI.notFound:
    entityUnknownWarning(Ent.RESOURCE_CALENDAR, calId, i, count)
  return (False, None)

RESOURCE_DFLT_FIELDS = ['resourceId', 'resourceName', 'resourceEmail', 'resourceDescription', 'resourceType']
RESOURCE_ADDTL_FIELDS = [
  'buildingId',	# buildingId must be first element
  'capacity',
  'featureInstances',
  'floorName',
  'floorSection',
  'generatedResourceName',
  'resourceCategory',
  'userVisibleDescription',
  ]
RESOURCE_ALL_FIELDS = RESOURCE_DFLT_FIELDS+RESOURCE_ADDTL_FIELDS
RESOURCE_FIELDS_WITH_CRS_NLS = {'resourceDescription'}

def _showResource(cd, resource, i, count, FJQC, acls=None):

  def _showResourceField(title, resource, field):
    if field in resource:
      if field not in RESOURCE_FIELDS_WITH_CRS_NLS:
        printKeyValueList([title, resource[field]])
      else:
        printKeyValueWithCRsNLs(title, resource[field])

  if 'buildingId' in resource:
    resource['buildingName'] = _getBuildingNameById(cd, resource['buildingId'])
    resource['buildingId'] = f'id:{resource["buildingId"]}'
  if FJQC.formatJSON:
    if acls:
      resource['acls'] = [{'id': rule['id'], 'role': rule['role']} for rule in acls]
    printLine(json.dumps(cleanJSON(resource), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.RESOURCE_ID, resource['resourceId']], i, count)
  Ind.Increment()
  _showResourceField('Name', resource, 'resourceName')
  _showResourceField('Email', resource, 'resourceEmail')
  _showResourceField('Type', resource, 'resourceType')
  _showResourceField('Description', resource, 'resourceDescription')
  if 'featureInstances' in resource:
    resource['featureInstances'] = ', '.join([a_feature['feature']['name'] for a_feature in resource.pop('featureInstances')])
  if 'buildingId' in resource:
    _showResourceField('buildingId', resource, 'buildingId')
    _showResourceField('buildingName', resource, 'buildingName')
  for field in RESOURCE_ADDTL_FIELDS[1:]:
    _showResourceField(field, resource, field)
  calendar = resource.get('calendar')
  if calendar:
    _showCalendarSettings(calendar, 0, 0)
  if acls:
    j = 0
    jcount = len(acls)
    printEntitiesCount(Ent.CALENDAR_ACL, acls)
    Ind.Increment()
    for rule in acls:
      j += 1
      printKeyValueListWithCount(ACLRuleKeyValueList(rule), j, jcount)
    Ind.Decrement()
  Ind.Decrement()

def _doInfoResourceCalendars(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  getCalSettings = getCalPermissions = False
  FJQC = FormatJSONQuoteChar()
  acls = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
      getCalPermissions = True
    elif myarg == Cmd.ARG_CALENDAR:
      getCalSettings = True
    else:
      FJQC.GetFormatJSON(myarg)
  if getCalSettings or getCalPermissions:
    cal = buildGAPIObject(API.CALENDAR)
  fields = ','.join(RESOURCE_ALL_FIELDS)
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    try:
      resource = callGAPI(cd.resources().calendars(), 'get',
                          throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, fields=fields)
      if getCalSettings or getCalPermissions:
        status, acls = _getResourceACLsCalSettings(cal, resource, getCalSettings, getCalPermissions, i, count)
        if not status:
          continue
      _showResource(cd, resource, i, count, FJQC, acls)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)

# gam info resources <ResourceEntity> [acls] [calendar] [formatjson]
def doInfoResourceCalendars():
  _doInfoResourceCalendars(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# gam info resource <ResourceID> [acls] [calendar] [formatjson]
def doInfoResourceCalendar():
  _doInfoResourceCalendars(getStringReturnInList(Cmd.OB_RESOURCE_ID))

RESOURCE_FIELDS_CHOICE_MAP = {
  'description': 'resourceDescription',
  'building': 'buildingId',
  'buildingid': 'buildingId',
  'capacity': 'capacity',
  'category': 'resourceCategory',
  'email': 'resourceEmail',
  'feature': 'featureInstances',
  'features': 'featureInstances',
  'featureinstances': 'featureInstances',
  'floor': 'floorName',
  'floorname': 'floorName',
  'floorsection': 'floorSection',
  'generatedresourcename': 'generatedResourceName',
  'id': 'resourceId',
  'name': 'resourceName',
  'resourcecategory': 'resourceCategory',
  'resourcedescription': 'resourceDescription',
  'resourceemail': 'resourceEmail',
  'resourceid': 'resourceId',
  'resourcename': 'resourceName',
  'resourcetype': 'resourceType',
  'type': 'resourceType',
  'userdescription': 'userVisibleDescription',
  'uservisibledescription': 'userVisibleDescription',
  }

# gam show resources [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)]
#	[query <String>]
#	[acls] [calendar] [convertcrnl] [formatjson]
# gam print resources [todrive <ToDriveAttribute>*] [allfields|<ResourceFieldName>*|(fields <ResourceFieldNameList>)]
#	[query <String>]
#	[acls] [calendar] [convertcrnl] [formatjson [quotechar <Character>]]
def doPrintShowResourceCalendars():
  cd = buildGAPIObject(API.DIRECTORY)
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  getCalSettings = getCalPermissions = False
  acls = query = None
  fieldsList = []
  csvPF = CSVPrintFile() if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'query':
      query = getString(Cmd.OB_QUERY)
    elif myarg == 'allfields':
      fieldsList = RESOURCE_ALL_FIELDS[:]
    elif myarg in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
      getCalPermissions = True
    elif myarg == Cmd.ARG_CALENDAR:
      getCalSettings = True
    elif myarg in RESOURCE_FIELDS_CHOICE_MAP:
      if not fieldsList:
        fieldsList = ['resourceId']
      fieldsList.append(RESOURCE_FIELDS_CHOICE_MAP[myarg])
    elif myarg == 'fields':
      if not fieldsList:
        fieldsList = ['resourceId']
      for field in _getFieldsList():
        if field in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
          getCalPermissions = True
        elif field == Cmd.ARG_CALENDAR:
          getCalSettings = True
        elif field in RESOURCE_FIELDS_CHOICE_MAP:
          fieldsList.append(RESOURCE_FIELDS_CHOICE_MAP[field])
        else:
          invalidChoiceExit(field, RESOURCE_FIELDS_CHOICE_MAP, True)
    elif myarg in {'convertcrnl', 'converttextnl'}:
      convertCRNL = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if not fieldsList:
    fieldsList = RESOURCE_DFLT_FIELDS[:]
  if getCalSettings or getCalPermissions:
    cal = buildGAPIObject(API.CALENDAR)
    fields = getItemFieldsFromFieldsList('items', fieldsList+['resourceEmail'])
  else:
    fields = getItemFieldsFromFieldsList('items', fieldsList)
  if 'buildingId' in fieldsList:
    fieldsList.append('buildingName')
  if csvPF:
    if not FJQC.formatJSON:
      csvPF.AddTitles(fieldsList)
      csvPF.SetSortTitles(RESOURCE_DFLT_FIELDS)
    else:
      if 'resourceName' in fieldsList:
        sortTitles = ['resourceId', 'resourceName', 'JSON']
      else:
        sortTitles = ['resourceId', 'JSON']
      csvPF.AddTitles(sortTitles)
  printGettingAllAccountEntities(Ent.RESOURCE_CALENDAR)
  try:
    resources = callGAPIpages(cd.resources().calendars(), 'list', 'items',
                              pageMessage=getPageMessage(showFirstLastItems=True), messageAttribute='resourceName',
                              throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_INPUT],
                              query=query, customer=GC.Values[GC.CUSTOMER_ID], fields=fields)
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  except GAPI.invalidInput as e:
    entityActionFailedWarning([Ent.RESOURCE_CALENDAR, ''], str(e))
    return
  i = 0
  count = len(resources)
  for resource in resources:
    i += 1
    if getCalSettings or getCalPermissions:
      status, acls = _getResourceACLsCalSettings(cal, resource, getCalSettings, getCalPermissions, i, count)
      if not status:
        continue
    if not csvPF:
      _showResource(cd, resource, i, count, FJQC, acls)
    else:
      if 'buildingId' in resource:
        resource['buildingName'] = _getBuildingNameById(cd, resource['buildingId'])
        resource['buildingId'] = f'id:{resource["buildingId"]}'
      if not FJQC.formatJSON:
        if 'featureInstances' in resource:
          resource['featureInstances'] = ', '.join([a_feature['feature']['name'] for a_feature in resource.pop('featureInstances')])
        row = {}
        for field in fieldsList:
          if convertCRNL and field in RESOURCE_FIELDS_WITH_CRS_NLS:
            row[field] = escapeCRsNLs(resource.get(field, ''))
          else:
            row[field] = resource.get(field, '')
        if getCalSettings and 'calendar' in resource:
          flattenJSON(resource['calendar'], flattened=row)
        if getCalPermissions:
          for rule in acls:
            csvPF.WriteRowTitles(flattenJSON(rule, flattened=row.copy()))
        else:
          csvPF.WriteRowTitles(row)
      else:
        if getCalPermissions:
          resource['acls'] = [{'id': rule['id'], 'role': rule['role']} for rule in acls]
        row = {'resourceId': resource['resourceId'], 'JSON': json.dumps(cleanJSON(resource), ensure_ascii=False, sort_keys=True)}
        if 'resourceName' in resource:
          row['resourceName'] = resource['resourceName']
        csvPF.WriteRow(row)
  if csvPF:
    csvPF.writeCSVfile('Resources')

# Calendar commands utilities
def normalizeCalendarId(calId, user):
  if not user or calId.lower() != 'primary':
    return convertUIDtoEmailAddress(calId, emailTypes=['user', 'resource'])
  return user

def checkCalendarExists(cal, calId, showMessage=False):
  if not cal:
    cal = buildGAPIObject(API.CALENDAR)
  try:
    return callGAPI(cal.calendars(), 'get',
                    throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
                    calendarId=calId, fields='id')['id']
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.notACalendarUser, GAPI.notFound) as e:
    if showMessage:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e))
    return None

def validateCalendar(calId, i=0, count=0):
  cal = None
  if not calId.endswith('.calendar.google.com'):
    calId, cal = buildGAPIServiceObject(API.CALENDAR, calId, i, count, displayError=False)
  if not cal:
    cal = buildGAPIObject(API.CALENDAR)
  try:
    callGAPI(cal.calendars(), 'get',
             throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
             calendarId=calId, fields='')
    return (calId, cal)
  except (GAPI.notACalendarUser, GAPI.notFound) as e:
    entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
  return (calId, None)

def getNormalizedCalIdCal(cal, calId, user, i=0, count=0):
  if not cal:
    return validateCalendar(calId, i, count)
  return (normalizeCalendarId(calId, user), cal)

CALENDAR_ACL_ROLES_MAP = {
  'editor': 'writer',
  'freebusy': 'freeBusyReader',
  'freebusyreader': 'freeBusyReader',
  'owner': 'owner',
  'read': 'reader',
  'reader': 'reader',
  'writer': 'writer',
  'none': 'none',
  }

ACL_SCOPE_CHOICES = ['default', 'user', 'group', 'domain'] # default must be first element

def getACLScope():
  scopeType, scopeValue = getChoiceAndValue(Cmd.OB_ACL_SCOPE, ACL_SCOPE_CHOICES[1:], ':')
  if scopeType:
    if scopeType != 'domain':
      scopeValue = normalizeEmailAddressOrUID(scopeValue, noUid=True)
    else:
      scopeValue = scopeValue.lower()
    return (scopeType, scopeValue)
  scopeType = getChoice(ACL_SCOPE_CHOICES, defaultChoice='user')
  if scopeType == 'domain':
    entity = getString(Cmd.OB_DOMAIN_NAME, optional=True)
    if entity:
      scopeValue = entity.lower()
    else:
      scopeValue = GC.Values[GC.DOMAIN]
  elif scopeType != 'default':
    scopeValue = getEmailAddress(noUid=True)
  else:
    scopeValue = None
  return (scopeType, scopeValue)

def getCalendarACLScope():
  scopeType, scopeValue = getACLScope()
  if scopeType != 'default':
    return {'list': [f'{scopeType}:{scopeValue}'], 'dict': None}
  return {'list': [scopeType], 'dict': None}

def getCalendarSiteACLScopeEntity():
  ACLScopeEntity = {'list': getEntityList(Cmd.OB_ACL_SCOPE_ENTITY), 'dict': None}
  if isinstance(ACLScopeEntity['list'], dict):
    ACLScopeEntity['dict'] = ACLScopeEntity['list']
  return ACLScopeEntity

def getCalendarACLSendNotifications():
  return getBoolean() if checkArgumentPresent('sendnotifications') else True

def getCalendarCreateUpdateACLsOptions(getScopeEntity):
  role = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity() if getScopeEntity else getCalendarACLScope()
  sendNotifications = getCalendarACLSendNotifications()
  checkForExtraneousArguments()
  return (role, ACLScopeEntity, sendNotifications)

def getCalendarDeleteACLsOptions(getScopeEntity):
  rolesMap = CALENDAR_ACL_ROLES_MAP.copy()
  rolesMap['id'] = 'id'
  role = getChoice(rolesMap, defaultChoice=None, mapChoice=True)
  ACLScopeEntity = getCalendarSiteACLScopeEntity() if getScopeEntity else getCalendarACLScope()
  checkForExtraneousArguments()
  return (role, ACLScopeEntity)

def _normalizeCalIdGetRuleIds(origUser, user, origCal, calId, j, jcount, ACLScopeEntity, showAction=True):
  if ACLScopeEntity['dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity['dict'][calId]
      else:
        ruleIds = ACLScopeEntity['dict'][origUser][calId]
    else:
      ruleIds = ACLScopeEntity['dict'][calId]
  else:
    ruleIds = ACLScopeEntity['list']
  calId, cal = getNormalizedCalIdCal(origCal, calId, user, j, jcount)
  if not cal:
    return (calId, cal, None, 0)
  kcount = len(ruleIds)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if showAction:
    entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.CALENDAR_ACL, j, jcount)
  return (calId, cal, ruleIds, kcount)

def _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, role, ruleId, sendNotifications):
  result = True
  if function == 'insert':
    kwargs = {'body': makeRoleRuleIdBody(role, ruleId), 'fields': '', 'sendNotifications': sendNotifications}
  elif function == 'patch':
    kwargs = {'ruleId': ruleId, 'body': {'role': role}, 'fields': '', 'sendNotifications': sendNotifications}
  else: # elif function == 'delete':
    kwargs = {'ruleId': ruleId}
  try:
    callGAPI(cal.acl(), function,
             throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.INVALID_SCOPE_VALUE,
                           GAPI.ILLEGAL_ACCESS_ROLE_FOR_DEFAULT, GAPI.CANNOT_CHANGE_OWN_ACL, GAPI.CANNOT_CHANGE_OWNER_ACL,
                           GAPI.FORBIDDEN, GAPI.AUTH_ERROR, GAPI.CONDITION_NOT_MET],
             calendarId=calId, **kwargs)
    entityActionPerformed([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], k, kcount)
  except GAPI.notFound as e:
    if not checkCalendarExists(cal, calId):
      entityUnknownWarning(entityType, calId, j, jcount)
      result = False
    else:
      entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
  except (GAPI.invalid, GAPI.invalidParameter, GAPI.invalidScopeValue,
          GAPI.illegalAccessRoleForDefault, GAPI.cannotChangeOwnAcl, GAPI.cannotChangeOwnerAcl,
          GAPI.forbidden, GAPI.authError, GAPI.conditionNotMet) as e:
    entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
  return result

def _createCalendarACLs(cal, entityType, calId, j, jcount, role, ruleIds, kcount, sendNotifications):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, 'insert', entityType, calId, j, jcount, k, kcount, role, ruleId, sendNotifications):
      break
  Ind.Decrement()

def _doCalendarsCreateACLs(origUser, user, origCal, calIds, count, role, ACLScopeEntity, sendNotifications):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, origCal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _createCalendarACLs(cal, Ent.CALENDAR, calId, i, count, role, ruleIds, jcount, sendNotifications)

# gam calendar <CalendarEntity> create|add <CalendarACLRole> <CalendarACLScope> [sendnotifications <Boolean>]
def doCalendarsCreateACL(calIds):
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(False)
  _doCalendarsCreateACLs(None, None, None, calIds, len(calIds), role, ACLScopeEntity, sendNotifications)

# gam calendars <CalendarEntity> create|add acls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def doCalendarsCreateACLs(calIds):
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  _doCalendarsCreateACLs(None, None, None, calIds, len(calIds), role, ACLScopeEntity, sendNotifications)

def _updateDeleteCalendarACLs(cal, function, entityType, calId, j, jcount, role, ruleIds, kcount, sendNotifications):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    if not _processCalendarACLs(cal, function, entityType, calId, j, jcount, k, kcount, role, ruleId, sendNotifications):
      break
  Ind.Decrement()

def _doUpdateDeleteCalendarACLs(origUser, user, origCal, function, calIds, count, ACLScopeEntity, role, sendNotifications):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, origCal, calId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Ent.CALENDAR, calId, i, count, role, ruleIds, jcount, sendNotifications)

# gam calendar <CalendarEntity> update <CalendarACLRole> <CalendarACLScope> [sendnotifications <Boolean>]
def doCalendarsUpdateACL(calIds):
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(False)
  _doUpdateDeleteCalendarACLs(None, None, None, 'patch', calIds, len(calIds), ACLScopeEntity, role, sendNotifications)

# gam calendars <CalendarEntity> update acls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def doCalendarsUpdateACLs(calIds):
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  _doUpdateDeleteCalendarACLs(None, None, None, 'patch', calIds, len(calIds), ACLScopeEntity, role, sendNotifications)

# gam calendar <CalendarEntity> del|delete [<CalendarACLRole>] <CalendarACLScope>
def doCalendarsDeleteACL(calIds):
  role, ACLScopeEntity = getCalendarDeleteACLsOptions(False)
  _doUpdateDeleteCalendarACLs(None, None, None, 'delete', calIds, len(calIds), ACLScopeEntity, role, False)

# gam calendars <CalendarEntity> del|delete acls <CalendarACLScopeEntity>
def doCalendarsDeleteACLs(calIds):
  role, ACLScopeEntity = getCalendarDeleteACLsOptions(True)
  _doUpdateDeleteCalendarACLs(None, None, None, 'delete', calIds, len(calIds), ACLScopeEntity, role, False)

def _showCalendarACL(user, entityType, calId, acl, k, kcount, FJQC):
  if FJQC.formatJSON:
    if entityType == Ent.CALENDAR:
      if user:
        printLine(json.dumps(cleanJSON({'primaryEmail': user, 'calendarId': calId, 'acl': acl}),
                             ensure_ascii=False, sort_keys=True))
      else:
        printLine(json.dumps(cleanJSON({'calendarId': calId, 'acl': acl}),
                             ensure_ascii=False, sort_keys=True))
    else:
      printLine(json.dumps(cleanJSON({'resourceId': user, 'resourceEmail': calId, 'acl': acl}),
                           ensure_ascii=False, sort_keys=True))
  else:
    printKeyValueListWithCount(ACLRuleKeyValueList(acl), k, kcount)

def _infoCalendarACLs(cal, user, entityType, calId, j, jcount, ruleIds, kcount, FJQC):
  Ind.Increment()
  k = 0
  for ruleId in ruleIds:
    k += 1
    ruleId = normalizeRuleId(ruleId)
    try:
      result = callGAPI(cal.acl(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_SCOPE_VALUE, GAPI.FORBIDDEN, GAPI.AUTH_ERROR],
                        calendarId=calId, ruleId=ruleId, fields='id,role,scope')
      _showCalendarACL(user, entityType, calId, result, k, kcount, FJQC)
    except (GAPI.notFound, GAPI.invalid) as e:
      if not checkCalendarExists(cal, calId):
        entityUnknownWarning(entityType, calId, j, jcount)
        break
      entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], str(e), k, kcount)
    except (GAPI.invalidScopeValue, GAPI.forbidden, GAPI.authError) as e:
      entityActionFailedWarning([entityType, calId, Ent.CALENDAR_ACL, formatACLScopeRole(ruleId, None)], str(e), k, kcount)
  Ind.Decrement()

def _doInfoCalendarACLs(origUser, user, origCal, calIds, count, ACLScopeEntity, FJQC):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, ruleIds, jcount = _normalizeCalIdGetRuleIds(origUser, user, origCal, calId, i, count, ACLScopeEntity, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, user, Ent.CALENDAR, calId, i, count, ruleIds, jcount, FJQC)

def _getCalendarInfoACLOptions():
  return FormatJSONQuoteChar(formatJSONOnly=True)

# gam calendars <CalendarEntity> info acl|acls <CalendarACLScopeEntity> [formatjson]
def doCalendarsInfoACLs(calIds):
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  FJQC = _getCalendarInfoACLOptions()
  _doInfoCalendarACLs(None, None, None, calIds, len(calIds), ACLScopeEntity, FJQC)

def _printShowCalendarACLs(cal, user, entityType, calId, i, count, csvPF, FJQC):
  if csvPF:
    printGettingEntityItemForWhom(Ent.CALENDAR_ACL, calId, i, count)
  try:
    acls = callGAPIpages(cal.acl(), 'list', 'items',
                         throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.AUTH_ERROR],
                         calendarId=calId, fields='nextPageToken,items(id,role,scope)')
  except (GAPI.forbidden, GAPI.authError) as e:
    entityActionFailedWarning([entityType, calId], str(e), i, count)
    return
  except GAPI.notFound:
    entityUnknownWarning(entityType, calId, i, count)
    return
  jcount = len(acls)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if not csvPF:
    if not FJQC.formatJSON:
      entityPerformActionNumItems([entityType, calId], jcount, Ent.CALENDAR_ACL, i, count)
    Ind.Increment()
    j = 0
    for rule in acls:
      j += 1
      _showCalendarACL(user, entityType, calId, rule, j, jcount, FJQC)
    Ind.Decrement()
  else:
    if entityType == Ent.CALENDAR:
      if acls:
        for rule in acls:
          row = {'calendarId': calId}
          if user:
            row['primaryEmail'] = user
          flattenJSON(rule, flattened=row)
          if not FJQC.formatJSON:
            csvPF.WriteRowTitles(row)
          elif csvPF.CheckRowTitles(row):
            row = {'calendarId': calId, 'JSON': json.dumps(cleanJSON(rule),
                                                           ensure_ascii=False, sort_keys=False)}
            if user:
              row['primaryEmail'] = user
            csvPF.WriteRowNoFilter(row)
      elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
        csvPF.WriteRowNoFilter({'calendarId': calId, 'primaryEmail': user})
    else: # Ent.RESOURCE_CALENDAR
      for rule in acls:
        row = flattenJSON(rule, flattened={'resourceId': user, 'resourceEmail': calId})
        if not FJQC.formatJSON:
          csvPF.WriteRowTitles(row)
        elif csvPF.CheckRowTitles(row):
          csvPF.WriteRowNoFilter({'resourceId': user, 'resourceEmail': calId,
                                  'JSON': json.dumps(cleanJSON(rule), ensure_ascii=False, sort_keys=False)})

def _getCalendarPrintShowACLOptions(entityType, titles):
  csvPF = CSVPrintFile(titles, 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  return (csvPF, FJQC)

# gam calendars <CalendarEntity> print acls [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam calendars <CalendarEntity> show acls [formatjson]
# gam calendar <CalendarEntity> showacl [formatjson]
def doCalendarsPrintShowACLs(calIds):
  csvPF, FJQC = _getCalendarPrintShowACLOptions(Ent.CALENDAR, ['calendarId'])
  count = len(calIds)
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = validateCalendar(calId, i, count)
    if not cal:
      continue
    _printShowCalendarACLs(cal, None, Ent.CALENDAR, calId, i, count, csvPF, FJQC)
  if csvPF:
    csvPF.writeCSVfile('Calendar ACLs')

LIST_EVENTS_DISPLAY_PROPERTIES = {
  'alwaysincludeemail': ('alwaysIncludeEmail', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'icaluid': ('iCalUID', {GC.VAR_TYPE: GC.TYPE_STRING}),
  'maxattendees': ('maxAttendees', {GC.VAR_TYPE: GC.TYPE_INTEGER, GC.VAR_LIMITS: (1, None)}),
  'orderby': ('orderBy', {GC.VAR_TYPE: GC.TYPE_CHOICE, 'choices': {'starttime': 'startTime', 'updated': 'updated'}}),
  'timezone': ('timeZone', {GC.VAR_TYPE: GC.TYPE_STRING}),
  }

LIST_EVENTS_SELECT_PROPERTIES = {
  'after': ('timeMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'before': ('timeMax', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'endtime': ('timeMax', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'includedeleted': ('showDeleted', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'includehidden': ('showHiddenInvitations', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'privateextendedproperty': ('privateExtendedProperty', {GC.VAR_TYPE: GC.TYPE_STRING}),
  'sharedextendedproperty': ('sharedExtendedProperty', {GC.VAR_TYPE: GC.TYPE_STRING}),
  'showdeletedevents': ('showDeleted', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'showhiddeninvitations': ('showHiddenInvitations', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'singleevents': ('singleEvents', {GC.VAR_TYPE: GC.TYPE_BOOLEAN}),
  'starttime': ('timeMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'timemax': ('timeMax', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'timemin': ('timeMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'updated': ('updatedMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  'updatedmin': ('updatedMin', {GC.VAR_TYPE: GC.TYPE_DATETIME}),
  }

LIST_EVENTS_MATCH_FIELDS = {
  'attendees': ['attendees', 'email'],
  'attendeespattern': ['attendees', 'match'],
  'attendeesstatus': ['attendees', 'status'],
  'description': ['description'],
  'hangoutlink': ['hangoutLink'],
  'location': ['location'],
  'summary': ['summary'],
  'creatorname': ['creator', 'displayName'],
  'creatoremail': ['creator', 'email'],
  'organizername': ['organizer', 'displayName'],
  'organizeremail': ['organizer', 'email'],
  'status': ['status'],
  'transparency': ['transparency'],
  'visibility': ['visibility'],
  }

def _getCalendarListEventsProperty(myarg, attributes, kwargs):
  attrName, attribute = attributes.get(myarg, (None, None))
  if not attrName:
    return False
  attrType = attribute[GC.VAR_TYPE]
  if attrType == GC.TYPE_BOOLEAN:
    kwargs[attrName] = True
  elif attrType == GC.TYPE_STRING:
    kwargs[attrName] = getString(Cmd.OB_STRING)
  elif attrType == GC.TYPE_CHOICE:
    kwargs[attrName] = getChoice(attribute['choices'], mapChoice=True)
  elif attrType == GC.TYPE_DATETIME:
    kwargs[attrName] = getTimeOrDeltaFromNow()
  else: # GC.TYPE_INTEGER
    minVal, maxVal = attribute[GC.VAR_LIMITS]
    kwargs[attrName] = getInteger(minVal=minVal, maxVal=maxVal)
  return True

def _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
  return _getCalendarListEventsProperty(myarg, LIST_EVENTS_DISPLAY_PROPERTIES, calendarEventEntity['kwargs'])

def initCalendarEventEntity():
  return {'list': [], 'queries': [], 'kwargs': {}, 'dict': None,
          'matches': [], 'maxinstances': -1, 'countsOnly': False, 'showDayOfWeek': False}

def getCalendarEventEntity(noIds=False):
  calendarEventEntity = initCalendarEventEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'event', 'events'}:
      if noIds:
        unknownArgumentExit()
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEventEntity['dict'] = entityList
        else:
          calendarEventEntity['list'] = entityList
      else:
        calendarEventEntity['list'].extend(convertEntityToList(getString(Cmd.OB_EVENT_ID)))
    elif myarg in {'id', 'eventid'}:
      if noIds:
        unknownArgumentExit()
      calendarEventEntity['list'].append(getString(Cmd.OB_EVENT_ID))
    elif myarg in {'q', 'query', 'eventquery'}:
      calendarEventEntity['queries'].append(getString(Cmd.OB_QUERY))
    elif myarg == 'matchfield':
      matchField = getChoice(LIST_EVENTS_MATCH_FIELDS, mapChoice=True)
      if matchField[0] != 'attendees' or matchField[1] == 'match':
        calendarEventEntity['matches'].append((matchField, getREPattern(re.IGNORECASE)))
      elif matchField[1] == 'email':
        calendarEventEntity['matches'].append((matchField, getNormalizedEmailAddressEntity()))
      else: #status
        calendarEventEntity['matches'].append((matchField,
                                               getChoice(CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP, defaultChoice=False, mapChoice=True),
                                               getChoice(CALENDAR_ATTENDEE_STATUS_CHOICE_MAP, defaultChoice='needsAction', mapChoice=True),
                                               getNormalizedEmailAddressEntity()))
    elif myarg == 'maxinstances':
      calendarEventEntity['maxinstances'] = getInteger(minVal=-1)
    elif _getCalendarListEventsProperty(myarg, LIST_EVENTS_SELECT_PROPERTIES, calendarEventEntity['kwargs']):
      pass
    else:
      Cmd.Backup()
      break
  return calendarEventEntity

CALENDAR_EVENT_SENDUPDATES_CHOICES_MAP = {'all': 'all', 'externalonly': 'externalOnly', 'none': 'none'}

def _getCalendarSendUpdates(myarg, parameters):
  if myarg == 'sendnotifications':
    parameters['sendUpdates'] = 'all' if getBoolean() else 'none'
  elif myarg == 'notifyattendees':
    parameters['sendUpdates'] = 'all'
  elif myarg == 'sendupdates':
    parameters['sendUpdates'] = getChoice(CALENDAR_EVENT_SENDUPDATES_CHOICES_MAP, mapChoice=True)
  else:
    return False
  return True

CALENDAR_MIN_COLOR_INDEX = 1
CALENDAR_MAX_COLOR_INDEX = 24

CALENDAR_EVENT_MIN_COLOR_INDEX = 1
CALENDAR_EVENT_MAX_COLOR_INDEX = 11

CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP = {
  'optional': True,
  'required': False,
  }
CALENDAR_ATTENDEE_STATUS_CHOICE_MAP = {
  'accepted': 'accepted',
  'declined': 'declined',
  'needsaction': 'needsAction',
  'tentative': 'tentative',
  }
CALENDAR_EVENT_STATUS_CHOICES = ['confirmed', 'tentative', 'cancelled']
CALENDAR_EVENT_TRANSPARENCY_CHOICES = ['opaque', 'transparent']
CALENDAR_EVENT_VISIBILITY_CHOICES = ['default', 'public', 'private', 'confedential']

EVENT_JSON_CLEAR_FIELDS = ['created', 'creator', 'endTimeUpspecified', 'hangoutLink', 'htmlLink',
                           'privateCopy', 'locked', 'recurringEventId', 'updated']
EVENT_JSON_INSERT_CLEAR_FIELDS = ['iCalUID', 'id', 'organizer']
EVENT_JSON_UPDATE_CLEAR_FIELDS = ['iCalUID', 'id', 'organizer']
EVENT_JSON_SUBFIELD_CLEAR_FIELDS = {
  'attendees': ['id', 'organizer', 'self'],
  'attachments': ['fileId', 'iconLink', 'mimeType', 'title'],
  'organizer': ['id', 'self'],
  }
EVENT_JSONATTENDEES_SUBFIELD_CLEAR_FIELDS = {
  'attendees': ['id', 'organizer', 'self'],
  }

def _getCalendarEventAttribute(myarg, body, parameters, function):
  def clearJSONfields(body, clearFields):
    for field in clearFields:
      body.pop(field, None)

  def clearJSONsubfields(body, clearFields):
    for field, subfields in iter(clearFields.items()):
      if field in body:
        if isinstance(body[field], list):
          for item in body[field]:
            for subfield in subfields:
              item.pop(subfield, None)
        else:
          for subfield in subfields:
            body.pop(subfield, None)

  if function == 'insert' and myarg in {'id', 'eventid'}:
    body['id'] = getEventID()
  elif function == 'import' and myarg == 'icaluid':
    body['iCalUID'] = getString(Cmd.OB_ICALUID)
  elif myarg == 'description':
    body['description'] = getStringWithCRsNLs()
  elif function == 'update' and myarg == 'replacedescription':
    parameters['replaceDescription'].append((getREPattern(re.IGNORECASE), getString(Cmd.OB_STRING, minLen=0)))
  elif myarg == 'location':
    body['location'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == 'source':
    body['source'] = {'title': getString(Cmd.OB_STRING), 'url': getString(Cmd.OB_URL)}
  elif myarg == 'summary':
    body['summary'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg in  {'start', 'starttime'}:
    body['start'] = getEventTime()
  elif myarg in {'originalstart', 'originalstarttime'}:
    body['originalStart'] = getEventTime()
  elif myarg in {'end', 'endtime'}:
    body['end'] = getEventTime()
  elif myarg == 'attachment':
    body.setdefault('attachments', [])
    body['attachments'].append({'title': getString(Cmd.OB_STRING), 'fileUrl': getString(Cmd.OB_URL)})
  elif function == 'update' and myarg == 'clearattachments':
    body['attachments'] = []
  elif myarg == 'hangoutsmeet':
    body['conferenceData'] = {'createRequest': {'requestId': f'{str(uuid.uuid4())}'}}
  elif function == 'update' and myarg == 'clearhangoutsmeet':
    body['conferenceData'] = None
  elif myarg == 'recurrence':
    body.setdefault('recurrence', [])
    body['recurrence'].append(getString(Cmd.OB_RECURRENCE))
  elif myarg == 'timezone':
    parameters['timeZone'] = getString(Cmd.OB_STRING)
  elif function == 'update' and myarg == 'replacemode':
    parameters['replaceMode'] = True
  elif function == 'update' and myarg == 'clearattendees':
    parameters['clearAttendees'] = True
  elif function == 'update' and myarg == 'removeattendee':
    parameters['removeAttendees'].add(getEmailAddress(noUid=True))
  elif function == 'update' and myarg == 'selectremoveattendees':
    _, attendeeList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    for attendee in attendeeList:
      parameters['removeAttendees'].add(normalizeEmailAddressOrUID(attendee, noUid=True))
  elif myarg == 'attendee':
    parameters['attendees'].append({'email': getEmailAddress(noUid=True)})
  elif myarg == 'optionalattendee':
    parameters['attendees'].append({'email': getEmailAddress(noUid=True), 'optional': True})
  elif myarg in {'attendeestatus', 'selectattendees'}:
    optional = getChoice(CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP, defaultChoice=None, mapChoice=True)
    responseStatus = getChoice(CALENDAR_ATTENDEE_STATUS_CHOICE_MAP, defaultChoice=None, mapChoice=True)
    if myarg == 'attendeestatus':
      attendeeList = [getEmailAddress(noUid=True)]
    else:
      _, attendeeList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    for attendee in attendeeList:
      addAttendee = {'email': normalizeEmailAddressOrUID(attendee, noUid=True)}
      if optional is not None:
        addAttendee['optional'] = optional
      if responseStatus is not None:
        addAttendee['responseStatus'] = responseStatus
      parameters['attendees'].append(addAttendee)
  elif myarg == 'json':
    jsonData = getJSON(EVENT_JSON_CLEAR_FIELDS)
    if function == 'insert':
      body.update(jsonData)
      clearJSONfields(body, EVENT_JSON_INSERT_CLEAR_FIELDS)
    elif function == 'update':
      if 'event' in jsonData and 'attendees' in jsonData['event']:
        parameters['attendees'].extend(jsonData['event'].pop('attendees'))
        clearJSONsubfields(parameters, EVENT_JSONATTENDEES_SUBFIELD_CLEAR_FIELDS)
      body.update(jsonData)
      clearJSONfields(body, EVENT_JSON_UPDATE_CLEAR_FIELDS)
    clearJSONsubfields(body, EVENT_JSON_SUBFIELD_CLEAR_FIELDS)
    if ('conferenceData' in body and body['conferenceData'] and
        'createRequest' in body['conferenceData'] and
        'status' in body['conferenceData']['createRequest']):
      body['conferenceData']['createRequest']['status'].pop('statusCode', None)
  elif myarg == 'jsonattendees':
    jsonData = getJSON([])
    if 'event' in jsonData and 'attendees' in jsonData['event']:
      parameters['attendees'].extend(jsonData['event']['attendees'])
    elif 'attendees' in jsonData:
      parameters['attendees'].extend(jsonData['attendees'])
    clearJSONsubfields(parameters, EVENT_JSONATTENDEES_SUBFIELD_CLEAR_FIELDS)
  elif function != 'import' and _getCalendarSendUpdates(myarg, parameters):
    pass
  elif myarg == 'anyonecanaddself':
    body['anyoneCanAddSelf'] = getBoolean()
  elif myarg == 'guestscaninviteothers':
    body['guestsCanInviteOthers'] = getBoolean()
  elif myarg == 'guestscantinviteothers':
    body['guestsCanInviteOthers'] = False
  elif myarg == 'guestscanmodify':
    body['guestsCanModify'] = getBoolean()
  elif myarg == 'guestscanseeotherguests':
    body['guestsCanSeeOtherGuests'] = getBoolean()
  elif myarg == 'guestscantseeotherguests':
    body['guestsCanSeeOtherGuests'] = False
  elif myarg == 'status':
    body['status'] = getChoice(CALENDAR_EVENT_STATUS_CHOICES)
  elif myarg == 'tentative':
    body['status'] = 'tentative'
  elif myarg == 'transparency':
    body['transparency'] = getChoice(CALENDAR_EVENT_TRANSPARENCY_CHOICES)
  elif myarg == 'available':
    body['transparency'] = 'transparent'
  elif myarg == 'visibility':
    body['visibility'] = getChoice(CALENDAR_EVENT_VISIBILITY_CHOICES)
  elif myarg == 'color':
    body['colorId'] = getChoice(CALENDAR_EVENT_COLOR_MAP, mapChoice=True)
  elif myarg in {'colorindex', 'colorid'}:
    body['colorId'] = getInteger(CALENDAR_EVENT_MIN_COLOR_INDEX, CALENDAR_EVENT_MAX_COLOR_INDEX)
  elif myarg == 'noreminders':
    body['reminders'] = {'useDefault': False}
  elif myarg == 'reminder':
    body.setdefault('reminders', {'overrides': [], 'useDefault': False})
    body['reminders']['overrides'].append(getCalendarReminder())
    body['reminders']['useDefault'] = False
  elif myarg == 'sequence':
    body['sequence'] = getInteger(minVal=0)
  elif myarg == 'privateproperty':
    body.setdefault('extendedProperties', {})
    body['extendedProperties'].setdefault('private', {})
    key = getString(Cmd.OB_PROPERTY_KEY)
    body['extendedProperties']['private'][key] = getString(Cmd.OB_PROPERTY_VALUE, minLen=0)
  elif myarg == 'sharedproperty':
    body.setdefault('extendedProperties', {})
    body['extendedProperties'].setdefault('shared', {})
    key = getString(Cmd.OB_PROPERTY_KEY)
    body['extendedProperties']['shared'][key] = getString(Cmd.OB_PROPERTY_VALUE, minLen=0)
  elif function == 'update' and myarg == 'clearprivateproperty':
    body.setdefault('extendedProperties', {})
    body['extendedProperties'].setdefault('private', {})
    body['extendedProperties']['private'][getString(Cmd.OB_PROPERTY_KEY)] = None
  elif function == 'update' and myarg == 'clearsharedproperty':
    body.setdefault('extendedProperties', {})
    body['extendedProperties'].setdefault('shared', {})
    body['extendedProperties']['shared'][getString(Cmd.OB_PROPERTY_KEY)] = None
  elif function == 'import' and myarg == 'organizername':
    body.setdefault('organizer', {})
    body['organizer']['displayName'] = getString(Cmd.OB_NAME)
  elif function == 'import' and myarg == 'organizeremail':
    body.setdefault('organizer', {})
    body['organizer']['email'] = getEmailAddress(noUid=True)
  else:
    return False
  return True

def _getEventMatchFields(calendarEventEntity, fieldsList):
  for match in calendarEventEntity['matches']:
    if match[0][0] != 'attendees':
      fieldsList.append(match[0][0])
    else:
      fieldsList.append('attendees/email')
      if match[0][1] == 'status':
        fieldsList.extend('attendees/optional', 'attendees/responseStatus')

def _eventMatches(event, match):
  if match[0][0] != 'attendees':
    eventAttr = event
    for attr in match[0]:
      eventAttr = eventAttr.get(attr, '')
      if not eventAttr:
        break
    if match[0][0] != 'hangoutLink':
      return match[1].search(eventAttr) is not None
# vkj-przn-nvg or vkjprznnvg
    return match[1].search(eventAttr) is not None or match[1].search(eventAttr.replace('-', '')) is not None
  attendees = [attendee['email'] for attendee in event.get('attendees', []) if 'email' in attendee]
  if not attendees:
    return False
  if match[0][1] == 'email':
    for attendee in match[1]:
      if attendee not in attendees:
        return False
    return True
  if match[0][1] == 'match':
    for attendee in attendees:
      if match[1].search(attendee) is not None:
        return True
    return False
  # status
  for matchEmail in match[3]:
    for attendee in event['attendees']:
      if 'email' in attendee and matchEmail == attendee['email']:
        if attendee.get('optional', False) != match[1] or attendee.get('responseStatus') != match[2]:
          return False
        break
    else:
      return False
  return True

def _validateCalendarGetEventIDs(origUser, user, origCal, calId, j, jcount, calendarEventEntity, doIt=True, showAction=True):
  if calendarEventEntity['dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        calEventIds = calendarEventEntity['dict'][calId]
      else:
        calEventIds = calendarEventEntity['dict'][origUser][calId]
    else:
      calEventIds = calendarEventEntity['dict'][calId]
  else:
    calEventIds = calendarEventEntity['list']
  calId, cal = getNormalizedCalIdCal(origCal, calId, user, j, jcount)
  if not cal:
    return (calId, cal, None, 0)
  if not calEventIds:
    fieldsList = ['id']
    _getEventMatchFields(calendarEventEntity, fieldsList)
    fields = ','.join(fieldsList)
    try:
      eventIdsSet = set()
      calEventIds = []
      if len(calendarEventEntity['queries']) <= 1:
        if len(calendarEventEntity['queries']) == 1:
          calendarEventEntity['kwargs']['q'] = calendarEventEntity['queries'][0]
        events = callGAPIpages(cal.events(), 'list', 'items',
                               throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                               calendarId=calId, fields=f'nextPageToken,items({fields})',
                               maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity['kwargs'])
        for event in events:
          for match in calendarEventEntity['matches']:
            if not _eventMatches(event, match):
              break
          else:
            calEventIds.append(event['id'])
      else:
        for query in calendarEventEntity['queries']:
          calendarEventEntity['kwargs']['q'] = query
          events = callGAPIpages(cal.events(), 'list', 'items',
                                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                                 calendarId=calId, fields=f'nextPageToken,items({fields})',
                                 maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity['kwargs'])
          for event in events:
            for match in calendarEventEntity['matches']:
              if not _eventMatches(event, match):
                break
            else:
              eventId = event['id']
              if eventId not in eventIdsSet:
                calEventIds.append(eventId)
                eventIdsSet.add(eventId)
      kcount = len(calEventIds)
      if kcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.CALENDAR, calId], Ent.EVENT, kcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(Ent.EVENT)), j, jcount)
        setSysExitRC(NO_ENTITIES_FOUND)
        return (calId, cal, None, 0)
    except GAPI.notFound:
      entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
    except (GAPI.notACalendarUser, GAPI.forbidden, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
      return (calId, cal, None, 0)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, None, 0)
  else:
    kcount = len(calEventIds)
  if kcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if not doIt:
    if showAction:
      entityNumEntitiesActionNotPerformedWarning([Ent.CALENDAR, calId], Ent.EVENT, kcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
    return (calId, cal, None, 0)
  if showAction:
    entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.EVENT, j, jcount)
  return (calId, cal, calEventIds, kcount)

def _validateCalendarGetEvents(origUser, user, origCal, calId, j, jcount, calendarEventEntity,
                               fieldsList, showAction):
  if calendarEventEntity['dict']:
    if origUser:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        calEventIds = calendarEventEntity['dict'][calId]
      else:
        calEventIds = calendarEventEntity['dict'][origUser][calId]
    else:
      calEventIds = calendarEventEntity['dict'][calId]
  else:
    calEventIds = calendarEventEntity['list']
  calId, cal = getNormalizedCalIdCal(origCal, calId, user, j, jcount)
  if not cal:
    return (calId, cal, [], 0)
  eventIdsSet = set()
  eventsList = []
  fields = getFieldsFromFieldsList(fieldsList)
  ifields = getItemFieldsFromFieldsList('items', fieldsList)
  try:
    if not calEventIds:
      if len(calendarEventEntity['queries']) <= 1:
        if len(calendarEventEntity['queries']) == 1:
          calendarEventEntity['kwargs']['q'] = calendarEventEntity['queries'][0]
        events = callGAPIpages(cal.events(), 'list', 'items',
                               throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                               calendarId=calId, fields=ifields,
                               maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity['kwargs'])
        for event in events:
          for match in calendarEventEntity['matches']:
            if not _eventMatches(event, match):
              break
          else:
            eventsList.append(event)
      else:
        for query in calendarEventEntity['queries']:
          calendarEventEntity['kwargs']['q'] = query
          events = callGAPIpages(cal.events(), 'list', 'items',
                                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                                 calendarId=calId, fields=ifields,
                                 maxResults=GC.Values[GC.EVENT_MAX_RESULTS], **calendarEventEntity['kwargs'])
          for event in events:
            for match in calendarEventEntity['matches']:
              if not _eventMatches(event, match):
                break
            else:
              eventId = event['id']
              if eventId not in eventIdsSet:
                eventsList.append(event)
                eventIdsSet.add(eventId)
    else:
      k = 0
      for eventId in calEventIds:
        k += 1
        if eventId not in eventIdsSet:
          eventsList.append(callGAPI(cal.events(), 'get',
                                     throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                                     calendarId=calId, eventId=eventId, fields=fields))
          eventIdsSet.add(eventId)
    kcount = len(eventsList)
    if showAction:
      entityPerformActionNumItems([Ent.CALENDAR, calId], kcount, Ent.EVENT, j, jcount)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    return (calId, cal, eventsList, kcount)
  except (GAPI.notFound, GAPI.deleted) as e:
    if not checkCalendarExists(cal, calId):
      entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
      return (calId, cal, [], 0)
    entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), k, kcount)
  except (GAPI.notACalendarUser, GAPI.forbidden, GAPI.invalid) as e:
    entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
    return (calId, cal, [], 0)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
    return (calId, cal, [], 0)

def _getCalendarCreateImportUpdateEventOptions(function, calendarEventEntity=None):
  body = {}
  parameters = {'clearAttendees': False, 'replaceMode': False,
                'attendees': [], 'removeAttendees': set(),
                'replaceDescription': [], 'sendUpdates': 'none'}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if calendarEventEntity and myarg in {'id', 'eventid'}:
      calendarEventEntity['list'].append(getString(Cmd.OB_EVENT_ID))
    elif not _getCalendarEventAttribute(myarg, body, parameters, function):
      unknownArgumentExit()
  return (body, parameters)

def _setEventRecurrenceTimeZone(cal, calId, body, parameters, i, count):
  if ('recurrence' in body) and (('start' in body) or ('end' in body)):
    timeZone = parameters.get('timeZone')
    if not timeZone:
      try:
        timeZone = callGAPI(cal.calendars(), 'get',
                            throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                            calendarId=calId, fields='timeZone')['timeZone']
      except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden, GAPI.invalid) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        return False
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        return False
    if 'start' in body:
      body['start']['timeZone'] = timeZone
    if 'end' in body:
      body['end']['timeZone'] = timeZone
  return True

def _createCalendarEvents(user, origCal, function, calIds, count, body, parameters):
  if parameters['attendees']:
    body['attendees'] = parameters.pop('attendees')
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = getNormalizedCalIdCal(origCal, calId, user, i, count)
    if not cal:
      continue
    if not _setEventRecurrenceTimeZone(cal, calId, body, parameters, i, count):
      continue
    event = {'id': body.get('id', 'Unknown')}
    if function == 'import' and body.get('status', '') == 'cancelled':
      entityActionNotPerformedWarning([Ent.CALENDAR, calId, Ent.EVENT, body.get('iCalUID', event['id'])], Msg.EVENT_IS_CANCELED, count)
      continue
    try:
      if function == 'insert':
        event = callGAPI(cal.events(), 'insert',
                         throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY, GAPI.EVENT_DURATION_EXCEEDS_LIMIT,
                                                                   GAPI.REQUIRED_ACCESS_LEVEL, GAPI.DUPLICATE, GAPI.FORBIDDEN],
                         calendarId=calId, conferenceDataVersion=1, sendUpdates=parameters['sendUpdates'], supportsAttachments=True, body=body, fields='id')
      else:
        event = callGAPI(cal.events(), 'import_',
                         throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY, GAPI.EVENT_DURATION_EXCEEDS_LIMIT,
                                                                   GAPI.REQUIRED_ACCESS_LEVEL, GAPI.DUPLICATE, GAPI.FORBIDDEN,
                                                                   GAPI.PARTICIPANT_IS_NEITHER_ORGANIZER_NOR_ATTENDEE],
                         calendarId=calId, conferenceDataVersion=1, supportsAttachments=True, body=body, fields='id')
      entityActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, event['id']], i, count)
    except (GAPI.invalid, GAPI.required, GAPI.timeRangeEmpty, GAPI.eventDurationExceedsLimit,
            GAPI.requiredAccessLevel, GAPI.participantIsNeitherOrganizerNorAttendee) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, event['id']], str(e), i, count)
    except GAPI.duplicate as e:
      entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, event['id']], str(e), i, count)
    except (GAPI.forbidden, GAPI.notACalendarUser) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
      break
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
      break

# gam calendars <CalendarEntity> create|add event [id <String>] <EventAddAttribute>+
# gam calendar <UserItem> addevent [id <String>] <EventAddAttribute>+
def doCalendarsCreateEvent(calIds):
  body, parameters = _getCalendarCreateImportUpdateEventOptions('insert')
  _createCalendarEvents(None, None, 'insert', calIds, len(calIds), body, parameters)

# gam calendars <CalendarEntity> import event icaluid <iCalUID> <EventImportAttribute>+
def doCalendarsImportEvent(calIds):
  body, parameters = _getCalendarCreateImportUpdateEventOptions('import')
  _createCalendarEvents(None, None, 'import', calIds, len(calIds), body, parameters)

def _updateCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity, body, parameters):
  updateFieldList = []
  if parameters['replaceDescription']:
    updateFieldList.append('description')
  if not parameters['replaceMode'] and (parameters['attendees'] or parameters['removeAttendees']):
    updateFieldList.append('attendees')
  updateFields = ','.join(updateFieldList)
  if 'attendees' not in updateFieldList:
    if parameters['attendees']:
      body['attendees'] = parameters.pop('attendees')
    elif parameters['clearAttendees']:
      body['attendees'] = []
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, origCal, calId, i, count, calendarEventEntity)
    if jcount == 0:
      continue
    if not _setEventRecurrenceTimeZone(cal, calId, body, parameters, i, count):
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        if updateFieldList:
          event = callGAPI(cal.events(), 'get',
                           throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                           calendarId=calId, eventId=eventId, fields=updateFields)
          if 'description' in updateFieldList and 'description' in event:
            body['description'] = event['description']
            for replacement in parameters['replaceDescription']:
              body['description'] = re.sub(replacement[0], replacement[1], body['description'])
          if 'attendees' in updateFieldList:
            if not parameters['clearAttendees']:
              if 'attendees' in event:
                body['attendees'] = event['attendees']
                for addAttendee in parameters['attendees']:
                  for attendee in body['attendees']:
                    if attendee['email'].lower() == addAttendee['email']:
                      attendee.update(addAttendee)
                      break
                  else:
                    body['attendees'].append(addAttendee)
              elif parameters['attendees']:
                body['attendees'] = parameters['attendees']
            elif parameters['attendees']:
              body['attendees'] = parameters['attendees']
            else:
              body['attendees'] = []
            if parameters['removeAttendees']:
              body['attendees'] = [attendee for attendee in body['attendees'] if attendee['email'].lower() not in parameters['removeAttendees']]
        callGAPI(cal.events(), 'patch',
                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN,
                                                           GAPI.INVALID, GAPI.REQUIRED, GAPI.TIME_RANGE_EMPTY, GAPI.EVENT_DURATION_EXCEEDS_LIMIT,
                                                           GAPI.REQUIRED_ACCESS_LEVEL, GAPI.CANNOT_CHANGE_ORGANIZER_OF_INSTANCE],
                 calendarId=calId, eventId=eventId, conferenceDataVersion=1, sendUpdates=parameters['sendUpdates'], supportsAttachments=True,
                 body=body, fields='')
        entityActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, eventId], j, jcount)
      except (GAPI.notFound, GAPI.deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
          break
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.forbidden, GAPI.invalid, GAPI.required, GAPI.timeRangeEmpty, GAPI.eventDurationExceedsLimit,
              GAPI.requiredAccessLevel, GAPI.cannotChangeOrganizerOfInstance) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except GAPI.notACalendarUser as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

# gam calendars <CalendarEntity> update events [<EventEntity>] [replacemode] <EventUpdateAttribute>+ [<EventNotificationAttribute>]
def doCalendarsUpdateEvents(calIds):
  calendarEventEntity = getCalendarEventEntity()
  body, parameters = _getCalendarCreateImportUpdateEventOptions('update')
  _updateCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, body, parameters)

# gam calendar <CalendarEntity> updateevent <EventID> [replacemode] <EventUpdateAttribute>+ [<EventNotificationAttribute>]
def doCalendarsUpdateEventsOld(calIds):
  calendarEventEntity = initCalendarEventEntity()
  calendarEventEntity['list'].append(getString(Cmd.OB_EVENT_ID))
  body, parameters = _getCalendarCreateImportUpdateEventOptions('update')
  _updateCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, body, parameters)

def _getCalendarDeleteEventOptions(calendarEventEntity=None):
  parameters = {'sendUpdates': 'none', 'doIt': False}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarSendUpdates(myarg, parameters):
      pass
    elif calendarEventEntity and myarg in {'id', 'eventid'}:
      calendarEventEntity['list'].append(getString(Cmd.OB_EVENT_ID))
    elif myarg == 'doit':
      parameters['doIt'] = True
    else:
      unknownArgumentExit()
  return parameters

def _deleteCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity, parameters):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, origCal, calId, i, count, calendarEventEntity, doIt=parameters['doIt'])
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), 'delete',
                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN,
                                                           GAPI.INVALID, GAPI.REQUIRED, GAPI.REQUIRED_ACCESS_LEVEL],
                 calendarId=calId, eventId=eventId, sendUpdates=parameters['sendUpdates'])
        entityActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, eventId], j, jcount)
      except (GAPI.notFound, GAPI.deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
          break
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.forbidden, GAPI.invalid, GAPI.required, GAPI.requiredAccessLevel) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except GAPI.notACalendarUser as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

# gam calendars <CalendarEntity> delete event <EventEntity> [doit] [<EventNotificationAttribute>]
def doCalendarsDeleteEvents(calIds):
  calendarEventEntity = getCalendarEventEntity()
  parameters = _getCalendarDeleteEventOptions()
  _deleteCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, parameters)

# gam calendar <CalendarEntity> deleteevent (id|eventid <EventID>)+ [doit] [<EventNotificationAttribute>]
def doCalendarsDeleteEventsOld(calIds):
  calendarEventEntity = initCalendarEventEntity()
  parameters = _getCalendarDeleteEventOptions(calendarEventEntity)
  _deleteCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, parameters)

def _getCalendarMoveEventsOptions(calendarEventEntity=None):
  parameters = {'sendUpdates': 'none'}
  newCalId = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarSendUpdates(myarg, parameters):
      pass
    elif calendarEventEntity and myarg in {'id', 'eventid'}:
      calendarEventEntity['list'].append(getString(Cmd.OB_EVENT_ID))
    elif calendarEventEntity and myarg == 'destination':
      newCalId = convertUIDtoEmailAddress(getString(Cmd.OB_CALENDAR_ITEM))
    else:
      unknownArgumentExit()
  return (parameters, newCalId)

def _moveCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity, newCalId, parameters):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, origCal, calId, i, count, calendarEventEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        callGAPI(cal.events(), 'move',
                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.CANNOT_CHANGE_ORGANIZER, GAPI.CANNOT_CHANGE_ORGANIZER_OF_INSTANCE],
                 calendarId=calId, eventId=eventId, destination=newCalId, sendUpdates=parameters['sendUpdates'], fields='')
        entityModifierNewValueActionPerformed([Ent.CALENDAR, calId, Ent.EVENT, eventId], Act.MODIFIER_TO, f'{Ent.Singular(Ent.CALENDAR)}: {newCalId}', j, jcount)
      except GAPI.notFound as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, i, count)
          break
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId, Ent.CALENDAR, newCalId], Ent.TypeNameMessage(Ent.EVENT, eventId, str(e)), j, jcount)
      except GAPI.notACalendarUser as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.forbidden, GAPI.cannotChangeOrganizer, GAPI.cannotChangeOrganizerOfInstance) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

# gam calendars <CalendarEntity> move events <EventEntity> to|destination <CalendarItem> [<EventNotificationAttribute>]
def doCalendarsMoveEvents(calIds):
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent(['to', 'destination'])
  newCalId = convertUIDtoEmailAddress(getString(Cmd.OB_CALENDAR_ITEM))
  parameters, _ = _getCalendarMoveEventsOptions()
  if not checkCalendarExists(None, newCalId, True):
    return
  _moveCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, newCalId, parameters)

# gam calendars <CalendarEntity> moveevent (id|eventid <EventID>)+ destination <CalendarItem> [<EventNotificationAttribute>]
def doCalendarsMoveEventsOld(calIds):
  calendarEventEntity = initCalendarEventEntity()
  parameters, newCalId = _getCalendarMoveEventsOptions(calendarEventEntity)
  if not checkCalendarExists(None, newCalId, True):
    return
  _moveCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, newCalId, parameters)

def _purgeCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity, parameters, emptyTrash):
  body = {'summary': f'GamPurgeCalendar-{random.randint(1, 99999):05}'}
  if user:
    entityValueList = [Ent.USER, user, Ent.CALENDAR, body['summary']]
  else:
    entityValueList = [Ent.CALENDAR, body['summary']]
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = getNormalizedCalIdCal(origCal, calId, user, i, count)
    if not cal:
      continue
    try:
      purgeCalId = callGAPI(cal.calendars(), 'insert',
                            throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.FORBIDDEN],
                            body=body, fields='id')['id']
      Act.Set(Act.CREATE)
      entityActionPerformed(entityValueList)
      Ind.Increment()
      if not emptyTrash:
        Act.Set(Act.DELETE)
        _deleteCalendarEvents(origUser, user, cal, [calId], count, calendarEventEntity, parameters)
      Act.Set(Act.MOVE)
      calendarEventEntity['kwargs']['showDeleted'] = True
      _moveCalendarEvents(origUser, user, cal, [calId], count, calendarEventEntity, purgeCalId, parameters)
      calendarEventEntity['kwargs'].pop('showDeleted')
      Ind.Decrement()
      callGAPI(cal.calendars(), 'delete',
               throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
               calendarId=purgeCalId)
      Act.Set(Act.REMOVE)
      entityActionPerformed(entityValueList)
    except (GAPI.notFound, GAPI.notACalendarUser, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, body['summary']], str(e))
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user)

# gam calendars <CalendarEntity> purge event <EventEntity> [doit] [<EventNotificationAttribute>]
def doCalendarsPurgeEvents(calIds):
  calendarEventEntity = getCalendarEventEntity()
  parameters = _getCalendarDeleteEventOptions()
  _purgeCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, parameters, False)

def _wipeCalendarEvents(user, origCal, calIds, count):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = getNormalizedCalIdCal(origCal, calId, user, i, count)
    if not cal:
      continue
    try:
      callGAPI(cal.calendars(), 'clear',
               throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID, GAPI.REQUIRED_ACCESS_LEVEL],
               calendarId=calId)
      entityActionPerformed([Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden, GAPI.invalid, GAPI.requiredAccessLevel) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)

# gam calendars <CalendarEntity> wipe events
# gam calendar <CalendarEntity> wipe
def doCalendarsWipeEvents(calIds):
  checkArgumentPresent([Cmd.ARG_EVENT, Cmd.ARG_EVENTS])
  checkForExtraneousArguments()
  _wipeCalendarEvents(None, None, calIds, len(calIds))

def _emptyCalendarTrash(user, origCal, calIds, count):
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = getNormalizedCalIdCal(origCal, calId, user, i, count)
    if not cal:
      continue
    Act.Set(Act.PURGE)
    calendarEventEntity = initCalendarEventEntity()
    try:
      events = callGAPIpages(cal.events(), 'list', 'items',
                             throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                             calendarId=calId, showDeleted=True, fields='nextPageToken,items(id,status,organizer(self),recurringEventId)',
                             maxResults=GC.Values[GC.EVENT_MAX_RESULTS])
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
      continue
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
      continue
    for event in events:
      if event['status'] == 'cancelled' and event.get('organizer', {}).get('self', user is None) and not event.get('recurringEventId', ''):
        calendarEventEntity['list'].append(event['id'])
    jcount = len(calendarEventEntity['list'])
    if not user:
      entityPerformActionNumItems([Ent.CALENDAR, calId], jcount, Ent.TRASHED_EVENT, i, count)
      Ind.Increment()
    if jcount > 0:
      _purgeCalendarEvents(user, user, cal, [calId], 1, calendarEventEntity, {'sendUpdates': 'none', 'doIt': True}, True)
    if not user:
      Ind.Decrement()

# gam calendars <CalendarEntity> empty calendartrash
def doCalendarsEmptyTrash(calIds):
  checkForExtraneousArguments()
  Act.Set(Act.PURGE)
  _emptyCalendarTrash(None, None, calIds, len(calIds))

EVENT_FIELDS_CHOICE_MAP = {
  'anyonecanaddself': 'anyoneCanAddSelf',
  'attachments': 'attachments',
  'attendees': 'attendees',
  'attendeesomitted': 'attendeesOmitted',
  'colorid': 'colorId',
  'conferencedata': 'conferenceData',
  'created': 'created',
  'creator': 'creator',
  'description': 'description',
  'end': 'end',
  'endtime': 'end',
  'endtimeunspecified': 'endTimeUnspecified',
  'extendedproperties': 'extendedProperties',
  'gadget': 'gadget',
  'guestscaninviteothers': 'guestsCanInviteOthers',
  'guestscanmodify': 'guestsCanModify',
  'guestscanseeotherguests': 'guestsCanSeeOtherGuests',
  'hangoutlink': 'hangoutLink',
  'htmllink': 'htmlLink',
  'icaluid': 'iCalUID',
  'id': 'id',
  'location': 'location',
  'locked': 'locked',
  'organizer': 'organizer',
  'originalstarttime': 'originalStartTime',
  'privatecopy': 'privateCopy',
  'recurrence': 'recurrence',
  'recurringeventid': 'recurringEventId',
  'reminders': 'reminders',
  'sequence': 'sequence',
  'source': 'source',
  'start': 'start',
  'starttime': 'start',
  'status': 'status',
  'summary': 'summary',
  'transparency': 'transparency',
  'updated': 'updated',
  'visibility': 'visibility',
  }

EVENT_ATTACHMENTS_SUBFIELDS_CHOICE_MAP = {
  'fileid': 'fileId',
  'fileurl': 'fileUrl',
  'iconlink': 'iconLink',
  'mimetype': 'mimeType',
  'title': 'title',
  }

EVENT_ATTENDEES_SUBFIELDS_CHOICE_MAP = {
  'additionalguests': 'additionalGuests',
  'comment': 'comment',
  'displayname': 'displayName',
  'email': 'email',
  'id': 'id',
  'optional': 'optional',
  'organizer': 'organizer',
  'resource': 'resource',
  'responsestatus': 'responseStatus',
  'self': 'self',
  }

EVENT_CONFERENCEDATA_SUBFIELDS_CHOICE_MAP = {
  'conferenceid': 'conferenceId',
  'conferencesolution': 'conferenceSolution',
  'createrequest': 'createRequest',
  'entrypoints': 'entryPoints',
  'notes': 'notes',
  'signature': 'signature',
  }

EVENT_CREATOR_SUBFIELDS_CHOICE_MAP = {
  'displayname': 'displayName',
  'email': 'email',
  'id': 'id',
  'self': 'self',
  }

EVENT_ORGANIZER_SUBFIELDS_CHOICE_MAP = {
  'displayname': 'displayName',
  'email': 'email',
  'id': 'id',
  'self': 'self',
  }

EVENT_SUBFIELDS_CHOICE_MAP = {
  'attachments': EVENT_ATTACHMENTS_SUBFIELDS_CHOICE_MAP,
  'attendees': EVENT_ATTENDEES_SUBFIELDS_CHOICE_MAP,
  'conferencedata': EVENT_CONFERENCEDATA_SUBFIELDS_CHOICE_MAP,
  'creator': EVENT_CREATOR_SUBFIELDS_CHOICE_MAP,
  'organizer': EVENT_ORGANIZER_SUBFIELDS_CHOICE_MAP,
}

def _getEventFields(fieldsList):
  if not fieldsList:
    fieldsList.append('id')
  for field in _getFieldsList():
    if field.find('.') == -1:
      if field in EVENT_FIELDS_CHOICE_MAP:
        addFieldToFieldsList(field, EVENT_FIELDS_CHOICE_MAP, fieldsList)
      else:
        invalidChoiceExit(field, EVENT_FIELDS_CHOICE_MAP, True)
    else:
      field, subField = field.split('.', 1)
      if field in EVENT_SUBFIELDS_CHOICE_MAP:
        if subField in EVENT_SUBFIELDS_CHOICE_MAP[field]:
          fieldsList.append(f'{EVENT_FIELDS_CHOICE_MAP[field]}.{EVENT_SUBFIELDS_CHOICE_MAP[field][subField]}')
        else:
          invalidChoiceExit(subField, list(EVENT_SUBFIELDS_CHOICE_MAP[field]), True)
      else:
        invalidChoiceExit(field, list(EVENT_SUBFIELDS_CHOICE_MAP), True)

def _addEventEntitySelectFields(calendarEventEntity, fieldsList):
  if fieldsList:
    _getEventMatchFields(calendarEventEntity, fieldsList)
    if calendarEventEntity['maxinstances'] != -1:
      fieldsList.append('recurrence')

def _getCalendarInfoEventOptions(calendarEventEntity):
  FJQC = FormatJSONQuoteChar()
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'fields':
      _getEventFields(fieldsList)
    else:
      FJQC.GetFormatJSON(myarg)
  _addEventEntitySelectFields(calendarEventEntity, fieldsList)
  return (FJQC, fieldsList)

def _infoCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity, FJQC, fieldsList):
  fields = getFieldsFromFieldsList(fieldsList)
  ifields = getItemFieldsFromFieldsList('items', fieldsList)
  i = 0
  for calId in calIds:
    i += 1
    calId, cal, calEventIds, jcount = _validateCalendarGetEventIDs(origUser, user, origCal, calId, i, count, calendarEventEntity, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for eventId in calEventIds:
      j += 1
      try:
        event = callGAPI(cal.events(), 'get',
                         throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                         calendarId=calId, eventId=eventId, fields=fields)
        if calendarEventEntity['maxinstances'] == -1 or 'recurrence' not in event:
          _showCalendarEvent(user, calId, Ent.EVENT, event, j, jcount, FJQC)
        else:
          instances = callGAPIpages(cal.events(), 'instances', 'items',
                                    throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.DELETED, GAPI.FORBIDDEN],
                                    calendarId=calId, eventId=eventId, fields=ifields,
                                    maxItems=calendarEventEntity['maxinstances'], maxResults=GC.Values[GC.EVENT_MAX_RESULTS])
          lcount = len(instances)
          if not FJQC.formatJSON:
            entityPerformActionNumItems([Ent.EVENT, event['id']], lcount, Ent.INSTANCE, j, jcount)
          Ind.Increment()
          l = 0
          for instance in instances:
            l += 1
            _showCalendarEvent(user, calId, Ent.INSTANCE, instance, l, lcount, FJQC)
          Ind.Decrement()
      except (GAPI.notFound, GAPI.deleted) as e:
        if not checkCalendarExists(cal, calId):
          entityUnknownWarning(Ent.CALENDAR, calId, i, count)
          break
        entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventId], str(e), j, jcount)
      except (GAPI.notACalendarUser, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
        break
    Ind.Decrement()

# gam calendars <CalendarEntity> info events <EventEntity> [maxinstances <Number>]
#	[fields <EventFieldNameList>] [showdayofweek]
#	[formatjson]
def doCalendarsInfoEvents(calIds):
  calendarEventEntity = getCalendarEventEntity()
  FJQC, fieldsList = _getCalendarInfoEventOptions(calendarEventEntity)
  _infoCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity, FJQC, fieldsList)

EVENT_INDEXED_TITLES = ['attendees', 'attachments', 'recurrence']

def _getCalendarPrintShowEventOptions(calendarEventEntity, entityType):
  csvPF = CSVPrintFile(['primaryEmail', 'calendarId', 'id'] if entityType == Ent.USER else ['calendarId', 'id'], 'sortall', indexedTitles=EVENT_INDEXED_TITLES) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCalendarListEventsDisplayProperty(myarg, calendarEventEntity):
      pass
    elif myarg == 'fields':
      _getEventFields(fieldsList)
    elif myarg == 'countsonly':
      calendarEventEntity['countsOnly'] = True
    elif myarg == 'showdayofweek':
      calendarEventEntity['showDayOfWeek'] = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if calendarEventEntity['countsOnly']:
    fieldsList = ['id']
  if csvPF:
    if calendarEventEntity['countsOnly']:
      csvPF.AddTitles(['events'])
    elif not FJQC.formatJSON and not fieldsList:
      csvPF.AddSortTitles(EVENT_PRINT_ORDER)
  _addEventEntitySelectFields(calendarEventEntity, fieldsList)
  return (csvPF, FJQC, fieldsList)

def _getEventDaysOfWeek(event):
  for attr in ['start', 'end']:
    if attr in event:
      if 'date' in event[attr]:
        try:
          dateTime = datetime.datetime.strptime(event[attr]['date'], YYYYMMDD_FORMAT)
          event[attr]['dayOfWeek'] = calendarlib.day_abbr[dateTime.weekday()]
        except ValueError:
          pass
      elif 'dateTime' in event[attr]:
        try:
          dateTime, _ = iso8601.parse_date(event[attr]['dateTime'])
          event[attr]['dayOfWeek'] = calendarlib.day_abbr[dateTime.weekday()]
        except (iso8601.ParseError, OverflowError):
          pass

EVENT_SHOW_ORDER = ['id', 'summary', 'status', 'description', 'location',
                    'start', 'end', 'endTimeUnspecified',
                    'creator', 'organizer', 'created', 'updated', 'iCalUID']
EVENT_PRINT_ORDER = ['id', 'summary', 'status', 'description', 'location',
                     'created', 'updated', 'iCalUID']

EVENT_TIME_OBJECTS = {'created', 'updated', 'dateTime'}

def _showCalendarEvent(primaryEmail, calId, eventEntityType, event, k, kcount, FJQC):
  if FJQC.formatJSON:
    if primaryEmail:
      printLine(json.dumps(cleanJSON({'primaryEmail': primaryEmail, 'calendarId': calId, 'event': event},
                                     timeObjects=EVENT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    else:
      printLine(json.dumps(cleanJSON({'calendarId': calId, 'event': event},
                                     timeObjects=EVENT_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([eventEntityType, event['id']], k, kcount)
  skipObjects = {'id'}
  Ind.Increment()
  for field in EVENT_SHOW_ORDER:
    if field in event:
      showJSON(field, event[field], skipObjects, EVENT_TIME_OBJECTS)
      skipObjects.add(field)
  showJSON(None, event, skipObjects)
  Ind.Decrement()

def _printShowCalendarEvents(origUser, user, origCal, calIds, count, calendarEventEntity,
                             csvPF, FJQC, fieldsList):
  i = 0
  for calId in calIds:
    i += 1
    if csvPF:
      printGettingEntityItemForWhom(Ent.EVENT, calId, i, count)
    calId, _, events, jcount = _validateCalendarGetEvents(origUser, user, origCal, calId, i, count, calendarEventEntity,
                                                          fieldsList, not csvPF and not FJQC.formatJSON and not calendarEventEntity['countsOnly'])
    if not csvPF:
      if not calendarEventEntity['countsOnly']:
        Ind.Increment()
        j = 0
        for event in events:
          j += 1
          if calendarEventEntity['showDayOfWeek']:
            _getEventDaysOfWeek(event)
          _showCalendarEvent(user, calId, Ent.EVENT, event, j, jcount, FJQC)
        Ind.Decrement()
      else:
        printKeyValueList([Ent.Singular(Ent.CALENDAR), calId, Ent.Choose(Ent.EVENT, jcount), jcount])
    else:
      if not calendarEventEntity['countsOnly']:
        if events:
          for event in events:
            row = {'calendarId': calId, 'id': event['id']}
            if user:
              row['primaryEmail'] = user
            if calendarEventEntity['showDayOfWeek']:
              _getEventDaysOfWeek(event)
            flattenJSON(event, flattened=row, timeObjects=EVENT_TIME_OBJECTS)
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(row)
            elif csvPF.CheckRowTitles(row):
              row = {'calendarId': calId, 'id': event['id'],
                     'JSON': json.dumps(cleanJSON(event, timeObjects=EVENT_TIME_OBJECTS),
                                        ensure_ascii=False, sort_keys=False)}
              if user:
                row['primaryEmail'] = user
              csvPF.WriteRowNoFilter(row)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT] and user:
          csvPF.WriteRowNoFilter({'calendarId': calId, 'primaryEmail': user, 'id': ''})
      else:
        row = {'calendarId': calId}
        if user:
          row['primaryEmail'] = user
        row['events'] = jcount
        csvPF.WriteRow(row)

# gam calendars <CalendarEntity> print events <EventEntity> <EventDisplayProperties>*
#	[fields <EventFieldNameList>] [showdayofweek]
#	[countsonly] [formatjson [quotechar <Character>]] [todrive <ToDriveAttribute>*]
# gam calendars <CalendarEntity> show events <EventEntity> <EventDisplayProperties>*
#	[fields <EventFieldNameList>] [showdayofweek]
#	[countsonly] [formatjson]
def doCalendarsPrintShowEvents(calIds):
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  csvPF, FJQC, fieldsList = _getCalendarPrintShowEventOptions(calendarEventEntity, Ent.CALENDAR)
  _printShowCalendarEvents(None, None, None, calIds, len(calIds), calendarEventEntity,
                           csvPF, FJQC, fieldsList)
  if csvPF:
    csvPF.writeCSVfile('Calendar Events')

# <CalendarSettings> ::==
#	[description <String>] [location <String>] [summary <String>] [timezone <TimeZone>]
def _getCalendarSetting(myarg, body):
  if myarg == 'description':
    body['description'] = getStringWithCRsNLs()
  elif myarg == 'location':
    body['location'] = getString(Cmd.OB_STRING, minLen=0)
  elif myarg == 'summary':
    body['summary'] = getString(Cmd.OB_STRING)
  elif myarg == 'timezone':
    body['timeZone'] = getString(Cmd.OB_STRING)
  else:
    return False
  return True

def getCalendarSettings(summaryRequired=False):
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getCalendarSetting(myarg, body):
      pass
    else:
      unknownArgumentExit()
  if summaryRequired and not body.get('summary', None):
    missingArgumentExit('summary <String>')
  return body

# gam calendars <CalendarEntity> modify <CalendarSettings>
def doCalendarsModifySettings(calIds):
  body = getCalendarSettings(summaryRequired=False)
  count = len(calIds)
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = validateCalendar(calId, i, count)
    if not cal:
      continue
    try:
      callGAPI(cal.calendars(), 'patch',
               throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
               calendarId=calId, body=body)
      entityActionPerformed([Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)

def _showCalendarSettings(calendar, j, jcount):
  printEntity([Ent.CALENDAR, calendar['id']], j, jcount)
  Ind.Increment()
  printKeyValueList(['Summary', calendar.get('summaryOverride', calendar.get('summary', ''))])
  printKeyValueWithCRsNLs('Description', calendar.get('description', ''))
  printKeyValueList(['Location', calendar.get('location', '')])
  printKeyValueList(['Timezone', calendar.get('timeZone', '')])
  printKeyValueList(['ConferenceProperties', None])
  Ind.Increment()
  printKeyValueList(['AllowedConferenceSolutionTypes', ','.join(calendar.get('conferenceProperties', {}).get('allowedConferenceSolutionTypes', []))])
  Ind.Decrement()
  Ind.Decrement()

# gam calendars <CalendarEntity> print settings [todrive <ToDriveAttribute>*] [formatjson] [quotechar <Character>}
# gam calendars <CalendarEntity> show settings [formatjson]
def doCalendarsPrintShowSettings(calIds):
  csvPF = CSVPrintFile(['calendarId'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  count = len(calIds)
  i = 0
  for calId in calIds:
    i += 1
    calId, cal = validateCalendar(calId, i, count)
    if not cal:
      continue
    try:
      calendar = callGAPI(cal.calendars(), 'get',
                          throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                          calendarId=calId)
      if not csvPF:
        if not FJQC.formatJSON:
          _showCalendarSettings(calendar, i, count)
        else:
          printLine(json.dumps(cleanJSON(calendar), ensure_ascii=False, sort_keys=True))
      else:
        row = flattenJSON(calendar)
        if not FJQC.formatJSON:
          row['calendarId'] = row.pop('id')
          csvPF.WriteRowTitles(row)
        elif csvPF.CheckRowTitles(row):
          csvPF.WriteRowNoFilter({'calendarId': calId, 'JSON': json.dumps(cleanJSON(calendar), ensure_ascii=False, sort_keys=True)})
    except (GAPI.notACalendarUser, GAPI.notFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.CALENDAR, calId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.CALENDAR, calId, i, count)
  if csvPF:
    csvPF.writeCSVfile('Calendar Settings')

def _validateResourceId(resourceId, i, count):
  cd = buildGAPIObject(API.DIRECTORY)
  try:
    return callGAPI(cd.resources().calendars(), 'get',
                    throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                    customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId, fields='resourceEmail')['resourceEmail']
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)
    return None

def _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity, showAction=True):
  calId = _validateResourceId(resourceId, i, count)
  if not calId:
    return (None, None, 0)
  if ACLScopeEntity['dict']:
    ruleIds = ACLScopeEntity['dict'][resourceId]
  else:
    ruleIds = ACLScopeEntity['list']
  jcount = len(ruleIds)
  if showAction:
    entityPerformActionNumItems([Ent.RESOURCE_CALENDAR, resourceId], jcount, Ent.CALENDAR_ACL, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (calId, ruleIds, jcount)

# gam resource <ResourceID> create|add calendaracls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
# gam resources <ResourceEntity> create|add calendaracls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def doResourceCreateCalendarACLs(entityList):
  cal = buildGAPIObject(API.CALENDAR)
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _createCalendarACLs(cal, Ent.RESOURCE_CALENDAR, calId, i, count, role, ruleIds, jcount, sendNotifications)

def _resourceUpdateDeleteCalendarACLs(entityList, function, ACLScopeEntity, role, sendNotifications):
  cal = buildGAPIObject(API.CALENDAR)
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity)
    if jcount == 0:
      continue
    _updateDeleteCalendarACLs(cal, function, Ent.RESOURCE_CALENDAR, calId, i, count, role, ruleIds, jcount, sendNotifications)

# gam resource <ResourceID> update calendaracls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
# gam resources <ResourceEntity> update calendaracls <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def doResourceUpdateCalendarACLs(entityList):
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  _resourceUpdateDeleteCalendarACLs(entityList, 'patch', ACLScopeEntity, role, sendNotifications)

# gam resource <ResourceID> delete calendaracls [<CalendarACLRole>] <CalendarACLScopeEntity>
# gam resources <ResourceEntity> delete calendaracls [<CalendarACLRole>] <CalendarACLScopeEntity>
def doResourceDeleteCalendarACLs(entityList):
  role, ACLScopeEntity = getCalendarDeleteACLsOptions(True)
  _resourceUpdateDeleteCalendarACLs(entityList, 'delete', ACLScopeEntity, role, False)

# gam resource <ResourceID> info calendaracls <CalendarACLScopeEntity> [formatjson]
# gam resources <ResourceEntity> info calendaracls <CalendarACLScopeEntity> [formatjson]
def doResourceInfoCalendarACLs(entityList):
  cal = buildGAPIObject(API.CALENDAR)
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  FJQC = _getCalendarInfoACLOptions()
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId, ruleIds, jcount = _normalizeResourceIdGetRuleIds(resourceId, i, count, ACLScopeEntity, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    _infoCalendarACLs(cal, resourceId, Ent.RESOURCE_CALENDAR, calId, i, count, ruleIds, jcount, FJQC)

# gam resource <ResourceID> print calendaracls [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam resources <ResourceEntity> print calendaracls [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam resource <ResourceID> show calendaracls [formatjson]
# gam resources <ResourceEntity> show calendaracls [formatjson]
def doResourcePrintShowCalendarACLs(entityList):
  cal = buildGAPIObject(API.CALENDAR)
  csvPF, FJQC = _getCalendarPrintShowACLOptions(Ent.RESOURCE_CALENDAR, ['resourceId', 'resourceEmail'])
  i = 0
  count = len(entityList)
  for resourceId in entityList:
    i += 1
    calId = _validateResourceId(resourceId, i, count)
    if not calId:
      continue
    _printShowCalendarACLs(cal, resourceId, Ent.RESOURCE_CALENDAR, calId, i, count, csvPF, FJQC)
  if csvPF:
    csvPF.writeCSVfile('Resource Calendar ACLs')

def _showSchema(schema, i=0, count=0):
  printEntity([Ent.USER_SCHEMA, schema['schemaName']], i, count)
  Ind.Increment()
  for a_key in schema:
    if a_key not in {'kind', 'etag', 'schemaName', 'fields'}:
      printKeyValueList([a_key, schema[a_key]])
  for field in schema['fields']:
    printKeyValueList(['Field', field['fieldName']])
    Ind.Increment()
    for a_key in field:
      if a_key not in {'kind', 'etag', 'fieldName'}:
        printKeyValueList([a_key, field[a_key]])
    Ind.Decrement()
  Ind.Decrement()

SCHEMA_FIELDTYPE_CHOICE_MAP = {
  'bool': 'BOOL',
  'date': 'DATE',
  'double': 'DOUBLE',
  'email': 'EMAIL',
  'int64': 'INT64',
  'phone': 'PHONE',
  'string': 'STRING',
  }

# gam create schema|schemas <SchemaName> <SchemaFieldDefinition>+
# gam update schema|schemas <SchemaEntity> <SchemaFieldDefinition>+
def doCreateUpdateUserSchemas():
  cd = buildGAPIObject(API.DIRECTORY)
  updateCmd = Act.Get() == Act.UPDATE
  if not updateCmd:
    entityList = getStringReturnInList(Cmd.OB_SCHEMA_NAME)
  else:
    entityList = getEntityList(Cmd.OB_SCHEMA_ENTITY)
  addBody = {'schemaName': '', 'fields': []}
  deleteFields = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'field':
      a_field = {'fieldName': getString(Cmd.OB_FIELD_NAME), 'fieldType': 'STRING'}
      while Cmd.ArgumentsRemaining():
        argument = getArgument()
        if argument == 'type':
          a_field['fieldType'] = getChoice(SCHEMA_FIELDTYPE_CHOICE_MAP, mapChoice=True)
        elif argument in {'multivalued', 'multivalue'}:
          a_field['multiValued'] = True
        elif argument == 'indexed':
          a_field['indexed'] = True
        elif argument == 'restricted':
          a_field['readAccessType'] = 'ADMINS_AND_SELF'
        elif argument == 'range':
          a_field['numericIndexingSpec'] = {'minValue': getInteger(), 'maxValue': getInteger()}
        elif argument == 'endfield':
          break
        elif argument == 'field':
          Cmd.Backup()
          break
        else:
          unknownArgumentExit()
      addBody['fields'].append(a_field)
    elif updateCmd and myarg == 'deletefield':
      deleteFields.append(getString(Cmd.OB_FIELD_NAME))
    else:
      unknownArgumentExit()
  if not updateCmd and not addBody['fields']:
    missingArgumentExit('SchemaFieldDefinition')
  i = 0
  count = len(entityList)
  for schemaName in entityList:
    i += 1
    try:
      if updateCmd:
        oldBody = callGAPI(cd.schemas(), 'get',
                           throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                           customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaName, fields='schemaName,fields')
        for field in oldBody['fields']:
          field.pop('etag', None)
          field.pop('kind', None)
          field.pop('fieldId', None)
        badDelete = False
        for delField in deleteFields:
          fieldNameLower = delField.lower()
          for n, field in enumerate(oldBody['fields']):
            if field['fieldName'].lower() == fieldNameLower:
              del oldBody['fields'][n]
              break
          else:
            entityActionNotPerformedWarning([Ent.USER_SCHEMA, schemaName, Ent.FIELD, delField], Msg.DOES_NOT_EXIST)
            badDelete = True
        if badDelete:
          continue
        for addField in addBody['fields']:
          fieldNameLower = addField['fieldName'].lower()
          for n, field in enumerate(oldBody['fields']):
            if field['fieldName'].lower() == fieldNameLower:
              del oldBody['fields'][n]
              break
        oldBody['fields'].extend(addBody['fields'])
        if not oldBody['fields']:
          entityActionNotPerformedWarning([Ent.USER_SCHEMA, schemaName],
                                          Msg.SCHEMA_WOULD_HAVE_NO_FIELDS.format(Ent.Singular(Ent.USER_SCHEMA), Ent.Plural(Ent.FIELD)))
          continue
        result = callGAPI(cd.schemas(), 'update',
                          throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customerId=GC.Values[GC.CUSTOMER_ID], body=oldBody, schemaKey=schemaName)
        entityActionPerformed([Ent.USER_SCHEMA, result['schemaName']], i, count)
      else:
        addBody['schemaName'] = schemaName
        result = callGAPI(cd.schemas(), 'insert',
                          throwReasons=[GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          customerId=GC.Values[GC.CUSTOMER_ID], body=addBody, fields='schemaName')
        entityActionPerformed([Ent.USER_SCHEMA, result['schemaName']], i, count)
    except GAPI.duplicate:
      entityDuplicateWarning([Ent.USER_SCHEMA, schemaName], i, count)
    except GAPI.conditionNotMet as e:
      entityActionFailedWarning([Ent.USER_SCHEMA, schemaName], str(e), i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaName, i, count)

# gam delete schema|schemas <SchemaEntity>
def doDeleteUserSchemas():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      callGAPI(cd.schemas(), 'delete',
               throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
               customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaKey)
      entityActionPerformed([Ent.USER_SCHEMA, schemaKey], i, count)
    except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaKey, i, count)

# gam info schema|schemas <SchemaEntity>
def doInfoUserSchemas():
  cd = buildGAPIObject(API.DIRECTORY)
  entityList = getEntityList(Cmd.OB_SCHEMA_ENTITY)
  checkForExtraneousArguments()
  i = 0
  count = len(entityList)
  for schemaKey in entityList:
    i += 1
    try:
      schema = callGAPI(cd.schemas(), 'get',
                        throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                        customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaKey)
      _showSchema(schema, i, count)
    except (GAPI.invalid, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
      checkEntityAFDNEorAccessErrorExit(cd, Ent.USER_SCHEMA, schemaKey, i, count)

SCHEMAS_SORT_TITLES = ['schemaId', 'schemaName', 'displayName']
SCHEMAS_INDEXED_TITLES = ['fields']

# gam print schema|schemas [todrive <ToDriveAttribute>*]
# gam show schema|schemas
def doPrintShowUserSchemas():
  csvPF = CSVPrintFile(SCHEMAS_SORT_TITLES, 'sortall', SCHEMAS_INDEXED_TITLES) if Act.csvFormat() else None
  cd = buildGAPIObject(API.DIRECTORY)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  try:
    result = callGAPI(cd.schemas(), 'list',
                      throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                      customerId=GC.Values[GC.CUSTOMER_ID])
    jcount = len(result.get('schemas', [])) if (result) else 0
    if not csvPF:
      performActionNumItems(jcount, Ent.USER_SCHEMA)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    else:
      if not csvPF:
        Ind.Increment()
        j = 0
        for schema in result['schemas']:
          j += 1
          _showSchema(schema, j, jcount)
        Ind.Decrement()
      else:
        for schema in result['schemas']:
          csvPF.WriteRowTitles(flattenJSON(schema))
  except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
    accessErrorExit(cd)
  if csvPF:
    csvPF.writeCSVfile('User Schemas')

def formatVaultNameId(vaultName, vaultId):
  return f'{vaultName}({vaultId})'

def convertExportNameToID(v, nameOrId, matterId, matterNameId):
  cg = UID_PATTERN.match(nameOrId)
  if cg:
    try:
      export = callGAPI(v.matters().exports(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                        matterId=matterId, exportId=cg.group(1))
      return (export['id'], export['name'], formatVaultNameId(export['id'], export['name']))
    except (GAPI.notFound, GAPI.badRequest):
      entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, nameOrId])
    except GAPI.forbidden:
      ClientAPIAccessDeniedExit()
  nameOrIdlower = nameOrId.lower()
  try:
    exports = callGAPIpages(v.matters().exports(), 'list', 'exports',
                            throwReasons=[GAPI.FORBIDDEN],
                            matterId=matterId, fields='exports(id,name),nextPageToken')
  except GAPI.forbidden:
    ClientAPIAccessDeniedExit()
  for export in exports:
    if export['name'].lower() == nameOrIdlower:
      return (export['id'], export['name'], formatVaultNameId(export['id'], export['name']))
  entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, nameOrId])

def convertHoldNameToID(v, nameOrId, matterId, matterNameId):
  cg = UID_PATTERN.match(nameOrId)
  if cg:
    try:
      hold = callGAPI(v.matters().holds(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                      matterId=matterId, holdId=cg.group(1))
      return (hold['holdId'], hold['name'], formatVaultNameId(hold['holdId'], hold['name']))
    except (GAPI.notFound, GAPI.badRequest):
      entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, nameOrId])
    except GAPI.forbidden:
      ClientAPIAccessDeniedExit()
  nameOrIdlower = nameOrId.lower()
  try:
    holds = callGAPIpages(v.matters().holds(), 'list', 'holds',
                          throwReasons=[GAPI.FORBIDDEN],
                          matterId=matterId, fields='holds(holdId,name),nextPageToken')
  except GAPI.forbidden:
    ClientAPIAccessDeniedExit()
  for hold in holds:
    if hold['name'].lower() == nameOrIdlower:
      return (hold['holdId'], hold['name'], formatVaultNameId(hold['holdId'], hold['name']))
  entityDoesNotHaveItemExit([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, nameOrId])

def convertMatterNameToID(v, nameOrId):
  cg = UID_PATTERN.match(nameOrId)
  if cg:
    try:
      matter = callGAPI(v.matters(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                        matterId=cg.group(1), view='BASIC', fields='matterId,name,state')
      return (matter['matterId'], matter['name'], formatVaultNameId(matter['name'], matter['matterId']), matter['state'])
    except (GAPI.notFound, GAPI.forbidden):
      entityDoesNotExistExit(Ent.VAULT_MATTER, nameOrId)
  try:
    matters = callGAPIpages(v.matters(), 'list', 'matters',
                            throwReasons=[GAPI.FORBIDDEN],
                            view='BASIC', fields='matters(matterId,name,state),nextPageToken')
  except GAPI.forbidden:
    ClientAPIAccessDeniedExit()
  nameOrIdlower = nameOrId.lower()
  ids = []
  states = []
  for matter in matters:
    if matter['name'].lower() == nameOrIdlower:
      nameOrId = matter['name']
      ids.append(matter['matterId'])
      states.append(matter['state'])
  if len(ids) == 1:
    return (ids[0], nameOrId, formatVaultNameId(nameOrId, ids[0]), states[0])
  if not ids:
    entityDoesNotExistExit(Ent.VAULT_MATTER, nameOrId)
  else:
    entityIsNotUniqueExit(Ent.VAULT_MATTER, nameOrId, Ent.VAULT_MATTER_ID, ids)

def getMatterItem(v):
  matterId, _, matterNameId, _ = convertMatterNameToID(v, getString(Cmd.OB_MATTER_ITEM))
  return (matterId, matterNameId)

def warnMatterNotOpen(matter, matterNameId, j, jcount):
  printWarningMessage(DATA_NOT_AVALIABLE_RC, formatKeyValueList('',
                                                                Ent.FormatEntityValueList([Ent.VAULT_MATTER, matterNameId])+[Msg.MATTER_NOT_OPEN.format(matter['state'])],
                                                                currentCount(j, jcount)))

def _getExportOrgUnitName(export, cd):
  query = export.get('query')
  if query:
    if 'orgUnitInfo' in query:
      query['orgUnitInfo']['orgUnitPath'] = convertOrgUnitIDtoPath(query['orgUnitInfo']['orgUnitId'], cd)

VAULT_EXPORT_TIME_OBJECTS = {'versionDate', 'createTime', 'startTime', 'endTime'}

def _showVaultExport(export, cd):
  if cd is not None:
    _getExportOrgUnitName(export, cd)
  Ind.Increment()
  showJSON(None, export, timeObjects=VAULT_EXPORT_TIME_OBJECTS)
  Ind.Decrement()

VAULT_SEARCH_METHODS_MAP = {
  'account': 'ACCOUNT',
  'accounts': 'ACCOUNT',
  'entireorg': 'ENTIRE_ORG',
  'everyone': 'ENTIRE_ORG',
  'org': 'ORG_UNIT',
  'orgunit': 'ORG_UNIT',
  'ou': 'ORG_UNIT',
  'room': 'ROOM',
  'rooms': 'ROOM',
  'shareddrive': 'SHARED_DRIVE',
  'shareddrives': 'SHARED_DRIVE',
  'teamdrive': 'SHARED_DRIVE',
  'teamdrives': 'SHARED_DRIVE',
  }
VAULT_CORPUS_ARGUMENT_MAP = {
  'drive': 'DRIVE',
  'mail': 'MAIL',
  'groups': 'GROUPS',
  'hangoutschat': 'HANGOUTS_CHAT',
  }
VAULT_EXPORT_DATASCOPE_MAP = {
  'alldata': 'ALL_DATA',
  'helddata': 'HELD_DATA',
  'unprocesseddata': 'UNPROCESSED_DATA',
  }
VAULT_EXPORT_FORMAT_MAP = {
  'mbox': 'MBOX',
  'pst': 'PST',
  }
VAULT_EXPORT_REGION_MAP = {
  'any': 'ANY',
  'europe': 'EUROPE',
  'us': 'US',
  }
VAULT_CORPUS_OPTIONS_MAP = {
  'DRIVE': 'driveOptions',
  'MAIL': 'mailOptions',
  'GROUPS': 'groupsOptions',
  'HANGOUTS_CHAT': 'hangoutsChatOptions',
  }
VAULT_CORPUS_QUERY_MAP = {
  'DRIVE': 'driveQuery',
  'MAIL': 'mailQuery',
  'GROUPS': 'groupsQuery',
  'HANGOUTS_CHAT': 'hangoutsChatQuery',
  }

# gam create vaultexport|export matter <MatterItem> [name <String>] corpus drive|mail|groups|hangouts_chat
#	(accounts <EmailAddressEntity>) | (orgunit|org|ou <OrgUnitPath>) | (shareddrives|teamdrives <TeamDriveIDList>) | (rooms <RoomList>) | everyone
#	[scope <all_data|held_data|unprocessed_data>]
#	[terms <String>] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>] [timezone <TimeZone>]
#	[excludedrafts <Boolean>] [format mbox|pst] [showconfidentialmodecontent <Boolean>]
#	[includerooms <Boolean>]
#	[includeshareddrives|includeteamdrives <Boolean>] [driveversiondate <Date>|<Time>] [includeaccessinfo <Boolean>]
#	[region any|europe|us] [showdetails]
def doCreateVaultExport():
  v = buildGAPIObject(API.VAULT)
  matterId = None
  body = {'query': {'dataScope': 'ALL_DATA'}, 'exportOptions': {}}
  export_format = 'MBOX'
  showConfidentialModeContent = None
  showDetails = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      body['matterId'] = matterId
    elif myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    elif myarg == 'corpus':
      body['query']['corpus'] = getChoice(VAULT_CORPUS_ARGUMENT_MAP, mapChoice=True)
    elif myarg in VAULT_SEARCH_METHODS_MAP:
      if body['query'].get('searchMethod'):
        Cmd.Backup()
        usageErrorExit(Msg.MULTIPLE_SEARCH_METHODS_SPECIFIED.format(formatChoiceList(VAULT_SEARCH_METHODS_MAP)))
      searchMethod = VAULT_SEARCH_METHODS_MAP[myarg]
      body['query']['searchMethod'] = searchMethod
      if searchMethod == 'ACCOUNT':
        body['query']['accountInfo'] = {'emails': getNormalizedEmailAddressEntity()}
      elif searchMethod == 'ORG_UNIT':
        body['query']['orgUnitInfo'] = {'orgUnitId': getOrgUnitId()[1]}
      elif searchMethod == 'SHARED_DRIVE':
        body['query']['sharedDriveInfo'] = {'sharedDriveIds': getString(Cmd.OB_TEAMDRIVE_ID_LIST).replace(',', ' ').split()}
      elif searchMethod == 'ROOM':
        body['query']['hangoutsChatInfo'] = {'roomId': getString(Cmd.OB_ROOM_LIST).replace(',', ' ').split()}
    elif myarg == 'scope':
      body['query']['dataScope'] = getChoice(VAULT_EXPORT_DATASCOPE_MAP, mapChoice=True)
    elif myarg == 'terms':
      body['query']['terms'] = getString(Cmd.OB_STRING)
    elif myarg in {'start', 'starttime'}:
      body['query']['startTime'] = getTimeOrDeltaFromNow()
    elif myarg in {'end', 'endtime'}:
      body['query']['endTime'] = getTimeOrDeltaFromNow()
    elif myarg == 'timezone':
      body['query']['timeZone'] = getString(Cmd.OB_STRING)
    elif myarg == 'includerooms':
      body['query']['hangoutsChatOptions'] = {'includeRooms': getBoolean()}
    elif myarg == 'excludedrafts':
      body['query']['mailOptions'] = {'excludeDrafts': getBoolean()}
    elif myarg == 'format':
      export_format = getChoice(VAULT_EXPORT_FORMAT_MAP, mapChoice=True)
    elif myarg == 'region':
      body['exportOptions']['region'] = getChoice(VAULT_EXPORT_REGION_MAP, mapChoice=True)
    elif myarg == 'showconfidentialmodecontent':
      showConfidentialModeContent = getBoolean()
    elif myarg == 'driveversiondate':
      body['query'].setdefault('driveOptions', {})['versionDate'] = getTimeOrDeltaFromNow()
    elif myarg in {'includeshareddrives', 'includeteamdrives'}:
      body['query'].setdefault('driveOptions', {})['includeSharedDrives'] = getBoolean()
    elif myarg == 'includeaccessinfo':
      body['exportOptions'].setdefault('driveOptions', {})['includeAccessInfo'] = getBoolean()
    elif myarg == 'showdetails':
      showDetails = True
    else:
      unknownArgumentExit()
  if not matterId:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  if 'corpus' not in body['query']:
    missingArgumentExit(f'corpus {formatChoiceList(VAULT_CORPUS_ARGUMENT_MAP)}')
  if 'searchMethod' not in body['query']:
    missingArgumentExit(formatChoiceList(VAULT_SEARCH_METHODS_MAP))
  if 'name' not in body:
    body['name'] = f'GAM {body["query"]["corpus"]} Export - {ISOformatTimeStamp(todaysTime())}'
  if body['query']['corpus'] != 'DRIVE':
    body['exportOptions'].pop('driveOptions', None)
    body['exportOptions'][VAULT_CORPUS_OPTIONS_MAP[body['query']['corpus']]] = {'exportFormat': export_format}
    if body['query']['corpus'] == 'MAIL' and showConfidentialModeContent is not None:
      body['exportOptions'][VAULT_CORPUS_OPTIONS_MAP['MAIL']]['showConfidentialModeContent'] = showConfidentialModeContent
  try:
    export = callGAPI(v.matters().exports(), 'create',
                      throwReasons=[GAPI.ALREADY_EXISTS, GAPI.BAD_REQUEST, GAPI.BACKEND_ERROR,
                                    GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.QUOTA_EXCEEDED],
                      matterId=matterId, body=body)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, formatVaultNameId(export['name'], export['id'])])
    if showDetails:
      _showVaultExport(export, None)
  except (GAPI.alreadyExists, GAPI.badRequest, GAPI.backendError,
          GAPI.failedPrecondition, GAPI.forbidden, GAPI.quotaExceeded) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, body.get('name')], str(e))

# gam delete vaultexport|export <ExportItem> matter <MatterItem>
# gam delete vaultexport|export <MatterItem> <ExportItem>
def doDeleteVaultExport():
  v = buildGAPIObject(API.VAULT)
  if not Cmd.ArgumentIsAhead('matter'):
    matterId, matterNameId = getMatterItem(v)
    exportId, exportName, exportNameId = convertExportNameToID(v, getString(Cmd.OB_EXPORT_ITEM), matterId, matterNameId)
  else:
    exportName = getString(Cmd.OB_EXPORT_ITEM)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      exportId, exportName, exportNameId = convertExportNameToID(v, exportName, matterId, matterNameId)
    else:
      unknownArgumentExit()
  try:
    callGAPI(v.matters().exports(), 'delete',
             throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
             matterId=matterId, exportId=exportId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId])
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId], str(e))

VAULT_EXPORT_FIELDS_CHOICE_MAP = {
  'cloudstoragesink': 'cloudStorageSink',
  'createtime': 'createTime',
  'exportoptions': 'exportOptions',
  'id': 'id',
  'matterid': 'matterId',
  'name': 'name',
  'query': 'query',
  'requester': 'requester',
  'requester.displayname': 'requester.displayName',
  'requester.email': 'requester.email',
  'stats': 'stats',
  'stats.exportedartifactcount': 'stats.exportedArtifactCount',
  'stats.sizeinbytes': 'stats.sizeInBytes',
  'stats.totalartifactcount': 'stats.totalArtifactCount',
  'status': 'status',
  }

# gam info vaultexport|export <ExportItem> matter <MatterItem>
#	[fields <VaultExportFieldNameList>] [shownames]
# gam info vaultexport|export <MatterItem> <ExportItem>
#	[fields <VaultExportFieldNameList>] [shownames]
def doInfoVaultExport():
  v = buildGAPIObject(API.VAULT)
  if not Cmd.ArgumentIsAhead('matter'):
    matterId, matterNameId = getMatterItem(v)
    exportId, exportName, exportNameId = convertExportNameToID(v, getString(Cmd.OB_EXPORT_ITEM), matterId, matterNameId)
  else:
    exportName = getString(Cmd.OB_EXPORT_ITEM)
  cd = None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      exportId, exportName, exportNameId = convertExportNameToID(v, exportName, matterId, matterNameId)
    elif myarg == 'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    elif getFieldsList(myarg, VAULT_EXPORT_FIELDS_CHOICE_MAP, fieldsList, initialField=['id', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = getFieldsFromFieldsList(fieldsList)
  try:
    export = callGAPI(v.matters().exports(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                      matterId=matterId, exportId=exportId, fields=fields)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, formatVaultNameId(export['name'], export['id'])])
    _showVaultExport(export, cd)
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId], str(e))

VAULT_EXPORT_STATUS_MAP = {'completed': 'COMPLETED', 'failed': 'FAILED', 'inprogress': 'IN_PROGRESS'}
PRINT_VAULT_EXPORTS_TITLES = ['matterId', 'matterName', 'id', 'name']

# gam print vaultexports|exports [todrive <ToDriveAttribute>*]
#	[matters <MatterItemList>] [exportstatus <ExportStatusList>]
#	[fields <ValutExportFieldNameList>] [shownames]
# gam show vaultexports|exports
#	[matters <MatterItemList>] [exportstatus <ExportStatusList>]
#	[fields <VaultExportFieldNameList>] [shownames]
def doPrintShowVaultExports():
  v = buildGAPIObject(API.VAULT)
  csvPF = CSVPrintFile(PRINT_VAULT_EXPORTS_TITLES, 'sortall') if Act.csvFormat() else None
  matters = []
  exportStatusList = []
  cd = None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'matter', 'matters'}:
      matters = shlexSplitList(getString(Cmd.OB_MATTER_ITEM_LIST))
    elif myarg == 'exportstatus':
      for state in getString(Cmd.OB_STATE_NAME_LIST).lower().replace('_', '').replace(',', ' ').split():
        if state in VAULT_EXPORT_STATUS_MAP:
          exportStatusList.append(VAULT_EXPORT_STATUS_MAP[state])
        else:
          invalidChoiceExit(state, list(VAULT_EXPORT_STATUS_MAP), True)
    elif myarg == 'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    elif getFieldsList(myarg, VAULT_EXPORT_FIELDS_CHOICE_MAP, fieldsList, initialField=['id', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = getItemFieldsFromFieldsList('exports', fieldsList)
  exportStatuses = set(exportStatusList)
  exportQualifier = f' ({",".join(exportStatusList)})' if exportStatusList else ''
  if not matters:
    printGettingAllAccountEntities(Ent.VAULT_MATTER, qualifier=' (OPEN)')
    try:
      results = callGAPIpages(v.matters(), 'list', 'matters',
                              pageMessage=getPageMessage(),
                              throwReasons=[GAPI.FORBIDDEN],
                              view='BASIC', state='OPEN', fields='matters(matterId,name,state),nextPageToken')
    except GAPI.forbidden as e:
      entityActionFailedWarning([Ent.VAULT_EXPORT, None], str(e))
      return
  else:
    results = []
    for matter in matters:
      matterId, matterName, _, state = convertMatterNameToID(v, matter)
      results.append({'matterId': matterId, 'name': matterName, 'state': state})
  jcount = len(results)
  if not csvPF:
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  j = 0
  for matter in results:
    j += 1
    matterId = matter['matterId']
    matterName = matter['name']
    matterNameId = formatVaultNameId(matterName, matterId)
    if csvPF:
      printGettingAllEntityItemsForWhom(Ent.VAULT_EXPORT, f'{Ent.Singular(Ent.VAULT_MATTER)}: {matterNameId}',
                                        j, jcount, qualifier=exportQualifier)
      pageMessage = getPageMessageForWhom()
    else:
      pageMessage = None
    if matter['state'] == 'OPEN':
      try:
        exports = callGAPIpages(v.matters().exports(), 'list', 'exports',
                                pageMessage=pageMessage,
                                throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                                matterId=matterId, fields=fields)
      except GAPI.failedPrecondition:
        warnMatterNotOpen(matter, matterNameId, j, jcount)
        continue
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_EXPORT, None], str(e))
        break
    else:
      warnMatterNotOpen(matter, matterNameId, j, jcount)
      continue
    kcount = len(exports)
    if not csvPF:
      entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], kcount, Ent.VAULT_EXPORT, j, jcount)
      Ind.Increment()
      k = 0
      for export in exports:
        k += 1
        if not exportStatuses or export['status'] in exportStatuses:
          printEntity([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, formatVaultNameId(export['name'], export['id'])], k, kcount)
          _showVaultExport(export, cd)
      Ind.Decrement()
    else:
      for export in exports:
        if not exportStatuses or export['status'] in exportStatuses:
          if cd is not None:
            _getExportOrgUnitName(export, cd)
          csvPF.WriteRowTitles(flattenJSON(export, flattened={'matterId': matterId, 'matterName': matterName}, timeObjects=VAULT_EXPORT_TIME_OBJECTS))
  if csvPF:
    csvPF.writeCSVfile('Vault Exports')

def md5MatchesFile(filename, expected_md5, j=0, jcount=0):
  action = Act.Get()
  Act.Set(Act.VERIFY)
  try:
    f = openFile(filename, 'rb')
    hash_md5 = hashlib.md5()
    for chunk in iter(lambda: f.read(4096), b""):
      hash_md5.update(chunk)
    closeFile(f)
    actual_hash = hash_md5.hexdigest()
    if actual_hash == expected_md5:
      entityActionPerformed([Ent.FILE, filename, Ent.MD5HASH, expected_md5], j, jcount)
      Act.Set(action)
      return True
    entityActionFailedWarning([Ent.FILE, filename, Ent.MD5HASH, expected_md5], Msg.DOES_NOT_MATCH.format(actual_hash), j, jcount)
    Act.Set(action)
    return False
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(filename, e))

ZIP_EXTENSION_PATTERN = re.compile(r'^.*\.zip$', re.IGNORECASE)
COUNT_ZIP_EXTENSION_PATTERN = re.compile(r'^.*(-\d+\.zip)$', re.IGNORECASE)

# gam download vaultexport|export <ExportItem> matter <MatterItem> [targetfolder <FilePath>] [targetname <FileName>] [noverify] [noextract] [ziptostdout]
# gam download vaultexport|export <MatterItem> <ExportItem> [targetfolder <FilePath>] [targetname <FileName>] [noverify] [noextract] [ziptostdout]
def doDownloadVaultExport():
  def extract_nested_zip(zippedFile):
    """ Extract a zip file including any nested zip files
        Delete the zip file(s) after extraction
    """
    Act.Set(Act.UNZIP)
    performAction(Ent.FILE, zippedFile)
    Ind.Increment()
    with zipfile.ZipFile(zippedFile, 'r') as zfile:
      inner_files = zfile.infolist()
      for inner_file in inner_files:
        Act.Set(Act.EXTRACT)
        performAction(Ent.FILE, inner_file.filename)
        innerFilePath = zfile.extract(inner_file, targetFolder)
        if ZIP_EXTENSION_PATTERN.match(inner_file.filename):
          extract_nested_zip(innerFilePath)
    Ind.Decrement()
    try:
      os.remove(zippedFile)
    except OSError as e:
      stderrWarningMsg(e)

  v = buildGAPIObject(API.VAULT)
  s = buildGAPIObject(API.STORAGE)
  verifyFiles = extractFiles = True
  targetFolder = GC.Values[GC.DRIVE_DIR]
  targetName = None
  if not Cmd.ArgumentIsAhead('matter'):
    matterId, matterNameId = getMatterItem(v)
    exportId, exportName, exportNameId = convertExportNameToID(v, getString(Cmd.OB_EXPORT_ITEM), matterId, matterNameId)
  else:
    exportName = getString(Cmd.OB_EXPORT_ITEM)
  zipToStdout = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      exportId, exportName, exportNameId = convertExportNameToID(v, exportName, matterId, matterNameId)
    elif myarg == 'targetname':
      targetName = getString(Cmd.OB_FILE_NAME)
    elif myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == 'noverify':
      verifyFiles = False
    elif myarg == 'noextract':
      extractFiles = False
    elif myarg == 'ziptostdout':
      zipToStdout = True
      verifyFiles = extractFiles = False
    else:
      unknownArgumentExit()
  try:
    export = callGAPI(v.matters().exports(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                      matterId=matterId, exportId=exportId)
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId], str(e))
    return
  if export['status'] != 'COMPLETED':
    entityActionNotPerformedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId], Msg.EXPORT_NOT_COMPLETE.format(export['status']))
    return
  jcount = len(export['cloudStorageSink']['files'])
  if not zipToStdout:
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_EXPORT, exportNameId], jcount, Ent.CLOUD_STORAGE_FILE)
  Ind.Increment()
  j = 0
  for s_file in export['cloudStorageSink']['files']:
    j += 1
    bucket = s_file['bucketName']
    s_object = s_file['objectName']
    filename = os.path.join(targetFolder, s_object.replace('/', '-'))
    if zipToStdout and not ZIP_EXTENSION_PATTERN.match(filename):
      continue
    if targetName:
      _, s_objectFilename = s_object.rsplit('/', 1)
      mg = COUNT_ZIP_EXTENSION_PATTERN.match(s_objectFilename)
      if mg:
        s_objectExtension = mg.group(1)
      else:
        _, s_objectExtension = s_objectFilename.rsplit('.', 1)
        s_objectExtension = '.'+s_objectExtension
      if targetName.find('#') == -1:
        filename = targetName+s_objectExtension
      else:
        filename = targetName.replace('#objectname#', s_object).replace('#filename#', s_objectFilename).replace('#extension#', s_objectExtension)
      filename = os.path.join(targetFolder, filename.replace('/', '-'))
    Act.Set(Act.DOWNLOAD)
    if not zipToStdout:
      performAction(Ent.CLOUD_STORAGE_FILE, s_object, j, jcount)
    Ind.Increment()
    try:
      request = s.objects().get_media(bucket=bucket, object=s_object)
      f = openFile(filename if not zipToStdout else '-', 'wb')
      downloader = googleapiclient.http.MediaIoBaseDownload(f, request)
      done = False
      while not done:
        status, done = downloader.next_chunk()
        if not zipToStdout:
          entityActionPerformedMessage([Ent.CLOUD_STORAGE_FILE, s_object], f'{status.progress():>7.2%}', j, jcount)
      if not zipToStdout:
        entityModifierNewValueActionPerformed([Ent.CLOUD_STORAGE_FILE, s_object], Act.MODIFIER_TO, filename, j, jcount)
      if not zipToStdout:
        closeFile(f, True)
      if verifyFiles:
        if not md5MatchesFile(filename, s_file['md5Hash'], j, jcount):
          Ind.Decrement()
          break
      if extractFiles and ZIP_EXTENSION_PATTERN.match(filename):
        Act.Set(Act.EXTRACT)
        extract_nested_zip(filename)
        Act.Set(Act.DOWNLOAD)
    except httplib2.HttpLib2Error as e:
      entityModifierNewValueActionFailedWarning([Ent.CLOUD_STORAGE_FILE, s_object], Act.MODIFIER_TO, filename, str(e), j, jcount)
    Ind.Decrement()
  Ind.Decrement()

def _getCloudStorageObject(s, bucket, s_object, local_file=None, expectedMd5=None):
  if not local_file:
    local_file = s_object
  entityValueList = [Ent.DRIVE_FILE, local_file]
  if os.path.exists(local_file):
    printEntityMessage(entityValueList, Msg.EXISTS)
    if not expectedMd5:
      return # nothing to verify, just assume we're good.
    if md5MatchesFile(local_file, expectedMd5):
      return
    printEntityMessage(entityValueList, Msg.DOWNLOADING_AGAIN_AND_OVER_WRITING)
  entityPerformAction(entityValueList)
  request = s.objects().get_media(bucket=bucket, object=s_object)
  file_path = os.path.dirname(local_file)
  if not os.path.exists(file_path):
    os.makedirs(file_path)
  f = openFile(local_file, 'wb')
  downloader = googleapiclient.http.MediaIoBaseDownload(f, request)
  done = False
  while not done:
    status, done = downloader.next_chunk()
    entityActionPerformedMessage(entityValueList, f'{status.progress():>7.2%}')
  entityModifierNewValueActionPerformed([Ent.CLOUD_STORAGE_FILE, s_object], Act.MODIFIER_TO, local_file)
  closeFile(f, True)
  if expectedMd5 and not md5MatchesFile(local_file, expectedMd5):
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(local_file, Msg.CORRUPT_FILE))

TAKEOUT_EXPORT_PATTERN = re.compile(r'(takeout-export-[a-f,0-9,-]*)')

def doDownloadCloudStorageBucket():
  bucket_url = getString(Cmd.OB_URL)
  checkForExtraneousArguments()
  bucket_match = re.search(TAKEOUT_EXPORT_PATTERN, bucket_url)
  if not bucket_match:
    systemErrorExit(ACTION_NOT_PERFORMED_RC, f'Could not find a takeout-export-* bucket in {bucket_url}')
  bucket = bucket_match.group(1)
  s = buildGAPIObject(API.STORAGE)
  printGettingAllAccountEntities(Ent.FILE)
  pageMessage = getPageMessage()
  objects = callGAPIpages(s.objects(), 'list', 'items',
                          pageMessage=pageMessage, bucket=bucket, projection='noAcl', fields='nextPageToken,items(name,id,md5Hash)')
  count = len(objects)
  i = 0
  for s_object in objects:
    i += 1
    printGettingEntityItem(Ent.FILE, s_object['name'], i, count)
    expectedMd5 = base64.b64decode(s_object['md5Hash']).hex()
    _getCloudStorageObject(s, bucket, s_object['name'], expectedMd5=expectedMd5)

def _getHoldEmailAddressesOrgUnitName(hold, cd):
  if 'accounts' in hold:
    accountType = 'group' if hold['corpus'] == 'GROUPS' else 'user'
    for i in range(0, len(hold['accounts'])):
      hold['accounts'][i]['email'] = convertUIDtoEmailAddress(f'uid:{hold["accounts"][i]["accountId"]}', cd, accountType)
  if 'orgUnit' in hold:
    hold['orgUnit']['orgUnitPath'] = convertOrgUnitIDtoPath(hold['orgUnit']['orgUnitId'], cd)

VAULT_HOLD_TIME_OBJECTS = {'holdTime', 'updateTime', 'startTime', 'endTime'}

def _showVaultHold(hold, cd):
  if cd is not None:
    _getHoldEmailAddressesOrgUnitName(hold, cd)
  Ind.Increment()
  showJSON(None, hold, timeObjects=VAULT_HOLD_TIME_OBJECTS)
  Ind.Decrement()

def _getHoldQueryParameters(myarg, queryParameters):
  if myarg == 'query':
    queryParameters['queryLocation'] = Cmd.Location()
    queryParameters['query'] = getString(Cmd.OB_QUERY)
  elif myarg == 'terms':
    queryParameters['terms'] = getString(Cmd.OB_STRING)
  elif myarg in {'start', 'starttime'}:
    queryParameters['startTime'] = getTimeOrDeltaFromNow()
  elif myarg in {'end', 'endtime'}:
    queryParameters['endTime'] = getTimeOrDeltaFromNow()
  elif myarg == 'includerooms':
    queryParameters['includeRooms'] = getBoolean()
  elif myarg in {'includeshareddrives', 'includeteamdrives'}:
    queryParameters['includeSharedDriveFiles'] = getBoolean()
  else:
    return False
  return True

def _setHoldQuery(body, queryParameters):
  queryType = VAULT_CORPUS_QUERY_MAP[body['corpus']]
  body['query'] = {queryType: {}}
  if body['corpus'] == 'DRIVE':
    if queryParameters.get('query'):
      try:
        body['query'][queryType] = json.loads(queryParameters['query'])
      except (IndexError, KeyError, SyntaxError, TypeError, ValueError) as e:
        Cmd.SetLocation(queryParameters['queryLocation'])
        usageErrorExit(f'{str(e)}: {queryParameters["query"]}')
    elif queryParameters.get('includeSharedDriveFiles'):
      body['query'][queryType]['includeSharedDriveFiles'] = queryParameters['includeSharedDriveFiles']
  elif body['corpus'] in {'GROUPS', 'MAIL'}:
    if queryParameters.get('query'):
      body['query'][queryType]['terms'] = queryParameters['query']
    elif queryParameters.get('terms'):
      body['query'][queryType]['terms'] = queryParameters['terms']
    if queryParameters.get('startTime'):
      body['query'][queryType]['startTime'] = queryParameters['startTime']
    if queryParameters.get('endTime'):
      body['query'][queryType]['endTime'] = queryParameters['endTime']
  elif body['corpus'] == 'HANGOUTS_CHAT':
    if queryParameters.get('includeRooms'):
      body['query'][queryType]['includeRooms'] = queryParameters['includeRooms']

# gam create vaulthold|hold matter <MatterItem> [name <String>] corpus drive|mail|groups|hangouts_chat
#	[(accounts|groups|users <EmailItemList>) | (orgunit|org|ou <OrgUnit>)]
#	[query <QueryVaultCorpus>]
#	[terms <String>] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
#	[includerooms <Boolean>]
#	[includeshareddrives|includeteamdrives <Boolean>]
#	[showdetails]
def doCreateVaultHold():
  v = buildGAPIObject(API.VAULT)
  body = {}
  matterId = None
  accounts = []
  queryParameters = {}
  showDetails = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
    elif myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    elif myarg == 'corpus':
      body['corpus'] = getChoice(VAULT_CORPUS_ARGUMENT_MAP, mapChoice=True)
    elif myarg in {'accounts', 'users', 'groups'}:
      accountsLocation = Cmd.Location()
      accounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    elif myarg in {'orgunit', 'org', 'ou'}:
      body['orgUnit'] = {'orgUnitId': getOrgUnitId()[1]}
    elif _getHoldQueryParameters(myarg, queryParameters):
      pass
    elif myarg == 'showdetails':
      showDetails = True
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  if not body.get('corpus'):
    missingArgumentExit(f'corpus {"|".join(VAULT_CORPUS_ARGUMENT_MAP)}')
  if 'name' not in body:
    body['name'] = f'GAM {body["corpus"]} Hold - {ISOformatTimeStamp(todaysTime())}'
  _setHoldQuery(body, queryParameters)
  if accounts:
    body['accounts'] = []
    cd = buildGAPIObject(API.DIRECTORY)
    accountType = 'group' if body['corpus'] == 'GROUPS' else 'user'
    for account in accounts:
      body['accounts'].append({'accountId': convertEmailAddressToUID(account, cd, accountType, accountsLocation)})
  try:
    hold = callGAPI(v.matters().holds(), 'create',
                    throwReasons=[GAPI.ALREADY_EXISTS, GAPI.BAD_REQUEST, GAPI.BACKEND_ERROR, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                    matterId=matterId, body=body)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatVaultNameId(hold['name'], hold['holdId'])])
    if showDetails:
      _showVaultHold(hold, None)
  except (GAPI.alreadyExists, GAPI.badRequest, GAPI.backendError, GAPI.failedPrecondition, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, body.get('name')], str(e))

# gam update vaulthold|hold <HoldItem> matter <MatterItem>
#	[([addaccounts|addgroups|addusers <EmailItemList>] [removeaccounts|removegroups|removeusers <EmailItemList>]) | (orgunit|org|ou <OrgUnit>)]
#	[query <QueryVaultCorpus>]
#	[terms <String>] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
#	[includerooms <Boolean>]
#	[includeshareddrives|includeteamdrives <Boolean>]
#	[showdetails]
def doUpdateVaultHold():
  v = buildGAPIObject(API.VAULT)
  holdName = getString(Cmd.OB_HOLD_ITEM)
  body = {}
  cd = matterId = None
  addAccounts = []
  addAccountIds = []
  removeAccounts = []
  removeAccountIds = []
  queryParameters = {}
  showDetails = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    elif myarg in {'addusers', 'addaccounts', 'addgroups'}:
      addAccountsLocation = Cmd.Location()
      addAccounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    elif myarg in {'removeusers', 'removeaccounts', 'removegroups'}:
      removeAccountsLocation = Cmd.Location()
      removeAccounts = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
    elif myarg in {'orgunit', 'org', 'ou'}:
      body['orgUnit'] = {'orgUnitId': getOrgUnitId()[1]}
    elif _getHoldQueryParameters(myarg, queryParameters):
      pass
    elif myarg == 'showdetails':
      showDetails = True
    else:
      unknownArgumentExit()
  if matterId is None:
    missingArgumentExit(Cmd.OB_MATTER_ITEM)
  try:
    old_body = callGAPI(v.matters().holds(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                        matterId=matterId, holdId=holdId, fields='name,corpus,query,orgUnit')
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))
    return
  accountType = 'group' if old_body['corpus'] == 'GROUPS' else 'user'
  if addAccounts:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    for account in addAccounts:
      addAccountIds.append({'email': account, 'id': convertEmailAddressToUID(account, cd, accountType, addAccountsLocation)})
  if removeAccounts:
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    for account in removeAccounts:
      removeAccountIds.append({'email': account, 'id': convertEmailAddressToUID(account, cd, accountType, removeAccountsLocation)})
  if queryParameters or body.get('orgUnit'):
    body['corpus'] = old_body['corpus']
    if 'orgUnit' in old_body and 'orgUnit' not in body:
      # bah, API requires this to be sent on update even when it's not changing
      body['orgUnit'] = old_body['orgUnit']
    if queryParameters:
      _setHoldQuery(body, queryParameters)
    else:
      body['query'] = old_body['query']
  if body:
    try:
      hold = callGAPI(v.matters().holds(), 'update',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                      matterId=matterId, holdId=holdId, body=body)
      entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId])
    except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))
      return
  jcount = len(addAccountIds)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], jcount, Ent.ACCOUNT)
    Ind.Increment()
    j = 0
    for account in addAccountIds:
      j += 1
      try:
        callGAPI(v.matters().holds().accounts(), 'create',
                 throwReasons=[GAPI.ALREADY_EXISTS, GAPI.BACKEND_ERROR, GAPI.FORBIDDEN],
                 matterId=matterId, holdId=holdId, body={'accountId': account['id']})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account['email']], j, jcount)
      except (GAPI.alreadyExists, GAPI.backendError) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account['email']], str(e), j, jcount)
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, None], str(e))
        return
    Ind.Decrement()
  jcount = len(removeAccountIds)
  if jcount > 0:
    Act.Set(Act.REMOVE)
    if cd is None:
      cd = buildGAPIObject(API.DIRECTORY)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], jcount, Ent.ACCOUNT)
    Ind.Increment()
    j = 0
    for account in removeAccountIds:
      j += 1
      try:
        callGAPI(v.matters().holds().accounts(), 'delete',
                 throwReasons=[GAPI.NOT_FOUND, GAPI.BACKEND_ERROR, GAPI.FORBIDDEN],
                 matterId=matterId, holdId=holdId, accountId=account['id'])
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account['email']], j, jcount)
      except (GAPI.alreadyExists, GAPI.backendError) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId, Ent.ACCOUNT, account['email']], str(e), j, jcount)
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, None], str(e))
        return
    Ind.Decrement()
  if showDetails:
    _showVaultHold(hold, cd)

# gam delete vaulthold|hold <HoldItem> matter <MatterItem>
# gam delete vaulthold|hold <MatterItem> <HoldItem>
def doDeleteVaultHold():
  v = buildGAPIObject(API.VAULT)
  if not Cmd.ArgumentIsAhead('matter'):
    matterId, matterNameId = getMatterItem(v)
    holdId, holdName, holdNameId = convertHoldNameToID(v, getString(Cmd.OB_HOLD_ITEM), matterId, matterNameId)
  else:
    holdName = getString(Cmd.OB_HOLD_ITEM)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    else:
      unknownArgumentExit()
  try:
    callGAPI(v.matters().holds(), 'delete',
             throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
             matterId=matterId, holdId=holdId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId])
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))

VAULT_HOLD_FIELDS_CHOICE_MAP = {
  'accounts': 'accounts',
  'accounts.acountid': 'accounts.accountId',
  'accounts.email': 'accounts.email',
  'accounts.firstname': 'accounts.firstName',
  'accounts.holdtime': 'accounts.holdTime',
  'accounts.lastname': 'accounts.lastName',
  'corpus': 'corpus',
  'holdid': 'holdId',
  'name': 'name',
  'orgunit': 'orgUnit',
  'orgunit.holdtime': 'orgUnit.holdTime',
  'orgunit.ordunitid': 'orgUnit.orgUnitId',
  'query': 'query',
  'updatetime': 'updateTime',
  }

# gam info vaulthold|hold <HoldItem> matter <MatterItem>
#	[fields <VaultHoldFieldNameList>] [shownames]
# gam info vaulthold|hold <MatterItem> <HoldItem>
#	[fields <VaultHoldFieldNameList>] [shownames]
def doInfoVaultHold():
  v = buildGAPIObject(API.VAULT)
  if not Cmd.ArgumentIsAhead('matter'):
    matterId, matterNameId = getMatterItem(v)
    holdId, holdName, holdNameId = convertHoldNameToID(v, getString(Cmd.OB_HOLD_ITEM), matterId, matterNameId)
  else:
    holdName = getString(Cmd.OB_HOLD_ITEM)
  cd = None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'matter':
      matterId, matterNameId = getMatterItem(v)
      holdId, holdName, holdNameId = convertHoldNameToID(v, holdName, matterId, matterNameId)
    elif myarg == 'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    elif getFieldsList(myarg, VAULT_HOLD_FIELDS_CHOICE_MAP, fieldsList, initialField=['holdId', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = getFieldsFromFieldsList(fieldsList)
  try:
    hold = callGAPI(v.matters().holds(), 'get',
                    throwReasons=[GAPI.NOT_FOUND, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                    matterId=matterId, holdId=holdId, fields=fields)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatVaultNameId(hold['name'], hold['holdId'])])
    _showVaultHold(hold, cd)
  except (GAPI.notFound, GAPI.badRequest, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, holdNameId], str(e))

PRINT_VAULT_HOLDS_TITLES = ['matterId', 'matterName', 'holdId', 'name']

# gam print vaultholds|holds [todrive <ToDriveAttribute>*] [matters <MatterItemList>]
#	[fields <VaultHoldFieldNameList>] [shownames]
# gam show vaultholds|holds [matters <MatterItemList>]
#	[fields <VaultHoldFieldNameList>] [shownames]
def doPrintShowVaultHolds():
  v = buildGAPIObject(API.VAULT)
  csvPF = CSVPrintFile(PRINT_VAULT_HOLDS_TITLES, 'sortall') if Act.csvFormat() else None
  matters = []
  cd = None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'matter', 'matters'}:
      matters = shlexSplitList(getString(Cmd.OB_MATTER_ITEM_LIST))
    elif myarg == 'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
    elif getFieldsList(myarg, VAULT_HOLD_FIELDS_CHOICE_MAP, fieldsList, initialField=['holdId', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = getItemFieldsFromFieldsList('holds', fieldsList)
  if not matters:
    printGettingAllAccountEntities(Ent.VAULT_MATTER, qualifier=' (OPEN)')
    try:
      results = callGAPIpages(v.matters(), 'list', 'matters',
                              pageMessage=getPageMessage(),
                              throwReasons=[GAPI.FORBIDDEN],
                              view='BASIC', state='OPEN', fields='matters(matterId,name,state),nextPageToken')
    except GAPI.forbidden as e:
      entityActionFailedWarning([Ent.VAULT_HOLD, None], str(e))
      return
  else:
    results = []
    for matter in matters:
      matterId, matterName, _, state = convertMatterNameToID(v, matter)
      results.append({'matterId': matterId, 'name': matterName, 'state': state})
  jcount = len(results)
  if not csvPF:
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  j = 0
  for matter in results:
    j += 1
    matterId = matter['matterId']
    matterName = matter['name']
    matterNameId = formatVaultNameId(matterName, matterId)
    if csvPF:
      printGettingAllEntityItemsForWhom(Ent.VAULT_HOLD, f'{Ent.Singular(Ent.VAULT_MATTER)}: {matterNameId}', j, jcount)
      pageMessage = getPageMessageForWhom()
    else:
      pageMessage = None
    if matter['state'] == 'OPEN':
      try:
        holds = callGAPIpages(v.matters().holds(), 'list', 'holds',
                              pageMessage=pageMessage,
                              throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                              matterId=matterId, fields=fields)
      except GAPI.failedPrecondition:
        warnMatterNotOpen(matter, matterNameId, j, jcount)
        continue
      except GAPI.forbidden as e:
        entityActionFailedWarning([Ent.VAULT_HOLD, None], str(e))
        break
    else:
      warnMatterNotOpen(matter, matterNameId, j, jcount)
      continue
    kcount = len(holds)
    if not csvPF:
      entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], kcount, Ent.VAULT_HOLD, j, jcount)
      Ind.Increment()
      k = 0
      for hold in holds:
        k += 1
        printEntity([Ent.VAULT_MATTER, matterNameId, Ent.VAULT_HOLD, formatVaultNameId(hold['name'], hold['holdId'])], k, kcount)
        _showVaultHold(hold, cd)
      Ind.Decrement()
    else:
      for hold in holds:
        if cd is not None:
          _getHoldEmailAddressesOrgUnitName(hold, cd)
        csvPF.WriteRowTitles(flattenJSON(hold, flattened={'matterId': matterId, 'matterName': matterName}, timeObjects=VAULT_HOLD_TIME_OBJECTS))
  if csvPF:
    csvPF.writeCSVfile('Vault Holds')

def validateCollaborators(cd):
  collaborators = []
  for collaborator in getEntityList(Cmd.OB_COLLABORATOR_ENTITY):
    collaborators.append({'email': collaborator, 'id': convertEmailAddressToUID(collaborator, cd)})
  return collaborators

def _showVaultMatter(matter, cd):
  if 'matterPermissions' in matter:
    for i in range(0, len(matter['matterPermissions'])):
      matter['matterPermissions'][i]['email'] = convertUIDtoEmailAddress(f'uid:{matter["matterPermissions"][i]["accountId"]}', cd)
  Ind.Increment()
  showJSON(None, matter)
  Ind.Decrement()

# gam create vaultmatter|matter [name <String>] [description <string>]
#	[collaborator|collaborators <CollaboratorItemList>] [sendemails <Boolean>] [ccme <Boolean>]
#	[showdetails]
def doCreateVaultMatter():
  v = buildGAPIObject(API.VAULT)
  body = {}
  cbody = {'matterPermission': {'role': 'COLLABORATOR', 'accountId': ''}, 'sendEmails': False, 'ccMe': False}
  collaborators = []
  cd = None
  showDetails = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    elif myarg == 'description':
      body['description'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in {'collaborator', 'collaborators'}:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      collaborators.extend(validateCollaborators(cd))
    elif myarg == 'sendemails':
      cbody['sendEmails'] = getBoolean()
    elif myarg == 'ccme':
      cbody['ccMe'] = getBoolean()
    elif myarg == 'showdetails':
      showDetails = True
    else:
      unknownArgumentExit()
  if 'name' not in body:
    body['name'] = f'GAM Matter - {ISOformatTimeStamp(todaysTime())}'
  try:
    matter = callGAPI(v.matters(), 'create',
                      throwReasons=[GAPI.ALREADY_EXISTS, GAPI.FORBIDDEN],
                      body=body)
    matterId = matter['matterId']
    matterNameId = formatVaultNameId(matter['name'], matterId)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
  except (GAPI.alreadyExists, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, body['name']], str(e))
    return
  jcount = len(collaborators)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in collaborators:
      j += 1
      cbody['matterPermission']['accountId'] = collaborator['id']
      try:
        callGAPI(v.matters(), 'addPermissions',
                 throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body=cbody)
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator['email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()
  if showDetails:
    _showVaultMatter(matter, cd)

VAULT_MATTER_ACTIONS = {
  'close': Act.CLOSE,
  'reopen': Act.REOPEN,
  'delete': Act.DELETE,
  'undelete': Act.UNDELETE,
  }

def doActionVaultMatter(action, matterId=None, matterNameId=None, v=None):
  if v is None:
    v = buildGAPIObject(API.VAULT)
    matterId, matterNameId = getMatterItem(v)
  else:
    Act.Set(VAULT_MATTER_ACTIONS[action])
  checkForExtraneousArguments()
  action_kwargs = {} if action == 'delete' else {'body': {}}
  try:
    callGAPI(v.matters(), action,
             throwReasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
             matterId=matterId, **action_kwargs)
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
  except (GAPI.notFound, GAPI.failedPrecondition, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))

# gam close vaultmatter|matter <MatterItem>
def doCloseVaultMatter():
  doActionVaultMatter('close')

# gam reopen vaultmatter|matter <MatterItem>
def doReopenVaultMatter():
  doActionVaultMatter('reopen')

# gam delete vaultmatter|matter <MatterItem>
def doDeleteVaultMatter():
  doActionVaultMatter('delete')

# gam undelete vaultmatter|matter <MatterItem>
def doUndeleteVaultMatter():
  doActionVaultMatter('undelete')

# gam update vaultmatter|matter <MatterItem> [name <String>] [description <string>]
#	[addcollaborator|addcollaborators <CollaboratorItemList>] [removecollaborator|removecollaborators <CollaboratorItemList>]
def doUpdateVaultMatter():
  v = buildGAPIObject(API.VAULT)
  matterId, matterNameId = getMatterItem(v)
  body = {}
  addCollaborators = []
  removeCollaborators = []
  cd = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'action':
      action = getChoice(VAULT_MATTER_ACTIONS)
      doActionVaultMatter(action, matterId, matterNameId, v)
      return
    if myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    elif myarg == 'description':
      body['description'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in {'addcollaborator', 'addcollaborators'}:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      addCollaborators.extend(validateCollaborators(cd))
    elif myarg in {'removecollaborator', 'removecollaborators'}:
      if not cd:
        cd = buildGAPIObject(API.DIRECTORY)
      removeCollaborators.extend(validateCollaborators(cd))
    else:
      unknownArgumentExit()
  if body:
    try:
      if 'name' not in body or 'description' not in body:
        # bah, API requires name/description to be sent on update even when it's not changing
        result = callGAPI(v.matters(), 'get',
                          throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                          matterId=matterId, view='BASIC')
        body.setdefault('name', result['name'])
        body.setdefault('description', result.get('description'))
      callGAPI(v.matters(), 'update',
               throwReasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
               matterId=matterId, body=body)
      entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
    except (GAPI.notFound, GAPI.failedPrecondition, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
      return
  jcount = len(addCollaborators)
  if jcount > 0:
    Act.Set(Act.ADD)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in addCollaborators:
      j += 1
      try:
        callGAPI(v.matters(), 'addPermissions',
                 throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body={'matterPermission': {'role': 'COLLABORATOR', 'accountId': collaborator['id']}})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator['email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()
  jcount = len(removeCollaborators)
  if jcount > 0:
    Act.Set(Act.REMOVE)
    entityPerformActionNumItems([Ent.VAULT_MATTER, matterNameId], jcount, Ent.COLLABORATOR)
    Ind.Increment()
    j = 0
    for collaborator in removeCollaborators:
      j += 1
      try:
        callGAPI(v.matters(), 'removePermissions',
                 throwReasons=[GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN],
                 matterId=matterId, body={'accountId': collaborator['id']})
        entityActionPerformed([Ent.VAULT_MATTER, matterNameId, Ent.COLLABORATOR, collaborator['email']], j, jcount)
      except (GAPI.failedPrecondition, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))
        break
    Ind.Decrement()

VAULT_MATTER_FIELDS_CHOICE_MAP = {
  'matterid': 'matterId',
  'name': 'name',
  'description': 'description',
  'state': 'state',
  'matterpermissions': 'matterPermissions',
  }

# gam info vaultmatter|matter <MatterItem>
#	[basic|full|(fields <VaultMatterFieldNameList>)]
def doInfoVaultMatter():
  v = buildGAPIObject(API.VAULT)
  matterId, matterNameId = getMatterItem(v)
  fieldsList = []
  view = 'FULL'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in PROJECTION_CHOICE_MAP:
      view = PROJECTION_CHOICE_MAP[myarg]
    elif getFieldsList(myarg, VAULT_MATTER_FIELDS_CHOICE_MAP, fieldsList, initialField=['matterId', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = getFieldsFromFieldsList(fieldsList)
  try:
    matter = callGAPI(v.matters(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      matterId=matterId, view=view, fields=fields)
    cd = buildGAPIObject(API.DIRECTORY) if 'matterPermissions' in matter else None
    entityActionPerformed([Ent.VAULT_MATTER, matterNameId])
    _showVaultMatter(matter, cd)
  except (GAPI.notFound, GAPI.forbidden) as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, matterNameId], str(e))

VAULT_MATTER_STATE_MAP = {'open': 'OPEN', 'closed': 'CLOSED', 'deleted': 'DELETED'}
PRINT_VAULT_MATTERS_TITLES = ['matterId', 'name']

# gam print vaultmatters|matters [todrive <ToDriveAttribute>*] [matterstate <MatterStateList>]
#	[basic|full|(fields <VaultMatterFieldNameList>)]
# gam show vaultmatters|matters [matterstate <MatterStateList>]
#	[basic|full|(fields <VaultMatterFieldNameList>)]
def doPrintShowVaultMatters():
  def getPermissionEmails(matter):
    for matterPermission in matter.get('matterPermissions', []):
      userId = matterPermission['accountId']
      userEmail = emails.get(userId)
      if userEmail is None:
        try:
          userEmail = callGAPI(cd.users(), 'get',
                               throwReasons=GAPI.USER_GET_THROW_REASONS,
                               userKey=userId, fields='primaryEmail').get('primaryEmail')
        except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
          userEmail = 'Unknown user'
        emails[userId] = userEmail
      matterPermission['email'] = emails[userId]

  v = buildGAPIObject(API.VAULT)
  csvPF = CSVPrintFile(PRINT_VAULT_MATTERS_TITLES, 'sortall') if Act.csvFormat() else None
  fieldsList = []
  view = 'FULL'
  matterStatesList = []
  emails = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'matterstate':
      fieldsList.append('state')
      for state in getString(Cmd.OB_STATE_NAME_LIST).lower().replace('_', '').replace(',', ' ').split():
        if state in VAULT_MATTER_STATE_MAP:
          matterStatesList.append(VAULT_MATTER_STATE_MAP[state])
        else:
          invalidChoiceExit(state, list(VAULT_MATTER_STATE_MAP), True)
    elif myarg in PROJECTION_CHOICE_MAP:
      view = PROJECTION_CHOICE_MAP[myarg]
    elif getFieldsList(myarg, VAULT_MATTER_FIELDS_CHOICE_MAP, fieldsList, initialField=['matterId', 'name']):
      pass
    else:
      unknownArgumentExit()
  fields = f'nextPageToken,matters({getFieldsFromFieldsList(fieldsList)})' if fieldsList else None
  # If no states are set, there is no filtering; if 1 state is set, the API can filter; else GAM filters
  matterStates = set()
  stateParm = None
  if matterStatesList:
    if len(matterStatesList) == 1:
      stateParm = matterStatesList[0]
    else:
      matterStates = set(matterStatesList)
    qualifier = f' ({",".join(matterStatesList)})'
  else:
    qualifier = ''
  printGettingAllAccountEntities(Ent.VAULT_MATTER, qualifier=qualifier)
  try:
    matters = callGAPIpages(v.matters(), 'list', 'matters',
                            pageMessage=getPageMessage(),
                            throwReasons=[GAPI.FORBIDDEN],
                            view=view, state=stateParm, fields=fields)
  except GAPI.forbidden as e:
    entityActionFailedWarning([Ent.VAULT_MATTER, None], str(e))
    return
  jcount = len(matters)
  if view == 'FULL':
    cd = buildGAPIObject(API.DIRECTORY)
    for matter in matters:
      getPermissionEmails(matter)
  if not csvPF:
    performActionNumItems(jcount, Ent.VAULT_MATTER)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      return
    Ind.Increment()
    j = 0
    for matter in matters:
      j += 1
      if not matterStates or matter['state'] in matterStates:
        printEntity([Ent.VAULT_MATTER, formatVaultNameId(matter['name'], matter['matterId'])], j, jcount)
        Ind.Increment()
        showJSON(None, matter)
        Ind.Decrement()
    Ind.Decrement()
  else:
    for matter in matters:
      if not matterStates or matter['state'] in matterStates:
        csvPF.WriteRowTitles(flattenJSON(matter))
  if csvPF:
    csvPF.writeCSVfile('Vault Matters')

def checkSiteExists(sitesObject, domain, site):
  try:
    callGData(sitesObject, 'GetSite',
              throwErrors=[GDATA.NOT_FOUND],
              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
              domain=domain, site=site)
    return True
  except GDATA.notFound:
    return None

SITE_ACLS = 'ACLs'
SITE_CATEGORIES = 'Categories'
SITE_LINK = 'Link'
SITE_NAME = 'Name'
SITE_SITE = 'Site'
SITE_SOURCELINK = 'SourceLink'
SITE_SUMMARY = 'Summary'
SITE_THEME = 'Theme'
SITE_UPDATED = 'Updated'
SITE_WEB_ADDRESS_MAPPINGS = 'WebAddressMappings'

SITE_DATA_DOMAIN = 'domain'
SITE_DATA_SITE = 'site'
SITE_DATA_DOMAIN_SITE = 'domainSite'
SITE_DATA_fields = 'fields'

class SitesManager():

  SITE_ARGUMENT_TO_PROPERTY_MAP = {
    'categories': SITE_CATEGORIES,
    'name': SITE_NAME,
    'sourcelink': SITE_SOURCELINK,
    'summary': SITE_SUMMARY,
    'theme': SITE_THEME,
    }

  @staticmethod
  def AclEntryToFields(acl_entry):

    def GetAclAttr(attrlist):
      objAttr = acl_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return None
      return objAttr

    fields = {}
    fields['role'] = GetAclAttr(['role', 'value'])
    if not fields['role']:
      fields['role'] = GetAclAttr(['withKey', 'role', 'value'])+' (with link)'
    fields['scope'] = {'type': GetAclAttr(['scope', 'type']),
                       'value': GetAclAttr(['scope', 'value'])}
    link = acl_entry.FindInviteLink()
    if link:
      fields['inviteLink'] = link
    return fields

  @staticmethod
  def FieldsToAclEntry(fields):
    acl_entry = gdata.apps.sites.AclEntry()
    acl_entry.role = gdata.apps.sites.AclRole(value=fields['role'])
    acl_entry.scope = gdata.apps.sites.AclScope(stype=fields['scope']['type'], value=fields['scope'].get('value'))
    return acl_entry

  @staticmethod
  def ActivityEntryToFields(activity_entry):
    fields = {}

    def GetActivityField(fieldName, attrlist):
      objAttr = activity_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def GetActivityFieldData(objAttr, attrlist, default):
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return default
      return  objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)


    GetActivityField('Summary', ['title', 'text'])
    GetActivityField('Updated', ['updated', 'text'])
    for author in activity_entry.author:
      AppendItemToFieldsList('Authors', f'{GetActivityFieldData(author, ["name", "text"], "Unknown Name")}/{GetActivityFieldData(author, ["email", "text"], "Unknown Email")}')
    fields['Operation'] = activity_entry.Kind()
    return fields

  @staticmethod
  def SiteToFields(site_entry):
    fields = {}

    def GetSiteField(fieldName, attrlist):
      objAttr = site_entry
      for attr in attrlist:
        objAttr = getattr(objAttr, attr)
        if not objAttr:
          return
      fields[fieldName] = objAttr

    def AppendItemToFieldsList(fieldName, fieldValue):
      fields.setdefault(fieldName, [])
      fields[fieldName].append(fieldValue)

    GetSiteField(SITE_SITE, ['siteName', 'text'])
    GetSiteField(SITE_NAME, ['title', 'text'])
    GetSiteField(SITE_SUMMARY, ['summary', 'text'])
    GetSiteField(SITE_THEME, ['theme', 'text'])
    GetSiteField(SITE_UPDATED, ['updated', 'text'])
    if site_entry.category:
      for category in site_entry.category:
        if category.term:
          AppendItemToFieldsList(SITE_CATEGORIES, category.term)
    link = site_entry.FindAlternateLink()
    if link:
      fields[SITE_LINK] = link
    link = site_entry.FindSourceLink()
    if link:
      fields[SITE_SOURCELINK] = link
    for link in site_entry.FindWebAddressMappings():
      AppendItemToFieldsList(SITE_WEB_ADDRESS_MAPPINGS, link)
    return fields

  @staticmethod
  def GetSiteFields():

    fields = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP:
        fieldName = SitesManager.SITE_ARGUMENT_TO_PROPERTY_MAP[myarg]
        if fieldName == SITE_NAME:
          fields[fieldName] = getString(Cmd.OB_STRING)
        elif fieldName == SITE_SOURCELINK:
          fields[fieldName] = getString(Cmd.OB_URI)
        elif fieldName == SITE_SUMMARY:
          fields[fieldName] = getStringWithCRsNLs()
        elif fieldName == SITE_THEME:
          fields[fieldName] = getString(Cmd.OB_STRING)
        elif fieldName == SITE_CATEGORIES:
          fields[fieldName] = getString(Cmd.OB_STRING, minLen=0).split(',')
      else:
        unknownArgumentExit()
    return fields

  @staticmethod
  def FieldsToSite(fields):
    def GetField(fieldName):
      return fields.get(fieldName)

    def GetSiteField(fieldName, fieldClass):
      value = fields.get(fieldName)
      if value:
        return fieldClass(text=value)
      return None

    site_entry = gdata.apps.sites.SiteEntry(sourceSite=GetField(SITE_SOURCELINK))
    site_entry.siteName = GetSiteField(SITE_SITE, gdata.apps.sites.SiteName)
    site_entry.title = GetSiteField(SITE_NAME, atom.Title)
    site_entry.summary = GetSiteField(SITE_SUMMARY, atom.Summary)
    site_entry.theme = GetSiteField(SITE_THEME, gdata.apps.sites.Theme)
    value = GetField(SITE_CATEGORIES)
    if value:
      for category in value:
        site_entry.category.append(atom.Category(term=category, scheme=gdata.apps.sites.TAG_KIND_TERM))
    return site_entry

def getSiteEntity():
  siteEntity = {'list': getEntityList(Cmd.OB_SITE_ENTITY), 'dict': None}
  if isinstance(siteEntity['list'], dict):
    siteEntity['dict'] = siteEntity['list']
  return siteEntity

def _validateUserGetSites(entityType, user, i, count, siteEntity, itemType=None, modifier=None):
  if siteEntity['dict']:
    sites = siteEntity['dict'][user]
  else:
    sites = siteEntity['list']
  user, sitesObject = getSitesObject(entityType, user, i, count)
  if not sitesObject:
    return (user, None, None, 0)
  jcount = len(sites)
  if not itemType:
    entityPerformActionNumItems([entityType, user], jcount, Ent.SITE, i, count)
  else:
    entityPerformActionSubItemModifierNumItems([entityType, user], itemType, modifier, jcount, Ent.SITE, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  return (user, sitesObject, sites, jcount)

def _validateSite(fullSite, i, count):
  domain, site, domainSite = validateSplitSiteName(fullSite)
  if domainSite:
    return (domain, site, domainSite)
  entityActionNotPerformedWarning([Ent.SITE, site], Msg.INVALID_SITE.format(site, SITENAME_FORMAT_REQUIRED), i, count)
  return (domain, site, None)

def _validateSiteGetRuleIds(origUser, fullSite, j, jcount, ACLScopeEntity, showAction=True):
  domain, site, domainSite = _validateSite(fullSite, j, jcount)
  if not domainSite:
    return (domain, site, None, None, 0)
  if ACLScopeEntity:
    if ACLScopeEntity['dict']:
      if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
        ruleIds = ACLScopeEntity['dict'][fullSite]
      else:
        ruleIds = ACLScopeEntity['dict'][origUser][fullSite]
    else:
      ruleIds = ACLScopeEntity['list']
    kcount = len(ruleIds)
    if kcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
  else:
    ruleIds = []
    kcount = 0
  if showAction:
    entityPerformActionNumItems([Ent.SITE, domainSite], kcount, Ent.SITE_ACL, j, jcount)
  return (domain, site, domainSite, ruleIds, kcount)

def _createSite(users, entityType):
  sitesManager = SitesManager()
  domain, site, domainSite = getSiteName()
  fields = sitesManager.GetSiteFields()
  if not fields.get(SITE_NAME):
    fields[SITE_NAME] = site
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    try:
      siteEntry = sitesManager.FieldsToSite(fields)
      callGData(sitesObject, 'CreateSite',
                throwErrors=[GDATA.NOT_FOUND, GDATA.ENTITY_EXISTS, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                siteentry=siteEntry, domain=domain, site=None)
      entityActionPerformed([Ent.SITE, domainSite])
    except GDATA.notFound as e:
      entityActionFailedWarning([Ent.DOMAIN, domain], str(e))
    except (GDATA.entityExists, GDATA.badRequest, GDATA.forbidden) as e:
      entityActionFailedWarning([Ent.SITE, domainSite], str(e))

# gam [<UserTypeEntity>] create site <SiteName> <SiteAttribute>*
def createUserSite(users):
  _createSite(users, Ent.USER)

def doCreateDomainSite():
  _createSite([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _updateSites(users, entityType):
  sitesManager = SitesManager()
  siteEntity = getSiteEntity()
  updateFields = sitesManager.GetSiteFields()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        siteEntry = callGData(sitesObject, 'GetSite',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site)
        fields = sitesManager.SiteToFields(siteEntry)
        for field in updateFields:
          if field != SITE_SOURCELINK:
            fields[field] = updateFields[field]
        newSiteEntry = sitesManager.FieldsToSite(fields)
        callGData(sitesObject, 'UpdateSite',
                  throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                  retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                  siteentry=newSiteEntry, domain=domain, site=site, extra_headers={'If-Match': siteEntry.etag})
        entityActionPerformed([Ent.SITE, domainSite])
      except (GDATA.notFound, GDATA.badRequest, GDATA.forbidden) as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e))

# gam [<UserTypeEntity>] update site <SiteEntity> <SiteAttribute>+
def updateUserSites(users):
  _updateSites(users, Ent.USER)

def doUpdateDomainSites():
  _updateSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

SITE_FIELD_PRINT_ORDER = [
  SITE_UPDATED,
  SITE_NAME,
  SITE_SUMMARY,
  SITE_THEME,
  SITE_SOURCELINK,
  SITE_CATEGORIES,
  SITE_LINK,
  ]

def _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount):
  fields = sitesManager.SiteToFields(site)
  domainSite = f'{domain}/{fields[SITE_SITE]}'
  printKeyValueListWithCount([SITE_SITE, domainSite], j, jcount)
  Ind.Increment()
  for field in SITE_FIELD_PRINT_ORDER:
    if field in fields:
      if not isinstance(fields[field], list):
        if field != SITE_SUMMARY:
          printKeyValueList([field, fields[field]])
        else:
          printKeyValueWithCRsNLs(field, fields[field])
      else:
        printKeyValueList([field, ','.join(fields[field])])
  if fields.get(SITE_WEB_ADDRESS_MAPPINGS):
    printKeyValueList([SITE_WEB_ADDRESS_MAPPINGS, None])
    Ind.Increment()
    for link in fields[SITE_WEB_ADDRESS_MAPPINGS]:
      printKeyValueList([link, None])
    Ind.Decrement()
  if roles:
    try:
      acls = callGDataPages(sitesObject, 'GetAclFeed',
                            throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                            retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                            domain=domain, site=fields[SITE_SITE])
      printKeyValueList([SITE_ACLS, None])
      Ind.Increment()
      for acl in acls:
        fields = sitesManager.AclEntryToFields(acl)
        if fields['role'] in roles:
          printKeyValueList([formatACLRule(fields)])
      Ind.Decrement()
    except GDATA.notFound as e:
      entityActionFailedWarning([Ent.SITE, domainSite], str(e))
    except GDATA.forbidden:
      pass
  Ind.Decrement()

SITE_ACL_ROLES_MAP = {
  'editor': 'writer',
  'invite': 'invite',
  'owner': 'owner',
  'read': 'reader',
  'reader': 'reader',
  'writer': 'writer',
  }

def getACLRoles(aclRolesMap):
  roles = []
  for role in getString(Cmd.OB_ROLE_LIST, minLen=0).strip().lower().replace(',', ' ').split():
    if role == 'all':
      for arole in aclRolesMap:
        roles.append(aclRolesMap[arole])
    elif role in aclRolesMap:
      roles.append(aclRolesMap[role])
    else:
      invalidChoiceExit(role, aclRolesMap, True)
  return set(roles)

def _infoSites(users, entityType):
  siteEntity = getSiteEntity()
  url_params = {}
  roles = set()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'withmappings':
      url_params['with-mappings'] = 'true'
    elif myarg in {'role', 'roles'}:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      try:
        result = callGData(sitesObject, 'GetSite',
                           throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                           retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                           domain=domain, site=site, url_params=url_params)
        if result:
          _showSite(sitesManager, sitesObject, domain, result, roles, j, jcount)
      except (GDATA.notFound, GDATA.forbidden) as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e))
    Ind.Decrement()

# gam [<UserTypeEntity>] info site <SiteEntity> [withmappings] [role|roles all|<SiteACLRoleList>]
def infoUserSites(users):
  _infoSites(users, Ent.USER)

def doInfoDomainSites():
  _infoSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def printShowSites(entityList, entityType):
  def _getSites(domain, i, count):
    try:
      return callGDataPages(sitesObject, 'GetSiteFeed',
                            pageMessage=getPageMessage(),
                            throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                            retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                            domain=domain, url_params=url_params)
    except (GDATA.notFound, GDATA.forbidden) as e:
      entityActionFailedWarning([Ent.DOMAIN, domain], str(e), i, count)
    return []

  def _printSites(entity, i, count, domain, sites):
    for site in sites:
      fields = sitesManager.SiteToFields(site)
      if fields[SITE_SITE] in sitesSet:
        continue
      sitesSet.add(fields[SITE_SITE])
      domainSite = f'{domain}/{fields[SITE_SITE]}'
      siteRow = {Ent.Singular(entityType): entity, SITE_SITE: domainSite}
      for field in fields:
        if field != SITE_SITE:
          if not isinstance(fields[field], list):
            if field != SITE_SUMMARY or not convertCRNL:
              siteRow[field] = fields[field]
            else:
              siteRow[field] = escapeCRsNLs(fields[field])
          else:
            siteRow[field] = delimiter.join(fields[field])
      rowShown = False
      if roles:
        try:
          acls = callGDataPages(sitesObject, 'GetAclFeed',
                                throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                                domain=domain, site=fields[SITE_SITE])
          for acl in acls:
            fields = sitesManager.AclEntryToFields(acl)
            if fields['role'] in roles:
              siteACLRow = siteRow.copy()
              siteACLRow.update(ACLRuleDict(fields))
              csvPF.WriteRowTitles(siteACLRow)
              rowShown = True
        except GDATA.notFound as e:
          entityActionFailedWarning([Ent.SITE, domainSite], str(e), i, count)
        except GDATA.forbidden:
          pass
      if not rowShown:
        csvPF.WriteRowTitles(siteRow)

  def _showSites(entity, i, count, domain, sites):
    jcount = len(sites)
    if entityType == Ent.USER:
      entityPerformActionNumItems([entityType, entity, Ent.DOMAIN, domain], jcount, Ent.SITE, i, count)
    else:
      entityPerformActionNumItems([entityType, entity], jcount, Ent.SITE, i, count)
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      _showSite(sitesManager, sitesObject, domain, site, roles, j, jcount)
    Ind.Decrement()

  domains = []
  domainLists = []
  url_params = {}
  includeAllSites = 'true' if entityType == Ent.DOMAIN else 'false'
  roles = set()
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  csvPF = CSVPrintFile([Ent.Singular(entityType), SITE_SITE, SITE_NAME, SITE_SUMMARY], 'sortall') if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'domain', 'domains'}:
      if entityType == Ent.DOMAIN:
        entityList = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
      else:
        domains = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
        domainLists = domains if isinstance(domains, dict) else None
    elif myarg == 'includeallsites':
      includeAllSites = 'true'
    elif myarg == 'maxresults':
      url_params['max-results'] = getInteger(minVal=1)
    elif myarg == 'startindex':
      url_params['start-index'] = getInteger(minVal=1)
    elif myarg == 'withmappings':
      url_params['with-mappings'] = 'true'
    elif myarg in {'role', 'roles'}:
      roles = getACLRoles(SITE_ACL_ROLES_MAP)
    elif myarg in {'convertcrnl', 'converttextnl', 'convertsummarynl'}:
      convertCRNL = True
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  sitesManager = SitesManager()
  sitesSet = set()
  i, count, entityList = getEntityArgument(entityList)
  if entityType == Ent.USER:
    for user in entityList:
      i += 1
      if domainLists:
        domainList = domainLists[user]
      elif domains:
        domainList = domains
      else:
        _, domain = splitEmailAddress(user)
        domainList = [domain]
      user, sitesObject = getSitesObject(entityType, user, i, count)
      if not sitesObject:
        continue
      jcount = len(domainList)
      j = 0
      for domain in domainList:
        j += 1
        if domain != 'site':
          url_params['include-all-sites'] = includeAllSites
        else:
          url_params.pop('include-all-sites', None)
        printGettingAllEntityItemsForWhom(Ent.SITE, f'{Ent.Singular(Ent.USER)}: {user}, {Ent.Singular(Ent.DOMAIN)}: {domain}')
        sites = _getSites(domain, i, count)
        if not csvPF:
          _showSites(domain, j, jcount, domain, sites)
        else:
          _printSites(user, j, jcount, domain, sites)
  else:
    for domain in entityList:
      i += 1
      domain, sitesObject = getSitesObject(entityType, domain, i, count)
      if not sitesObject:
        continue
      if domain != 'site':
        url_params['include-all-sites'] = includeAllSites
      else:
        url_params.pop('include-all-sites', None)
      printGettingAllEntityItemsForWhom(Ent.SITE, f'{Ent.Singular(Ent.DOMAIN)}: {domain}')
      sites = _getSites(domain, i, count)
      if not csvPF:
        _showSites(domain, i, count, domain, sites)
      else:
        _printSites(domain, i, count, domain, sites)
  if csvPF:
    csvPF.SortTitles()
    csvPF.SetSortTitles([])
    if roles:
      csvPF.MoveTitlesToEnd(['Scope', 'Role'])
    csvPF.writeCSVfile('Sites')

# gam print sites [todrive <ToDriveAttribute>*] [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [startindex <Number>] [maxresults <Number>] [convertcrnl] [delimiter <Character>]
# gam show sites [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [startindex <Number>] [maxresults <Number>] [convertcrnl]
def doPrintShowDomainSites():
  printShowSites([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

# gam [<UserTypeEntity>] print sites [todrive <ToDriveAttribute>*] [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [startindex <Number>] [maxresults <Number>] [convertcrnl] [delimiter <Character>]
# gam [<UserTypeEntity>] show sites [domain|domains <DomainNameEntity>] [includeallsites]
#	[withmappings] [role|roles all|<SiteACLRoleList>] [startindex <Number>] [maxresults <Number>] [convertcrnl]
def printShowUserSites(users):
  printShowSites(users, Ent.USER)

SITE_ACTION_TO_MODIFIER_MAP = {
  Act.ADD: Act.MODIFIER_TO,
  Act.UPDATE: Act.MODIFIER_IN,
  Act.DELETE: Act.MODIFIER_FROM,
  Act.INFO: Act.MODIFIER_FROM,
  Act.PRINT: Act.MODIFIER_FROM,
  Act.SHOW: Act.MODIFIER_FROM,
  }

def _processSiteACLs(users, entityType):
  action = Act.Get()
  siteEntity = getSiteEntity()
  csvPF = None
  if action in [Act.ADD, Act.UPDATE]:
    role = getChoice(SITE_ACL_ROLES_MAP, mapChoice=True)
  elif action == Act.PRINT:
    csvPF = CSVPrintFile([Ent.Singular(entityType), SITE_SITE, 'Scope', 'Role'])
  else:
    role = None
  actionPrintShow = action in [Act.PRINT, Act.SHOW]
  ACLScopeEntity = getCalendarSiteACLScopeEntity() if not actionPrintShow else {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  modifier = SITE_ACTION_TO_MODIFIER_MAP[action]
  sitesManager = SitesManager()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, sitesObject, sites, jcount = _validateUserGetSites(entityType, user, i, count, siteEntity, Ent.SITE_ACL, modifier)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite, ruleIds, kcount = _validateSiteGetRuleIds(origUser, site, j, jcount, ACLScopeEntity, showAction=not actionPrintShow)
      if not domainSite:
        continue
      if not actionPrintShow:
        Ind.Increment()
        k = 0
        for ruleId in ruleIds:
          k += 1
          ruleId = normalizeRuleId(ruleId)
          try:
            if action in [Act.CREATE, Act.ADD]:
              acl = callGData(sitesObject, 'CreateAclEntry',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.ENTITY_EXISTS, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              aclentry=sitesManager.FieldsToAclEntry(makeRoleRuleIdBody(role, ruleId)), domain=domain, site=site)
              fields = sitesManager.AclEntryToFields(acl)
              if not fields.get('inviteLink'):
                entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
              else:
                entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, f'{formatACLRule(fields)} (Link: {fields["inviteLink"]})'], k, kcount)
            elif action == Act.UPDATE:
              acl = callGData(sitesObject, 'GetAclEntry',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              acl.role.value = role
              acl = callGData(sitesObject, 'UpdateAclEntry',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              aclentry=acl, domain=domain, site=site, ruleId=ruleId, extra_headers={'If-Match': acl.etag})
              fields = sitesManager.AclEntryToFields(acl)
              entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
            elif action == Act.DELETE:
              acl = callGData(sitesObject, 'GetAclEntry',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              callGData(sitesObject, 'DeleteAclEntry',
                        throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                        retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                        domain=domain, site=site, ruleId=ruleId, extra_headers={'If-Match': acl.etag})
              entityActionPerformed([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, None)], k, kcount)
            elif action == Act.INFO:
              acl = callGData(sitesObject, 'GetAclEntry',
                              throwErrors=[GDATA.NOT_FOUND, GDATA.BAD_REQUEST, GDATA.FORBIDDEN],
                              retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                              domain=domain, site=site, ruleId=ruleId)
              fields = sitesManager.AclEntryToFields(acl)
              printEntity([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
          except GDATA.notFound as e:
            if not checkSiteExists(sitesObject, domain, site):
              entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
              break
            entityActionFailedWarning([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
          except (GDATA.entityExists, GDATA.badRequest, GDATA.forbidden) as e:
            entityActionFailedWarning([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLScopeRole(ruleId, role)], str(e), k, kcount)
        Ind.Decrement()
      else:
        try:
          acls = callGDataPages(sitesObject, 'GetAclFeed',
                                throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                                domain=domain, site=site)
          if not csvPF:
            kcount = len(acls)
            entityPerformActionNumItems([Ent.SITE, domainSite], kcount, Ent.SITE_ACL, j, jcount)
            if kcount == 0:
              continue
            Ind.Increment()
            k = 0
            for acl in acls:
              k += 1
              fields = sitesManager.AclEntryToFields(acl)
              printEntity([Ent.SITE, domainSite, Ent.SITE_ACL, formatACLRule(fields)], k, kcount)
            Ind.Decrement()
          else:
            siteRow = {Ent.Singular(entityType): user, SITE_SITE: domainSite}
            for acl in acls:
              fields = sitesManager.AclEntryToFields(acl)
              siteACLRow = siteRow.copy()
              siteACLRow.update(ACLRuleDict(fields))
              csvPF.WriteRowTitles(siteACLRow)
        except GDATA.notFound:
          entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
        except GDATA.forbidden as e:
          entityActionFailedWarning([Ent.SITE, domainSite], str(e), j, jcount)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Site ACLs')

# gam [<UserTypeEntity>] create|add siteacls <SiteEntity> <SiteACLRole> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] update siteacls <SiteEntity> <SiteACLRole> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] delete siteacls <SiteEntity> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] info siteacls <SiteEntity> <SiteACLScopeEntity>
# gam [<UserTypeEntity>] show siteacls <SiteEntity>
# gam [<UserTypeEntity>] print siteacls <SiteEntity> [todrive <ToDriveAttribute>*]
def processUserSiteACLs(users):
  _processSiteACLs(users, Ent.USER)

def doProcessDomainSiteACLs():
  _processSiteACLs([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

def _printSiteActivity(users, entityType):
  sitesManager = SitesManager()
  url_params = {}
  csvPF = CSVPrintFile([SITE_SITE, SITE_SUMMARY, SITE_UPDATED], 'sortall')
  sites = getEntityList(Cmd.OB_SITE_ENTITY)
  siteLists = sites if isinstance(sites, dict) else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'maxresults':
      url_params['max-results'] = getInteger(minVal=1)
    elif myarg == 'startindex':
      url_params['start-index'] = getInteger(minVal=1)
    elif myarg == 'updatedmin':
      url_params['updated-min'] = getYYYYMMDD()
    elif myarg == 'updatedmax':
      url_params['updated-max'] = getYYYYMMDD()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if siteLists:
      sites = siteLists[user]
    user, sitesObject = getSitesObject(entityType, user, i, count)
    if not sitesObject:
      continue
    jcount = len(sites)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    j = 0
    for site in sites:
      j += 1
      domain, site, domainSite = _validateSite(site, j, jcount)
      if not domainSite:
        continue
      printGettingAllEntityItemsForWhom(Ent.ACTIVITY, domainSite)
      try:
        activities = callGDataPages(sitesObject, 'GetActivityFeed',
                                    pageMessage=getPageMessage(),
                                    throwErrors=[GDATA.NOT_FOUND, GDATA.FORBIDDEN],
                                    retryErrors=[GDATA.INTERNAL_SERVER_ERROR],
                                    domain=domain, site=site, url_params=url_params)
        for activity in activities:
          fields = sitesManager.ActivityEntryToFields(activity)
          activityRow = {SITE_SITE: domainSite}
          for key in fields:
            if not isinstance(fields[key], list):
              activityRow[key] = fields[key]
            else:
              activityRow[key] = ','.join(fields[key])
          csvPF.WriteRowTitles(activityRow)
      except GDATA.notFound:
        entityUnknownWarning(Ent.SITE, domainSite, j, jcount)
      except GDATA.forbidden as e:
        entityActionFailedWarning([Ent.SITE, domainSite], str(e), j, jcount)
  csvPF.writeCSVfile('Site Activities')

# gam [<UserTypeEntity>] print siteactivity <SiteEntity> [todrive <ToDriveAttribute>*]
#	[startindex <Number>] [maxresults <Number>] [updated_min <Date>] [updated_max <Date>]
def printUserSiteActivity(users):
  _printSiteActivity(users, Ent.USER)

def doPrintDomainSiteActivity():
  _printSiteActivity([GC.Values[GC.DOMAIN]], Ent.DOMAIN)

# <FileName> [charset <String>] [warnifnodata] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	[keyfield <FieldName>] [datafield <FieldName>]
def _getGroupOrgUnitMap():

  def getKeyFieldInfo(keyword, defaultField):
    if not checkArgumentPresent(keyword):
      field = defaultField
    else:
      field = getString(Cmd.OB_FIELD_NAME)
    if field not in fieldnames:
      csvFieldErrorExit(field, fieldnames, backupArg=True)
    return field

  filename = getString(Cmd.OB_FILE_NAME)
  f, csvFile, fieldnames = openCSVFileReader(filename)
  keyField = getKeyFieldInfo('keyfield', 'Group')
  dataField = getKeyFieldInfo('datafield', 'OrgUnit')
  groupOrgUnitMap = {}
  for row in csvFile:
    group = row[keyField].strip().lower()
    orgUnit = row[dataField].strip()
    if not group or not orgUnit:
      systemErrorExit(USAGE_ERROR_RC, Msg.GROUP_MAPS_TO_OU_INVALID_ROW.format(filename, group, orgUnit))
    orgUnit = makeOrgUnitPathAbsolute(orgUnit)
    if group in groupOrgUnitMap:
      origOrgUnit = groupOrgUnitMap[group]
      if origOrgUnit != orgUnit:
        systemErrorExit(USAGE_ERROR_RC, Msg.GROUP_MAPS_TO_MULTIPLE_OUS.format(filename, group, ','.join([origOrgUnit, orgUnit])))
    groupOrgUnitMap[group] = orgUnit
  closeFile(f)
  return groupOrgUnitMap

class PasswordOptions():
  def __init__(self, updateCmd):
    self.password = ''
    self.notFoundPassword = ''
    self.b64DecryptPassword = False
    self.clearPassword = True
    self.hashPassword = True
    self.ignoreNullPassword = False
    self.makeRandomPassword = not updateCmd
    self.makeUniqueRandomPassword = False
    self.notifyPasswordSet = False
    self.updateCmd = updateCmd
    self.filename = ''

  def GetPassword(self):
    return getString(Cmd.OB_PASSWORD, minLen=1 if not self.ignoreNullPassword else 0, maxLen=100)

  def ProcessArgument(self, myarg, notify, notFoundBody):
    if myarg == 'ignorenullpassword':
      self.ignoreNullPassword = True
    elif myarg == 'notifypassword':
      password = self.GetPassword()
      if password:
        notify['password'] = password
        self.notifyPasswordSet = True
    elif myarg == 'nohash':
      self.hashPassword = False
    elif self.updateCmd and myarg == 'notfoundpassword':
      up = 'password'
      password = self.GetPassword()
      if password:
        notFoundBody[up] = password
        if notFoundBody[up].lower() in {'random', 'uniquerandom'}:
          rnd = SystemRandom()
          notFoundBody[up] = ''.join(rnd.choice(PASSWORD_SAFE_CHARS) for _ in range(25))
          self.notFoundPassword = notFoundBody[up]
    elif myarg == 'lograndompassword':
      self.filename = getString(Cmd.OB_FILE_NAME)
    else:
      return False
    return True

  HASH_FUNCTION_MAP = {
    'base64-md5': 'MD5',
    'base64-sha1': 'SHA-1',
    'crypt': 'crypt',
    'md5': 'MD5',
    'sha': 'SHA-1',
    'sha-1': 'SHA-1',
    'sha1': 'SHA-1',
    }

  def ProcessPropertyArgument(self, myarg, up, body):
    if up == 'password':
      password = self.GetPassword()
      if password:
        body[up] = password
        self.makeRandomPassword = self.makeUniqueRandomPassword = False
        if password.lower() == 'random':
          self.makeRandomPassword = True
        elif password.lower() == 'uniquerandom':
          if self.updateCmd:
            self.makeUniqueRandomPassword = True
          else:
            self.makeRandomPassword = True
    elif up == 'hashFunction':
      body[up] = self.HASH_FUNCTION_MAP[myarg]
      self.clearPassword = self.hashPassword = False
      self.b64DecryptPassword = myarg.startswith('base64')
    else:
      return False
    return True

  def FinalizePassword(self, body, notify, up):
    if not self.notifyPasswordSet:
      notify[up] = body[up] if self.clearPassword else Msg.CONTACT_ADMINISTRATOR_FOR_PASSWORD
    if self.hashPassword:
      if platform.system() == 'Windows':
        body[up] = sha512_crypt.hash(body[up], rounds=5000)
      else:
        body[up] = crypt(body[up])
      body['hashFunction'] = 'crypt'
    elif self.b64DecryptPassword:
      if body[up].lower()[:5] in ['{md5}', '{sha}']:
        body[up] = body[up][5:]
      body[up] = base64.b64decode(body[up]).hex()

  def AssignPassword(self, body, notify, notFoundBody, createIfNotFound):
    up = 'password'
    if self.makeRandomPassword or self.makeUniqueRandomPassword:
      rnd = SystemRandom()
      body[up] = ''.join(rnd.choice(PASSWORD_SAFE_CHARS) for _ in range(25))
      self.password = body[up]
    if up in body:
      self.FinalizePassword(body, notify, up)
    elif 'hashFunction' in body:
      body.pop('hashFunction')
    if createIfNotFound:
      if not notFoundBody:
        if up in body:
          notFoundBody[up] = body[up]
          if 'hashfunction' in body:
            notFoundBody['hashfunction'] = body['hashFunction']
          notify['notFoundPassword'] = notify[up]
          self.notFoundPassword = self.password
      else:
        notify['notFoundPassword'] = notify[up] if notify[up] else notFoundBody[up] if self.clearPassword else Msg.CONTACT_ADMINISTRATOR_FOR_PASSWORD
        self.FinalizePassword(notFoundBody, notify, up)

UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP = {
  'address': 'addresses',
  'addresses': 'addresses',
  'agreed2terms': 'agreedToTerms',
  'agreedtoterms': 'agreedToTerms',
  'archived': 'archived',
  'base64-md5': 'hashFunction',
  'base64-sha1': 'hashFunction',
  'changepassword': 'changePasswordAtNextLogin',
  'changepasswordatnextlogin': 'changePasswordAtNextLogin',
  'crypt': 'hashFunction',
  'customerid': 'customerId',
  'email': 'primaryEmail',
  'emails': 'emails',
  'externalid': 'externalIds',
  'externalids': 'externalIds',
  'familyname': 'familyName',
  'firstname': 'givenName',
  'gal': 'includeInGlobalAddressList',
  'gender': 'gender',
  'givenname': 'givenName',
  'im': 'ims',
  'ims': 'ims',
  'includeinglobaladdresslist': 'includeInGlobalAddressList',
  'ipwhitelisted': 'ipWhitelisted',
  'keyword': 'keywords',
  'keywords': 'keywords',
  'language': 'languages',
  'languages': 'languages',
  'lastname': 'familyName',
  'location': 'locations',
  'locations': 'locations',
  'md5': 'hashFunction',
  'note': 'notes',
  'notes': 'notes',
  'org': 'orgUnitPath',
  'organization': 'organizations',
  'organizations': 'organizations',
  'orgunitpath': 'orgUnitPath',
  'otheremail': 'emails',
  'otheremails': 'emails',
  'ou': 'orgUnitPath',
  'password': 'password',
  'phone': 'phones',
  'phones': 'phones',
  'posix': 'posixAccounts',
  'posixaccounts': 'posixAccounts',
  'primaryemail': 'primaryEmail',
  'recoveryemail': 'recoveryEmail',
  'recoveryphone': 'recoveryPhone',
  'relation': 'relations',
  'relations': 'relations',
  'sha': 'hashFunction',
  'sha-1': 'hashFunction',
  'sha1': 'hashFunction',
  'ssh': 'sshPublicKeys',
  'sshkeys': 'sshPublicKeys',
  'sshpublickeys': 'sshPublicKeys',
  'suspended': 'suspended',
  'username': 'primaryEmail',
  'website': 'websites',
  'websites': 'websites',
  }

ADDRESS_ARGUMENT_TO_FIELD_MAP = {
  'country': 'country',
  'countrycode': 'countryCode',
  'extendedaddress': 'extendedAddress',
  'locality': 'locality',
  'pobox': 'poBox',
  'postalcode': 'postalCode',
  'region': 'region',
  'streetaddress': 'streetAddress',
  }

ORGANIZATION_ARGUMENT_TO_FIELD_MAP = {
  'costcenter': 'costCenter',
  'department': 'department',
  'description': 'description',
  'domain': 'domain',
  'fulltimeequivalent': 'fullTimeEquivalent',
  'location': 'location',
  'name': 'name',
  'symbol': 'symbol',
  'title': 'title',
  }

# (MultiValue, IgnoreEmpty)
SCHEMA_VALUE_PROCESS_MAP = {
  'multivalued': (True, False),
  'multivalue': (True, False),
  'value': (True, False),
  'multinonempty': (True, True),
  'scalarnonempty': (False, True)
  }

USER_JSON_SKIP_FIELDS = ['agreedToTerms', 'aliases', 'creationTime', 'customerId', 'deletionTime', 'groups', 'id',
                         'isAdmin', 'isDelegatedAdmin', 'isEnforcedIn2Sv', 'isEnrolledIn2Sv', 'isMailboxSetup',
                         'lastLoginTime', 'licenses', 'primaryEmail', 'thumbnailPhotoEtag', 'thumbnailPhotoUrl']

def getUserAttributes(cd, updateCmd, noUid=False):
  def getKeywordAttribute(keywords, attrdict, **opts):
    if Cmd.ArgumentsRemaining():
      keyword = Cmd.Current().strip().lower()
      if keyword in keywords[UProp.PTKW_KEYWORD_LIST]:
        Cmd.Advance()
        if keyword != keywords[UProp.PTKW_CL_CUSTOM_KEYWORD]:
          attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keyword
          attrdict.pop(keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD], None)
          return
        if Cmd.ArgumentsRemaining():
          customType = Cmd.Current().strip()
          if customType:
            Cmd.Advance()
            if keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]:
              attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
            else:
              attrdict.pop(keywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
            attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = customType
            return
        missingArgumentExit('custom attribute type')
      elif DEFAULT_CHOICE in opts:
        attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
        return
      elif keywords[UProp.PTKW_CL_CUSTOM_KEYWORD]:
        if keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]:
          attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = keywords[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
        else:
          attrdict.pop(keywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
        attrdict[keywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = Cmd.Current()
        Cmd.Advance()
        return
      invalidChoiceExit(keyword, keywords[UProp.PTKW_KEYWORD_LIST], False)
    elif DEFAULT_CHOICE in opts:
      attrdict[keywords[UProp.PTKW_ATTR_TYPE_KEYWORD]] = opts[DEFAULT_CHOICE]
      return
    missingChoiceExit(keywords[UProp.PTKW_KEYWORD_LIST])

  def primaryNotPrimary(pnp, entry):
    if pnp == 'notprimary':
      return True
    if pnp == 'primary':
      entry['primary'] = True
      primary['location'] = Cmd.Location()
      return True
    return False

  def getPrimaryNotPrimaryChoice(entry, defaultChoice):
    if getChoice({'primary': True, 'notprimary': False}, defaultChoice=defaultChoice, mapChoice=True):
      entry['primary'] = True
      primary['location'] = Cmd.Location()

  def checkClearBodyList(body, itemName):
    if checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
      body.pop(itemName, None)
      body[itemName] = None
      return True
    return False

  def appendItemToBodyList(body, itemName, itemValue, checkBlankField=None, checkSystemId=False):
    if (itemName in body) and (body[itemName] is None):
      del body[itemName]
    body.setdefault(itemName, [])
    if checkBlankField is None or itemValue[checkBlankField]:
# Throw an error if multiple items are marked primary
      if itemValue.get('primary', False):
        for citem in body[itemName]:
          if citem.get('primary', False):
            if not checkSystemId or itemValue.get('systemId') == citem.get('systemId'):
              Cmd.SetLocation(primary['location']-1)
              usageErrorExit(Msg.MULTIPLE_ITEMS_MARKED_PRIMARY.format(itemName))
      body[itemName].append(itemValue)

  def _splitSchemaNameDotFieldName(sn_fn, fnRequired=True):
    if sn_fn.find('.') != -1:
      schemaName, fieldName = sn_fn.split('.', 1)
      schemaName = schemaName.strip()
      fieldName = fieldName.strip()
      if schemaName and fieldName:
        return (schemaName, fieldName)
    elif not fnRequired:
      schemaName = sn_fn.strip()
      if schemaName:
        return (schemaName, None)
    invalidArgumentExit(Cmd.OB_SCHEMA_NAME_FIELD_NAME)

  createIfNotFound = noActionIfAlias = False
  if updateCmd:
    body = {}
  else:
    body = {'name': {'givenName': 'Unknown', 'familyName': 'Unknown'}}
    body['primaryEmail'] = getEmailAddress(noUid=noUid)
  notFoundBody = {}
  notify = {'subject': '', 'message': '', 'html': False, 'charset': UTF8, 'password': ''}
  primary = {}
  updatePrimaryEmail = {}
  groupOrgUnitMap = None
  tagReplacements = _initTagReplacements()
  addGroups = {}
  PwdOpts = PasswordOptions(updateCmd)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'notify':
      notify['emailAddress'] = getEmailAddress(noUid=True)
    elif myarg == 'subject':
      notify['subject'] = getString(Cmd.OB_STRING)
    elif myarg in SORF_MSG_FILE_ARGUMENTS:
      notify['message'], notify['charset'], notify['html'] = getStringOrFile(myarg)
    elif myarg == 'html':
      notify['html'] = getBoolean()
    elif PwdOpts.ProcessArgument(myarg, notify, notFoundBody):
      pass
    elif myarg == 'replace':
      _getTagReplacement(tagReplacements, True)
    elif myarg == 'admin':
      value = getBoolean()
      if updateCmd or value:
        Cmd.Backup()
        unknownArgumentExit()
    elif updateCmd and myarg == 'createifnotfound':
      createIfNotFound = True
    elif updateCmd and myarg == 'noactionifalias':
      noActionIfAlias = True
    elif updateCmd and myarg == 'updateoufromgroup':
      groupOrgUnitMap = _getGroupOrgUnitMap()
    elif updateCmd and myarg == 'updateprimaryemail':
      search = getString(Cmd.OB_RE_PATTERN)
      pattern = validateREPattern(search, re.IGNORECASE)
      replace = getString(Cmd.OB_EMAIL_REPLACEMENT)
      patternGroups = pattern.groups
      replSubs = REPLACE_GROUP_PATTERN.findall(replace)
      for replSub in replSubs:
        if int(replSub) > patternGroups:
          Cmd.Backup()
          usageErrorExit(Msg.MISMATCH_RE_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, int(replSub), replace))
      updatePrimaryEmail['search'] = search
      updatePrimaryEmail['pattern'] = pattern
      updatePrimaryEmail['replace'] = replace
    elif myarg == 'json':
      body.update(getJSON(USER_JSON_SKIP_FIELDS))
      if 'name' in body and 'fullName' in body['name']:
        body['name'].pop('fullName')
      if 'sshPublicKeys' in body and 'fingerprint' in body['sshPublicKeys']:
        body['sshPublicKeys'].pop('fingerprint')
    elif myarg in UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP:
      up = UPDATE_USER_ARGUMENT_TO_PROPERTY_MAP[myarg]
      userProperty = UProp.PROPERTIES[up]
      propertyClass = userProperty[UProp.CLASS]
      if UProp.TYPE_KEYWORDS in userProperty:
        typeKeywords = userProperty[UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
      if up == 'givenName':
        body.setdefault('name', {})
        body['name'][up] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
      elif up == 'familyName':
        body.setdefault('name', {})
        body['name'][up] = getString(Cmd.OB_STRING, minLen=0, maxLen=60)
      elif PwdOpts.ProcessPropertyArgument(myarg, up, body):
        pass
      elif propertyClass == UProp.PC_BOOLEAN:
        body[up] = getBoolean()
      elif up == 'primaryEmail':
        if updateCmd:
          body[up] = getEmailAddress(noUid=True)
        elif body[up] != getEmailAddress(noUid=True):
          Cmd.Backup()
          unknownArgumentExit()
      elif up == 'recoveryEmail':
        rcvryEmail = getEmailAddress(noUid=True, optional=True)
        body[up] = rcvryEmail if rcvryEmail is not None else ""
      elif up == 'recoveryPhone':
        body[up] = getString(Cmd.OB_STRING, minLen=0)
        if body[up] and body[up][0] != '+':
          body[up] = '+' + body[up]
      elif up == 'customerId':
        body[up] = getString(Cmd.OB_STRING)
      elif up == 'orgUnitPath':
        body[up] = getOrgUnitItem(pathOnly=True)
      elif up == 'languages':
        if checkClearBodyList(body, up):
          continue
        for language in getString(Cmd.OB_LANGUAGE_LIST).replace('_', '-').replace(',', ' ').split():
          if language.lower() in LANGUAGE_CODES_MAP:
            appendItemToBodyList(body, up, {'languageCode': LANGUAGE_CODES_MAP[language.lower()]})
          else:
            appendItemToBodyList(body, up, {'customLanguage': language})
      elif up == 'gender':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        if checkArgumentPresent('addressmeas'):
          entry['addressMeAs'] = getString(Cmd.OB_STRING, minLen=0)
        body[up] = entry
      elif up == 'addresses':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        if checkArgumentPresent(['unstructured', 'formatted']):
          entry['sourceIsStructured'] = False
          entry['formatted'] = getStringWithCRsNLs()
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in ADDRESS_ARGUMENT_TO_FIELD_MAP:
            value = getString(Cmd.OB_STRING, minLen=0)
            if value:
              entry[ADDRESS_ARGUMENT_TO_FIELD_MAP[argument]] = value
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == 'ims':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        getChoice([UProp.IM_PROTOCOLS[UProp.PTKW_CL_TYPE_KEYWORD]])
        getKeywordAttribute(UProp.IM_PROTOCOLS, entry)
        # Backwards compatability: notprimary|primary on either side of IM address
        getPrimaryNotPrimaryChoice(entry, False)
        entry['im'] = getString(Cmd.OB_STRING, minLen=0)
        getPrimaryNotPrimaryChoice(entry, entry.get('primary', False))
        appendItemToBodyList(body, up, entry, 'im')
      elif up == 'keywords':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, 'value')
      elif up == 'locations':
        if checkClearBodyList(body, up):
          continue
        entry = {'type': 'desk', 'area': ''}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(typeKeywords, entry)
          elif argument == 'area':
            entry['area'] = getString(Cmd.OB_STRING)
          elif argument in {'building', 'buildingid'}:
            entry['buildingId'] = _getBuildingByNameOrId(cd)
          elif argument in {'floor', 'floorname'}:
            entry['floorName'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in {'section', 'floorsection'}:
            entry['floorSection'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in {'desk', 'deskcode'}:
            entry['deskCode'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == 'endlocation':
            break
          else:
            unknownArgumentExit()
        if 'area' not in entry:
          missingArgumentExit('area <String>')
        appendItemToBodyList(body, up, entry)
      elif up == 'notes':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getKeywordAttribute(typeKeywords, entry, defaultChoice='text_plain')
        entry['value'] = getStringWithCRsNLsOrFile()
        body[up] = entry
      elif up == 'organizations':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(typeKeywords, entry)
          elif argument == typeKeywords[UProp.PTKW_CL_CUSTOMTYPE_KEYWORD]:
            entry[typeKeywords[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]] = getString(Cmd.OB_STRING, minLen=0)
            entry.pop(typeKeywords[UProp.PTKW_ATTR_TYPE_KEYWORD], None)
          elif argument in ORGANIZATION_ARGUMENT_TO_FIELD_MAP:
            argument = ORGANIZATION_ARGUMENT_TO_FIELD_MAP[argument]
            if argument != 'fullTimeEquivalent':
              value = getString(Cmd.OB_STRING, minLen=0)
              if value:
                entry[argument] = value
            else:
              entry[argument] = getInteger(minVal=0, maxVal=100000)
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry)
      elif up == 'phones':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == clTypeKeyword:
            getKeywordAttribute(typeKeywords, entry)
          elif argument == 'value':
            entry['value'] = getString(Cmd.OB_STRING, minLen=0)
          elif primaryNotPrimary(argument, entry):
            break
          else:
            unknownArgumentExit()
        appendItemToBodyList(body, up, entry, 'value')
      elif up == 'posixAccounts':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument in {'username', 'name'}:
            entry['username'] = getString(Cmd.OB_STRING)
          elif argument == 'uid':
            entry['uid'] = getInteger(minVal=1000)
          elif argument == 'gid':
            entry['gid'] = getInteger(minVal=0)
          elif argument in {'system', 'systemid'}:
            entry['systemId'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument in {'home', 'homedirectory'}:
            entry['homeDirectory'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == 'shell':
            entry['shell'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == 'gecos':
            entry['gecos'] = getString(Cmd.OB_STRING, minLen=0)
          elif argument == 'primary':
            primary['location'] = Cmd.Location()
            entry['primary'] = getBoolean()
          elif argument in {'os', 'operatingsystemtype'}:
            entry['operatingSystemType'] = getChoice(['linux', 'unspecified', 'windows'])
          elif argument == 'endposix':
            break
          else:
            unknownArgumentExit()
        if 'username' not in entry:
          missingArgumentExit('username <String>')
        if 'uid' not in entry:
          missingArgumentExit('uid <Integer>')
        appendItemToBodyList(body, up, entry, checkSystemId=True)
      elif up == 'relations':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, 'value')
      elif up == 'emails':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        entry['address'] = getEmailAddress(noUid=True, minLen=0)
        appendItemToBodyList(body, up, entry, 'address')
      elif up == 'sshPublicKeys':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        while Cmd.ArgumentsRemaining():
          argument = getArgument()
          if argument == 'expires':
            entry['expirationTimeUsec'] = getInteger(minVal=0)
          elif argument == 'key':
            entry['key'] = getString(Cmd.OB_STRING)
          elif argument == 'endssh':
            break
          else:
            unknownArgumentExit()
        if 'key' not in entry:
          missingArgumentExit('key <String>')
        appendItemToBodyList(body, up, entry)
      elif up == 'externalIds':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        entry['value'] = getString(Cmd.OB_STRING, minLen=0)
        appendItemToBodyList(body, up, entry, 'value')
      elif up == 'websites':
        if checkClearBodyList(body, up):
          continue
        entry = {}
        getChoice([clTypeKeyword], defaultChoice=None)
        getKeywordAttribute(typeKeywords, entry)
        entry['value'] = getString(Cmd.OB_URL, minLen=0)
        getPrimaryNotPrimaryChoice(entry, False)
        appendItemToBodyList(body, up, entry, 'value')
    elif myarg in {'group', 'groups'}:
      role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
      delivery_settings = getDeliverySettings()
      for group in getEntityList(Cmd.OB_GROUP_ENTITY):
        addGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': delivery_settings}
    elif myarg == 'clearschema':
      if not updateCmd:
        unknownArgumentExit()
      schemaName, fieldName = _splitSchemaNameDotFieldName(getString(Cmd.OB_SCHEMA_NAME_FIELD_NAME), False)
      up = 'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      if fieldName is None:
        try:
          schema = callGAPI(cd.schemas(), 'get',
                            throwReasons=[GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                            customerId=GC.Values[GC.CUSTOMER_ID], schemaKey=schemaName, fields='fields(fieldName)')
          for field in schema['fields']:
            body[up][schemaName][field['fieldName']] = None
        except (GAPI.invalid, GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          entityDoesNotExistWarning(Ent.USER_SCHEMA, schemaName)
          unknownArgumentExit()
      else:
        body[up][schemaName][fieldName] = None
    elif myarg.find('.') >= 0:
      schemaName, fieldName = _splitSchemaNameDotFieldName(Cmd.Previous())
      up = 'customSchemas'
      body.setdefault(up, {})
      body[up].setdefault(schemaName, {})
      multivalue, ignoreEmpty = getChoice(SCHEMA_VALUE_PROCESS_MAP, defaultChoice=(False, False), mapChoice=True)
      if multivalue:
        body[up][schemaName].setdefault(fieldName, [])
        typeKeywords = UProp.PROPERTIES[up][UProp.TYPE_KEYWORDS]
        clTypeKeyword = typeKeywords[UProp.PTKW_CL_TYPE_KEYWORD]
        schemaValue = {}
        if checkArgumentPresent(clTypeKeyword):
          getKeywordAttribute(typeKeywords, schemaValue)
        schemaValue['value'] = getString(Cmd.OB_STRING, minLen=0)
        if schemaValue['value'] or not ignoreEmpty:
          body[up][schemaName][fieldName].append(schemaValue)
      else:
        schemaValue = getString(Cmd.OB_STRING, minLen=0)
        if schemaValue or not ignoreEmpty:
          body[up][schemaName][fieldName] = schemaValue
        elif updateCmd:
          body[up][schemaName][fieldName] = None
    else:
      unknownArgumentExit()
  if not PwdOpts.makeUniqueRandomPassword:
    PwdOpts.AssignPassword(body, notify, notFoundBody, createIfNotFound)
  return (body, notify, tagReplacements, addGroups, PwdOpts, updatePrimaryEmail, notFoundBody, groupOrgUnitMap, createIfNotFound, noActionIfAlias)

def createUserAddToGroups(cd, user, addGroups, i, count):
  action = Act.Get()
  Act.Set(Act.ADD)
  _addUserToGroups(cd, user, set(addGroups), addGroups, i, count)
  Act.Set(action)

# gam create user <EmailAddress> <UserAttribute>
#	(groups [<GroupRole>] [[delivery] <DeliverySetting>] <GroupEntity>)*
#	[notify <EmailAddress>] [subject <String>] [notifypassword <String>]
#	    [(message|htmlmessage <String>)|(file|htmlfile <FileName> [charset <CharSet>])|
#	     (gdoc|ghtml <UserGoogleDoc>)] [html [<Boolean>]]
#	(replace <Tag> <String>)*
#	[lograndompassword <FileName>] [ignorenullpassword]
def doCreateUser():
  cd = buildGAPIObject(API.DIRECTORY)
  body, notify, tagReplacements, addGroups, PwdOpts, _, _, _, _, _ = getUserAttributes(cd, False, noUid=True)
  user = body['primaryEmail']
  fields = '*' if tagReplacements['subs'] else 'primaryEmail,name'
  try:
    result = callGAPI(cd.users(), 'insert',
                      throwReasons=[GAPI.DUPLICATE, GAPI.DOMAIN_NOT_FOUND,
                                    GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN,
                                    GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_PARAMETER,
                                    GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE],
                      body=body, fields=fields)
    entityActionPerformed([Ent.USER, user])
    if PwdOpts.filename and PwdOpts.password:
      writeFile(PwdOpts.filename, f'{user},{PwdOpts.password}\n', mode='a', continueOnError=True)
    if addGroups:
      createUserAddToGroups(cd, result['primaryEmail'], addGroups, 0, 0)
    if notify.get('emailAddress'):
      sendCreateUpdateUserNotification(result, notify, tagReplacements)
  except GAPI.duplicate:
    entityDuplicateWarning([Ent.USER, user])
  except GAPI.invalidSchemaValue:
    entityActionFailedWarning([Ent.USER, user], Msg.INVALID_SCHEMA_VALUE)
  except GAPI.invalidOrgunit:
    entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT)
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
          GAPI.invalid, GAPI.invalidInput, GAPI.invalidParameter) as e:
    entityActionFailedWarning([Ent.USER, user], str(e))

def verifyPrimaryEmail(cd, user, createIfNotFound, i, count):
  try:
    result = callGAPI(cd.users(), 'get',
                      throwReasons=GAPI.USER_GET_THROW_REASONS,
                      userKey=user, fields='id,primaryEmail')
    if (result['primaryEmail'].lower() == user) or (result['id'] == user):
      return True
    entityActionNotPerformedWarning([Ent.USER, user], Msg.NOT_A_PRIMARY_EMAIL_ADDRESS, i, count)
    return False
  except GAPI.userNotFound:
    if createIfNotFound:
      return True
  except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
    pass
  entityUnknownWarning(Ent.USER, user, i, count)
  return False

# gam <UserTypeEntity> update user <UserAttribute>* [noactionifalias]
#	[updateprimaryemail <RegularExpression> <EmailReplacement>]
#	[updateoufromgroup <FileName> [charset <String>] [columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	    [keyfield <FieldName>] [datafield <FieldName>]]
#	[clearschema <SchemaName>] [clearschema <SchemaName>.<FieldName>]
#	[createifnotfound] [notfoundpassword random|<Password>]
#	(groups [<GroupRole>] [[delivery] <DeliverySetting>] <GroupEntity>)*
#	[notify <EmailAddress>] [subject <String>] [notifypassword <String>]
#	    [(message|htmlmessage <String>)|(file|htmlfile <FileName> [charset <CharSet>])|
#	     (gdoc|ghtml <UserGoogleDoc>)] [html [<Boolean>]]
#	(replace <Tag> <String>)*
#	[lograndompassword <FileName>] [ignorenullpassword]
def updateUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  body, notify, tagReplacements, addGroups, PwdOpts, updatePrimaryEmail, notFoundBody, groupOrgUnitMap, createIfNotFound, noActionIfAlias = getUserAttributes(cd, True)
  vfe = 'primaryEmail' in body and body['primaryEmail'][:4].lower() == 'vfe@'
  i, count, entityList = getEntityArgument(entityList)
  fields = '*' if tagReplacements['subs'] else 'primaryEmail,name'
  for user in entityList:
    i += 1
    user = userKey = normalizeEmailAddressOrUID(user)
    if noActionIfAlias and not verifyPrimaryEmail(cd, user, createIfNotFound, i, count):
      continue
    try:
      if vfe:
        result = callGAPI(cd.users(), 'get',
                          throwReasons=GAPI.USER_GET_THROW_REASONS,
                          userKey=userKey, fields='primaryEmail,id')
        userKey = result['id']
        userPrimary = result['primaryEmail']
        userName, userDomain = splitEmailAddress(userPrimary)
        body['primaryEmail'] = f'vfe.{userName}.{random.randint(1, 99999):05d}@{userDomain}'
        body['emails'] = [{'type': 'custom',
                           'customType': 'former_employee',
                           'primary': False, 'address': userPrimary}]
      elif updatePrimaryEmail:
        if updatePrimaryEmail['pattern'].search(user) is not None:
          body['primaryEmail'] = updatePrimaryEmail['pattern'].sub(updatePrimaryEmail['replace'], user)
        else:
          body.pop('primaryEmail', None)
          if not body:
            entityActionNotPerformedWarning([Ent.USER, user], Msg.PRIMARY_EMAIL_DID_NOT_MATCH_PATTERN.format(updatePrimaryEmail['search']), i, count)
      if groupOrgUnitMap:
        try:
          groups = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=userKey, orderBy='email', fields='nextPageToken,groups(email)')
        except (GAPI.invalidMember, GAPI.invalidInput):
          entityUnknownWarning(Ent.USER, userKey, i, count)
          continue
        groupList = []
        for group in groups:
          orgUnit = groupOrgUnitMap.get(group['email'].lower())
          if orgUnit:
            groupList.append(group['email'])
        jcount = len(groupList)
        if jcount != 1:
          entityActionNotPerformedWarning([Ent.USER, user], Msg.USER_BELONGS_TO_N_GROUPS_THAT_MAP_TO_ORGUNITS.format(jcount, ','.join(groupList)), i, count)
          continue
        body['orgUnitPath'] = orgUnit
      if body:
        if PwdOpts.makeUniqueRandomPassword:
          PwdOpts.AssignPassword(body, notify, notFoundBody, createIfNotFound)
        try:
          result = callGAPI(cd.users(), 'update',
                            throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN,
                                          GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_PARAMETER,
                                          GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE, GAPI.DUPLICATE,
                                          GAPI.INSUFFICIENT_ARCHIVED_USER_LICENSES],
                            userKey=userKey, body=body, fields=fields)
          entityActionPerformed([Ent.USER, user], i, count)
          if PwdOpts.filename and PwdOpts.password:
            writeFile(PwdOpts.filename, f'{userKey},{PwdOpts.password}\n', mode='a', continueOnError=True)
          if notify.get('emailAddress') and notify['password']:
            sendCreateUpdateUserNotification(result, notify, tagReplacements, i, count, createMessage=False)
        except GAPI.userNotFound:
          if createIfNotFound:
            if notFoundBody and (count == 1) and not vfe and ('password' in notFoundBody) and ('name' in body) and ('givenName' in body['name']) and ('familyName' in body['name']):
              if 'primaryEmail' not in body:
                body['primaryEmail'] = user
              body.update(notFoundBody)
              try:
                result = callGAPI(cd.users(), 'insert',
                                  throwReasons=[GAPI.DUPLICATE, GAPI.DOMAIN_NOT_FOUND, GAPI.FORBIDDEN,
                                                GAPI.INVALID, GAPI.INVALID_INPUT, GAPI.INVALID_PARAMETER,
                                                GAPI.INVALID_ORGUNIT, GAPI.INVALID_SCHEMA_VALUE],
                                  body=body, fields=fields)
                Act.Set(Act.CREATE)
                entityActionPerformed([Ent.USER, user], i, count)
                if PwdOpts.filename and PwdOpts.notFoundPassword:
                  writeFile(PwdOpts.filename, f'{user},{PwdOpts.notFoundPassword}\n', mode='a', continueOnError=True)
                if addGroups:
                  createUserAddToGroups(cd, result['primaryEmail'], addGroups, i, count)
                if notify.get('emailAddress'):
                  notify['password'] = notify['notFoundPassword']
                  sendCreateUpdateUserNotification(result, notify, tagReplacements, i, count)
              except GAPI.duplicate:
                entityDuplicateWarning([Ent.USER, user], i, count)
            else:
              entityActionFailedWarning([Ent.USER, user], Msg.UNABLE_TO_CREATE_NOT_FOUND_USER, i, count)
          else:
            entityUnknownWarning(Ent.USER, user, i, count)
      else:
        entityActionNotPerformedWarning([Ent.USER, user], Msg.NO_CHANGES, i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except GAPI.invalidSchemaValue:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_SCHEMA_VALUE, i, count)
    except GAPI.duplicate as e:
      entityActionFailedWarning([Ent.USER, user, Ent.USER, body['primaryEmail']], str(e), i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT, i, count)
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
            GAPI.invalid, GAPI.invalidInput, GAPI.invalidParameter, GAPI.insufficientArchivedUserLicenses,
            GAPI.badRequest, GAPI.backendError, GAPI.systemError) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam update users <UserTypeEntity> ...
def doUpdateUsers():
  updateUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1])

# gam update user <UserItem> ...
def doUpdateUser():
  updateUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

# gam <UserTypeEntity> delete users [noactionifalias]
def deleteUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  noActionIfAlias = checkArgumentPresent('noactionifalias')
  checkForExtraneousArguments()
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if noActionIfAlias and not verifyPrimaryEmail(cd, user, False, i, count):
      continue
    try:
      callGAPI(cd.users(), 'delete',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                             GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
               userKey=user)
      entityActionPerformed([Ent.USER, user], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam delete users <UserTypeEntity> [noactionifalias]
def doDeleteUsers():
  deleteUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1])

# gam delete user <UserItem> [noactionifalias]
def doDeleteUser():
  deleteUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

# gam <UserEntity> undelete users [org|ou <OrgUnitPath>]
def undeleteUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkArgumentPresent(['org', 'ou']):
    entitySelector = getEntitySelector()
    if entitySelector:
      orgUnitPaths = getEntitySelection(entitySelector, True)
    else:
      orgUnitPaths = [getOrgUnitItem()]
    userOrgUnitLists = orgUnitPaths if isinstance(orgUnitPaths, dict) else None
  else:
    orgUnitPaths = ['/']
    userOrgUnitLists = None
  checkForExtraneousArguments()
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    origUser = user
    user = normalizeEmailAddressOrUID(user)
    user_uid = user if user.find('@') == -1 else None
    if not user_uid:
      printEntityKVList([Ent.DELETED_USER, user],
                        [Msg.LOOKING_UP_GOOGLE_UNIQUE_ID, None],
                        i, count)
      try:
        deleted_users = callGAPIpages(cd.users(), 'list', 'users',
                                      throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                                      customer=GC.Values[GC.CUSTOMER_ID], showDeleted=True, orderBy='email',
                                      maxResults=GC.Values[GC.USER_MAX_RESULTS])
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        accessErrorExit(cd)
      matching_users = []
      for deleted_user in deleted_users:
        if str(deleted_user['primaryEmail']).lower() == user:
          matching_users.append(deleted_user)
      jcount = len(matching_users)
      if jcount == 0:
        entityUnknownWarning(Ent.DELETED_USER, user, i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if jcount > 1:
        entityActionNotPerformedWarning([Ent.DELETED_USER, user],
                                        Msg.PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Ent.Plural(Ent.DELETED_USER), 'undelete', 'uid:<String>'),
                                        i, count)
        Ind.Increment()
        j = 0
        for matching_user in matching_users:
          printEntity([Ent.UNIQUE_ID, matching_user['id']], j, jcount)
          Ind.Increment()
          for attr_name in ['creationTime', 'lastLoginTime', 'deletionTime']:
            if attr_name in matching_user:
              printKeyValueList([attr_name, formatLocalTime(matching_user[attr_name])])
          Ind.Decrement()
        Ind.Decrement()
        setSysExitRC(MULTIPLE_DELETED_USERS_FOUND_RC)
        continue
      user_uid = matching_users[0]['id']
    if userOrgUnitLists:
      orgUnitPaths = userOrgUnitLists[origUser]
    try:
      callGAPI(cd.users(), 'undelete',
               throwReasons=[GAPI.DELETED_USER_NOT_FOUND, GAPI.INVALID_ORGUNIT,
                             GAPI.DOMAIN_NOT_FOUND, GAPI.DOMAIN_CANNOT_USE_APIS,
                             GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.DUPLICATE],
               userKey=user_uid, body={'orgUnitPath': makeOrgUnitPathAbsolute(orgUnitPaths[0])})
      entityActionPerformed([Ent.DELETED_USER, user], i, count)
    except GAPI.deletedUserNotFound:
      entityUnknownWarning(Ent.DELETED_USER, user, i, count)
    except GAPI.invalidOrgunit:
      entityActionFailedWarning([Ent.USER, user], Msg.INVALID_ORGUNIT, i, count)
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.invalid, GAPI.duplicate) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam undelete users <UserEntity> [org|ou <OrgUnitPath>]
def doUndeleteUsers():
  undeleteUsers(getEntityList(Cmd.OB_USER_ENTITY))

# gam undelete user <UserItem> [org|ou <OrgUnitPath>]
def doUndeleteUser():
  undeleteUsers(getStringReturnInList(Cmd.OB_USER_ITEM))

def suspendUnsuspendUsers(entityList, suspended):
  cd = buildGAPIObject(API.DIRECTORY)
  noActionIfAlias = checkArgumentPresent('noactionifalias')
  checkForExtraneousArguments()
  body = {'suspended': suspended}
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if noActionIfAlias and not verifyPrimaryEmail(cd, user, False, i, count):
      continue
    try:
      callGAPI(cd.users(), 'update',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                             GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
               userKey=user, body=body)
      entityActionPerformed([Ent.USER, user], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam <UserTypeEntity> suspend users [noactionifalias]
def suspendUsers(entityList):
  suspendUnsuspendUsers(entityList, True)

# gam suspend users <UserTypeEntity> [noactionifalias]
def doSuspendUsers():
  suspendUnsuspendUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1], True)

# gam suspend user <UserItem> [noactionifalias]
def doSuspendUser():
  suspendUnsuspendUsers(getStringReturnInList(Cmd.OB_USER_ITEM), True)

# gam <UserTypeEntity> unsuspend users [noactionifalias]
def unsuspendUsers(entityList):
  suspendUnsuspendUsers(entityList, False)

# gam unsuspend users <UserTypeEntity> [noactionifalias]
def doUnsuspendUsers():
  suspendUnsuspendUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)[1], False)

# gam unsuspend user <UserItem> [noactionifalias]
def doUnsuspendUser():
  suspendUnsuspendUsers(getStringReturnInList(Cmd.OB_USER_ITEM), False)

# gam <UserTypeEntity> signout
# gam <UserTypeEntity> turnoff2sv
def signoutTurnoff2SVUsers(entityList):
  cd = buildGAPIObject(API.DIRECTORY)
  if Act.Get() == Act.SIGNOUT:
    service = cd.users()
    function = 'signOut'
  else:
    service = cd.twoStepVerification()
    function = 'turnOff'
  checkForExtraneousArguments()
  i, count, entityList = getEntityArgument(entityList)
  for user in entityList:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(service, function,
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.DOMAIN_NOT_FOUND,
                             GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN, GAPI.AUTH_ERROR],
               userKey=user)
      entityActionPerformed([Ent.USER, user], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.invalid, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.authError) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

USER_NAME_PROPERTY_PRINT_ORDER = [
  'givenName',
  'familyName',
  'fullName',
  ]
USER_LANGUAGE_PROPERTY_PRINT_ORDER = [
  'languageCode',
  'customLanguage',
  ]
USER_SCALAR_PROPERTY_PRINT_ORDER = [
  'isAdmin',
  'isDelegatedAdmin',
  'isEnrolledIn2Sv',
  'isEnforcedIn2Sv',
  'agreedToTerms',
  'ipWhitelisted',
  'suspended',
  'suspensionReason',
  'archived',
  'changePasswordAtNextLogin',
  'id',
  'customerId',
  'isMailboxSetup',
  'includeInGlobalAddressList',
  'creationTime',
  'lastLoginTime',
  'deletionTime',
  'orgUnitPath',
  'recoveryEmail',
  'recoveryPhone',
  'thumbnailPhotoUrl',
  ]
USER_ARRAY_PROPERTY_PRINT_ORDER = [
  'gender',
  'keywords',
  'notes',
  'addresses',
  'locations',
  'organizations',
  'relations',
  'emails',
  'ims',
  'phones',
  'posixAccounts',
  'sshPublicKeys',
  'externalIds',
  'websites',
  ]

USER_ADDRESSES_PROPERTY_PRINT_ORDER = [
  'primary',
  'sourceIsStructured',
  'formatted',
  'extendedAddress',
  'streetAddress',
  'poBox',
  'locality',
  'region',
  'postalCode',
  'country',
  'countryCode',
  ]

USER_LOCATIONS_PROPERTY_PRINT_ORDER = [
  'area',
  'buildingId',
  'buildingName',
  'floorName',
  'floorSection',
  'deskCode',
  ]

USER_ORGANIZATIONS_PROPERTY_PRINT_ORDER = [
  'name',
  'description',
  'domain',
  'symbol',
  'location',
  'costCenter',
  'department',
  'title',
  'fullTimeEquivalent',
  'primary',
  ]

USER_POSIX_PROPERTY_PRINT_ORDER = [
  'accountId',
  'uid',
  'gid',
  'systemId',
  'operatingSystemType',
  'homeDirectory',
  'shell',
  'gecos',
  'primary',
  ]

USER_SSH_PROPERTY_PRINT_ORDER = [
  'expirationTimeUsec',
  'fingerprint',
  ]

USER_FIELDS_CHOICE_MAP = {
  'address': 'addresses',
  'addresses': 'addresses',
  'admin': ['isAdmin', 'isDelegatedAdmin'],
  'agreed2terms': 'agreedToTerms',
  'agreedtoterms': 'agreedToTerms',
  'aliases': ['aliases', 'nonEditableAliases'],
  'archived': 'archived',
  'changepassword': 'changePasswordAtNextLogin',
  'changepasswordatnextlogin': 'changePasswordAtNextLogin',
  'creationtime': 'creationTime',
  'customerid': 'customerId',
  'deletiontime': 'deletionTime',
  'email': 'emails',
  'emails': 'emails',
  'externalid': 'externalIds',
  'externalids': 'externalIds',
  'familyname': 'name.familyName',
  'firstname': 'name.givenName',
  'fullname': 'name.fullName',
  'gal': 'includeInGlobalAddressList',
  'givenname': 'name.givenName',
  'gender': ['gender.type', 'gender.customGender', 'gender.addressMeAs'],
  'id': 'id',
  'im': 'ims',
  'ims': 'ims',
  'includeinglobaladdresslist': 'includeInGlobalAddressList',
  'ipwhitelisted': 'ipWhitelisted',
  'isadmin': ['isAdmin', 'isDelegatedAdmin'],
  'isdelegatedadmin': ['isAdmin', 'isDelegatedAdmin'],
  'isenforcedin2sv': 'isEnforcedIn2Sv',
  'isenrolledin2sv': 'isEnrolledIn2Sv',
  'is2svenforced': 'isEnforcedIn2Sv',
  'is2svenrolled': 'isEnrolledIn2Sv',
  'ismailboxsetup': 'isMailboxSetup',
  'keyword': 'keywords',
  'keywords': 'keywords',
  'language': 'languages',
  'languages': 'languages',
  'lastlogintime': 'lastLoginTime',
  'lastname': 'name.familyName',
  'location': 'locations',
  'locations': 'locations',
  'name': ['name.givenName', 'name.familyName', 'name.fullName'],
  'nicknames': ['aliases', 'nonEditableAliases'],
  'noneditablealiases': ['aliases', 'nonEditableAliases'],
  'note': 'notes',
  'notes': 'notes',
  'org': 'orgUnitPath',
  'organization': 'organizations',
  'organizations': 'organizations',
  'orgunitpath': 'orgUnitPath',
  'otheremail': 'emails',
  'otheremails': 'emails',
  'ou': 'orgUnitPath',
  'phone': 'phones',
  'phones': 'phones',
  'photo': 'thumbnailPhotoUrl',
  'photourl': 'thumbnailPhotoUrl',
  'posix': 'posixAccounts',
  'posixaccounts': 'posixAccounts',
  'primaryemail': 'primaryEmail',
  'recoveryemail': 'recoveryEmail',
  'recoveryphone': 'recoveryPhone',
  'relation': 'relations',
  'relations': 'relations',
  'ssh': 'sshPublicKeys',
  'sshkeys': 'sshPublicKeys',
  'sshpublickeys': 'sshPublicKeys',
  'suspended': ['suspended', 'suspensionReason'],
  'thumbnailphotourl': 'thumbnailPhotoUrl',
  'username': 'primaryEmail',
  'website': 'websites',
  'websites': 'websites',
  }

INFO_USER_OPTIONS = {'noaliases', 'nobuildingnames', 'nogroups', 'nolicenses', 'nolicences', 'noschemas', 'schemas', 'userview'}
USER_SKIP_OBJECTS = {'thumbnailPhotoEtag'}
USER_TIME_OBJECTS = {'creationTime', 'deletionTime', 'lastLoginTime'}

def infoUsers(entityList):
  def _showType(row, typeKey, typeCustomValue, customTypeKey):
    if typeKey in row:
      if row[typeKey] != typeCustomValue or not row.get(customTypeKey):
        printKeyValueList([typeKey, row[typeKey]])
      else:
        printKeyValueList([typeKey, row[typeKey]])
        Ind.Increment()
        printKeyValueList([customTypeKey, row[customTypeKey]])
        Ind.Decrement()
      return True
    if customTypeKey in row:
      printKeyValueList([customTypeKey, row[customTypeKey]])
      return True
    return False

  def _callbackGetLicense(request_id, response, exception):
    if exception is None:
      if response and 'skuId' in response:
        licenses.append(response['skuId'])

  cd = buildGAPIObject(API.DIRECTORY)
  getAliases = getBuildingNames = getGroups = getLicenses = getSchemas = True
  FJQC = FormatJSONQuoteChar()
  projection = 'full'
  customFieldMask = None
  viewType = 'admin_view'
  fieldsList = []
  groups = []
  skus = SKU.getSortedSKUList()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'quick':
      getAliases = getBuildingNames = getGroups = getLicenses = getSchemas = False
    elif myarg == 'noaliases':
      getAliases = False
    elif myarg == 'nobuildingnames':
      getBuildingNames = False
    elif myarg == 'nogroups':
      getGroups = False
    elif myarg in {'nolicenses', 'nolicences'}:
      getLicenses = False
    elif myarg == 'noschemas':
      getSchemas = False
      projection = 'basic'
    elif myarg in {'custom', 'schemas', 'customschemas'}:
      getSchemas = True
      projection = 'custom'
      customFieldMask = getString(Cmd.OB_SCHEMA_NAME_LIST)
      if myarg == 'customschemas':
        fieldsList.append('customSchemas')
    elif myarg in {'products', 'product'}:
      skus = SKU.convertProductListToSKUList(getGoogleProductList())
    elif myarg in {'sku', 'skus'}:
      skus = getGoogleSKUList()
    elif myarg == 'userview':
      viewType = 'domain_public'
      getGroups = getLicenses = False
    elif getFieldsList(myarg, USER_FIELDS_CHOICE_MAP, fieldsList):
      pass
# Ignore info group arguments that may have come from whatis
    elif myarg in INFO_GROUP_OPTIONS:
      pass
    else:
      FJQC.GetFormatJSON(myarg)
  if fieldsList:
    fieldsList.append('primaryEmail')
  fields = getFieldsFromFieldsList(fieldsList)
  if getLicenses:
    lic = buildGAPIObject(API.LICENSING)
# Special case; for info users, 'all users' means 'all users_ns_susp'
  if isinstance(entityList, dict) and entityList.get('entityType') == Cmd.ENTITY_ALL_USERS:
    entityList['entityType'] = Cmd.ENTITY_ALL_USERS_NS_SUSP
  i, count, entityList = getEntityArgument(entityList)
  for userEmail in entityList:
    i += 1
    userEmail = normalizeEmailAddressOrUID(userEmail)
    try:
      user = callGAPI(cd.users(), 'get',
                      throwReasons=GAPI.USER_GET_THROW_REASONS+[GAPI.INVALID_INPUT, GAPI.RESOURCE_NOT_FOUND],
                      userKey=userEmail, projection=projection, customFieldMask=customFieldMask, viewType=viewType, fields=fields)
      if getGroups:
        try:
          groups = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=user['primaryEmail'], orderBy='email', fields='nextPageToken,groups(name,email)')
        except (GAPI.forbidden, GAPI.domainNotFound):
### Print some message
          groups = []
      licenses = []
      if getLicenses:
        svcargs = dict([('userId', None), ('productId', None), ('skuId', None), ('fields', 'skuId')]+GM.Globals[GM.EXTRA_ARGS_LIST])
        method = getattr(lic.licenseAssignments(), 'get')
        dbatch = lic.new_batch_http_request(callback=_callbackGetLicense)
        for skuId in skus:
          svcparms = svcargs.copy()
          svcparms['userId'] = user['primaryEmail']
          svcparms['productId'], svcparms['skuId'] = SKU.getProductAndSKU(skuId)
          dbatch.add(method(**svcparms))
        dbatch.execute()
      if FJQC.formatJSON:
        if getGroups:
          user['groups'] = groups
        if getLicenses:
          user['licenses'] = [SKU.formatSKUIdDisplayName(u_license) for u_license in licenses]
        printLine(json.dumps(cleanJSON(user, skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.USER, user['primaryEmail']], i, count)
      Ind.Increment()
      printKeyValueList(['Settings', None])
      Ind.Increment()
      if 'name' in user:
        for up in USER_NAME_PROPERTY_PRINT_ORDER:
          if up in user['name']:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user['name'][up]])
      up = 'languages'
      if up in user:
        propertyValue = user[up]
        if propertyValue:
          for up in USER_LANGUAGE_PROPERTY_PRINT_ORDER:
            languages = [row[up] for row in propertyValue if up in row]
            if languages:
              printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], ','.join(languages)])
      for up in USER_SCALAR_PROPERTY_PRINT_ORDER:
        if up in user:
          if up not in USER_TIME_OBJECTS:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], user[up]])
          else:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], formatLocalTime(user[up])])
      Ind.Decrement()
      for up in USER_ARRAY_PROPERTY_PRINT_ORDER:
        if up not in user:
          continue
        propertyValue = user[up]
        userProperty = UProp.PROPERTIES[up]
        propertyClass = userProperty[UProp.CLASS]
        propertyTitle = userProperty[UProp.TITLE]
        if UProp.TYPE_KEYWORDS in userProperty:
          typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
          typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
        if propertyClass == UProp.PC_ARRAY:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              for key in row:
                if key in [typeKey, customTypeKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_GENDER:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            _showType(propertyValue, typeKey, typeCustomValue, customTypeKey)
            if 'addressMeAs' in propertyValue:
              printKeyValueList(['addressMeAs', propertyValue['addressMeAs']])
            Ind.Decrement()
        elif propertyClass == UProp.PC_ADDRESSES:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              for key in USER_ADDRESSES_PROPERTY_PRINT_ORDER:
                if key in row:
                  if key != 'formatted':
                    printKeyValueList([key, row[key]])
                  else:
                    printKeyValueWithCRsNLs(key, row[key])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_EMAILS:
          if propertyValue:
            needTitle = True
            for row in propertyValue:
              if row['address'].lower() == user['primaryEmail'].lower():
                continue
              if needTitle:
                needTitle = False
                printKeyValueList([propertyTitle, None])
                Ind.Increment()
              if not _showType(row, typeKey, typeCustomValue, customTypeKey):
                if not getAliases:
                  continue
                printKeyValueList([typeKey, 'alias'])
              Ind.Increment()
              for key in row:
                if key in [typeKey, customTypeKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            if not needTitle:
              Ind.Decrement()
        elif propertyClass == UProp.PC_IMS:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            protocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_KEYWORD]
            protocolCustomValue = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
            customProtocolKey = UProp.IM_PROTOCOLS[UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              _showType(row, protocolKey, protocolCustomValue, customProtocolKey)
              for key in row:
                if key in [typeKey, customTypeKey, protocolKey, customProtocolKey]:
                  continue
                printKeyValueList([key, row[key]])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_NOTES:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, dict):
              typeVal = propertyValue.get(typeKey, 'text_plain')
              printKeyValueList([typeKey, typeVal])
              Ind.Increment()
              if typeVal == 'text_html':
                printKeyValueWithCRsNLs('value', dehtml(propertyValue['value']))
              else:
                printKeyValueWithCRsNLs('value', propertyValue['value'])
              Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_LOCATIONS:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                _showType(row, typeKey, typeCustomValue, customTypeKey)
                Ind.Increment()
                if getBuildingNames:
                  row['buildingName'] = _getBuildingNameById(cd, row.get('buildingId', ''))
                for key in USER_LOCATIONS_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_ORGANIZATIONS:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            for row in propertyValue:
              _showType(row, typeKey, typeCustomValue, customTypeKey)
              Ind.Increment()
              for key in USER_ORGANIZATIONS_PROPERTY_PRINT_ORDER:
                if key in row:
                  printKeyValueList([key, row[key]])
              Ind.Decrement()
            Ind.Decrement()
        elif propertyClass == UProp.PC_POSIX:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                printKeyValueList(['username', row.get('username')])
                Ind.Increment()
                for key in USER_POSIX_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
        elif propertyClass == UProp.PC_SSH:
          if propertyValue:
            printKeyValueList([propertyTitle, None])
            Ind.Increment()
            if isinstance(propertyValue, list):
              for row in propertyValue:
                printKeyValueList(['key', row['key']])
                Ind.Increment()
                for key in USER_SSH_PROPERTY_PRINT_ORDER:
                  if key in row:
                    printKeyValueList([key, row[key]])
                Ind.Decrement()
            else:
              printKeyValueList([Ind.MultiLineText(propertyValue)])
            Ind.Decrement()
      if getSchemas:
        up = 'customSchemas'
        if up in user:
          propertyValue = user[up]
          userProperty = UProp.PROPERTIES[up]
          propertyTitle = userProperty[UProp.TITLE]
          typeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_KEYWORD]
          typeCustomValue = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_TYPE_CUSTOM_VALUE]
          customTypeKey = userProperty[UProp.TYPE_KEYWORDS][UProp.PTKW_ATTR_CUSTOMTYPE_KEYWORD]
          printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], None])
          Ind.Increment()
          for schema in sorted(propertyValue):
            printKeyValueList(['Schema', schema])
            Ind.Increment()
            for field in propertyValue[schema]:
              if isinstance(propertyValue[schema][field], list):
                printKeyValueList([field])
                Ind.Increment()
                for an_item in propertyValue[schema][field]:
                  _showType(an_item, typeKey, typeCustomValue, customTypeKey)
                  Ind.Increment()
                  printKeyValueList(['value', an_item['value']])
                  Ind.Decrement()
                Ind.Decrement()
              else:
                printKeyValueList([field, propertyValue[schema][field]])
            Ind.Decrement()
          Ind.Decrement()
      if getAliases:
        for up in ['aliases', 'nonEditableAliases']:
          propertyValue = user.get(up, [])
          if propertyValue:
            printEntitiesCount([Ent.NONEDITABLE_ALIAS, Ent.EMAIL_ALIAS][up == 'aliases'], propertyValue)
            Ind.Increment()
            for alias in propertyValue:
              printKeyValueList(['alias', alias])
            Ind.Decrement()
      if groups:
        printEntitiesCount(Ent.GROUP, groups)
        Ind.Increment()
        for group in groups:
          printKeyValueList([group['name'], group['email']])
        Ind.Decrement()
      if licenses:
        printEntitiesCount(Ent.LICENSE, licenses)
        Ind.Increment()
        for u_license in licenses:
          printKeyValueList([SKU.formatSKUIdDisplayName(u_license)])
        Ind.Decrement()
      Ind.Decrement()
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, userEmail, i, count)
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden,
            GAPI.badRequest, GAPI.backendError, GAPI.systemError) as e:
      entityActionFailedWarning([Ent.USER, userEmail], str(e), i, count)
    except (GAPI.invalidInput, GAPI.invalidMember) as e:
      if customFieldMask:
        entityActionFailedWarning([Ent.USER, userEmail], invalidUserSchema(customFieldMask), i, count)
      else:
        entityActionFailedWarning([Ent.USER, userEmail], str(e), i, count)

# gam info users <UserTypeEntity> [quick] [noaliases] [nogroups] [nolicenses|nolicences]
#	[noschemas|(schemas|custom <SchemaNameList>)|(customschemas <SchemaNameList>)]
#	[userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
def doInfoUsers():
  infoUsers(getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, delayGet=True)[1])

# gam info user <UserItem> [quick] [noaliases] [nogroups] [nolicenses|nolicences]
#	[noschemas|(schemas|custom <SchemaNameList>)|(customschemas <SchemaNameList>)]
#	[userview] [fields <UserFieldNameList>] [products|product <ProductIDList>] [skus|sku <SKUIDList>] [formatjson]
# gam info user
def doInfoUser():
  if Cmd.ArgumentsRemaining():
    infoUsers(getStringReturnInList(Cmd.OB_USER_ITEM))
  else:
    infoUsers([_getAdminEmail()])

USERS_ORDERBY_CHOICE_MAP = {
  'familyname': 'familyName',
  'lastname': 'familyName',
  'givenname': 'givenName',
  'firstname': 'givenName',
  'email': 'email',
  }
USERS_INDEXED_TITLES = ['addresses', 'aliases', 'nonEditableAliases', 'emails', 'externalIds',
                        'ims', 'keywords', 'locations', 'organizations',
                        'phones', 'posixAccounts', 'relations', 'sshPublicKeys', 'websites']

# gam print users [todrive <ToDriveAttribute>*]
#	([domain <DomainName>] [(query <QueryUser>)|(queries <QueryUserList>)]
#	 [limittoou <OrgUnitItem>] [deleted_only|only_deleted])|[select <UserTypeEntity>]
#	[groups|groupsincolumns] [license|licenses|licence|licences] [emailpart|emailparts|username] [schemas|custom all|<SchemaNameList>]
#	[orderby <UserOrderByFieldName> [ascending|descending]]
#	[userview] [basic|full|allfields | <UserFieldName>* | fields <UserFieldNameList>]
#	[delimiter <Character>] [sortheaders] [formatjson [quotechar <Character>]] [quoteplusphonenumbers]
#	[issuspended <Boolean>]
#
# gam <UserTypeEntity> print users [todrive <ToDriveAttribute>*]
#	[groups|groupsincolumns] [license|licenses|licence|licences] [emailpart|emailparts|username] [schemas|custom all|<SchemaNameList>]
#	[orderby <UserOrderByFieldName> [ascending|descending]]
#	[userview] [basic|full|allfields | <UserFieldName>* | fields <UserFieldNameList>]
#	[delimiter <Character>] [sortheaders] [formatjson [quotechar <Character>]] [quoteplusphonenumbers]
#	[issuspended <Boolean>]
#
# gam print users [todrive <ToDriveAttribute>*]
#	([domain <DomainName>] [(query <QueryUser>)|(queries <QueryUserList>)]
#	 [limittoou <OrgUnitItem>] [deleted_only|only_deleted])|[select <UserTypeEntity>]
#	[formatjson [quotechar <Character>]] [countonly]
#	[issuspended <Boolean>]
#
# gam <UserTypeEntity> print users [todrive <ToDriveAttribute>*]
#	[formatjson [quotechar <Character>]] [countonly]
#	[issuspended <Boolean>]
def doPrintUsers(entityList=None):
  def _printUser(userEntity, i, count):
    if isSuspended is None or isSuspended == userEntity.get('suspended', isSuspended):
      userEmail = userEntity['primaryEmail']
      if printOptions['emailParts']:
        if userEmail.find('@') != -1:
          userEntity['primaryEmailLocal'], userEntity['primaryEmailDomain'] = splitEmailAddress(userEmail)
      for location in userEntity.get('locations', []):
        location['buildingName'] = _getBuildingNameById(cd, location.get('buildingId', ''))
      if quotePlusPhoneNumbers:
        for phone in userEntity.get('phones', []):
          phoneNumber = phone.get('value', '')
          if phoneNumber.startswith('+'):
            phone['value'] = "'"+phoneNumber
      if printOptions['getGroupFeed']:
        printGettingAllEntityItemsForWhom(Ent.GROUP_MEMBERSHIP, userEmail, i, count)
        try:
          groups = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=userEmail, orderBy='email', fields='nextPageToken,groups(email)')
          numGroups = len(groups)
          if not printOptions['groupsInColumns']:
            userEntity['GroupsCount'] = numGroups
            userEntity['Groups'] = delimiter.join([groupname['email'] for groupname in groups])
          else:
            if numGroups > printOptions['maxGroups']:
              printOptions['maxGroups'] = numGroups
            userEntity['Groups'] = numGroups
            for j, group in enumerate(groups):
              userEntity[f'Groups.{j}'] = group['email']
        except (GAPI.invalidMember, GAPI.invalidInput):
          badRequestWarning(Ent.GROUP, Ent.MEMBER, userEmail)
        except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
          accessErrorExit(cd)
      if licenses:
        u_licenses = licenses.get(userEmail.lower())
        if u_licenses:
          userEntity['LicensesCount'] = len(u_licenses)
          userEntity['Licenses'] = delimiter.join(u_licenses)
          userEntity['LicensesDisplay'] = delimiter.join([SKU.skuIdToDisplayName(skuId) for skuId in u_licenses])
        else:
          userEntity['LicensesCount'] = 0
      row = flattenJSON(userEntity, skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS)
      if not FJQC.formatJSON:
        csvPF.WriteRowTitles(row)
      elif csvPF.CheckRowTitles(row):
        csvPF.WriteRowNoFilter({'primaryEmail': userEmail,
                                'JSON': json.dumps(cleanJSON(userEntity, skipObjects=USER_SKIP_OBJECTS, timeObjects=USER_TIME_OBJECTS),
                                                   ensure_ascii=False, sort_keys=True)})

  def _updateDomainCounts(emailAddress):
    atLoc = emailAddress.find('@')
    if atLoc == -1:
      dom = 'Unknown'
    else:
      dom = emailAddress[atLoc+1:].lower()
    domainCounts.setdefault(dom, 0)
    domainCounts[dom] += 1

  _PRINT_USER_REASON_TO_MESSAGE_MAP = {GAPI.RESOURCE_NOT_FOUND: Msg.DOES_NOT_EXIST}
  def _callbackPrintUser(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _printUser(response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason in GAPI.USER_GET_THROW_REASONS:
        entityUnknownWarning(Ent.USER, ri[RI_ITEM], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      elif (reason == GAPI.INVALID_INPUT) and customFieldMask:
        entityActionFailedWarning([Ent.USER, ri[RI_ITEM]], invalidUserSchema(customFieldMask), int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        errMsg = getHTTPError(_PRINT_USER_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        printKeyValueList([ERROR, errMsg])

  cd = buildGAPIObject(API.DIRECTORY)
  fieldsList = ['primaryEmail']
  csvPF = CSVPrintFile(fieldsList, indexedTitles=USERS_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  printOptions = {
    'countOnly': False,
    'emailParts': False,
    'getGroupFeed': False,
    'getLicenseFeed': False,
    'groupsInColumns': False,
    'scalarsFirst': False,
    'sortHeaders': False,
    'maxGroups': 0
    }
  customer = GC.Values[GC.CUSTOMER_ID]
  licenses = {}
  domain = None
  queries = [None]
  projection = 'basic'
  projectionSet = False
  customFieldMask = None
  quotePlusPhoneNumbers = showDeleted = False
  isSuspended = orgUnitPath = orgUnitPathLower = orderBy = sortOrder = None
  viewType = 'admin_view'
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif entityList is None and myarg == 'limittoou':
      orgUnitPath = getOrgUnitItem(pathOnly=True)
      orgUnitPathLower = orgUnitPath.lower()
    elif myarg == 'domain':
      domain = getString(Cmd.OB_DOMAIN_NAME).lower()
      customer = None
    elif entityList is None and myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
    elif entityList is None and myarg in {'deletedonly', 'onlydeleted'}:
      showDeleted = True
    elif entityList is None and myarg == 'select':
      _, entityList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    elif myarg == 'issuspended':
      isSuspended = getBoolean()
    elif myarg == 'orderby':
      orderBy, sortOrder = getOrderBySortOrder(USERS_ORDERBY_CHOICE_MAP)
    elif myarg == 'userview':
      viewType = 'domain_public'
    elif myarg in {'custom', 'schemas', 'customschemas'}:
      if not fieldsList:
        fieldsList = ['primaryEmail']
      fieldsList.append('customSchemas')
      customFieldMask = getString(Cmd.OB_SCHEMA_NAME_LIST).replace(' ', ',')
      if customFieldMask.lower() == 'all':
        customFieldMask = None
        projection = 'full'
      else:
        projection = 'custom'
      projectionSet = True
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg in PROJECTION_CHOICE_MAP:
      projection = myarg
      projectionSet = printOptions['sortHeaders'] = True
      fieldsList = []
    elif myarg == 'allfields':
      projection = 'basic'
      projectionSet = printOptions['sortHeaders'] = True
      fieldsList = []
    elif myarg == 'sortheaders':
      printOptions['sortHeaders'] = getBoolean()
    elif myarg == 'scalarsfirst':
      printOptions['scalarsFirst'] = getBoolean()
    elif csvPF.GetFieldsListTitles(myarg, USER_FIELDS_CHOICE_MAP, fieldsList, initialField='primaryEmail'):
      pass
    elif myarg == 'groups':
      printOptions['getGroupFeed'] = True
      printOptions['groupsInColumns'] = False
    elif myarg == 'groupsincolumns':
      printOptions['getGroupFeed'] = True
      printOptions['groupsInColumns'] = True
    elif myarg in {'license', 'licenses', 'licence', 'licences'}:
      printOptions['getLicenseFeed'] = True
    elif myarg in {'emailpart', 'emailparts', 'username'}:
      printOptions['emailParts'] = True
    elif myarg in {'countonly', 'countsonly'}:
      printOptions['countOnly'] = True
    elif myarg == 'quoteplusphonenumbers':
      quotePlusPhoneNumbers = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  _, _, entityList = getEntityArgument(entityList)
  if printOptions['countOnly']:
    fieldsList = ['primaryEmail']
    domainCounts = {}
    if not FJQC.formatJSON:
      csvPF.SetTitles(['domain', 'count'])
    else:
      csvPF.SetJSONTitles(['JSON'])
  else:
    if FJQC.formatJSON:
      printOptions['sortHeaders'] = False
      csvPF.SetJSONTitles(['primaryEmail', 'JSON'])
    else:
      if printOptions['getGroupFeed']:
        if not printOptions['groupsInColumns']:
          csvPF.AddTitles(['GroupsCount', 'Groups'])
        else:
          csvPF.AddTitles(['Groups'])
      if printOptions['getLicenseFeed']:
        csvPF.AddTitles(['LicensesCount', 'Licenses', 'LicensesDisplay'])
    if printOptions['getLicenseFeed']:
      licenses = doPrintLicenses(returnFields=['userId', 'skuId'])
  if entityList is None:
    sortRows = False
    if orgUnitPath is not None:
      fieldsList.append('orgUnitPath')
    fields = getItemFieldsFromFieldsList('users', fieldsList)
    for query in queries:
      if orgUnitPath is not None:
        if query is not None and query.find(orgUnitPath) == -1:
          query += f" orgUnitPath='{orgUnitPath}'"
        else:
          if query is None:
            query = ''
          else:
            query += ' '
          query += f"orgUnitPath='{orgUnitPath}'"
      if isSuspended is not None:
        if query is None:
          query = ''
        else:
          query += ' '
        query += f'isSuspended={isSuspended}'
      printGettingAllAccountEntities(Ent.USER, query)
      pageMessage = getPageMessage(showFirstLastItems=True)
      pageToken = None
      totalItems = 0
      while True:
        try:
          feed = callGAPI(cd.users(), 'list',
                          throwReasons=[GAPI.DOMAIN_NOT_FOUND, GAPI.INVALID_ORGUNIT, GAPI.INVALID_INPUT,
                                        GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                          pageToken=pageToken,
                          customer=customer, domain=domain, query=query, fields=fields,
                          showDeleted=showDeleted, orderBy=orderBy, sortOrder=sortOrder, viewType=viewType,
                          projection=projection, customFieldMask=customFieldMask, maxResults=GC.Values[GC.USER_MAX_RESULTS])
        except GAPI.domainNotFound:
          entityActionFailedWarning([Ent.USER, None, Ent.DOMAIN, domain], Msg.NOT_FOUND)
          return
        except (GAPI.invalidOrgunit, GAPI.invalidInput) as e:
          if query and not customFieldMask:
            entityActionFailedWarning([Ent.USER, None], invalidQuery(query))
          elif customFieldMask and not query:
            entityActionFailedWarning([Ent.USER, None], invalidUserSchema(customFieldMask))
          elif query and customFieldMask:
            entityActionFailedWarning([Ent.USER, None], f'{invalidQuery(query)} or {invalidUserSchema(customFieldMask)}')
          else:
            entityActionFailedWarning([Ent.USER, None], str(e))
          return
        except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
          accessErrorExit(cd)
        pageToken, totalItems = _processGAPIpagesResult(feed, 'users', None, totalItems, pageMessage, 'primaryEmail', Ent.USER)
        if feed:
          if orgUnitPath is None:
            if not printOptions['countOnly']:
              for user in feed.get('users', []):
                _printUser(user, 0, 0)
            else:
              for user in feed.get('users', []):
                _updateDomainCounts(user['primaryEmail'])
          else:
            if not printOptions['countOnly']:
              for user in feed.get('users', []):
                if orgUnitPathLower == user.get('orgUnitPath', '').lower():
                  _printUser(user, 0, 0)
            else:
              for user in feed.get('users', []):
                if orgUnitPathLower == user.get('orgUnitPath', '').lower():
                  _updateDomainCounts(user['primaryEmail'])
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          break
  else:
    sortRows = True
# If no individual fields were specified (allfields, basic, full) or individual fields other than primaryEmail were specified, look up each user
    if isSuspended is not None:
      fieldsList.append('suspended')
    if projectionSet or len(set(fieldsList)) > 1:
      jcount = len(entityList)
      fields = getFieldsFromFieldsList(fieldsList)
      if GC.Values[GC.BATCH_SIZE] > 1 and jcount > 1:
        svcargs = dict([('userKey', None), ('fields', fields), ('projection', projection), ('customFieldMask', customFieldMask), ('viewType', viewType)]+GM.Globals[GM.EXTRA_ARGS_LIST])
        method = getattr(cd.users(), 'get')
        dbatch = cd.new_batch_http_request(callback=_callbackPrintUser)
        bcount = 0
        j = 0
        for userEntity in entityList:
          j += 1
          svcparms = svcargs.copy()
          svcparms['userKey'] = normalizeEmailAddressOrUID(userEntity)
          dbatch.add(method(**svcparms), request_id=batchRequestID('', 0, 0, j, jcount, svcparms['userKey']))
          bcount += 1
          if bcount >= GC.Values[GC.BATCH_SIZE]:
            executeBatch(dbatch)
            dbatch = cd.new_batch_http_request(callback=_callbackPrintUser)
            bcount = 0
        if bcount > 0:
          dbatch.execute()
      else:
        j = 0
        for userEntity in entityList:
          j += 1
          userEmail = normalizeEmailAddressOrUID(userEntity)
          try:
            user = callGAPI(cd.users(), 'get',
                            throwReasons=GAPI.USER_GET_THROW_REASONS+[GAPI.INVALID_INPUT, GAPI.RESOURCE_NOT_FOUND],
                            userKey=userEmail, projection=projection, customFieldMask=customFieldMask, viewType=viewType, fields=fields)
            _printUser(user, j, jcount)
          except (GAPI.userNotFound, GAPI.resourceNotFound):
            entityUnknownWarning(Ent.USER, userEmail, j, jcount)
          except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError) as e:
            entityActionFailedWarning([Ent.USER, userEmail], str(e), j, jcount)
          except GAPI.invalidInput as e:
            if customFieldMask:
              entityActionFailedWarning([Ent.USER, userEmail], invalidUserSchema(customFieldMask), j, jcount)
            else:
              entityActionFailedWarning([Ent.USER, userEmail], str(e), j, jcount)
# The only field specified was primaryEmail, just list the users/count the domains
    elif not printOptions['countOnly']:
      for userEntity in entityList:
        _printUser({'primaryEmail': normalizeEmailAddressOrUID(userEntity)}, 0, 0)
    else:
      for userEntity in entityList:
        _updateDomainCounts(normalizeEmailAddressOrUID(userEntity))
  if not printOptions['countOnly']:
    if printOptions['sortHeaders']:
      sortTitles = ['primaryEmail']
      if printOptions['scalarsFirst']:
        sortTitles.extend([f'name.{field}' for field in USER_NAME_PROPERTY_PRINT_ORDER]+sorted(USER_LANGUAGE_PROPERTY_PRINT_ORDER+USER_SCALAR_PROPERTY_PRINT_ORDER))
      csvPF.SetSortTitles(sortTitles)
      csvPF.SortTitles()
      csvPF.SetSortTitles([])
    if sortRows and orderBy:
      orderBy = 'primaryEmail' if orderBy == 'email' else f'name.{orderBy}'
      csvPF.SortRows(orderBy, reverse=sortOrder == 'DESCENDING')
    if printOptions['getGroupFeed']:
      if not printOptions['groupsInColumns']:
        csvPF.MoveTitlesToEnd(['GroupsCount', 'Groups'])
      else:
        csvPF.MoveTitlesToEnd(['Groups']+[f'Groups.{j}' for j in range(printOptions['maxGroups'])])
    if printOptions['getLicenseFeed']:
      csvPF.MoveTitlesToEnd(['LicensesCount', 'Licenses', 'LicensesDisplay'])
  elif not FJQC.formatJSON:
    for domain, count in sorted(iter(domainCounts.items())):
      csvPF.WriteRowNoFilter({'domain': domain, 'count': count})
  else:
    csvPF.WriteRowNoFilter({'JSON': json.dumps(cleanJSON(domainCounts), ensure_ascii=False, sort_keys=True)})
  if printOptions['countOnly']:
    csvPF.SetIndexedTitles([])
  csvPF.writeCSVfile('Users' if not printOptions['countOnly'] else 'User Domain Counts')

# gam <UserTypeEntity> print users
def doPrintUserEntity(entityList):
  if not Cmd.ArgumentsRemaining():
    writeEntityNoHeaderCSVFile(Ent.USER, entityList)
  else:
    doPrintUsers(entityList)

def getUserPeopleId(cd, user, i, count):
  if user.find('@') != -1:
    try:
      memberId = callGAPI(cd.users(), 'get',
                          throwReasons=GAPI.USER_GET_THROW_REASONS,
                          userKey=user, fields='id')['id']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
      memberId = None
  else:
    memberId = user
  return memberId

PEOPLE_FIELDS_CHOICE_MAP = {
  'addresses': 'addresses',
  'ageranges': 'ageRanges',
  'biographies': 'biographies',
  'birthdays': 'birthdays',
  'braggingrights': 'braggingRights',
  'coverphotos': 'coverPhotos',
  'emailaddresses': 'emailAddresses',
  'events': 'events',
  'genders': 'genders',
  'imclients': 'imClients',
  'interests': 'interests',
  'locales': 'locales',
  'memberships': 'memberships',
  'metadata': 'metadata',
  'names': 'names',
  'nicknames': 'nicknames',
  'occupations': 'occupations',
  'organizations': 'organizations',
  'phonenumbers': 'phoneNumbers',
  'photos': 'photos',
  'relations': 'relations',
  'relationshipinterests': 'relationshipInterests',
  'relationshipstatuses': 'relationshipStatuses',
  'residences': 'residences',
  'sipaddresses': 'sipAddresses',
  'skills': 'skills',
  'taglines': 'taglines',
  'urls': 'urls',
  'userdefined': 'userDefined',
  }

# gam <UserTypeEntity> print peopleprofile [todrive <ToDriveAttribute>*]
#	[allfields|(fields <PeopleFieldNameList>)]
#	[formatjson [quotechar <Character>]]
# gam <UserTypeEntity> show peopleprofile
#	[allfields|(fields <PeopleFieldNameList>)]
#	[formatjson]
def printShowPeopleProfile(users):
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['User', 'resourceName']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  peopleLookupUser = None
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'allfields':
      for field in PEOPLE_FIELDS_CHOICE_MAP:
        addFieldToFieldsList(field, PEOPLE_FIELDS_CHOICE_MAP, fieldsList)
    elif getFieldsList(myarg, PEOPLE_FIELDS_CHOICE_MAP, fieldsList):
      pass
    elif myarg == 'peoplelookupuser':
      peopleLookupUser = getEmailAddress()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if not fieldsList:
    fieldsList.append('names,emailAddresses')
  personFields = ','.join(set(fieldsList))
  if csvPF and FJQC.formatJSON:
    csvPF.SetJSONTitles(['User', 'resourceName', 'JSON'])
  if peopleLookupUser:
    _, people = buildGAPIServiceObject(API.PEOPLE, peopleLookupUser)
    if not people:
      return
  else:
    people = buildGAPIObject(API.PEOPLE)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    memberId = getUserPeopleId(cd, user, i, count)
    if not memberId:
      continue
    if csvPF:
      printGettingEntityItemForWhom(Ent.PEOPLE_PROFILE, user, i, count)
    try:
      result = callGAPI(people.people(), 'get',
                        throwReasons=GAPI.PEOPLE_GET_THROW_REASONS,
                        resourceName=f'people/{memberId}', personFields=personFields)
      if not csvPF:
        if not FJQC.formatJSON:
          printEntity([Ent.USER, user], i, count)
          Ind.Increment()
          showJSON(None, result)
          Ind.Decrement()
        else:
          printLine(json.dumps(cleanJSON(result), ensure_ascii=False, sort_keys=True))
      elif not FJQC.formatJSON:
        csvPF.WriteRowTitles(flattenJSON(result, flattened={'User': user}))
      elif csvPF.CheckRowTitles(result):
        csvPF.WriteRowNoFilter({'User': user, 'resourceName': result['resourceName'],
                                'JSON': json.dumps(cleanJSON(result),
                                                   ensure_ascii=False, sort_keys=True)})
    except GAPI.notFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.serviceNotAvailable, GAPI.forbidden):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('People Profiles')

SITEVERIFICATION_METHOD_CHOICE_MAP = {
  'cname': 'DNS_CNAME',
  'dnscname': 'DNS_CNAME',
  'dnstxt': 'DNS_TXT',
  'txt': 'DNS_TXT',
  'text': 'DNS_TXT',
  'file': 'FILE',
  'site': 'FILE',
  }

# gam create verify|verification <DomainName>
def doCreateSiteVerification():
  verif = buildGAPIObject(API.SITEVERIFICATION)
  a_domain = getString(Cmd.OB_DOMAIN_NAME)
  checkForExtraneousArguments()
  txt_record = callGAPI(verif.webResource(), 'getToken',
                        body={'site': {'type': 'INET_DOMAIN', 'identifier': a_domain},
                              'verificationMethod': 'DNS_TXT'})
  printKeyValueList(['TXT Record Name ', a_domain])
  printKeyValueList(['TXT Record Value', txt_record['token']])
  printBlankLine()
  cname_record = callGAPI(verif.webResource(), 'getToken',
                          body={'site': {'type': 'INET_DOMAIN', 'identifier': a_domain},
                                'verificationMethod': 'DNS_CNAME'})
  cname_token = cname_record['token']
  cname_list = cname_token.split(' ')
  cname_subdomain = cname_list[0]
  cname_value = cname_list[1]
  printKeyValueList(['CNAME Record Name ', f'{cname_subdomain}.{a_domain}'])
  printKeyValueList(['CNAME Record Value', cname_value])
  printBlankLine()
  webserver_file_record = callGAPI(verif.webResource(), 'getToken',
                                   body={'site': {'type': 'SITE', 'identifier': f'http://{a_domain}/'},
                                         'verificationMethod': 'FILE'})
  webserver_file_token = webserver_file_record['token']
  printKeyValueList(['Saving web server verification file to', webserver_file_token])
  writeFile(webserver_file_token, f'google-site-verification: {webserver_file_token}', continueOnError=True)
  printKeyValueList(['Verification File URL', f'http://{a_domain}/{webserver_file_token}'])
  printBlankLine()
  webserver_meta_record = callGAPI(verif.webResource(), 'getToken',
                                   body={'site': {'type': 'SITE', 'identifier': f'http://{a_domain}/'},
                                         'verificationMethod': 'META'})
  printKeyValueList(['Meta URL', f'//{a_domain}/'])
  printKeyValueList(['Meta HTML Header Data', webserver_meta_record['token']])
  printBlankLine()

def _showSiteVerificationInfo(site):
  printKeyValueList(['Site', site['site']['identifier']])
  Ind.Increment()
  printKeyValueList(['ID', unquote(site['id'])])
  printKeyValueList(['Type', site['site']['type']])
  printKeyValueList(['All Owners', None])
  if 'owners' in site:
    Ind.Increment()
    for owner in sorted(site['owners']):
      printKeyValueList([owner])
    Ind.Decrement()
  Ind.Decrement()

DNS_ERROR_CODES_MAP = {
  1: 'DNS Query Format Error',
  2: 'Server failed to complete the DNS request',
  3: 'Domain name does not exist',
  4: 'Function not implemented',
  5: 'The server refused to answer for the query',
  6: 'Name that should not exist, does exist',
  7: 'RRset that should not exist, does exist',
  8: 'Server not authoritative for the zone',
  9: 'Name not in zone'
  }

# gam update verify|verification <DomainName> cname|txt|text|file|site
def doUpdateSiteVerification():
  def showDNSrecords():
    try:
      verify_data = callGAPI(verif.webResource(), 'getToken',
                             throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_PARAMETER],
                             body=body)
    except (GAPI.badRequest, GAPI.invalidParameter) as e:
      printKeyValueList([ERROR, str(e)])
      return
    printKeyValueList(['Method', verify_data['method']])
    if verify_data['method'] in {'DNS_CNAME', 'DNS_TXT'}:
      if verify_data['method'] == 'DNS_CNAME':
        cname_subdomain, cname_target = verify_data['token'].split(' ')
        query_params = {'name': f'{cname_subdomain}.{a_domain}', 'type': 'cname'}
        printKeyValueList(['Expected Record',
                           f'{query_params["name"]} IN CNAME {cname_target}'])
      else:
        query_params = {'name': f'{a_domain}', 'type': 'txt'}
        printKeyValueList(['Expected Record',
                           f'{query_params["name"]} IN TXT {verify_data["token"]}'])
      _, content = getHttpObj().request('https://dns.google/resolve?' + urlencode(query_params), 'GET')
      try:
        result = json.loads(content.decode(UTF8))
        status = result['Status']
        if status == 0 and 'Answer' in result:
          if verify_data['method'] == 'DNS_CNAME':
            printKeyValueList(['DNS      Record',
                               f'{result["Answer"][0]["name"].rstrip(".")} IN CNAME {result["Answer"][0]["data"]}'])
          else:
            found = False
            for answer in result['Answer']:
              answer['data'] = answer['data'].strip('"')
              if answer['data'].startswith('google-site-verification'):
                found = True
                printKeyValueList(['DNS      Record',
                                   f'{answer["name"].rstrip(".")} IN TXT {answer["data"]}'])
            if not found:
              printKeyValueList(['DNS      Record', 'No matching record found'])
        elif status == 0:
          systemErrorExit(NETWORK_ERROR_RC, Msg.DOMAIN_NOT_FOUND_IN_DNS)
        else:
          systemErrorExit(NETWORK_ERROR_RC, DNS_ERROR_CODES_MAP.get(status, f'Unknown error {status}'))
      except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
        systemErrorExit(INVALID_JSON_RC, Msg.INVALID_JSON_INFORMATION)

  verif = buildGAPIObject(API.SITEVERIFICATION)
  a_domain = getString(Cmd.OB_DOMAIN_NAME)
  verificationMethod = getChoice(SITEVERIFICATION_METHOD_CHOICE_MAP, mapChoice=True)
  if verificationMethod in {'DNS_TXT', 'DNS_CNAME'}:
    verify_type = 'INET_DOMAIN'
    identifier = a_domain
    showDNS = True
  else:
    verify_type = 'SITE'
    identifier = f'http://{a_domain}/'
    showDNS = False
  checkForExtraneousArguments()
  body = {'site': {'type': verify_type, 'identifier': identifier},
          'verificationMethod': verificationMethod}
  try:
    verify_result = callGAPI(verif.webResource(), 'insert',
                             throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID_PARAMETER],
                             verificationMethod=verificationMethod, body=body)
  except GAPI.badRequest as e:
    printKeyValueList([ERROR, str(e)])
    if showDNS:
      showDNSrecords()
    return
  except GAPI.invalidParameter as e:
    printKeyValueList([ERROR, str(e)])
    return
  printKeyValueList(['Verified!'])
  if showDNS:
    showDNSrecords()
  _showSiteVerificationInfo(verify_result)
  printKeyValueList([Msg.YOU_CAN_ADD_DOMAIN_TO_ACCOUNT.format(a_domain, GC.Values[GC.DOMAIN])])

# gam info verify|verification
def doInfoSiteVerification():
  verif = buildGAPIObject(API.SITEVERIFICATION)
  checkForExtraneousArguments()
  sites = callGAPIitems(verif.webResource(), 'list', 'items')
  if sites:
    for site in sorted(sites, key=lambda k: (k['site']['type'], k['site']['identifier'])):
      _showSiteVerificationInfo(site)
  else:
    printKeyValueList(['No Sites Verified.'])

def checkCourseExists(croom, courseId, i=0, count=0, entityType=Ent.COURSE):
  courseId = addCourseIdScope(courseId)
  try:
    result = callGAPI(croom.courses(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                      id=courseId, fields='id,ownerId')
    return result
  except GAPI.notFound:
    entityActionFailedWarning([entityType, removeCourseIdScope(courseId)], Msg.DOES_NOT_EXIST, i, count)
  except GAPI.permissionDenied as e:
    entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
  return None

COURSE_MEMBER_ARGUMENTS = ['none', 'all', 'students', 'teachers']
COURSE_STATE_MAPS = {
  Cmd.OB_COURSE_STATE_LIST: {
    'active': 'ACTIVE',
    'archived': 'ARCHIVED',
    'provisioned': 'PROVISIONED',
    'declined': 'DECLINED',
    'suspended': 'SUSPENDED',
    },
  Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST: {
    'draft': 'DRAFT',
    'published': 'PUBLISHED',
    'deleted': 'DELETED',
    },
  Cmd.OB_COURSE_WORK_STATE_LIST: {
    'draft': 'DRAFT',
    'published': 'PUBLISHED',
    'deleted': 'DELETED',
    },
  Cmd.OB_COURSE_SUBMISSION_STATE_LIST: {
    'new': 'NEW',
    'created': 'CREATED',
    'turnedin': 'TURNED_IN',
    'returned': 'RETURNED',
    'reclaimedbystudent': 'RECLAIMED_BY_STUDENT',
    },
  }

def _getCourseStates(item, states):
  stateMap = COURSE_STATE_MAPS[item]
  for state in getString(item).lower().replace(',', ' ').split():
    if state == 'all':
      states.extend([stateMap[state] for state in stateMap])
    elif state in stateMap:
      states.append(stateMap[state])
    else:
      invalidChoiceExit(state, stateMap, True)

def _gettingCourseAnnouncementQuery(courseAnnouncementStates):
  query = ''
  if courseAnnouncementStates:
    query += f'{Ent.Choose(Ent.COURSE_ANNOUNCEMENT_STATE, len(courseAnnouncementStates))}: {",".join(courseAnnouncementStates)}, '
  if query:
    query = query[:-2]
  return query

class CourseAttributes():

  def __init__(self, croom, updateMode):
    self.croom = croom
    self.updateMode = updateMode
    self.body = {}
    self.courseId = None
    self.ownerId = None
    self.markPublishedAsDraft = False
    self.removeDueDate = False
    self.mapShareModeStudentCopy = None
    self.copyMaterialsFiles = False
    self.members = 'none'
    self.teachers = []
    self.students = []
    self.announcementStates = []
    self.courseAnnouncements = []
    self.workStates = []
    self.courseWorks = []
    self.copyTopics = False
    self.topicsById = {}
    self.csvPF = None

  COURSE_ANNOUNCEMENT_READONLY_FIELDS = [
    'alternateLink',
    'courseId',
    'creationTime',
    'creatorUserId',
    'updateTime',
    ]
  COURSE_COURSEWORK_READONLY_FIELDS = [
    'alternateLink',
    'assignment',
    'associatedWithDeveloper',
    'courseId',
    'creationTime',
    'creatorUserId',
    'updateTime',
    ]

  def CleanMaterials(self, body, entityType, entityId):
    if 'materials' not in body:
      return
    materials = body.pop('materials')
    body['materials'] = []
    for material in materials:
      if 'driveFile' in material:
        material['driveFile']['driveFile'].pop('title', None)
        material['driveFile']['driveFile'].pop('alternateLink', None)
        material['driveFile']['driveFile'].pop('thumbnailUrl', None)
        if material['driveFile'].get('shareMode', '') == 'STUDENT_COPY' and self.mapShareModeStudentCopy is not None:
          material['driveFile']['shareMode'] = self.mapShareModeStudentCopy
        body['materials'].append(material)
        if self.csvPF and not self.copyMaterialsFiles:
          self.csvPF.WriteRow({'courseId': self.courseId, 'ownerId': self.ownerId, 'fileId': material['driveFile']['driveFile']['id']})
      elif 'youtubeVideo' in material:
        material['youtubeVideo'].pop('title', None)
        material['youtubeVideo'].pop('alternateLink', None)
        material['youtubeVideo'].pop('thumbnailUrl', None)
        body['materials'].append(material)
      elif 'link' in material:
        material['link'].pop('title', None)
        material['link'].pop('thumbnailUrl', None)
        body['materials'].append(material)
      elif 'form' in material:
        action = Act.Get()
        Act.Set(Act.COPY)
        entityActionNotPerformedWarning([Ent.COURSE, self.courseId, entityType, entityId,
                                         Ent.COURSE_MATERIAL_FORM, material['form'].get('title', 'Unknown')],
                                        Msg.NOT_COPYABLE)
        Act.Set(action)

  @staticmethod
  def CleanAssignments(body):
    if 'assignment' in body and 'studentWorkFolder' in body['assignment']:
      body['assignment']['studentWorkFolder'].pop('title', None)
      body['assignment']['studentWorkFolder'].pop('alternateLink', None)

  COURSE_MATERIAL_SHAREMODE_MAP = {
    'edit': 'EDIT',
    'none': None,
    'view': 'VIEW'
    }

  def GetAttributes(self):
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if not self.updateMode and myarg in {'alias', 'id'}:
        self.body['id'] = getCourseAlias()
      elif myarg == 'name':
        self.body['name'] = getString(Cmd.OB_STRING)
      elif myarg == 'section':
        self.body['section'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == 'heading':
        self.body['descriptionHeading'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg == 'description':
        self.body['description'] = getStringWithCRsNLs()
      elif myarg == 'room':
        self.body['room'] = getString(Cmd.OB_STRING, minLen=0)
      elif myarg in {'owner', 'ownerid', 'teacher'}:
        self.body['ownerId'] = getEmailAddress()
      elif myarg in {'state', 'status', 'coursestate'}:
        self.body['courseState'] = getChoice(COURSE_STATE_MAPS[Cmd.OB_COURSE_STATE_LIST], mapChoice=True)
      elif myarg == 'guardiansenabled':
        self.body['guardiansEnabled'] = getBoolean()
      elif myarg == 'copyfrom':
        self.courseId = getString(Cmd.OB_COURSE_ID)
      elif myarg in {'announcementstate', 'announcementstates'}:
        _getCourseStates(Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST, self.announcementStates)
      elif myarg in {'workstate', 'workstates', 'courseworkstate', 'courseworkstates'}:
        _getCourseStates(Cmd.OB_COURSE_WORK_STATE_LIST, self.workStates)
      elif myarg == 'members':
        self.members = getChoice(COURSE_MEMBER_ARGUMENTS)
      elif myarg == 'markpublishedasdraft':
        self.markPublishedAsDraft = getBoolean()
      elif myarg == 'removeduedate':
        self.removeDueDate = getBoolean()
      elif myarg == 'mapsharemodestudentcopy':
        self.mapShareModeStudentCopy = getChoice(self.COURSE_MATERIAL_SHAREMODE_MAP, mapChoice=True)
      elif myarg == 'copymaterialsfiles':
        self.copyMaterialsFiles = getBoolean()
      elif myarg == 'copytopics':
        self.copyTopics = getBoolean()
      elif myarg == 'logdrivefileids':
        if getBoolean():
          self.csvPF = CSVPrintFile(['courseId', 'ownerId', 'fileId'])
        else:
          self.csvPF = None
      else:
        unknownArgumentExit()
    if not self.updateMode:
      if 'ownerId' not in self.body:
        missingArgumentExit('teacher <UserItem>)')
      if 'name' not in self.body:
        missingArgumentExit('name <String>)')
    if self.courseId:
      copyFromCourseInfo = checkCourseExists(self.croom, self.courseId, entityType=Ent.COPYFROM_COURSE)
      if copyFromCourseInfo is None:
        return False
      self.ownerId = copyFromCourseInfo['ownerId']
      if (self.announcementStates or self.workStates) and self.copyMaterialsFiles:
        self.body['courseState'] = 'ACTIVE'
    elif self.members != 'none' or self.announcementStates or self.workStates or self.copyTopics:
      missingArgumentExit('copyfrom <CourseID>)')
    else:
      return True
    if self.members != 'none':
      _, self.teachers, self.students = _getCourseAliasesMembers(self.croom, self.courseId, {'members': self.members},
                                                                 'nextPageToken,teachers(profile(emailAddress,id))',
                                                                 'nextPageToken,students(profile(emailAddress))')
    if self.announcementStates:
      printGettingAllEntityItemsForWhom(Ent.COURSE_ANNOUNCEMENT_ID, Ent.TypeName(Ent.COURSE, self.courseId), 0, 0,
                                        _gettingCourseAnnouncementQuery(self.announcementStates))
      try:
        self.courseAnnouncements = callGAPIpages(self.croom.courses().announcements(), 'list', 'announcements',
                                                 pageMessage=getPageMessage(),
                                                 throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                                 courseId=self.courseId, announcementStates=self.announcementStates,
                                                 pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseAnnouncement in self.courseAnnouncements:
          for field in self.COURSE_ANNOUNCEMENT_READONLY_FIELDS:
            courseAnnouncement.pop(field, None)
          self.CleanMaterials(courseAnnouncement, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncement['id'])
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, self.courseId], str(e))
        return False
    if self.workStates:
      printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, self.courseId), 0, 0,
                                        _gettingCourseWorkQuery(self.workStates))
      try:
        self.courseWorks = callGAPIpages(self.croom.courses().courseWork(), 'list', 'courseWork',
                                         pageMessage=getPageMessage(),
                                         throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                         courseId=self.courseId, courseWorkStates=self.workStates,
                                         pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseWork in self.courseWorks:
          for field in self.COURSE_COURSEWORK_READONLY_FIELDS:
            courseWork.pop(field, None)
          self.CleanMaterials(courseWork, Ent.COURSE_WORK_ID, courseWork['id'])
          self.CleanAssignments(courseWork)
          if self.markPublishedAsDraft and courseWork['state'] == 'PUBLISHED':
            courseWork['state'] = 'DRAFT'
          if self.removeDueDate:
            courseWork.pop('dueDate', None)
            courseWork.pop('dueTime', None)
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, self.courseId], str(e))
        return False
    if self.copyTopics:
      printGettingAllEntityItemsForWhom(Ent.COURSE_TOPIC, Ent.TypeName(Ent.COURSE, self.courseId), 0, 0)
      try:
        courseTopics = callGAPIpages(self.croom.courses().topics(), 'list', 'topic',
                                     pageMessage=getPageMessage(),
                                     throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                     courseId=self.courseId, fields='nextPageToken,topic(topicId,name)',
                                     pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for topic in courseTopics:
          self.topicsById[topic['topicId']] = topic['name']
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, self.courseId], str(e))
        return False
    return True

  def CopyMaterials(self, drive, newCourseId, body, entityType, entityId, teacherFolderId):
    def _copyMaterialsError(fileId, errMsg):
      entityModifierItemValueListActionNotPerformedWarning([Ent.COURSE, newCourseId, entityType, entityId, Ent.COURSE_MATERIAL_DRIVEFILE, ''], Act.MODIFIER_FROM,
                                                           [Ent.COURSE, self.courseId, Ent.COURSE_MATERIAL_DRIVEFILE, fileId], errMsg)

    if 'materials' not in body:
      return
    action = Act.Get()
    Act.Set(Act.COPY)
    materials = body.pop('materials')
    body['materials'] = []
    for material in materials:
      if 'driveFile' in material:
        fileId = material['driveFile']['driveFile']['id']
        try:
          source = callGAPI(drive.files(), 'get',
                            throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                            fileId=fileId,
                            fields='name,appProperties,capabilities,contentHints,copyRequiresWriterPermission,'\
                              'description,mimeType,modifiedTime,properties,starred,driveId,viewedByMeTime,writersCanShare',
                            supportsAllDrives=True)
          if not source.pop('capabilities')['canCopy']:
            _copyMaterialsError(fileId, Msg.NOT_COPYABLE)
            continue
          source['parents'] = [teacherFolderId]
          result = callGAPI(drive.files(), 'copy',
                            throwReasons=GAPI.DRIVE_COPY_THROW_REASONS,
                            fileId=fileId, body=source, fields='id', supportsAllDrives=True)
          material['driveFile']['driveFile']['id'] = result['id']
          body['materials'].append(material)
          entityModifierItemValueListActionPerformed([Ent.COURSE, newCourseId, entityType, entityId, Ent.COURSE_MATERIAL_DRIVEFILE, result['id']], Act.MODIFIER_FROM,
                                                     [Ent.COURSE, self.courseId, Ent.COURSE_MATERIAL_DRIVEFILE, fileId])
          if self.csvPF:
            self.csvPF.WriteRow({'courseId': self.courseId, 'ownerId': self.ownerId, 'fileId': result['id']})
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
                GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.fileNeverWritable) as e:
          _copyMaterialsError(fileId, str(e))
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          _copyMaterialsError(fileId, str(e))
          break
      else:
        body['materials'].append(material)
    Act.Set(action)

  def CopyAttributes(self, newCourse, i=0, count=0):
    newCourseId = newCourse['id']
    ownerId = newCourse['ownerId']
    teacherFolderId = newCourse['teacherFolder']['id']
    if self.announcementStates or self.workStates or self.copyTopics:
      _, tcroom = buildGAPIServiceObject(API.CLASSROOM, f'uid:{ownerId}')
      if tcroom is None:
        return
    if (self.announcementStates or self.workStates) and self.copyMaterialsFiles:
      _, tdrive = buildGAPIServiceObject(API.DRIVE3, f'uid:{ownerId}')
      if tdrive is None:
        return
    if self.members in {'all', 'students'}:
      addParticipants = [student['profile']['emailAddress'] for student in self.students]
      _batchAddItemsToCourse(self.croom, newCourseId, i, count, addParticipants, Ent.STUDENT)
    if self.members in {'all', 'teachers'}:
      addParticipants = [teacher['profile']['emailAddress'] for teacher in self.teachers if teacher['profile']['id'] != ownerId]
      _batchAddItemsToCourse(self.croom, newCourseId, i, count, addParticipants, Ent.TEACHER)
    if self.copyTopics:
      try:
        newCourseTopics = callGAPIpages(self.croom.courses().topics(), 'list', 'topic',
                                        throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS+[GAPI.FAILED_PRECONDITION],
                                        courseId=newCourseId, fields='nextPageToken,topic(topicId,name)',
                                        pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        newTopicsByName = {}
        for topic in newCourseTopics:
          newTopicsByName[topic['name']] = topic['topicId']
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.COURSE, newCourseId], str(e), i, count)
        return
      except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.failedPrecondition, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, newCourseId], str(e), i, count)
      jcount = len(self.topicsById)
      j = 0
      for topicId, topicName in self.topicsById.items():
        j += 1
        if topicName in newTopicsByName:
          entityModifierItemValueListActionNotPerformedWarning([Ent.COURSE, newCourseId, Ent.COURSE_TOPIC, topicName], Act.MODIFIER_FROM,
                                                               [Ent.COURSE, self.courseId], Msg.DUPLICATE, j, jcount)
          continue
        try:
          result = callGAPI(tcroom.courses().topics(), 'create',
                            throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.FAILED_PRECONDITION, GAPI.INVALID_ARGUMENT],
                            courseId=newCourseId, body={'name': topicName}, fields='topicId')
          newTopicsByName[topicName] = result['topicId']
          entityModifierItemValueListActionPerformed([Ent.COURSE, newCourseId, Ent.COURSE_TOPIC, topicName], Act.MODIFIER_FROM,
                                                     [Ent.COURSE, self.courseId], j, jcount)
        except GAPI.notFound as e:
          entityActionFailedWarning([Ent.COURSE, newCourseId], str(e), i, count)
          return
        except (GAPI.failedPrecondition, GAPI.invalidArgument, GAPI.forbidden) as e:
          entityModifierItemValueListActionFailedWarning([Ent.COURSE, newCourseId], Act.MODIFIER_FROM,
                                                         [Ent.COURSE, self.courseId, Ent.COURSE_TOPIC, topicName], str(e), j, jcount)
    if self.courseAnnouncements:
      jcount = len(self.courseAnnouncements)
      j = 0
      for courseAnnouncement in self.courseAnnouncements:
        j += 1
        body = courseAnnouncement.copy()
        courseAnnouncementId = body.pop('id')
        if courseAnnouncement['state'] == 'DELETED':
          entityModifierItemValueListActionNotPerformedWarning([Ent.COURSE, newCourseId, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], Act.MODIFIER_FROM,
                                                               [Ent.COURSE, self.courseId], Msg.DELETED, j, jcount)
          continue
        if self.copyMaterialsFiles:
          self.CopyMaterials(tdrive, newCourseId, body, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId, teacherFolderId)
        try:
          result = callGAPI(tcroom.courses().announcements(), 'create',
                            throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FORBIDDEN,
                                          GAPI.BAD_REQUEST, GAPI.FAILED_PRECONDITION, GAPI.BACKEND_ERROR, GAPI.INTERNAL_ERROR],
                            courseId=newCourseId, body=body, fields='id')
          entityModifierItemValueListActionPerformed([Ent.COURSE, newCourseId, Ent.COURSE_ANNOUNCEMENT_ID, result['id']], Act.MODIFIER_FROM,
                                                     [Ent.COURSE, self.courseId, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], j, jcount)
        except GAPI.notFound as e:
          entityActionFailedWarning([Ent.COURSE, newCourseId], str(e), i, count)
          return
        except (GAPI.badRequest, GAPI.failedPrecondition, GAPI.backendError, GAPI.internalError,
                GAPI.permissionDenied, GAPI.forbidden) as e:
          entityModifierItemValueListActionFailedWarning([Ent.COURSE, newCourseId], Act.MODIFIER_FROM,
                                                         [Ent.COURSE, self.courseId, Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], str(e), j, jcount)
    if self.courseWorks:
      jcount = len(self.courseWorks)
      j = 0
      for courseWork in self.courseWorks:
        j += 1
        body = courseWork.copy()
        courseWorkId = body.pop('id')
        if courseWork['state'] == 'DELETED':
          entityModifierItemValueListActionNotPerformedWarning([Ent.COURSE, newCourseId, Ent.COURSE_WORK, f'{body.get("title", courseWorkId)}'], Act.MODIFIER_FROM,
                                                               [Ent.COURSE, self.courseId], Msg.DELETED, j, jcount)
          continue
        if self.copyMaterialsFiles:
          self.CopyMaterials(tdrive, newCourseId, body, Ent.COURSE_WORK_ID, courseWorkId, teacherFolderId)
        topicId = body.pop('topicId', None)
        if self.copyTopics:
          if topicId:
            topicName = self.topicsById.get(topicId)
            if topicName:
              newTopicId = newTopicsByName.get(topicName)
              if newTopicId:
                body['topicId'] = newTopicId
        try:
          result = callGAPI(tcroom.courses().courseWork(), 'create',
                            bailOnInternalError=True,
                            throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FORBIDDEN,
                                          GAPI.BAD_REQUEST, GAPI.FAILED_PRECONDITION, GAPI.BACKEND_ERROR, GAPI.INTERNAL_ERROR],
                            courseId=newCourseId, body=body, fields='id')
          entityModifierItemValueListActionPerformed([Ent.COURSE, newCourseId, Ent.COURSE_WORK_ID, result['id']], Act.MODIFIER_FROM,
                                                     [Ent.COURSE, self.courseId, Ent.COURSE_WORK, f'{body.get("title", courseWorkId)}'], j, jcount)
        except GAPI.notFound as e:
          entityActionFailedWarning([Ent.COURSE, newCourseId], str(e), i, count)
          return
        except (GAPI.badRequest, GAPI.failedPrecondition, GAPI.backendError, GAPI.internalError,
                GAPI.permissionDenied, GAPI.forbidden) as e:
          entityModifierItemValueListActionFailedWarning([Ent.COURSE, newCourseId], Act.MODIFIER_FROM,
                                                         [Ent.COURSE, self.courseId, Ent.COURSE_WORK, f'{body.get("title", courseWorkId)}'], str(e), j, jcount)

  def CopyFromCourse(self, newCourse, i=0, count=0):
    action = Act.Get()
    Act.Set(Act.COPY)
    entityPerformActionModifierItemValueList([Ent.COURSE, newCourse['id']], Act.MODIFIER_FROM, [Ent.COURSE, self.courseId], i, count)
    Ind.Increment()
    self.CopyAttributes(newCourse, i, count)
    if self.csvPF:
      self.csvPF.writeCSVfile('Course Drive File IDs')
    Ind.Decrement()
    Act.Set(action)

# gam create course [id|alias <CourseAlias>] <CourseAttribute>*
#	 [copyfrom <CourseID>
#	    [announcementstates <CourseAnnouncementStateList>]
#	    [workstates <CourseWorkStateList>]
#	        [markpublishedasdraft [<Boolean>]] [removeduedate [<Boolean>]]
#		[mapsharemodestudentcopy edit|none|view]
#           [copymaterialsfiles [<Boolean>]]
#	    [copytopics [<Boolean>]]
#	    [members none|all|students|teachers]]
#	    [logdrivefileids [<Boolean>>]]
def doCreateCourse():
  croom = buildGAPIObject(API.CLASSROOM)
  courseAttributes = CourseAttributes(croom, False)
  if not courseAttributes.GetAttributes():
    return
  try:
    result = callGAPI(croom.courses(), 'create',
                      throwReasons=[GAPI.ALREADY_EXISTS, GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED,
                                    GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.BAD_REQUEST],
                      body=courseAttributes.body, fields='id,name,ownerId,courseState,teacherFolder(id)')
    entityActionPerformed([Ent.COURSE_NAME, result['name'], Ent.COURSE, result['id']])
    if courseAttributes.courseId:
      courseAttributes.CopyFromCourse(result)
  except (GAPI.alreadyExists, GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition, GAPI.forbidden, GAPI.badRequest) as e:
    entityActionFailedWarning([Ent.COURSE_NAME, courseAttributes.body['name'], Ent.TEACHER, courseAttributes.body['ownerId']], str(e))

def _doUpdateCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  courseAttributes = CourseAttributes(croom, True)
  if not courseAttributes.GetAttributes():
    return
  updateMask = ','.join(list(courseAttributes.body))
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      if courseAttributes.body:
        result = callGAPI(croom.courses(), 'patch',
                          throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION,
                                        GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_ARGUMENT],
                          id=courseId, body=courseAttributes.body, updateMask=updateMask, fields='id,name,ownerId,courseState,teacherFolder(id)')
        entityActionPerformed([Ent.COURSE_NAME, result['name'], Ent.COURSE, result['id']], i, count)
      else:
        result = callGAPI(croom.courses(), 'get',
                          throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                          id=courseId, fields='id,name,ownerId,courseState,teacherFolder(id)')
      if courseAttributes.courseId:
        courseAttributes.CopyFromCourse(result, i, count)
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition,
            GAPI.forbidden, GAPI.badRequest, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)

# gam update courses <CourseEntity> <CourseAttribute>+
#	 [copyfrom <CourseID>
#	    [announcementstates <CourseAnnouncementStateList>]
#	    [workstates <CourseWorkStateList>]
#	        [markpublishedasdraft [<Boolean>]] [removeduedate [<Boolean>]]
#		[mapsharemodestudentcopy edit|none|view]
#           [copymaterialsfiles [<Boolean>]]
#	    [copytopics [<Boolean>]]
#	    [members none|all|students|teachers]]
#	    [logdrivefileids [<Boolean>>]]
def doUpdateCourses():
  _doUpdateCourses(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True))

# gam update course <CourseID> <CourseAttribute>+
#	 [copyfrom <CourseID>
#	    [announcementstates <CourseAnnouncementStateList>]
#	    [workstates <CourseWorkStateList>]
#	        [markpublishedasdraft [<Boolean>]] [removeduedate [<Boolean>]]
#		[mapsharemodestudentcopy edit|none|view]
#           [copymaterialsfiles [<Boolean>]]
#	    [copytopics [<Boolean>]]
#	    [members none|all|students|teachers]]
def doUpdateCourse():
  _doUpdateCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

def _doDeleteCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'archive', 'archived'}:
      body['courseState'] = 'ARCHIVED'
      updateMask = 'courseState'
    else:
      unknownArgumentExit()
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      if body:
        callGAPI(croom.courses(), 'patch',
                 throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION,
                               GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_ARGUMENT],
                 id=courseId, body=body, updateMask=updateMask, fields='')
      callGAPI(croom.courses(), 'delete',
               throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION],
               id=courseId)
      entityActionPerformed([Ent.COURSE, removeCourseIdScope(courseId)], i, count)
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition,
            GAPI.forbidden, GAPI.badRequest, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)

# gam delete courses <CourseEntity> [archive|archived]
def doDeleteCourses():
  _doDeleteCourses(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True))

# gam delete course <CourseID> [archive|archived]
def doDeleteCourse():
  _doDeleteCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

COURSE_FIELDS_CHOICE_MAP = {
  'alternatelink': 'alternateLink',
  'calendarid': 'calendarId',
  'coursegroupemail': 'courseGroupEmail',
  'coursematerialsets': 'courseMaterialSets',
  'coursestate': 'courseState',
  'creationtime': 'creationTime',
  'description': 'description',
  'descriptionheading': 'descriptionHeading',
  'enrollmentcode': 'enrollmentCode',
  'guardiansenabled': 'guardiansEnabled',
  'id': 'id',
  'name': 'name',
  'owneremail': 'ownerId',
  'ownerid': 'ownerId',
  'room': 'room',
  'section': 'section',
  'teacherfolder': 'teacherFolder',
  'teachergroupemail': 'teacherGroupEmail',
  'updatetime': 'updateTime',
  }
COURSE_TIME_OBJECTS = {'creationTime', 'updateTime'}
COURSE_NOLEN_OBJECTS = {'materials'}
COURSE_PROPERTY_PRINT_ORDER = [
  'id',
  'name',
  'Aliases',
  'courseState',
  'descriptionHeading',
  'description',
  'section',
  'room',
  'enrollmentCode',
  'guardiansEnabled',
  'alternateLink',
  'ownerEmail',
  'ownerId',
  'creationTime',
  'updateTime',
  'calendarId',
  'courseGroupEmail',
  'teacherGroupEmail',
  'teacherFolder.id',
  'teacherFolder.title',
  'teacherFolder.alternateLink',
  ]

def _initCourseShowProperties(fields=None):
  return {'aliases': False, 'aliasesInColumns': False, 'ownerEmail': False, 'ownerEmailMatchPattern': None, 'members': 'none', 'countsOnly': False,
          'fields': fields if fields is not None else [], 'skips': []}

def _getCourseShowProperties(myarg, courseShowProperties):
  if myarg in {'alias', 'aliases'}:
    courseShowProperties['aliases'] = True
    courseShowProperties['aliasesInColumns'] = False
  elif myarg == 'aliasesincolumns':
    courseShowProperties['aliases'] = True
    courseShowProperties['aliasesInColumns'] = True
  elif myarg == 'owneremail':
    courseShowProperties['ownerEmail'] = True
  elif myarg == 'owneremailmatchpattern':
    courseShowProperties['ownerEmail'] = True
    courseShowProperties['ownerEmailMatchPattern'] = getREPattern(re.IGNORECASE)
  elif myarg == 'show':
    courseShowProperties['members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
  elif myarg == 'countsonly':
    courseShowProperties['countsOnly'] = True
  elif myarg == 'fields':
    for field in _getFieldsList():
      if field in {'alias', 'aliases'}:
        courseShowProperties['aliases'] = True
        courseShowProperties['aliasesInColumns'] = False
      elif field == 'aliasesincolumns':
        courseShowProperties['aliases'] = True
        courseShowProperties['aliasesInColumns'] = True
      elif field == 'owneremail':
        courseShowProperties['ownerEmail'] = True
        courseShowProperties['fields'].append(COURSE_FIELDS_CHOICE_MAP[field])
      elif field == 'teachers':
        if courseShowProperties['members'] == 'none':
          courseShowProperties['members'] = field
        elif courseShowProperties['members'] == 'students':
          courseShowProperties['members'] = 'all'
      elif field == 'students':
        if courseShowProperties['members'] == 'none':
          courseShowProperties['members'] = field
        elif courseShowProperties['members'] == 'teachers':
          courseShowProperties['members'] = 'all'
      elif field in COURSE_FIELDS_CHOICE_MAP:
        courseShowProperties['fields'].append(COURSE_FIELDS_CHOICE_MAP[field])
      else:
        invalidChoiceExit(field, COURSE_FIELDS_CHOICE_MAP, True)
  elif myarg == 'skipfields':
    for field in _getFieldsList():
      if field in {'alias', 'aliases'}:
        courseShowProperties['aliases'] = False
      elif field == 'teachers':
        if courseShowProperties['members'] == 'all':
          courseShowProperties['members'] = 'students'
        elif courseShowProperties['members'] == field:
          courseShowProperties['members'] = 'none'
      elif field == 'students':
        if courseShowProperties['members'] == 'all':
          courseShowProperties['members'] = 'teachers'
        elif courseShowProperties['members'] == field:
          courseShowProperties['members'] = 'none'
      elif field in COURSE_FIELDS_CHOICE_MAP:
        if field != 'id':
          courseShowProperties['skips'].append(COURSE_FIELDS_CHOICE_MAP[field])
      else:
        invalidChoiceExit(field, COURSE_FIELDS_CHOICE_MAP, True)
  else:
    return False
  return True

def _setCourseFields(courseShowProperties, pagesMode, getOwnerId=False):
  if not courseShowProperties['fields']:
    return None
  courseShowProperties['fields'].append('id')
  if courseShowProperties['ownerEmail'] or getOwnerId:
    courseShowProperties['fields'].append('ownerId')
  if not pagesMode:
    return ','.join(set(courseShowProperties['fields']))
  return f'nextPageToken,courses({",".join(set(courseShowProperties["fields"]))})'

def _convertCourseUserIdToEmail(croom, userId, emails, entityValueList, i, count):
  userEmail = emails.get(userId)
  if userEmail is None:
    try:
      userEmail = callGAPI(croom.userProfiles(), 'get',
                           throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                           userId=userId, fields='emailAddress').get('emailAddress')
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.badRequest, GAPI.forbidden):
      pass
    if userEmail is None:
      entityDoesNotHaveItemWarning(entityValueList, i, count)
      userEmail = 'Unknown user'
    emails[userId] = userEmail
  return userEmail

def _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, showGettings=False, i=0, count=0):
  aliases = []
  teachers = []
  students = []
  if showGettings:
    pageMessage = getPageMessageForWhom(forWhom=formatKeyValueList('',
                                                                   [Ent.Singular(Ent.COURSE), courseId],
                                                                   currentCount(i, count)))
  else:
    pageMessage = None
  if courseShowProperties.get('aliases'):
    if showGettings:
      Ent.SetGetting(Ent.ALIAS)
    try:
      aliases = callGAPIpages(croom.courses().aliases(), 'list', 'aliases',
                              pageMessage=pageMessage,
                              throwReasons=[GAPI.NOT_FOUND, GAPI.NOT_IMPLEMENTED, GAPI.FORBIDDEN],
                              courseId=courseId, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
    except (GAPI.notFound, GAPI.notImplemented):
      pass
    except GAPI.forbidden:
      ClientAPIAccessDeniedExit()
  if courseShowProperties['members'] != 'none':
    if courseShowProperties['members'] != 'students':
      if showGettings:
        Ent.SetGetting(Ent.TEACHER)
      try:
        teachers = callGAPIpages(croom.courses().teachers(), 'list', 'teachers',
                                 pageMessage=pageMessage,
                                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                 courseId=courseId, fields=teachersFields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
      except GAPI.notFound:
        pass
      except GAPI.forbidden:
        ClientAPIAccessDeniedExit()
    if courseShowProperties['members'] != 'teachers':
      if showGettings:
        Ent.SetGetting(Ent.STUDENT)
      try:
        students = callGAPIpages(croom.courses().students(), 'list', 'students',
                                 pageMessage=pageMessage,
                                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                                 courseId=courseId, fields=studentsFields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
      except GAPI.notFound:
        pass
      except GAPI.forbidden:
        ClientAPIAccessDeniedExit()
  return (aliases, teachers, students)

def _doInfoCourses(entityList):
  croom = buildGAPIObject(API.CLASSROOM)
  courseShowProperties = _initCourseShowProperties()
  courseShowProperties['ownerEmail'] = True
  ownerEmails = {}
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getCourseShowProperties(myarg, courseShowProperties):
      pass
    else:
      FJQC.GetFormatJSON(myarg)
  fields = _setCourseFields(courseShowProperties, False)
  if courseShowProperties['members'] != 'none':
    if courseShowProperties['countsOnly']:
      teachersFields = 'nextPageToken,teachers(profile(id))'
      studentsFields = 'nextPageToken,students(profile(id))'
    else:
      teachersFields = 'nextPageToken,teachers(profile)'
      studentsFields = 'nextPageToken,students(profile)'
  else:
    teachersFields = studentsFields = None
  i = 0
  count = len(entityList)
  for course in entityList:
    i += 1
    courseId = addCourseIdScope(course)
    try:
      course = callGAPI(croom.courses(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                        id=courseId, fields=fields)
      if courseShowProperties['ownerEmail']:
        course['ownerEmail'] = _convertCourseUserIdToEmail(croom, course['ownerId'], ownerEmails,
                                                           [Ent.COURSE, course['id'], Ent.OWNER_ID, course['ownerId']], i, count)
      aliases, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields)
      if FJQC.formatJSON:
        if courseShowProperties['aliases']:
          course.update({'aliases': list(aliases)})
        if courseShowProperties['members'] != 'none':
          if courseShowProperties['members'] != 'students':
            if not courseShowProperties['countsOnly']:
              course.update({'teachers': list(teachers)})
            else:
              course.update({'teachers': len(teachers)})
          if courseShowProperties['members'] != 'teachers':
            if not courseShowProperties['countsOnly']:
              course.update({'students': list(students)})
            else:
              course.update({'students': len(students)})
        printLine(json.dumps(cleanJSON(course, skipObjects=courseShowProperties['skips'], timeObjects=COURSE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        continue
      printEntity([Ent.COURSE, course['id']], i, count)
      Ind.Increment()
      showJSON(None, course, courseShowProperties['skips'], COURSE_TIME_OBJECTS)
      if courseShowProperties['aliases']:
        printKeyValueList(['Aliases', len(aliases)])
        Ind.Increment()
        for alias in aliases:
          printKeyValueList([removeCourseAliasScope(alias['alias'])])
        Ind.Decrement()
      if courseShowProperties['members'] != 'none':
        printKeyValueList(['Participants', None])
        Ind.Increment()
        if courseShowProperties['members'] != 'students':
          if teachers:
            printKeyValueList(['Teachers', len(teachers)])
            if not courseShowProperties['countsOnly']:
              Ind.Increment()
              for teacher in teachers:
                if 'emailAddress' in teacher['profile']:
                  printKeyValueList([f'{teacher["profile"]["name"]["fullName"]} - {teacher["profile"]["emailAddress"]}'])
                else:
                  printKeyValueList([teacher['profile']['name']['fullName']])
              Ind.Decrement()
        if courseShowProperties['members'] != 'teachers':
          if students:
            printKeyValueList(['Students', len(students)])
            if not courseShowProperties['countsOnly']:
              Ind.Increment()
              for student in students:
                if 'emailAddress' in student['profile']:
                  printKeyValueList([f'{student["profile"]["name"]["fullName"]} - {student["profile"]["emailAddress"]}'])
                else:
                  printKeyValueList([student['profile']['name']['fullName']])
              Ind.Decrement()
          Ind.Decrement()
        Ind.Decrement()
      Ind.Decrement()
    except GAPI.notFound:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], Msg.DOES_NOT_EXIST, i, count)
    except GAPI.permissionDenied as e:
      entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
    except GAPI.forbidden:
      ClientAPIAccessDeniedExit()

# gam info courses <CourseEntity> [owneremail] [alias|aliases] [show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson]
def doInfoCourses():
  _doInfoCourses(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True))

# gam info course <CourseID> [owneremail] [alias|aliases] [show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson]
def doInfoCourse():
  _doInfoCourses(getStringReturnInList(Cmd.OB_COURSE_ID))

def _initCourseSelectionParameters():
  return {'courseIds': [], 'teacherId': None, 'studentId': None, 'courseStates': []}

def _getCourseSelectionParameters(myarg, courseSelectionParameters):
  if myarg in {'course', 'courses', 'class', 'classes'}:
    courseSelectionParameters['courseIds'].extend(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True))
  elif myarg == 'teacher':
    courseSelectionParameters['teacherId'] = getEmailAddress()
  elif myarg == 'student':
    courseSelectionParameters['studentId'] = getEmailAddress()
  elif myarg in {'state', 'states', 'status'}:
    _getCourseStates(Cmd.OB_COURSE_STATE_LIST, courseSelectionParameters['courseStates'])
  else:
    return False
  return True

COURSE_CU_FILTER_FIELDS_MAP = {'creationtime': 'creationTime', 'updatetime': 'updateTime'}
COURSE_CUS_FILTER_FIELDS_MAP = {'creationtime': 'creationTime', 'updatetime': 'updateTime', 'scheduledtime': 'scheduledTime'}
COURSE_U_FILTER_FIELDS_MAP = {'updatetime': 'updateTime'}
COURSE_START_ARGUMENTS = ['start', 'startdate', 'oldestdate']
COURSE_END_ARGUMENTS = ['end', 'enddate']

def _initCourseItemFilter():
  return {'timefilter': None, 'startTime': None, 'endTime': None}

def _getCourseItemFilter(myarg, courseItemFilter, courseFilterFields):
  if myarg == 'timefilter':
    courseItemFilter['timefilter'] = getChoice(courseFilterFields, mapChoice=True)
  elif myarg in COURSE_START_ARGUMENTS:
    courseItemFilter['startTime'], _, _ = getTimeOrDeltaFromNow(True)
  elif myarg in COURSE_END_ARGUMENTS:
    courseItemFilter['endTime'], _, _ = getTimeOrDeltaFromNow(True)
  else:
    return False
  return True

def _setApplyCourseItemFilter(courseItemFilter, fieldsList):
  if courseItemFilter['timefilter'] and (courseItemFilter['startTime'] or courseItemFilter['endTime']):
    if fieldsList:
      fieldsList.append(courseItemFilter['timefilter'])
    return True
  return False

def _courseItemPassesFilter(item, courseItemFilter):
  timeStr = item.get(courseItemFilter['timefilter'])
  if not timeStr:
    return False
  startTime = courseItemFilter['startTime']
  endTime = courseItemFilter['endTime']
  timeValue, _ = iso8601.parse_date(timeStr)
  return ((startTime is None) or (timeValue >= startTime)) and ((endTime is None) or (timeValue <= endTime))

def _gettingCoursesQuery(courseSelectionParameters):
  query = ''
  if courseSelectionParameters['teacherId']:
    query += f'{Ent.Singular(Ent.TEACHER)}: {courseSelectionParameters["teacherId"]}, '
  if courseSelectionParameters['studentId']:
    query += f'{Ent.Singular(Ent.STUDENT)}: {courseSelectionParameters["studentId"]}, '
  if courseSelectionParameters['courseStates']:
    query += f'{Ent.Choose(Ent.COURSE_STATE, len(courseSelectionParameters["courseStates"]))}: {",".join(courseSelectionParameters["courseStates"])}, '
  if query:
    query = query[:-2]
  return query

def _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties, getOwnerId=False):
  if not courseSelectionParameters['courseIds']:
    fields = _setCourseFields(courseShowProperties, True, getOwnerId)
    printGettingAllAccountEntities(Ent.COURSE, _gettingCoursesQuery(courseSelectionParameters))
    try:
      return callGAPIpages(croom.courses(), 'list', 'courses',
                           pageMessage=getPageMessage(),
                           throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID],
                           teacherId=courseSelectionParameters['teacherId'],
                           studentId=courseSelectionParameters['studentId'],
                           courseStates=courseSelectionParameters['courseStates'],
                           fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
    except (GAPI.invalid, GAPI.notFound):
      if (not courseSelectionParameters['studentId']) and courseSelectionParameters['teacherId']:
        entityUnknownWarning(Ent.TEACHER, courseSelectionParameters['teacherId'])
      elif (not courseSelectionParameters['teacherId']) and courseSelectionParameters['studentId']:
        entityUnknownWarning(Ent.STUDENT, courseSelectionParameters['studentId'])
      elif courseSelectionParameters['studentId'] and courseSelectionParameters['teacherId']:
        entityOrEntityUnknownWarning(Ent.TEACHER, courseSelectionParameters['teacherId'], Ent.STUDENT, courseSelectionParameters['studentId'])
    except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.invalidArgument, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.COURSE, None], str(e))
    return None
  fields = _setCourseFields(courseShowProperties, False, getOwnerId)
  coursesInfo = []
  for courseId in courseSelectionParameters['courseIds']:
    courseId = addCourseIdScope(courseId)
    try:
      info = callGAPI(croom.courses(), 'get',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                      id=courseId, fields=fields)
      coursesInfo.append(info)
    except GAPI.notFound:
      entityDoesNotExistWarning(Ent.COURSE, courseId)
    except GAPI.forbidden:
      ClientAPIAccessDeniedExit()
  return coursesInfo

# gam print courses [todrive <ToDriveAttribute>*] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[owneremail] [owneremailmatchpattern <RegularExpression>]
#	[alias|aliases|aliasesincolumns [delimiter <Character>]]
#	[show none|all|students|teachers] [countsonly]
#	[fields <CourseFieldNameList>] [skipfields <CourseFieldNameList>] [formatjson [quotechar <Character>]]
#	[timefilter creationtime|updatetime] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
def doPrintCourses():
  def _saveParticipants(course, participants, role, rtitles):
    jcount = len(participants)
    course[role] = jcount
    if courseShowProperties['countsOnly']:
      return
    j = 0
    for member in participants:
      memberTitles = []
      prefix = f'{role}.{j}.'
      profile = member['profile']
      emailAddress = profile.get('emailAddress')
      if emailAddress:
        memberTitle = prefix+'emailAddress'
        course[memberTitle] = emailAddress
        memberTitles.append(memberTitle)
      memberId = profile.get('id')
      if memberId:
        memberTitle = prefix+'id'
        course[memberTitle] = memberId
        memberTitles.append(memberTitle)
      fullName = profile.get('name', {}).get('fullName')
      if fullName:
        memberTitle = prefix+'name.fullName'
        course[memberTitle] = fullName
        memberTitles.append(memberTitle)
      for title in memberTitles:
        if title not in rtitles['set']:
          rtitles['set'].add(title)
          rtitles['list'].append(title)
      j += 1

  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile('id')
  FJQC = FormatJSONQuoteChar(csvPF)
  courseSelectionParameters = _initCourseSelectionParameters()
  courseItemFilter = _initCourseItemFilter()
  courseShowProperties = _initCourseShowProperties()
  ownerEmails = {}
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseItemFilter(myarg, courseItemFilter, COURSE_CU_FILTER_FIELDS_MAP):
      pass
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif _getCourseShowProperties(myarg, courseShowProperties):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  applyCourseItemFilter = _setApplyCourseItemFilter(courseItemFilter, None)
  if applyCourseItemFilter:
    if courseShowProperties['fields']:
      courseShowProperties['fields'].append(courseItemFilter['timefilter'])
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if courseShowProperties['aliases']:
    if FJQC.formatJSON:
      csvPF.AddJSONTitles('JSON-aliases')
  if courseShowProperties['members'] != 'none':
    ttitles = {'set': set(), 'list': []}
    stitles = {'set': set(), 'list': []}
    if courseShowProperties['members'] != 'students':
      ttitles['set'].add('teachers')
      ttitles['list'].append('teachers')
      if FJQC.formatJSON:
        csvPF.AddJSONTitles('JSON-teachers')
    if courseShowProperties['members'] != 'teachers':
      stitles['set'].add('students')
      stitles['list'].append('students')
      if FJQC.formatJSON:
        csvPF.AddJSONTitles('JSON-students')
    if courseShowProperties['countsOnly']:
      teachersFields = 'nextPageToken,teachers(profile(id))'
      studentsFields = 'nextPageToken,students(profile(id))'
    else:
      teachersFields = 'nextPageToken,teachers(profile)'
      studentsFields = 'nextPageToken,students(profile)'
  else:
    teachersFields = studentsFields = None
  count = len(coursesInfo)
  i = 0
  for course in coursesInfo:
    i += 1
    if applyCourseItemFilter and not _courseItemPassesFilter(course, courseItemFilter):
      continue
    for field in courseShowProperties['skips']:
      course.pop(field, None)
    courseId = course['id']
    if courseShowProperties['ownerEmail']:
      course['ownerEmail'] = _convertCourseUserIdToEmail(croom, course['ownerId'], ownerEmails,
                                                         [Ent.COURSE, courseId, Ent.OWNER_ID, course['ownerId']], i, count)
      if courseShowProperties['ownerEmailMatchPattern'] and not courseShowProperties['ownerEmailMatchPattern'].match(course['ownerEmail']):
        continue
    aliases, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, True, i, count)
    if courseShowProperties['aliases']:
      if not courseShowProperties['aliasesInColumns']:
        course['Aliases'] = delimiter.join([removeCourseAliasScope(alias['alias']) for alias in aliases])
      else:
        course['Aliases'] = [removeCourseAliasScope(alias['alias']) for alias in aliases]
    if courseShowProperties['members'] != 'none':
      if courseShowProperties['members'] != 'students':
        _saveParticipants(course, teachers, 'teachers', ttitles)
      if courseShowProperties['members'] != 'teachers':
        _saveParticipants(course, students, 'students', stitles)
    row = flattenJSON(course, timeObjects=COURSE_TIME_OBJECTS, noLenObjects=COURSE_NOLEN_OBJECTS)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(row)
    elif csvPF.CheckRowTitles(row):
      row = {'id': courseId, 'JSON': json.dumps(cleanJSON(course, timeObjects=COURSE_TIME_OBJECTS),
                                                ensure_ascii=False, sort_keys=True)}
      if courseShowProperties['aliases']:
        row['JSON-aliases'] = json.dumps(list(aliases))
      if courseShowProperties['members'] != 'none':
        if courseShowProperties['members'] != 'students':
          if not courseShowProperties['countsOnly']:
            row['JSON-teachers'] = json.dumps(list(teachers))
          else:
            row['JSON-teachers'] = json.dumps(len(teachers))
        if courseShowProperties['members'] != 'teachers':
          if not courseShowProperties['countsOnly']:
            row['JSON-students'] = json.dumps(list(students))
          else:
            row['JSON-students'] = json.dumps(len(students))
      csvPF.WriteRowNoFilter(row)
  if not FJQC.formatJSON:
    if courseShowProperties['aliases']:
      csvPF.AddTitles('Aliases')
    csvPF.SetSortTitles(COURSE_PROPERTY_PRINT_ORDER)
    if courseShowProperties['aliases'] and courseShowProperties['aliasesInColumns']:
      csvPF.FixCourseAliasesTitles()
    if courseShowProperties['members'] != 'none':
      csvPF.RearrangeCourseTitles(ttitles, stitles)
  csvPF.writeCSVfile('Courses')

COURSE_ANNOUNCEMENTS_FIELDS_CHOICE_MAP = {
  'alternatelink': 'alternateLink',
  'announcementid': 'id',
  'assigneemode': 'assigneeMode',
  'courseid': 'courseId',
  'courseannouncementid': 'id',
  'creationtime': 'creationTime',
  'creator': 'creatorUserId',
  'creatoruserid': 'creatorUserId',
  'id': 'id',
  'materials': 'materials',
  'scheduledtime': 'scheduledTime',
  'state': 'state',
  'text': 'text',
  'updatetime': 'updateTime',
  }
COURSE_ANNOUNCEMENTS_ORDERBY_CHOICE_MAP = {
  'updatetime': 'updateTime',
  'updatedate': 'updateTime',
  }
COURSE_ANNOUNCEMENTS_TIME_OBJECTS = {'creationTime', 'scheduledTime', 'updateTime'}
COURSE_ANNOUNCEMENTS_SORT_TITLES = ['courseId', 'courseName', 'id', 'text', 'state']
COURSE_ANNOUNCEMENTS_INDEXED_TITLES = ['materials']

# gam print course-announcements [todrive <ToDriveAttribute>*]
#	(course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(announcementids <CourseAnnouncementIDEntity>)|((announcementstates <CourseAnnouncementStateList>)*
#	(orderby <CourseAnnouncementOrderByFieldName> [ascending|descending])*)
#	[showcreatoremails] [fields <CourseAnnouncementFieldNameList>] [formatjson [quotechar <Character>]]
#	[timefilter creationtime|updatetime|scheduledtime] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
def doPrintCourseAnnouncements():
  def _printCourseAnnouncement(course, courseAnnouncement, i, count):
    if applyCourseItemFilter and not _courseItemPassesFilter(courseAnnouncement, courseItemFilter):
      return
    if showCreatorEmail:
      courseAnnouncement['creatorUserEmail'] = _convertCourseUserIdToEmail(croom, courseAnnouncement['creatorUserId'], creatorEmails,
                                                                           [Ent.COURSE, course['id'], Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncement['id'],
                                                                            Ent.CREATOR_ID, courseAnnouncement['creatorUserId']], i, count)
    row = flattenJSON(courseAnnouncement, flattened={'courseId': course['id'], 'courseName': course['name']}, timeObjects=COURSE_ANNOUNCEMENTS_TIME_OBJECTS)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(row)
    elif csvPF.CheckRowTitles(row):
      csvPF.WriteRowNoFilter({'courseId': course['id'], 'courseName': course['name'],
                              'JSON': json.dumps(cleanJSON(courseAnnouncement, timeObjects=COURSE_ANNOUNCEMENTS_TIME_OBJECTS),
                                                 ensure_ascii=False, sort_keys=True)})

  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['courseId', 'courseName'], COURSE_ANNOUNCEMENTS_SORT_TITLES, COURSE_ANNOUNCEMENTS_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseItemFilter = _initCourseItemFilter()
  courseShowProperties = _initCourseShowProperties(['name'])
  courseAnnouncementIds = []
  courseAnnouncementStates = []
  OBY = OrderBy(COURSE_ANNOUNCEMENTS_ORDERBY_CHOICE_MAP)
  creatorEmails = {}
  showCreatorEmail = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseItemFilter(myarg, courseItemFilter, COURSE_CUS_FILTER_FIELDS_MAP):
      pass
    elif myarg in {'announcementid', 'announcementids'}:
      courseAnnouncementIds = getEntityList(Cmd.OB_COURSE_ANNOUNCEMENT_ID_ENTITY)
    elif myarg in {'announcementstate', 'announcementstates'}:
      _getCourseStates(Cmd.OB_COURSE_ANNOUNCEMENT_STATE_LIST, courseAnnouncementStates)
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg in {'showcreatoremails', 'creatoremail'}:
      showCreatorEmail = True
    elif getFieldsList(myarg, COURSE_ANNOUNCEMENTS_FIELDS_CHOICE_MAP, fieldsList, initialField='id'):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  applyCourseItemFilter = _setApplyCourseItemFilter(courseItemFilter, fieldsList)
  if showCreatorEmail and fieldsList:
    fieldsList.append('creatorUserId')
  courseAnnouncementIdsLists = courseAnnouncementIds if isinstance(courseAnnouncementIds, dict) else None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course['id']
    if courseAnnouncementIdsLists:
      courseAnnouncementIds = courseAnnouncementIdsLists[courseId]
    if not courseAnnouncementIds:
      fields = getItemFieldsFromFieldsList('announcements', fieldsList)
      printGettingAllEntityItemsForWhom(Ent.COURSE_ANNOUNCEMENT_ID, Ent.TypeName(Ent.COURSE, courseId), i, count,
                                        _gettingCourseAnnouncementQuery(courseAnnouncementStates))
      try:
        results = callGAPIpages(croom.courses().announcements(), 'list', 'announcements',
                                pageMessage=getPageMessage(),
                                throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                courseId=courseId, announcementStates=courseAnnouncementStates, orderBy=OBY.orderBy,
                                fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseAnnouncement in results:
          _printCourseAnnouncement(course, courseAnnouncement, i, count)
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
    else:
      jcount = len(courseAnnouncementIds)
      if jcount == 0:
        continue
      fields = f'{",".join(set(fieldsList))}' if fieldsList else None
      j = 0
      for courseAnnouncementId in courseAnnouncementIds:
        j += 1
        try:
          courseAnnouncement = callGAPI(croom.courses().announcements(), 'get',
                                        throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                        courseId=courseId, id=courseAnnouncementId, fields=fields)
          _printCourseAnnouncement(course, courseAnnouncement, i, count)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], j, jcount)
        except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_ANNOUNCEMENT_ID, courseAnnouncementId], str(e), j, jcount)
  csvPF.writeCSVfile('Course Announcements')

COURSE_TOPICS_TIME_OBJECTS = {'updateTime'}
COURSE_TOPICS_SORT_TITLES = ['courseId', 'courseName', 'topicId', 'name', 'updateTime']

# gam print course-topics [todrive <ToDriveAttribute>*]
#	(course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	[topicids <CourseTopicIDEntity>]
#	[formatjson [quotechar <Character>]]
#	[timefilter updatetime] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
def doPrintCourseTopics():
  def _printCourseTopic(course, courseTopic):
    if applyCourseItemFilter and not _courseItemPassesFilter(courseTopic, courseItemFilter):
      return
    row = flattenJSON(courseTopic, flattened={'courseId': course['id'], 'courseName': course['name']}, timeObjects=COURSE_TOPICS_TIME_OBJECTS)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(row)
    elif csvPF.CheckRowTitles(row):
      csvPF.WriteRowNoFilter({'courseId': course['id'], 'courseName': course['name'],
                              'JSON': json.dumps(cleanJSON(courseTopic, timeObjects=COURSE_TOPICS_TIME_OBJECTS),
                                                 ensure_ascii=False, sort_keys=True)})

  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['courseId', 'courseName'], COURSE_TOPICS_SORT_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  fieldsList = ['topicId', 'name', 'updateTime']
  courseSelectionParameters = _initCourseSelectionParameters()
  courseItemFilter = _initCourseItemFilter()
  courseShowProperties = _initCourseShowProperties(['name'])
  courseTopicIds = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseItemFilter(myarg, courseItemFilter, COURSE_U_FILTER_FIELDS_MAP):
      pass
    elif myarg in {'topicid', 'topicids'}:
      courseTopicIds = getEntityList(Cmd.OB_COURSE_TOPIC_ID_ENTITY)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  applyCourseItemFilter = _setApplyCourseItemFilter(courseItemFilter, fieldsList)
  courseTopicIdsLists = courseTopicIds if isinstance(courseTopicIds, dict) else None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course['id']
    if courseTopicIdsLists:
      courseTopicIds = courseTopicIdsLists[courseId]

    if not courseTopicIds:
      fields = getItemFieldsFromFieldsList('topic', fieldsList)
      printGettingAllEntityItemsForWhom(Ent.COURSE_TOPIC, Ent.TypeName(Ent.COURSE, courseId), i, count)
      try:
        results = callGAPIpages(croom.courses().topics(), 'list', 'topic',
                                pageMessage=getPageMessage(),
                                throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                courseId=courseId,
                                fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseTopic in results:
          _printCourseTopic(course, courseTopic)
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
    else:
      jcount = len(courseTopicIds)
      if jcount == 0:
        continue
      fields = f'{",".join(set(fieldsList))}'
      j = 0
      for courseTopicId in courseTopicIds:
        j += 1
        try:
          courseTopic = callGAPI(croom.courses().topics(), 'get',
                                 throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                 courseId=courseId, id=courseTopicId, fields=fields)
          _printCourseTopic(course, courseTopic)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_TOPIC_ID, courseTopicId], j, jcount)
        except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_TOPIC_ID, courseTopicId], str(e), j, jcount)
  csvPF.writeCSVfile('Course Topics')

COURSE_WORK_FIELDS_CHOICE_MAP = {
  'alternatelink': 'alternateLink',
  'assigneemode': 'assigneeMode',
  'courseid': 'courseId',
  'courseworkid': 'id',
  'courseworktype': 'workType',
  'creationtime': 'creationTime',
  'creator': 'creatorUserId',
  'creatoruserid': 'creatorUserId',
  'description': 'description',
  'duedate': 'dueDate',
  'duetime': 'dueTime',
  'id': 'id',
  'materials': 'materials',
  'maxpoints': 'maxPoints',
  'scheduledtime': 'scheduledTime',
  'state': 'state',
  'submissionmodificationmode': 'submissionModificationMode',
  'title': 'title',
  'topicid': 'topicId',
  'updatetime': 'updateTime',
  'workid': 'id',
  'worktype': 'workType',
  }
COURSE_WORK_ORDERBY_CHOICE_MAP = {
  'duedate': 'dueDate',
  'updatetime': 'updateTime',
  'updatedate': 'updateTime',
  }
COURSE_WORK_TIME_OBJECTS = {'creationTime', 'scheduledTime', 'updateTime'}
COURSE_WORK_SORT_TITLES = ['courseId', 'courseName', 'id', 'title', 'description', 'state']
COURSE_WORK_INDEXED_TITLES = ['materials']

def _initCourseWorkSelectionParameters():
  return {'courseWorkIds': [], 'courseWorkStates': []}

def _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
  if myarg in {'workid', 'workids', 'courseworkid', 'courseworkids'}:
    courseWorkSelectionParameters['courseWorkIds'] = getEntityList(Cmd.OB_COURSE_WORK_ID_ENTITY)
  elif myarg in {'workstate', 'workstates', 'courseworkstate', 'courseworkstates'}:
    _getCourseStates(Cmd.OB_COURSE_WORK_STATE_LIST, courseWorkSelectionParameters['courseWorkStates'])
  else:
    return False
  return True

def _gettingCourseWorkQuery(courseWorkStates):
  query = ''
  if courseWorkStates:
    query += f'{Ent.Choose(Ent.COURSE_WORK_STATE, len(courseWorkStates))}: {",".join(courseWorkStates)}, '
  if query:
    query = query[:-2]
  return query

# gam print course-work [todrive <ToDriveAttribute>*]
#	(course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(workids <CourseWorkIDEntity>)|((workstates <CourseWorkStateList>)*
#	(orderby <CourseWorkOrderByFieldName> [ascending|descending])*)
#	[showcreatoremails] [showtopicnames] [fields <CourseWorkFieldNameList>] [formatjson [quotechar <Character>]]
#	[timefilter creationtime|updatetime|scheduledtime] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
def doPrintCourseWork():
  def _getTopicNames(croom, courseId):
    topicNames = {}
    try:
      results = callGAPIpages(croom.courses().topics(), 'list', 'topic',
                              throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                              courseId=courseId,
                              fields='nextPageToken,topic(topicId,name)', pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
      for courseTopic in results:
        topicNames[courseTopic['topicId']] = courseTopic['name']
    except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument):
      pass
    return topicNames

  def _printCourseWork(course, courseWork, i, count):
    if applyCourseItemFilter and not _courseItemPassesFilter(courseWork, courseItemFilter):
      return
    if showCreatorEmail:
      courseWork['creatorUserEmail'] = _convertCourseUserIdToEmail(croom, courseWork['creatorUserId'], creatorEmails,
                                                                   [Ent.COURSE, course['id'], Ent.COURSE_WORK_ID, courseWork['id'],
                                                                    Ent.CREATOR_ID, courseWork['creatorUserId']], i, count)
    if showTopicNames:
      topicId = courseWork.get('topicId')
      if topicId:
        courseWork['topicName'] = topicNames.get(topicId, topicId)
    row = flattenJSON(courseWork, flattened={'courseId': course['id'], 'courseName': course['name']}, timeObjects=COURSE_WORK_TIME_OBJECTS)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(row)
    elif csvPF.CheckRowTitles(row):
      csvPF.WriteRowNoFilter({'courseId': course['id'], 'courseName': course['name'],
                              'JSON': json.dumps(cleanJSON(courseWork, timeObjects=COURSE_WORK_TIME_OBJECTS),
                                                 ensure_ascii=False, sort_keys=True)})

  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['courseId', 'courseName'], COURSE_WORK_SORT_TITLES, COURSE_WORK_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseWorkSelectionParameters = _initCourseWorkSelectionParameters()
  courseItemFilter = _initCourseItemFilter()
  courseShowProperties = _initCourseShowProperties(['name'])
  OBY = OrderBy(COURSE_WORK_ORDERBY_CHOICE_MAP)
  creatorEmails = {}
  showCreatorEmail = showTopicNames = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
      pass
    elif _getCourseItemFilter(myarg, courseItemFilter, COURSE_CUS_FILTER_FIELDS_MAP):
      pass
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg in {'showcreatoremails', 'creatoremail'}:
      showCreatorEmail = True
    elif myarg == 'showtopicnames':
      showTopicNames = True
    elif getFieldsList(myarg, COURSE_WORK_FIELDS_CHOICE_MAP, fieldsList, initialField='id'):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if showCreatorEmail and fieldsList:
    fieldsList.append('creatorUserId')
  if showTopicNames and fieldsList:
    fieldsList.append('topicId')
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  applyCourseItemFilter = _setApplyCourseItemFilter(courseItemFilter, fieldsList)
  courseWorkIds = courseWorkSelectionParameters['courseWorkIds']
  courseWorkIdsLists = courseWorkIds if isinstance(courseWorkIds, dict) else {}
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course['id']
    if showTopicNames:
      topicNames = _getTopicNames(croom, courseId)
    if courseWorkIdsLists:
      courseWorkIds = courseWorkIdsLists[courseId]
    if not courseWorkIds:
      fields = getItemFieldsFromFieldsList('courseWork', fieldsList)
      printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, courseId), i, count, _gettingCourseWorkQuery(courseWorkSelectionParameters['courseWorkStates']))
      try:
        results = callGAPIpages(croom.courses().courseWork(), 'list', 'courseWork',
                                pageMessage=getPageMessage(),
                                throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                courseId=courseId, courseWorkStates=courseWorkSelectionParameters['courseWorkStates'], orderBy=OBY.orderBy,
                                fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        for courseWork in results:
          _printCourseWork(course, courseWork, i, count)
      except (GAPI.notFound, GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
    else:
      jcount = len(courseWorkIds)
      if jcount == 0:
        continue
      fields = f'{",".join(set(fieldsList))}' if fieldsList else None
      j = 0
      for courseWorkId in courseWorkIds:
        j += 1
        try:
          courseWork = callGAPI(croom.courses().courseWork(), 'get',
                                throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                courseId=courseId, id=courseWorkId, fields=fields)
          _printCourseWork(course, courseWork, i, count)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId], j, jcount)
        except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId], str(e), j, jcount)
  csvPF.writeCSVfile('Course Work')

COURSE_SUBMISSION_FIELDS_CHOICE_MAP = {
  'alternatelink': 'alternateLink',
  'assignedgrade': 'assignedGrade',
  'courseid': 'courseId',
  'coursesubmissionid': 'id',
  'courseworkid': 'courseWorkId',
  'courseworktype': 'courseWorkType',
  'creationtime': 'creationTime',
  'draftgrade': 'draftGrade',
  'id': 'id',
  'late': 'late',
  'state': 'state',
  'submissionhistory': 'submissionHistory',
  'submissionid': 'id',
  'updatetime': 'updateTime',
  'userid': 'userId',
  'workid': 'courseWorkId',
  'worktype': 'courseWorkType',
  }
COURSE_SUBMISSION_TIME_OBJECTS = {'creationTime', 'updateTime', 'gradeTimestamp', 'stateTimestamp'}
COURSE_SUBMISSION_SORT_TITLES = ['courseId', 'courseName', 'courseWorkId', 'id', 'userId',
                                 'profile.emailAddress', 'profile.name.givenName', 'profile.name.familyName', 'profile.name.fullName', 'state']
COURSE_SUBISSION_INDEXED_TITLES = ['submissionHistory']

def _gettingCourseSubmissionQuery(courseSubmissionStates, late, userId):
  query = ''
  if courseSubmissionStates:
    query += f'{Ent.Choose(Ent.COURSE_SUBMISSION_STATE, len(courseSubmissionStates))}: {",".join(courseSubmissionStates)}, '
  if late:
    query += f'{late}, '
  if userId:
    query += f'{Ent.Singular(Ent.USER)}: {userId}, '
  if query:
    query = query[:-2]
  return query

# gam print course-submissions [todrive <ToDriveAttribute>*]
#	(course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] states <CourseStateList>])
#	(workids <CourseWorkIDEntity>)|((workstates <CourseWorkStateList>)*
#	(orderby <CourseWorkOrderByFieldName> [ascending|descending])*)
#	(submissionids <CourseSubmissionIDEntity>)|((submissionstates <CourseSubmissionStateList>)*) [late|notlate]
#	[fields <CourseSubmissionFieldNameList>] [formatjson [quotechar <Character>]] [showuserprofile]
#	[timefilter creationtime|updatetime] [start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>]
def doPrintCourseSubmissions():
  def _printCourseSubmission(course, courseSubmission):
    if applyCourseItemFilter and not _courseItemPassesFilter(courseSubmission, courseItemFilter):
      return
    if showUserProfile:
      userId = courseSubmission.get('userId')
      if userId:
        if userId not in userProfiles:
          try:
            userProfile = callGAPI(tcroom.userProfiles(), 'get',
                                   throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED],
                                   userId=userId, fields='emailAddress,name')
            userProfiles[userId] = {'profile': {'emailAddress': userProfile.get('emailAddress', ''), 'name': userProfile['name']}}
          except (GAPI.notFound, GAPI.permissionDenied):
            userProfiles[userId] = {'profile': {'emailAddress': '', 'name': {'givenName': '', 'familyName': '', 'fullName': ''}}}
        courseSubmission.update(userProfiles[userId])
    row = flattenJSON(courseSubmission, flattened={'courseId': course['id'], 'courseName': course['name']}, timeObjects=COURSE_SUBMISSION_TIME_OBJECTS)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(row)
    elif csvPF.CheckRowTitles(row):
      csvPF.WriteRowNoFilter({'courseId': course['id'], 'courseName': course['name'],
                              'JSON': json.dumps(cleanJSON(courseSubmission, timeObjects=COURSE_SUBMISSION_TIME_OBJECTS),
                                                 ensure_ascii=False, sort_keys=True)})

  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['courseId', 'courseName'], COURSE_SUBMISSION_SORT_TITLES, COURSE_SUBISSION_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  fieldsList = []
  courseSelectionParameters = _initCourseSelectionParameters()
  courseWorkSelectionParameters = _initCourseWorkSelectionParameters()
  courseItemFilter = _initCourseItemFilter()
  courseShowProperties = _initCourseShowProperties(['name'])
  courseSubmissionStates = []
  courseSubmissionIds = []
  OBY = OrderBy(COURSE_WORK_ORDERBY_CHOICE_MAP)
  late = None
  userProfiles = {}
  showUserProfile = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif _getCourseWorkSelectionParameters(myarg, courseWorkSelectionParameters):
      pass
    elif _getCourseItemFilter(myarg, courseItemFilter, COURSE_CU_FILTER_FIELDS_MAP):
      pass
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg in {'submissionid', 'submissionids', 'coursesubmissionid', 'coursesubmissionids'}:
      courseSubmissionIds = getEntityList(Cmd.OB_COURSE_SUBMISSION_ID_ENTITY)
    elif myarg in {'submissionstate', 'submissionstates', 'coursesubmissionstate', 'coursesubmissionstates'}:
      _getCourseStates(Cmd.OB_COURSE_SUBMISSION_STATE_LIST, courseSubmissionStates)
    elif myarg == 'late':
      late = 'LATE_ONLY'
    elif myarg == 'notlate':
      late = 'NOT_LATE_ONLY'
    elif myarg == 'showuserprofile':
      showUserProfile = True
    elif getFieldsList(myarg, COURSE_SUBMISSION_FIELDS_CHOICE_MAP, fieldsList, initialField='id'):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties, getOwnerId=True)
  if coursesInfo is None:
    return
  applyCourseItemFilter = _setApplyCourseItemFilter(courseItemFilter, fieldsList)
  courseWorkIds = courseWorkSelectionParameters['courseWorkIds']
  courseWorkIdsLists = courseWorkIds if isinstance(courseWorkIds, dict) else {}
  courseSubmissionIdsLists = courseSubmissionIds if isinstance(courseSubmissionIds, dict) else {}
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    _, tcroom = buildGAPIServiceObject(API.CLASSROOM, f"uid:{course['ownerId']}")
    if tcroom is None:
      continue
    courseId = course['id']
    if courseWorkIdsLists:
      courseWorkIds = courseWorkIdsLists[courseId]
    if not courseWorkIds:
      printGettingAllEntityItemsForWhom(Ent.COURSE_WORK_ID, Ent.TypeName(Ent.COURSE, courseId), i, count, _gettingCourseWorkQuery(courseWorkSelectionParameters['courseWorkStates']))
      try:
        results = callGAPIpages(croom.courses().courseWork(), 'list', 'courseWork',
                                pageMessage=getPageMessage(),
                                throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                courseId=courseId, courseWorkStates=courseWorkSelectionParameters['courseWorkStates'], orderBy=OBY.orderBy,
                                fields='nextPageToken,courseWork(id)', pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
        courseWorkIdsForCourse = [courseWork['id'] for courseWork in results]
      except GAPI.notFound:
        continue
      except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId)], str(e), i, count)
        continue
    else:
      courseWorkIdsForCourse = courseWorkIds
    jcount = len(courseWorkIdsForCourse)
    if jcount == 0:
      continue
    j = 0
    for courseWorkId in courseWorkIdsForCourse:
      j += 1
      if not courseSubmissionIds:
        fields = getItemFieldsFromFieldsList('studentSubmissions', fieldsList)
        printGettingAllEntityItemsForWhom(Ent.COURSE_SUBMISSION_ID, Ent.TypeName(Ent.COURSE_WORK_ID, courseWorkId), j, jcount,
                                          _gettingCourseSubmissionQuery(courseSubmissionStates, late, courseSelectionParameters['studentId']))
        try:
          results = callGAPIpages(croom.courses().courseWork().studentSubmissions(), 'list', 'studentSubmissions',
                                  pageMessage=getPageMessage(),
                                  throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                  courseId=courseId, courseWorkId=courseWorkId, states=courseSubmissionStates, late=late, userId=courseSelectionParameters['studentId'],
                                  fields=fields, pageSize=GC.Values[GC.CLASSROOM_MAX_RESULTS])
          for submission in results:
            _printCourseSubmission(course, submission)
        except GAPI.notFound:
          entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId], j, jcount)
        except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId], str(e), j, jcount)
      else:
        if courseSubmissionIdsLists:
          if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
            courseSubmissionIds = courseSubmissionIdsLists[courseWorkId]
          else:
            courseSubmissionIds = courseSubmissionIdsLists[courseId][courseWorkId]
        kcount = len(courseSubmissionIds)
        if kcount == 0:
          continue
        fields = f'{",".join(set(fieldsList))}' if fieldsList else None
        k = 0
        for courseSubmissionId in courseSubmissionIds:
          k += 1
          try:
            submission = callGAPI(croom.courses().courseWork().studentSubmissions(), 'get',
                                  throwReasons=GAPI.COURSE_ACCESS_THROW_REASONS,
                                  courseId=courseId, courseWorkId=courseWorkId, id=courseSubmissionId,
                                  fields=fields)
            _printCourseSubmission(course, submission)
          except GAPI.notFound:
            entityDoesNotHaveItemWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId, Ent.COURSE_SUBMISSION_ID, courseSubmissionId], k, kcount)
          except (GAPI.insufficientPermissions, GAPI.permissionDenied, GAPI.forbidden, GAPI.invalidArgument) as e:
            entityActionFailedWarning([Ent.COURSE_NAME, course['name'], Ent.COURSE_WORK_ID, courseWorkId, Ent.COURSE_SUBMISSION_ID, courseSubmissionId], str(e), k, kcount)
  csvPF.writeCSVfile('Course Submissions')

COURSE_PARTICIPANTS_SORT_TITLES = ['courseId', 'courseName', 'userRole', 'userId']

# gam print course-participants [todrive <ToDriveAttribute>*]
#	(course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[show all|students|teachers] [formatjson [quotechar <Character>]]
def doPrintCourseParticipants():
  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['courseId', 'courseName'])
  FJQC = FormatJSONQuoteChar(csvPF)
  courseSelectionParameters = _initCourseSelectionParameters()
  courseShowProperties = _initCourseShowProperties(['name'])
  courseShowProperties['members'] = 'all'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif myarg == 'show':
      courseShowProperties['members'] = getChoice(COURSE_MEMBER_ARGUMENTS)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if courseShowProperties['members'] != 'none':
    if courseShowProperties['members'] != 'students':
      if FJQC.formatJSON:
        csvPF.AddJSONTitles('JSON-teachers')
    if courseShowProperties['members'] != 'teachers':
      if FJQC.formatJSON:
        csvPF.AddJSONTitles('JSON-students')
    teachersFields = 'nextPageToken,teachers(userId,profile)'
    studentsFields = 'nextPageToken,students(userId,profile)'
  else:
    teachersFields = studentsFields = None
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course['id']
    _, teachers, students = _getCourseAliasesMembers(croom, courseId, courseShowProperties, teachersFields, studentsFields, True, i, count)
    if not FJQC.formatJSON:
      if courseShowProperties['members'] != 'none':
        if courseShowProperties['members'] != 'students':
          for member in teachers:
            csvPF.WriteRowTitles(flattenJSON(member, flattened={'courseId': courseId, 'courseName': course['name'], 'userRole': 'TEACHER'}))
        if courseShowProperties['members'] != 'teachers':
          for member in students:
            csvPF.WriteRowTitles(flattenJSON(member, flattened={'courseId': courseId, 'courseName': course['name'], 'userRole': 'STUDENT'}))
    else:
      row = {'courseId': courseId, 'courseName': course['name']}
      if courseShowProperties['members'] != 'none':
        if courseShowProperties['members'] != 'students':
          row['JSON-teachers'] = json.dumps(list(teachers))
        if courseShowProperties['members'] != 'teachers':
          row['JSON-students'] = json.dumps(list(students))
      csvPF.WriteRowNoFilter(row)
  if not FJQC.formatJSON:
    csvPF.SetSortTitles(COURSE_PARTICIPANTS_SORT_TITLES)
  csvPF.writeCSVfile('Course Participants')

def _batchAddItemsToCourse(croom, courseId, i, count, addParticipants, role):
  _ADD_PART_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST,
                                     GAPI.ALREADY_EXISTS: Msg.DUPLICATE,
                                     GAPI.FAILED_PRECONDITION: Msg.NOT_ALLOWED}
  def _callbackAddItemsToCourse(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if (reason != GAPI.QUOTA_EXCEEDED) and ((reason != GAPI.NOT_FOUND) or (ri[RI_ROLE] == Ent.COURSE_ALIAS)):
        if reason in [GAPI.FORBIDDEN, GAPI.BACKEND_ERROR]:
          errMsg = getPhraseDNEorSNA(ri[RI_ITEM])
        else:
          errMsg = getHTTPError(_ADD_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(service, 'create',
                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR,
                               GAPI.ALREADY_EXISTS, GAPI.FAILED_PRECONDITION, GAPI.QUOTA_EXCEEDED],
                 retryReasons=[GAPI.NOT_FOUND], retries=10 if reason != GAPI.NOT_FOUND else 3,
                 courseId=ri[RI_ENTITY],
                 body={attribute: ri[RI_ITEM] if ri[RI_ROLE] != Ent.COURSE_ALIAS else addCourseAliasScope(ri[RI_ITEM])},
                 fields='')
      except (GAPI.notFound, GAPI.backendError, GAPI.forbidden):
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], getPhraseDNEorSNA(ri[RI_ITEM]), int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.alreadyExists:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], Msg.DUPLICATE, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.failedPrecondition:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], Msg.NOT_ALLOWED, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.quotaExceeded as e:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  if role == Ent.STUDENT:
    service = croom.courses().students()
    attribute = 'userId'
  elif role == Ent.TEACHER:
    service = croom.courses().teachers()
    attribute = 'userId'
  elif role == Ent.COURSE_ALIAS:
    service = croom.courses().aliases()
    attribute = 'alias'
  else: # role == Ent.COURSE_TOPIC:
    service = croom.courses().topics()
    attribute = 'name'
  method = getattr(service, 'create')
  Act.Set(Act.ADD)
  jcount = len(addParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Ent.COURSE, noScopeCourseId], jcount, role, i, count)
  Ind.Increment()
  svcargs = dict([('courseId', courseId), ('body', {attribute: None}), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackAddItemsToCourse)
  bcount = 0
  j = 0
  for participant in addParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role in {Ent.STUDENT, Ent.TEACHER}:
      svcparms['body'][attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    elif role == Ent.COURSE_ALIAS:
      svcparms['body'][attribute] = addCourseAliasScope(participant)
      cleanItem = removeCourseAliasScope(svcparms['body'][attribute])
    else: # role == Ent.COURSE_TOPIC:
      svcparms['body'][attribute] = cleanItem = participant
    dbatch.add(method(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = croom.new_batch_http_request(callback=_callbackAddItemsToCourse)
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  Ind.Decrement()

def _batchRemoveItemsFromCourse(croom, courseId, i, count, removeParticipants, role):
  _REMOVE_PART_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST,
                                        GAPI.FORBIDDEN: Msg.FORBIDDEN,
                                        GAPI.PERMISSION_DENIED: Msg.PERMISSION_DENIED}
  def _callbackRemoveItemssFromCourse(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason != GAPI.QUOTA_EXCEEDED:
        if reason == GAPI.NOT_FOUND and ri[RI_ROLE] != Ent.COURSE_ALIAS:
          errMsg = f'{Msg.NOT_A} {Ent.Singular(ri[RI_ROLE])}'
        else:
          errMsg = getHTTPError(_REMOVE_PART_REASON_TO_MESSAGE_MAP, http_status, reason, message)
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(service, 'delete',
                 throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED, GAPI.QUOTA_EXCEEDED],
                 courseId=ri[RI_ENTITY],
                 body={attribute: ri[RI_ITEM] if ri[RI_ROLE] != Ent.COURSE_ALIAS else addCourseAliasScope(ri[RI_ITEM])},
                 fields='')
      except GAPI.notFound:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], Msg.DOES_NOT_EXIST, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.forbidden:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], Msg.FORBIDDEN, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.permissionDenied:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], Msg.PERMISSION_DENIED, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.quotaExceeded as e:
        entityActionFailedWarning([Ent.COURSE, ri[RI_ENTITY], ri[RI_ROLE], ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  if role == Ent.STUDENT:
    service = croom.courses().students()
    attribute = 'userId'
  elif role == Ent.TEACHER:
    service = croom.courses().teachers()
    attribute = 'userId'
  elif role == Ent.COURSE_ALIAS:
    service = croom.courses().aliases()
    attribute = 'alias'
  else: # role == Ent.COURSE_TOPIC:
    service = croom.courses().topics()
    attribute = 'id'
  method = getattr(service, 'delete')
  Act.Set(Act.REMOVE)
  jcount = len(removeParticipants)
  noScopeCourseId = removeCourseIdScope(courseId)
  entityPerformActionNumItems([Ent.COURSE, noScopeCourseId], jcount, role, i, count)
  Ind.Increment()
  svcargs = dict([('courseId', courseId), ('fields', ''), (attribute, None)]+GM.Globals[GM.EXTRA_ARGS_LIST])
  dbatch = croom.new_batch_http_request(callback=_callbackRemoveItemssFromCourse)
  bcount = 0
  j = 0
  for participant in removeParticipants:
    j += 1
    svcparms = svcargs.copy()
    if role in {Ent.STUDENT, Ent.TEACHER}:
      svcparms[attribute] = cleanItem = normalizeEmailAddressOrUID(participant)
    elif role == Ent.COURSE_ALIAS:
      svcparms[attribute] = addCourseAliasScope(participant)
      cleanItem = removeCourseAliasScope(svcparms[attribute])
    else: # role == Ent.COURSE_TOPIC:
      svcparms[attribute] = cleanItem = participant
    dbatch.add(method(**svcparms), request_id=batchRequestID(noScopeCourseId, 0, 0, j, jcount, cleanItem, role))
    bcount += 1
    if bcount >= GC.Values[GC.BATCH_SIZE]:
      executeBatch(dbatch)
      dbatch = croom.new_batch_http_request(callback=_callbackRemoveItemssFromCourse)
      bcount = 0
  if bcount > 0:
    dbatch.execute()
  Ind.Decrement()

def _getCoursesOwnerInfo(croom, courseIds, coursesInfo, useAdminAccess):
  for courseId in courseIds:
    courseId = addCourseIdScope(courseId)
    if courseId not in coursesInfo:
      coursesInfo[courseId] = {}
      try:
        info = callGAPI(croom.courses(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                        id=courseId, fields='name,ownerId')
        if not useAdminAccess:
          _, ocroom = buildGAPIServiceObject(API.CLASSROOM, f'uid:{info["ownerId"]}')
        else:
          ocroom = croom
        if ocroom is not None:
          coursesInfo[courseId] = {'name': info['name'], 'croom': ocroom}
      except GAPI.notFound:
        entityDoesNotExistWarning(Ent.COURSE, courseId)
      except GAPI.permissionDenied as e:
        entityActionFailedWarning([Ent.COURSE, courseId], str(e))
      except GAPI.forbidden:
        ClientAPIAccessDeniedExit()

def _updateCourseOwner(croom, courseId, owner, i, count):
  action = Act.Get()
  Act.Set(Act.UPDATE_OWNER)
  try:
    callGAPI(croom.courses(), 'patch',
             throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.FAILED_PRECONDITION,
                           GAPI.FORBIDDEN, GAPI.BAD_REQUEST, GAPI.INVALID_ARGUMENT],
             id=courseId, body={'ownerId': owner}, updateMask='ownerId', fields='id')
    entityActionPerformed([Ent.COURSE, removeCourseIdScope(courseId), Ent.TEACHER, owner], i, count)
  except (GAPI.notFound, GAPI.permissionDenied, GAPI.failedPrecondition,
          GAPI.forbidden, GAPI.badRequest, GAPI.invalidArgument) as e:
    entityActionFailedWarning([Ent.COURSE, removeCourseIdScope(courseId), Ent.TEACHER, owner], str(e), i, count)
  Act.Set(action)

ADD_REMOVE_PARTICIPANT_TYPES_MAP = {
  'alias': Ent.COURSE_ALIAS,
  'aliases': Ent.COURSE_ALIAS,
  'student': Ent.STUDENT,
  'students': Ent.STUDENT,
  'teacher': Ent.TEACHER,
  'teachers': Ent.TEACHER,
  'topic': Ent.COURSE_TOPIC,
  'topics': Ent.COURSE_TOPIC,
  }
CLEAR_SYNC_PARTICIPANT_TYPES_MAP = {
  'student': Ent.STUDENT,
  'students': Ent.STUDENT,
  'teacher': Ent.TEACHER,
  'teachers': Ent.TEACHER,
  }
PARTICIPANT_EN_MAP = {
  Ent.STUDENT: Cmd.ENTITY_STUDENTS,
  Ent.TEACHER: Cmd.ENTITY_TEACHERS,
  }

# gam courses <CourseEntity> create|add alias <CourseAliasEntity>
# gam course <CourseID> create|add alias <CourseAlias>
# gam courses <CourseEntity> create|add topic <CourseTopicEntity>
# gam course <CourseID> create|add topic <CourseTopic>
# gam courses <CourseEntity> create|add students <UserTypeEntity>
# gam course <CourseID> create|add student <EmailAddress>
# gam courses <CourseEntity> create|add teachers [makefirstteacherowner] <UserTypeEntity>
# gam course <CourseID> create|add teacher [makefirstteacherowner] <EmailAddress>
def doCourseAddItems(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if role == Ent.TEACHER:
    makeFirstTeacherOwner = checkArgumentPresent(['makefirstteacherowner'])
  else:
    makeFirstTeacherOwner = False
  coursesInfo = {}
  if not getEntityListArg:
    if role in {Ent.STUDENT, Ent.TEACHER}:
      addItems = getStringReturnInList(Cmd.OB_EMAIL_ADDRESS)
    elif role == Ent.COURSE_ALIAS:
      addItems = getStringReturnInList(Cmd.OB_COURSE_ALIAS)
    else: # role == Ent.COURSE_TOPIC:
      addItems = getStringReturnInList(Cmd.OB_COURSE_TOPIC)
    courseParticipantLists = None
  else:
    if role in {Ent.STUDENT, Ent.TEACHER}:
      _, addItems = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                      typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]},
                                      isSuspended=False)
    elif role == Ent.COURSE_ALIAS:
      addItems = getEntityList(Cmd.OB_COURSE_ALIAS_ENTITY, shlexSplit=True)
    else: # role == Ent.COURSE_TOPIC:
      addItems = getEntityList(Cmd.OB_COURSE_TOPIC_ENTITY, shlexSplit=True)
    courseParticipantLists = addItems if isinstance(addItems, dict) else None
  if courseParticipantLists is None:
    firstTeacher = None
    if makeFirstTeacherOwner and addItems:
      firstTeacher = normalizeEmailAddressOrUID(addItems[0])
  checkForExtraneousArguments()
  _getCoursesOwnerInfo(croom, courseIdList, coursesInfo, role != Ent.COURSE_TOPIC)
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      addItems = courseParticipantLists[courseId]
      firstTeacher = None
      if makeFirstTeacherOwner and addItems:
        firstTeacher = normalizeEmailAddressOrUID(addItems[0])
    courseId = addCourseIdScope(courseId)
    courseInfo = coursesInfo[courseId]
    if courseInfo:
      _batchAddItemsToCourse(courseInfo['croom'], courseId, i, count, addItems, role)
      if makeFirstTeacherOwner and firstTeacher:
        _updateCourseOwner(courseInfo['croom'], courseId, firstTeacher, i, count)

# gam courses <CourseEntity> remove alias <CourseAliasEntity>
# gam course <CourseID> remove alias <CourseAlias>
# gam courses <CourseEntity> remove topic <CourseTopicIDEntity>
# gam course <CourseID> remove topic <CourseTopicID>
# gam courses <CourseEntity> remove teachers|students <UserTypeEntity>
# gam course <CourseID> remove teacher|student <EmailAddress>
def doCourseRemoveItems(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(ADD_REMOVE_PARTICIPANT_TYPES_MAP, mapChoice=True)
  coursesInfo = {}
  if not getEntityListArg:
    if role in {Ent.STUDENT, Ent.TEACHER}:
      removeItems = getStringReturnInList(Cmd.OB_EMAIL_ADDRESS)
    elif role == Ent.COURSE_ALIAS:
      removeItems = getStringReturnInList(Cmd.OB_COURSE_ALIAS)
    else: # role == Ent.COURSE_TOPIC:
      removeItems = getStringReturnInList(Cmd.OB_COURSE_TOPIC_ID)
    courseParticipantLists = None
  else:
    if role in {Ent.STUDENT, Ent.TEACHER}:
      _, removeItems = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                         typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]})
    elif role == Ent.COURSE_ALIAS:
      removeItems = getEntityList(Cmd.OB_COURSE_ALIAS_ENTITY, shlexSplit=True)
    else: # role == Ent.COURSE_TOPIC:
      removeItems = getEntityList(Cmd.OB_COURSE_TOPIC_ID_ENTITY, shlexSplit=True)
    courseParticipantLists = removeItems if isinstance(removeItems, dict) else None
  checkForExtraneousArguments()
  _getCoursesOwnerInfo(croom, courseIdList, coursesInfo, role != Ent.COURSE_TOPIC)
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      removeItems = courseParticipantLists[courseId]
    courseId = addCourseIdScope(courseId)
    courseInfo = coursesInfo[courseId]
    if courseInfo:
      _batchRemoveItemsFromCourse(courseInfo['croom'], courseId, i, count, removeItems, role)

# gam courses <CourseEntity> clear teachers|students
# gam course <CourseID> clear teacher|student
def doCourseClearParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(CLEAR_SYNC_PARTICIPANT_TYPES_MAP, mapChoice=True)
  checkForExtraneousArguments()
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    removeParticipants = getUsersToModify(PARTICIPANT_EN_MAP[role], courseId, noListConversion=True)
    _batchRemoveItemsFromCourse(croom, courseId, i, count, removeParticipants, role)

# gam courses <CourseEntity> sync students [addonly|removeonly] <UserTypeEntity>
# gam course <CourseID> sync students [addonly|removeonly] <UserTypeEntity>
# gam courses <CourseEntity> sync teachers [addonly|removeonly] [makefirstteacherowner] <UserTypeEntity>
# gam course <CourseID> sync teachers [addonly|removeonly] [makefirstteacherowner] <UserTypeEntity>
def doCourseSyncParticipants(courseIdList, getEntityListArg):
  croom = buildGAPIObject(API.CLASSROOM)
  role = getChoice(CLEAR_SYNC_PARTICIPANT_TYPES_MAP, mapChoice=True)
  if role == Ent.TEACHER:
    makeFirstTeacherOwner = checkArgumentPresent(['makefirstteacherowner'])
  else:
    makeFirstTeacherOwner = False
  syncOperation = getChoice(['addonly', 'removeonly'], defaultChoice='addremove')
  _, syncParticipants = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS,
                                          typeMap={Cmd.ENTITY_COURSEPARTICIPANTS: PARTICIPANT_EN_MAP[role]}, isSuspended=False)
  checkForExtraneousArguments()
  courseParticipantLists = syncParticipants if isinstance(syncParticipants, dict) else None
  if courseParticipantLists is None:
    syncParticipantsSet = set()
    firstTeacher = None
    if syncParticipants:
      for user in syncParticipants:
        syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
      if makeFirstTeacherOwner:
        firstTeacher = normalizeEmailAddressOrUID(syncParticipants[0])
  i = 0
  count = len(courseIdList)
  for courseId in courseIdList:
    i += 1
    if courseParticipantLists:
      syncParticipantsSet = set()
      firstTeacher = None
      if courseParticipantLists[courseId]:
        for user in courseParticipantLists[courseId]:
          syncParticipantsSet.add(normalizeEmailAddressOrUID(user))
        if makeFirstTeacherOwner:
          firstTeacher = normalizeEmailAddressOrUID(courseParticipantLists[courseId][0])
    courseInfo = checkCourseExists(croom, courseId, i, count)
    if courseInfo:
      courseId = courseInfo['id']
      currentParticipantsSet = set()
      for user in getUsersToModify(PARTICIPANT_EN_MAP[role], courseId, noListConversion=True):
        currentParticipantsSet.add(normalizeEmailAddressOrUID(user))
      if syncOperation != 'removeonly':
        _batchAddItemsToCourse(croom, courseId, i, count, list(syncParticipantsSet-currentParticipantsSet), role)
      if makeFirstTeacherOwner and firstTeacher:
        _updateCourseOwner(croom, courseId, firstTeacher, i, count)
      if syncOperation != 'addonly':
        _batchRemoveItemsFromCourse(croom, courseId, i, count, list(currentParticipantsSet-syncParticipantsSet), role)

def studentUnknownWarning(studentId, errMsg, i, count):
  setSysExitRC(SERVICE_NOT_APPLICABLE_RC)
  writeStderr(formatKeyValueList(Ind.Spaces(),
                                 [Ent.Singular(Ent.STUDENT), studentId, f'{Msg.SERVICE_NOT_APPLICABLE}: {errMsg}'],
                                 currentCountNL(i, count)))

def getGuardianEntity():
  guardians = getEntityList(Cmd.OB_GUARDIAN_ENTITY)
  if isinstance(guardians, dict):
    return (guardians, guardians)
  return ([normalizeEmailAddressOrUID(guardian) for guardian in guardians], None)

def getGuardianEmails(user, guardianEntity, guardianEntityList):
  studentId = normalizeStudentGuardianEmailAddressOrUID(user)
  if guardianEntityList:
    guardianEmails = [normalizeEmailAddressOrUID(guardian) for guardian in guardianEntityList[user]]
  else:
    guardianEmails = guardianEntity
  return (studentId, guardianEmails, len(guardianEmails))

def getGuardianInvitationEntity():
  invitations = getEntityList(Cmd.OB_GUARDIAN_INVITATION_ID_ENTITY)
  if isinstance(invitations, dict):
    return (invitations, invitations)
  return (invitations, None)

def getGuardianInvitationIds(user, invitationEntity, invitationEntityList):
  studentId = normalizeStudentGuardianEmailAddressOrUID(user)
  if invitationEntityList:
    invitationIds = invitationEntityList[user]
  else:
    invitationIds = invitationEntity
  return (studentId, invitationIds, len(invitationIds))

GUARDIAN_CLASS_UNDEFINED = 0
GUARDIAN_CLASS_ACCEPTED = 1
GUARDIAN_CLASS_INVITATIONS = 2
GUARDIAN_CLASS_ALL = 3

GUARDIAN_CLASS_MAP = {
  'all': GUARDIAN_CLASS_ALL,
  'accepted': GUARDIAN_CLASS_ACCEPTED,
  'invitation': GUARDIAN_CLASS_INVITATIONS,
  'invitations': GUARDIAN_CLASS_INVITATIONS,
  }
GUARDIAN_CLASS_ENTITY = {
  GUARDIAN_CLASS_ALL: Ent.GUARDIAN_AND_INVITATION,
  GUARDIAN_CLASS_ACCEPTED: Ent.GUARDIAN,
  GUARDIAN_CLASS_INVITATIONS: Ent.GUARDIAN_INVITATION,
  }

def _inviteGuardian(croom, studentId, guardianEmail, i=0, count=0, j=0, jcount=0):
  body = {'invitedEmailAddress': guardianEmail}
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), 'create',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS,
                                    GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED, GAPI.RESOURCE_EXHAUSTED],
                      studentId=studentId, body=body, fields='invitationId')
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN, body['invitedEmailAddress'], Ent.GUARDIAN_INVITATION, result['invitationId']], j, jcount)
    return 1
  except GAPI.notFound:
    entityUnknownWarning(Ent.STUDENT, studentId, i, count)
    return -1
  except GAPI.alreadyExists:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN, body['invitedEmailAddress']], Msg.DUPLICATE, j, jcount)
    return 0
  except GAPI.resourceExhausted as e:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN, body['invitedEmailAddress']], str(e), j, jcount)
    return -1
  except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
    studentUnknownWarning(studentId, str(e), i, count)
    return -1

# gam create guardian|guardianinvite|inviteguardian <EmailAddress> <StudentItem>
def doInviteGuardian():
  croom = buildGAPIObject(API.CLASSROOM)
  guardianEmail = getEmailAddress()
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  _inviteGuardian(croom, studentId, guardianEmail)

# gam <UserTypeEntity> create guardian|guardianinvite|inviteguardian <GuardianEntity>
def inviteGuardians(users):
  croom = buildGAPIObject(API.CLASSROOM)
  guardianEntity, guardianEntityList = getGuardianEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    studentId, guardianEmails, jcount = getGuardianEmails(user, guardianEntity, guardianEntityList)
    entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, Ent.GUARDIAN_INVITATION, i, count)
    Ind.Increment()
    j = 0
    for guardianEmail in guardianEmails:
      j += 1
      if _inviteGuardian(croom, studentId, guardianEmail, i, count, j, jcount) < 0:
        break
    Ind.Decrement()

def _cancelGuardianInvitation(croom, studentId, invitationId, i=0, count=0, j=0, jcount=0):
  try:
    result = callGAPI(croom.userProfiles().guardianInvitations(), 'patch',
                      throwReasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION,
                                    GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                      studentId=studentId, invitationId=invitationId, updateMask='state', body={'state': 'COMPLETE'}, fields='invitedEmailAddress')
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, result['invitedEmailAddress']], j, jcount)
    return 1
  except GAPI.notFound:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, invitationId], Msg.NOT_FOUND, j, jcount)
    return 0
  except GAPI.failedPrecondition:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, invitationId], Msg.GUARDIAN_INVITATION_STATUS_NOT_PENDING, j, jcount)
    return 1
  except (GAPI.invalidArgument, GAPI.badRequest) as e:
    entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN_INVITATION, invitationId], str(e), j, jcount)
    return -1
  except (GAPI.forbidden, GAPI.permissionDenied) as e:
    studentUnknownWarning(studentId, str(e), i, count)
    return -1

# gam cancel guardianinvitation|guardianinvitations <GuardianInvitationID> <StudentItem>
def doCancelGuardianInvitation():
  croom = buildGAPIObject(API.CLASSROOM)
  invitationId = getString(Cmd.OB_GUARDIAN_INVITATION_ID)
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM))
  checkForExtraneousArguments()
  _cancelGuardianInvitation(croom, studentId, invitationId)

# gam <UserTypeEntity> cancel guardianinvitation|guardianinvitations <GuardianInvitationIDEntity>
def cancelGuardianInvitations(users):
  croom = buildGAPIObject(API.CLASSROOM)
  invitationEntity, invitationEntityList = getGuardianInvitationEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    studentId, invitationIds, jcount = getGuardianInvitationIds(user, invitationEntity, invitationEntityList)
    entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, Ent.GUARDIAN_INVITATION, i, count)
    Ind.Increment()
    j = 0
    for invitationId in invitationIds:
      j += 1
      if _cancelGuardianInvitation(croom, studentId, invitationId, i, count, j, jcount) == -1:
        break
    Ind.Decrement()

def _deleteGuardian(croom, studentId, guardianId, guardianEmail, i, count, j, jcount):
  try:
    callGAPI(croom.userProfiles().guardians(), 'delete',
             throwReasons=[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
             studentId=studentId, guardianId=guardianId)
    entityActionPerformed([Ent.STUDENT, studentId, Ent.GUARDIAN, guardianEmail], j, jcount)
    return 1
  except GAPI.notFound:
    if guardianId == guardianEmail:
      entityActionFailedWarning([Ent.STUDENT, studentId, Ent.GUARDIAN, guardianEmail], Msg.NOT_FOUND, j, jcount)
    return 0
  except (GAPI.forbidden, GAPI.permissionDenied) as e:
    studentUnknownWarning(studentId, str(e), i, count)
    return -1

def _doDeleteGuardian(croom, studentId, guardianId, guardianClass, i=0, count=0, j=0, jcount=0):
  guardianIdIsEmail = guardianId.find('@') != -1
  guardianFound = False
  try:
    if guardianClass != GUARDIAN_CLASS_ACCEPTED:
      Act.Set(Act.CANCEL)
      if guardianIdIsEmail:
        invitations = callGAPIpages(croom.userProfiles().guardianInvitations(), 'list', 'guardianInvitations',
                                    throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                    studentId=studentId, invitedEmailAddress=guardianId, states=['PENDING'],
                                    fields='nextPageToken,guardianInvitations(studentId,invitationId)')
        for invitation in invitations:
          result = _cancelGuardianInvitation(croom, invitation['studentId'], invitation['invitationId'], i, count, j, jcount)
          if result < 0:
            return result
          if result > 0:
            guardianFound = True
      else:
        result = _cancelGuardianInvitation(croom, studentId, guardianId, i, count, j, jcount)
        if result != 0:
          return result
    if guardianClass != GUARDIAN_CLASS_INVITATIONS:
      Act.Set(Act.DELETE)
      if guardianIdIsEmail:
        guardians = callGAPIpages(croom.userProfiles().guardians(), 'list', 'guardians',
                                  throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                  studentId=studentId, invitedEmailAddress=guardianId,
                                  fields='nextPageToken,guardians(studentId,guardianId)')
        for guardian in guardians:
          result = _deleteGuardian(croom, guardian['studentId'], guardian['guardianId'], guardianId, i, count, j, jcount)
          if result < 0:
            return result
          if result > 0:
            guardianFound = True
      else:
        result = _deleteGuardian(croom, studentId, guardianId, guardianId, i, count, j, jcount)
        if result != 0:
          return result
  except GAPI.notFound:
    entityUnknownWarning(Ent.STUDENT, studentId, i, count)
    return -1
  except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
    studentUnknownWarning(studentId, str(e), i, count)
    return -1
  if not guardianFound:
    Act.Set(Act.DELETE)
    entityActionFailedWarning([Ent.STUDENT, studentId, GUARDIAN_CLASS_ENTITY[guardianClass], guardianId], Msg.NOT_FOUND)
    return 0
  return 1

# gam delete guardian|guardians <GuardianItem> <StudentItem> [accepted|invitations|all]
def doDeleteGuardian():
  croom = buildGAPIObject(API.CLASSROOM)
  guardianId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_GUARDIAN_ITEM))
  studentId = normalizeStudentGuardianEmailAddressOrUID(getString(Cmd.OB_STUDENT_ITEM), allowDash=True)
  guardianClass = getChoice(GUARDIAN_CLASS_MAP, mapChoice=True, defaultChoice=GUARDIAN_CLASS_ALL)
  checkForExtraneousArguments()
  _doDeleteGuardian(croom, studentId, guardianId, guardianClass)

# gam <UserTypeEntity> delete guardian|guardians <GuardianEntity> [accepted|invitations|all]
def deleteGuardians(users):
  croom = buildGAPIObject(API.CLASSROOM)
  guardianEntity, guardianEntityList = getGuardianEntity()
  guardianClass = getChoice(GUARDIAN_CLASS_MAP, mapChoice=True, defaultChoice=GUARDIAN_CLASS_ALL)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    studentId, guardianEmails, jcount = getGuardianEmails(user, guardianEntity, guardianEntityList)
    entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, GUARDIAN_CLASS_ENTITY[guardianClass], i, count)
    Ind.Increment()
    j = 0
    for guardianEmail in guardianEmails:
      j += 1
      if _doDeleteGuardian(croom, studentId, guardianEmail, guardianClass, i, count, j, jcount) < 0:
        break
    Ind.Decrement()

# gam <UserTypeEntity> clear guardian|guardians [accepted|invitations|all]
def clearGuardians(users):
  croom = buildGAPIObject(API.CLASSROOM)
  guardianClass = getChoice(GUARDIAN_CLASS_MAP, mapChoice=True, defaultChoice=GUARDIAN_CLASS_ALL)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    studentId = normalizeStudentGuardianEmailAddressOrUID(user)
    try:
      if guardianClass != GUARDIAN_CLASS_ACCEPTED:
        invitations = callGAPIpages(croom.userProfiles().guardianInvitations(), 'list', 'guardianInvitations',
                                    throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                    studentId=studentId, states=['PENDING'], fields='nextPageToken,guardianInvitations(invitationId)')
        Act.Set(Act.CANCEL)
        jcount = len(invitations)
        entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, Ent.GUARDIAN_INVITATION, i, count)
        Ind.Increment()
        j = 0
        for invitation in invitations:
          j += 1
          _cancelGuardianInvitation(croom, studentId, invitation['invitationId'], i, count, j, jcount)
        Ind.Decrement()
      if guardianClass != GUARDIAN_CLASS_INVITATIONS:
        guardians = callGAPIpages(croom.userProfiles().guardians(), 'list', 'guardians',
                                  throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                  studentId=studentId, fields='nextPageToken,guardians(guardianId,invitedEmailAddress)')
        Act.Set(Act.DELETE)
        jcount = len(guardians)
        entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, Ent.GUARDIAN, i, count)
        Ind.Increment()
        j = 0
        for guardian in guardians:
          j += 1
          _deleteGuardian(croom, studentId, guardian['guardianId'], guardian['invitedEmailAddress'], i, count, j, jcount)
        Ind.Decrement()
    except GAPI.notFound:
      entityUnknownWarning(Ent.STUDENT, studentId, i, count)
    except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
      studentUnknownWarning(studentId, str(e), i, count)

# gam <UserTypeEntity> sync guardian|guardians <GuardianEntity>
def syncGuardians(users):
  croom = buildGAPIObject(API.CLASSROOM)
  guardianEntity, guardianEntityList = getGuardianEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    Act.Set(Act.SYNC)
    studentId, guardianEmails, jcount = getGuardianEmails(user, guardianEntity, guardianEntityList)
    entityPerformActionNumItems([Ent.STUDENT, studentId], jcount, Ent.GUARDIAN, i, count)
    try:
      invitations = callGAPIpages(croom.userProfiles().guardianInvitations(), 'list', 'guardianInvitations',
                                  throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                  studentId=studentId, states=['PENDING'], fields='nextPageToken,guardianInvitations(invitationId,invitedEmailAddress)')
      guardians = callGAPIpages(croom.userProfiles().guardians(), 'list', 'guardians',
                                throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                studentId=studentId, fields='nextPageToken,guardians(guardianId,invitedEmailAddress)')
    except GAPI.notFound:
      entityUnknownWarning(Ent.STUDENT, studentId, i, count)
      continue
    except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
      studentUnknownWarning(studentId, str(e), i, count)
      continue
    Ind.Increment()
    Act.Set(Act.CANCEL)
    jcount = len(invitations)
    j = 0
    for invitation in invitations:
      j += 1
      if invitation['invitedEmailAddress'] not in guardianEmails:
        _cancelGuardianInvitation(croom, studentId, invitation['invitationId'], i, count, j, jcount)
    Act.Set(Act.DELETE)
    jcount = len(guardians)
    j = 0
    for guardian in guardians:
      j += 1
      if guardian['invitedEmailAddress'] not in guardianEmails:
        _deleteGuardian(croom, studentId, guardian['guardianId'], guardian['invitedEmailAddress'], i, count, j, jcount)
    Act.Set(Act.CREATE)
    for guardianEmail in guardianEmails:
      for guardian in guardians:
        if guardianEmail == guardian['invitedEmailAddress']:
          break
      else:
        for invitation in invitations:
          if guardianEmail == invitation['invitedEmailAddress']:
            break
        else:
          _inviteGuardian(croom, studentId, guardianEmail, i, count)
    Ind.Decrement()

def _getCourseName(croom, courseNames, courseId):
  courseName = courseNames.get(courseId)
  if courseName is None:
    try:
      courseName = callGAPI(croom.courses(), 'get',
                            throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                            id=courseId, fields='name')['name']
    except (GAPI.notFound, GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied):
      pass
    if courseName is None:
      courseName = courseId
    courseNames[courseId] = courseName
  return courseName

def _getClassroomEmail(croom, classroomEmails, userId, user):
  if user.find('@') != -1:
    return user
  userEmail = classroomEmails.get(userId)
  if userEmail is None:
    try:
      userEmail = callGAPI(croom.userProfiles(), 'get',
                           throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                           userId=userId, fields='emailAddress').get('emailAddress')
    except (GAPI.notFound, GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied):
      pass
    if userEmail is None:
      userEmail = userId
    classroomEmails[userId] = userEmail
  return userEmail

GUARDIAN_TIME_OBJECTS = {'creationTime'}
GUARDIAN_STATES = ['complete', 'pending']

def _printShowGuardians(entityList=None):
  croom = buildGAPIObject(API.CLASSROOM)
  if entityList is None:
    studentIds = ['-']
    allStudents = True
  else:
    studentIds = entityList
    allStudents = False
  showStudentEmails = False
  classroomEmails = {}
  invitedEmailAddress = None
  states = []
  guardianClass = GUARDIAN_CLASS_ACCEPTED
  csvPF = CSVPrintFile() if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'invitedguardian':
      invitedEmailAddress = getEmailAddress()
    elif myarg in {'invitation', 'invitations'}:
      guardianClass = GUARDIAN_CLASS_INVITATIONS
      if not states:
        states = [state.upper() for state in GUARDIAN_STATES]
    elif myarg == 'accepted':
      guardianClass = GUARDIAN_CLASS_ACCEPTED
    elif myarg == 'all':
      guardianClass = GUARDIAN_CLASS_ALL
    elif myarg in {'state', 'states', 'status'}:
      statesList = getString(Cmd.OB_GUARDIAN_STATE_LIST).lower().split(',')
      states = []
      for state in statesList:
        if state in GUARDIAN_STATES:
          states.append(state.upper())
        else:
          invalidChoiceExit(state, GUARDIAN_STATES, True)
    elif myarg == 'showstudentemails':
      showStudentEmails = True
    elif entityList is None and myarg == 'student':
      studentIds = [getString(Cmd.OB_STUDENT_ITEM)]
      allStudents = studentIds[0] == '-'
    elif FJQC.GetFormatJSONQuoteChar(myarg, False, True):
      pass
    elif entityList is None:
      Cmd.Backup()
      _, studentIds = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
      allStudents = False
    else:
      unknownArgumentExit()
  if csvPF:
    if not FJQC.formatJSON:
      sortTitles = ['studentEmail', 'studentId', 'invitedEmailAddress']
      if guardianClass != GUARDIAN_CLASS_ACCEPTED:
        sortTitles.extend(['invitationId', 'creationTime', 'state'])
      if guardianClass != GUARDIAN_CLASS_INVITATIONS:
        sortTitles.append('guardianId')
      csvPF.SetTitles(sortTitles)
      csvPF.SetSortAllTitles()
    else:
      csvPF.SetJSONTitles(['studentEmail', 'studentId', 'JSON'])
  i, count, studentIds = getEntityArgument(studentIds)
  for studentId in studentIds:
    i += 1
    if not allStudents:
      studentId = normalizeStudentGuardianEmailAddressOrUID(studentId)
      if showStudentEmails:
        studentId = _getClassroomEmail(croom, classroomEmails, studentId, studentId)
      if csvPF:
        printGettingAllEntityItemsForWhom(GUARDIAN_CLASS_ENTITY[guardianClass], studentId, i, count)
    try:
      if guardianClass != GUARDIAN_CLASS_ACCEPTED:
        invitations = callGAPIpages(croom.userProfiles().guardianInvitations(), 'list', 'guardianInvitations',
                                    throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                    studentId=studentId, invitedEmailAddress=invitedEmailAddress, states=states)
        jcount = len(invitations)
        if not csvPF:
          if not FJQC.formatJSON:
            entityPerformActionNumItems([Ent.STUDENT, studentId if not allStudents else 'All'], jcount, Ent.GUARDIAN_INVITATION, i, count)
            Ind.Increment()
            j = 0
            for invitation in invitations:
              j += 1
              printKeyValueListWithCount(['invitedEmailAddress', invitation['invitedEmailAddress']], j, jcount)
              Ind.Increment()
              if showStudentEmails:
                invitation['studentEmail'] = _getClassroomEmail(croom, classroomEmails, invitation['studentId'], studentId)
              showJSON(None, invitation, ['invitedEmailAddress'], GUARDIAN_TIME_OBJECTS)
              Ind.Decrement()
            Ind.Decrement()
          else:
            printLine(json.dumps(cleanJSON(invitations, timeObjects=GUARDIAN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
        else:
          if not FJQC.formatJSON:
            for invitation in invitations:
              if showStudentEmails:
                invitation['studentEmail'] = _getClassroomEmail(croom, classroomEmails, invitation['studentId'], studentId)
              else:
                invitation['studentEmail'] = studentId
              csvPF.WriteRowTitles(flattenJSON(invitation, timeObjects=GUARDIAN_TIME_OBJECTS))
          else:
            csvPF.WriteRow({'studentId': studentId, 'studentEmail': _getClassroomEmail(croom, classroomEmails, studentId, studentId),
                            'JSON': json.dumps(cleanJSON(invitations, timeObjects=GUARDIAN_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)})
      if guardianClass != GUARDIAN_CLASS_INVITATIONS:
        guardians = callGAPIpages(croom.userProfiles().guardians(), 'list', 'guardians',
                                  throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                  studentId=studentId, invitedEmailAddress=invitedEmailAddress)
        jcount = len(guardians)
        if not csvPF:
          if not FJQC.formatJSON:
            entityPerformActionNumItems([Ent.STUDENT, studentId if not allStudents else 'All'], jcount, Ent.GUARDIAN, i, count)
            Ind.Increment()
            j = 0
            for guardian in guardians:
              j += 1
              printKeyValueListWithCount(['invitedEmailAddress', guardian['invitedEmailAddress']], j, jcount)
              Ind.Increment()
              if showStudentEmails:
                guardian['studentEmail'] = _getClassroomEmail(croom, classroomEmails, guardian['studentId'], studentId)
              showJSON(None, guardian, ['invitedEmailAddress'])
              Ind.Decrement()
            Ind.Decrement()
          else:
            printLine(json.dumps(cleanJSON(guardians), ensure_ascii=False, sort_keys=True))
        else:
          if not FJQC.formatJSON:
            for guardian in guardians:
              if showStudentEmails:
                guardian['studentEmail'] = _getClassroomEmail(croom, classroomEmails, guardian['studentId'], studentId)
              else:
                guardian['studentEmail'] = studentId
              csvPF.WriteRowTitles(flattenJSON(guardian))
          else:
            csvPF.WriteRowNoFilter({'studentId': studentId, 'studentEmail': _getClassroomEmail(croom, classroomEmails, studentId, studentId),
                                    'JSON': json.dumps(cleanJSON(guardians), ensure_ascii=False, sort_keys=True)})
    except GAPI.notFound:
      entityUnknownWarning(Ent.STUDENT, studentId, i, count)
    except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
      studentUnknownWarning(studentId, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('Guardians')

# gam show guardian|guardians [accepted|invitations|all] [states <GuardianInvitationStateList>] [invitedguardian <EmailAddress>]
#	[student <StudentItem>] [<UserTypeEntity>]
#	[showstudentemails] [formatjson]
# gam print guardian|guardians [todrive <ToDriveAttribute>*] [accepted|invitations|all] [states <GuardianInvitationStateList>] [invitedguardian <EmailAddress>]
#	[student <StudentItem>] [<UserTypeEntity>]
#	[showstudentemails] [formatjson [quotechar <Character>]]
def doPrintShowGuardians():
  _printShowGuardians()

# gam <UserTypeEntity> show guardian|guardians [accepted|invitations|all] [states <GuardianInvitationStateList>] [invitedguardian <EmailAddress>]
#	[showstudentemails] [formatjson]
# gam <UserTypeEntity> print guardian|guardians [todrive <ToDriveAttribute>*] [accepted|invitations|all] [states <GuardianInvitationStateList>] [invitedguardian <EmailAddress>]
#	[showstudentemails] [formatjson [quotechar <Character>]]
def printShowGuardians(users):
  _printShowGuardians(users)

CLASSROOM_ROLE_ALL = 'ALL'
CLASSROOM_ROLE_OWNER = 'OWNER'
CLASSROOM_ROLE_STUDENT = 'STUDENT'
CLASSROOM_ROLE_TEACHER = 'TEACHER'

def _getClassroomInvitations(croom, userId, courseId, role, i, count, j=0, jcount=0):
  try:
    invitations = callGAPIpages(croom.invitations(), 'list', 'invitations',
                                throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.BAD_REQUEST, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                                userId=userId, courseId=courseId)
  except GAPI.notFound:
    if userId is not None:
      entityUnknownWarning(Ent.USER, userId, i, count)
      return (-1, None)
    entityUnknownWarning(Ent.COURSE, courseId, j, jcount)
    return (0, [])
  except (GAPI.invalidArgument, GAPI.badRequest, GAPI.forbidden, GAPI.permissionDenied) as e:
    if userId is not None:
      entityActionFailedWarning([Ent.USER, userId], str(e), i, count)
      return (-1, None)
    entityActionFailedWarning([Ent.COURSE, courseId], str(e), j, jcount)
    return (0, [])
  if role == CLASSROOM_ROLE_ALL:
    return (1, invitations)
  return (1, [invitation for invitation in invitations if invitation['role'] == role])

def _getClassroomInvitationIds(croom, userId, courseIds, role, i, count):
  invitationIds = []
  if courseIds is not None:
    jcount = len(courseIds)
    j = 0
    for courseId in courseIds:
      j += 1
      courseId = addCourseIdScope(courseId)
      status, invitations = _getClassroomInvitations(croom, userId, courseId, role, i, count, j, jcount)
      if status < 0:
        return (status, None)
      if status > 0:
        invitationIds.extend([invitation['id'] for invitation in invitations])
  else:
    status, invitations = _getClassroomInvitations(croom, userId, None, role, i, count)
    if status < 0:
      return (status, None)
    if status > 0:
      invitationIds.extend([invitation['id'] for invitation in invitations])
  return (1, invitationIds)

CLASSROOM_CREATE_ROLE_MAP = {
  'owner': CLASSROOM_ROLE_OWNER,
  'student': CLASSROOM_ROLE_STUDENT,
  'teacher': CLASSROOM_ROLE_TEACHER,
  }

CLASSROOM_ROLE_MAP = {
  'all': CLASSROOM_ROLE_ALL,
  'owner': CLASSROOM_ROLE_OWNER,
  'student': CLASSROOM_ROLE_STUDENT,
  'teacher': CLASSROOM_ROLE_TEACHER,
  }

CLASSROOM_ROLE_ENTITY_MAP = {
  CLASSROOM_ROLE_ALL: Ent.CLASSROOM_INVITATION,
  CLASSROOM_ROLE_OWNER: Ent.CLASSROOM_INVITATION_OWNER,
  CLASSROOM_ROLE_STUDENT: Ent.CLASSROOM_INVITATION_STUDENT,
  CLASSROOM_ROLE_TEACHER: Ent.CLASSROOM_INVITATION_TEACHER,
  }

# gam <UserTypeEntity> create classroominvitation courses <CourseEntity> [role owner|student|teacher]
#	[adminaccess|asadmin] [csvformat] [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
def createClassroomInvitations(users):
  croom = buildGAPIObject(API.CLASSROOM)
  classroomEmails = {}
  courseIds = None
  coursesInfo = {}
  role = CLASSROOM_ROLE_STUDENT
  useAdminAccess = False
  csvPF = None
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'course', 'courses', 'class', 'classes'}:
      courseIds = getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True)
    elif myarg == 'role':
      role = getChoice(CLASSROOM_CREATE_ROLE_MAP, mapChoice=True)
    elif myarg == 'csvformat':
      csvPF = CSVPrintFile()
      FJQC.SetCsvPF(csvPF)
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useAdminAccess = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if courseIds is None:
    missingArgumentExit('courses <CourseEntity>')
  if csvPF:
    if FJQC.formatJSON:
      csvPF.SetTitles(['userEmail', 'JSON'])
    else:
      csvPF.SetTitles(['userId', 'userEmail', 'courseId', 'courseName', 'id', 'role'])
    csvPF.SetSortAllTitles()
  courseIdsLists = courseIds if isinstance(courseIds, dict) else None
  if courseIdsLists is None:
    _getCoursesOwnerInfo(croom, courseIds, coursesInfo, useAdminAccess)
  entityType = CLASSROOM_ROLE_ENTITY_MAP[role]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    userId = normalizeEmailAddressOrUID(user)
    userEmail = _getClassroomEmail(croom, classroomEmails, userId, userId)
    if courseIdsLists:
      courseIds = courseIdsLists[user]
      _getCoursesOwnerInfo(croom, courseIds, coursesInfo, useAdminAccess)
    jcount = len(courseIds)
    if csvPF or not FJQC.formatJSON:
      entityPerformActionNumItems([Ent.USER, userId], jcount, entityType, i, count)
    if jcount == 0:
      continue
    j = 0
    for courseId in courseIds:
      j += 1
      courseId = addCourseIdScope(courseId)
      courseInfo = coursesInfo[courseId]
      if not courseInfo:
        continue
      courseNameId = f'{courseInfo["name"]} ({courseId})'
      try:
        invitation = callGAPI(courseInfo['croom'].invitations(), 'create',
                              throwReasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.ALREADY_EXISTS, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                              body={'userId': userId, 'courseId': courseId, 'role': role})
        if not csvPF:
          if not FJQC.formatJSON:
            Ind.Increment()
            entityActionPerformed([Ent.USER, userEmail, Ent.COURSE, courseNameId, entityType, invitation['id']], j, jcount)
            Ind.Decrement()
          else:
            printLine(json.dumps(cleanJSON(invitation), ensure_ascii=False, sort_keys=True))
        else:
          if not FJQC.formatJSON:
            invitation['courseName'] = courseInfo['name']
            invitation['userEmail'] = userEmail
            csvPF.WriteRow(invitation)
          else:
            csvPF.WriteRowNoFilter({'userEmail': userEmail,
                                    'JSON': json.dumps(cleanJSON(invitation), ensure_ascii=False, sort_keys=True)})
      except GAPI.permissionDenied:
        entityUnknownWarning(Ent.USER, userId, i, count)
        break
      except GAPI.notFound:
        entityUnknownWarning(Ent.COURSE, courseNameId, j, jcount)
      except (GAPI.failedPrecondition, GAPI.alreadyExists, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.USER, userId, Ent.COURSE, courseNameId, entityType, None], str(e), j, jcount)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('ClassroomInvitations')

def acceptDeleteClassroomInvitations(users, function):
  croom = buildGAPIObject(API.CLASSROOM)
  if function == 'delete':
    ucroom = croom
  courseIds = invitationIds = None
  role = CLASSROOM_ROLE_ALL
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'id', 'ids'}:
      invitationIds = getEntityList(Cmd.OB_CLASSROOM_INVITATION_ID_ENTITY)
      courseIds = None
    elif myarg in {'course', 'courses', 'class', 'classes'}:
      courseIds = getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True)
      invitationIds = None
    elif myarg == 'role':
      role = getChoice(CLASSROOM_ROLE_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  courseIdsLists = courseIds if isinstance(courseIds, dict) else None
  invitationIdsLists = invitationIds if isinstance(invitationIds, dict) else None
  entityType = CLASSROOM_ROLE_ENTITY_MAP[role]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if function == 'delete':
      userId = normalizeEmailAddressOrUID(user)
    else:
      userId, ucroom = buildGAPIServiceObject(API.CLASSROOM, user, i, count)
      if not ucroom:
        continue
    if invitationIdsLists:
      userInvitationIds = invitationIdsLists[user]
    elif invitationIds is not None:
      userInvitationIds = invitationIds
    else:
      if courseIdsLists:
        courseIds = courseIdsLists[user]
      status, userInvitationIds = _getClassroomInvitationIds(croom, userId, courseIds, role, i, count)
      if status < 0:
        continue
    jcount = len(userInvitationIds)
    entityPerformActionNumItems([Ent.USER, userId], jcount, entityType, i, count)
    Ind.Increment()
    j = 0
    for invitationId in userInvitationIds:
      j += 1
      try:
        callGAPI(ucroom.invitations(), function,
                 throwReasons=[GAPI.NOT_FOUND, GAPI.FAILED_PRECONDITION, GAPI.FORBIDDEN, GAPI.PERMISSION_DENIED],
                 id=invitationId)
        entityActionPerformed([Ent.USER, userId, entityType, invitationId], j, jcount)
      except (GAPI.notFound, GAPI.failedPrecondition, GAPI.forbidden, GAPI.permissionDenied) as e:
        entityActionFailedWarning([Ent.USER, userId, entityType, invitationId], str(e), j, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> accept classroominvitation (ids <ClassroomInvitationIDEntity>)|([courses <CourseEntity>] [role all|owner|student|teacher])
def acceptClassroomInvitations(users):
  acceptDeleteClassroomInvitations(users, 'accept')

# gam <UserTypeEntity> delete classroominvitation (ids <ClassroomInvitationIDEntity>)|([courses <CourseEntity>] [role all|owner|student|teacher])
def deleteClassroomInvitations(users):
  acceptDeleteClassroomInvitations(users, 'delete')

# gam <UserTypeEntity> show classroominvitations [role all|owner|student|teacher]
#	[formatjson]
# gam <UserTypeEntity> print classroominvitations [todrive <ToDriveAttribute>*] [role all|owner|student|teacher]
#	[formatjson [quotechar <Character>]]
def printShowClassroomInvitations(users):
  croom = buildGAPIObject(API.CLASSROOM)
  classroomEmails = {}
  courseNames = {}
  role = CLASSROOM_ROLE_ALL
  csvPF = CSVPrintFile() if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'role':
      role = getChoice(CLASSROOM_ROLE_MAP, mapChoice=True)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, False)
  if csvPF:
    if FJQC.formatJSON:
      csvPF.SetJSONTitles(['userEmail', 'JSON'])
    else:
      csvPF.SetTitles(['userId', 'userEmail', 'courseId', 'courseName', 'id', 'role'])
      csvPF.SetSortAllTitles()
  entityType = CLASSROOM_ROLE_ENTITY_MAP[role]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    userId = normalizeEmailAddressOrUID(user)
    userEmail = _getClassroomEmail(croom, classroomEmails, userId, userId)
    if csvPF:
      printGettingAllEntityItemsForWhom(entityType, userId, i, count)
    status, invitations = _getClassroomInvitations(croom, userId, None, role, i, count)
    if status > 0:
      jcount = len(invitations)
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, userId], jcount, entityType, i, count)
      if not csvPF:
        if not FJQC.formatJSON:
          Ind.Increment()
          j = 0
          for invitation in invitations:
            j += 1
            courseId = invitation['courseId']
            courseName = _getCourseName(croom, courseNames, courseId)
            printKeyValueListWithCount([Ent.Singular(Ent.COURSE), f'{courseName} ({courseId})'], j, jcount)
            Ind.Increment()
            printKeyValueList(['id', invitation['id']])
            printKeyValueList(['role', invitation['role']])
            printKeyValueList(['userid', invitation['userId']])
            printKeyValueList(['userEmail', userEmail])
            Ind.Decrement()
          Ind.Decrement()
        else:
          printLine(json.dumps(cleanJSON(invitations), ensure_ascii=False, sort_keys=True))
      else:
        if not FJQC.formatJSON:
          for invitation in invitations:
            invitation['courseName'] = _getCourseName(croom, courseNames, invitation['courseId'])
            invitation['userEmail'] = userEmail
            csvPF.WriteRow(invitation)
        else:
          csvPF.WriteRowNoFilter({'userEmail': userEmail,
                                  'JSON': json.dumps(cleanJSON(invitations), ensure_ascii=False, sort_keys=True)})
  if csvPF:
    csvPF.writeCSVfile('ClassroomInvitations')

# gam show classroominvitations (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[role all|owner|student|teacher] [formatjson]
# gam print classroominvitations [todrive <ToDriveAttribute>*] (course|class <CourseEntity>)*|([teacher <UserItem>] [student <UserItem>] [states <CourseStateList>])
#	[role all|owner|student|teacher] [formatjson [quotechar <Character>]]
def doPrintShowClassroomInvitations():
  croom = buildGAPIObject(API.CLASSROOM)
  classroomEmails = {}
  courseSelectionParameters = _initCourseSelectionParameters()
  courseShowProperties = _initCourseShowProperties(['id', 'name'])
  role = CLASSROOM_ROLE_ALL
  csvPF = CSVPrintFile(['courseId', 'courseName']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getCourseSelectionParameters(myarg, courseSelectionParameters):
      pass
    elif myarg == 'role':
      role = getChoice(CLASSROOM_ROLE_MAP, mapChoice=True)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  coursesInfo = _getCoursesInfo(croom, courseSelectionParameters, courseShowProperties)
  if coursesInfo is None:
    return
  if csvPF and not FJQC.formatJSON:
    csvPF.AddTitles(['id', 'role', 'userId', 'userEmail'])
    csvPF.SetSortAllTitles()
  entityType = CLASSROOM_ROLE_ENTITY_MAP[role]
  i = 0
  count = len(coursesInfo)
  for course in coursesInfo:
    i += 1
    courseId = course['id']
    courseName = course['name']
    status, invitations = _getClassroomInvitations(croom, None, courseId, role, i, count)
    if status > 0:
      jcount = len(invitations)
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.COURSE, f'{courseName} ({courseId})'], jcount, entityType, i, count)
      if not csvPF:
        if not FJQC.formatJSON:
          Ind.Increment()
          j = 0
          for invitation in invitations:
            j += 1
            printKeyValueListWithCount(['id', invitation['id']], j, jcount)
            Ind.Increment()
            printKeyValueList(['role', invitation['role']])
            userId = invitation.get('userId')
            if userId is not None:
              printKeyValueList(['userid', userId])
              printKeyValueList(['userEmail', _getClassroomEmail(croom, classroomEmails, userId, userId)])
            Ind.Decrement()
          Ind.Decrement()
        else:
          printLine(json.dumps(cleanJSON(invitations), ensure_ascii=False, sort_keys=True))
      else:
        if not FJQC.formatJSON:
          for invitation in invitations:
            invitation['courseName'] = courseName
            userId = invitation.get('userId')
            if userId is not None:
              invitation['userEmail'] = _getClassroomEmail(croom, classroomEmails, userId, userId)
            csvPF.WriteRowNoFilter(invitation)
        else:
          csvPF.WriteRowNoFilter({'courseId': courseId, 'courseName': courseName,
                                  'JSON': json.dumps(cleanJSON(invitations), ensure_ascii=False, sort_keys=True)})
  if csvPF:
    csvPF.writeCSVfile('ClassroomInvitations')

# gam <UserTypeEntity> print classroomprofile [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show classroomprofile
def printShowClassroomProfile(users):
  croom = buildGAPIObject(API.CLASSROOM)
  csvPF = CSVPrintFile(['emailAddress', 'id', 'name.givenName', 'name.familyName', 'name.fullName', 'photoUrl'], indexedTitles=['permissions']) if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    userId = normalizeEmailAddressOrUID(user)
    if csvPF:
      printGettingEntityItemForWhom(Ent.CLASSROOM_USER_PROFILE, user, i, count)
    try:
      result = callGAPI(croom.userProfiles(), 'get',
                        throwReasons=[GAPI.NOT_FOUND, GAPI.PERMISSION_DENIED, GAPI.BAD_REQUEST, GAPI.FORBIDDEN],
                        userId=userId, fields='*')
      result.setdefault('verifiedTeacher', False)
      if not csvPF:
        printEntity([Ent.USER, userId], i, count)
        Ind.Increment()
        printKeyValueList(['email', result['emailAddress']])
        printKeyValueList([UProp.PROPERTIES['id'][UProp.TITLE], result['id']])
        for up in USER_NAME_PROPERTY_PRINT_ORDER:
          if up in result['name']:
            printKeyValueList([UProp.PROPERTIES[up][UProp.TITLE], result['name'][up]])
        printKeyValueList([UProp.PROPERTIES['thumbnailPhotoUrl'][UProp.TITLE], result['photoUrl']])
        printKeyValueList(['Permissions', ','.join([permission['permission'] for permission in result.get('permissions', [])])])
        printKeyValueList(['Verified Teacher', result['verifiedTeacher']])
        Ind.Decrement()
      else:
        csvPF.WriteRowTitles(flattenJSON(result))
    except (GAPI.notFound, GAPI.permissionDenied, GAPI.badRequest, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, userId], str(e))
  if csvPF:
    csvPF.writeCSVfile('Classroom User Profiles')

def encode_multipart(fields, filepath, encoding):
  def escape_quote(s):
    return s.replace('"', '\\"')

  def getFormDataLine(name, value, boundary):
    return f'--{boundary}', f'Content-Disposition: form-data; name="{escape_quote(name)}"', '', str(value)

  boundary = ''.join(random.choice(ALPHANUMERIC_CHARS) for _ in range(30))
  lines = []
  for name, value in iter(fields.items()):
    if name == 'tags':
      for tag in value:
        lines.extend(getFormDataLine('tag', tag, boundary))
    else:
      lines.extend(getFormDataLine(name, value, boundary))
  if filepath:
    filename = os.path.basename(filepath)
    mimetype = mimetypes.guess_type(filepath)[0]
    if mimetype is None:
      mimetype = 'application/octet-stream'
    lines.extend((
      f'--{boundary}',
      f'Content-Disposition: form-data; name="content"; filename="{escape_quote(filename)}"',
      f'Content-Type: {mimetype}',
      '',
      '',
      ))
    body = '\r\n'.join(lines)+readFile(filepath, mode='r', encoding=encoding)+f'\r\n--{boundary}--\r\n'
  else:
    body = '\r\n'.join(lines)+f'\r\n--{boundary}--\r\n'
  headers = {
    'Content-Type': f'multipart/form-data; boundary={boundary}',
    'Content-Length': str(len(body)),
  }
  return (body, headers)

# gam [<UserTypeEntity>] register printer
# gam [<UserTypeEntity>] printer register
def registerPrinter(users):
  checkForExtraneousArguments()
  cd = buildGAPIObject(API.DIRECTORY)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    try:
      userId = callGAPI(cd.users(), 'get',
                        throwReasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=user, fields='id')['id']
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, user, i, count)
      continue
    entityPerformActionNumItems([Ent.USER, user], 1, Ent.PRINTER, i, count)
    Ind.Increment()
    form_fields = {
      'name': GAM, 'proxy': GAM, 'uuid': userId, 'manufacturer': __author__, 'model': 'cp1', 'gcp_version': '2.0',
      'setup_url': GAM_URL, 'support_url': 'https://groups.google.com/forum/#!forum/google-apps-manager',
      'update_url': GAM_RELEASES,
      'firmware': __version__, 'semantic_state': {"version": "1.0", "printer": {"state": "IDLE"}}, 'use_cdd': True,
      'capabilities': {"version": "1.0",
                       "printer": {"supported_content_type": [{"content_type": "application/pdf", "min_version": "1.5"},
                                                              {"content_type": "image/jpeg"},
                                                              {"content_type": "text/plain"},
                                                              ],
                                   "copies": {"default": 1, "max": 100},
                                   "media_size": {"option": [{"name": "ISO_A4", "width_microns": 210000, "height_microns": 297000},
                                                             {"name": "NA_LEGAL", "width_microns": 215900, "height_microns": 355600},
                                                             {"name": "NA_LETTER", "width_microns": 215900, "height_microns": 279400, "is_default": True},
                                                             ],
                                                  },
                                   },
                       },
      'tags': [GAM, GAM_URL],
      }
    body, headers = encode_multipart(form_fields, None, None)
    resp, result = cp._http.request(uri='https://www.google.com/cloudprint/register', method='POST', body=body, headers=headers)
    if resp['status'] == '200':
      result = checkCloudPrintResult(result)
      entityActionPerformed([Ent.PRINTER, result['printers'][0]['id']])
    else:
      entityActionFailedWarning([Ent.PRINTER, None], getCloudPrintError(resp, result))
    Ind.Decrement()

def doRegisterPrinter():
  registerPrinter([None])

#
PRINTER_UPDATE_ITEMS_CHOICE_MAP = {
  'currentquota': 'currentQuota',
  'dailyquota': 'dailyQuota',
  'defaultdisplayname': 'defaultDisplayName',
  'description': 'description',
  'displayname': 'displayName',
  'firmware': 'firmware',
  'gcpversion': 'gcpVersion',
  'istosaccepted': 'isTosAccepted',
  'manufacturer': 'manufacturer',
  'model': 'model',
  'name': 'name',
  'ownerid': 'ownerId',
  'proxy': 'proxy',
  'public': 'public',
  'quotaenabled': 'quotaEnabled',
  'setupurl': 'setupUrl',
  'status': 'status',
  'supporturl': 'supportUrl',
  'type': 'type',
  'updateurl': 'updateUrl',
  'uuid': 'uuid',
  }

# gam [<UserTypeEntity>] update printer|printers <PrinterIDEntity> <PrinterAttribute>
def updatePrinters(users):
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  kwargs = {}
  while Cmd.ArgumentsRemaining():
    item = getChoice(PRINTER_UPDATE_ITEMS_CHOICE_MAP, mapChoice=True)
    if item in {'isTosAccepted', 'public', 'quotaEnabled'}:
      kwargs[item] = getBoolean()
    elif item in {'currentQuota', 'dailyQuota', 'status'}:
      kwargs[item] = getInteger(minVal=0)
    elif item in {'displayName', 'defaultDisplayName'}:
      kwargs[item] = getString(Cmd.OB_STRING, minLen=0)
    else:
      kwargs[item] = getString(Cmd.OB_STRING)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.PRINTER, i, count)
    Ind.Increment()
    for printerId in entityList:
      j += 1
      try:
        callGCP(cp.printers(), 'update',
                throw_messages=[GCP.UNKNOWN_PRINTER],
                printerid=printerId, **kwargs)
        entityActionPerformed([Ent.PRINTER, printerId], j, jcount)
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e), j, jcount)
    Ind.Decrement()

def doUpdatePrinters():
  updatePrinters([None])

# gam [<UserTypeEntity>] delete printer|printers <PrinterIDEntity>
def deletePrinters(users):
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.PRINTER, i, count)
    Ind.Increment()
    for printerId in entityList:
      j += 1
      try:
        callGCP(cp.printers(), 'delete',
                throw_messages=[GCP.UNKNOWN_PRINTER],
                printerid=printerId)
        entityActionPerformed([Ent.PRINTER, printerId], j, jcount)
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e), j, jcount)
    Ind.Decrement()

def doDeletePrinters():
  deletePrinters([None])

PRINTER_EXTRA_FIELDS_CHOICE_MAP = {
  'connectionstatus': 'connectionStatus',
  'semanticstate': 'semanticState',
  'uistate': 'uiState',
  'queuedjobscount': 'queuedJobsCount',
  }

def _getPrinterExtraFields():
  extra_fields = []
  for field in _getFieldsList():
    if field in PRINTER_EXTRA_FIELDS_CHOICE_MAP:
      addFieldToFieldsList(field, PRINTER_EXTRA_FIELDS_CHOICE_MAP, extra_fields)
    else:
      invalidChoiceExit(field, PRINTER_EXTRA_FIELDS_CHOICE_MAP, True)
  return ','.join(extra_fields)

def _showPrinter(printer, everything, i, count):
  printEntity([Ent.PRINTER, printer['id']], i, count)
  Ind.Increment()
  printer['createTime'] = formatLocalTimestamp(printer['createTime'])
  printer['accessTime'] = formatLocalTimestamp(printer['accessTime'])
  printer['updateTime'] = formatLocalTimestamp(printer['updateTime'])
  printer['tags'] = ' '.join(printer['tags'])
  if not everything:
    printer.pop('capabilities', None)
    printer.pop('access', None)
  showJSON(None, printer)
  Ind.Decrement()

# gam [<UserTypeEntity>] info printers <PrinterIDEntity> [everything [<Boolean>]] [extrafields <PrinterExtraFieldsList>]
def infoPrinters(users):
  entityList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  everything = False
  extra_fields = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'everything':
      everything = getBoolean()
    elif myarg == 'extrafields':
      extra_fields = _getPrinterExtraFields()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(entityList)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.PRINTER, i, count)
    Ind.Increment()
    for printerId in entityList:
      j += 1
      try:
        result = callGCP(cp.printers(), 'get',
                         throw_messages=[GCP.UNKNOWN_PRINTER],
                         printerid=printerId, extra_fields=extra_fields)
        _showPrinter(result['printers'][0], everything, j, jcount)
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e), j, jcount)
    Ind.Decrement()

def doInfoPrinters():
  infoPrinters([None])

PRINTER_SORT_TITLES = ['id', 'name', 'displayName', 'description', 'createTime', 'updateTime', 'accessTime']

# gam [<UserTypeEntity>] show printers
#	[(query <QueryPrinter>)|(queries <QueryPrinterList>)] [type <String>] [status <String>]
#	[include_save_to_google_docs [<Boolean>]]
#	[extrafields <PrinterExtraFieldsList>]
# gam [<UserTypeEntity>] print printers [todrive <ToDriveAttribute>*]
#	[(query <QueryPrinter>)|(queries <QueryPrinterList>)] [type <String>] [status <String>]
#	[include_save_to_google_docs [<Boolean>]]
#	[extrafields <PrinterExtraFieldsList>] [delimiter <Character>]
def printShowPrinters(users):
  csvPF = CSVPrintFile(['id'], PRINTER_SORT_TITLES) if Act.csvFormat() else None
  queries = [None]
  printer_type = None
  connection_status = None
  extra_fields = None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  includeSaveToGoogleDocs = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'query', 'queries'}:
      queries = getQueries(myarg)
    elif myarg == 'type':
      printer_type = getString(Cmd.OB_STRING)
    elif myarg == 'status':
      connection_status = getString(Cmd.OB_STRING)
    elif myarg == 'extrafields':
      extra_fields = _getPrinterExtraFields()
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'includesavetogoogledocs':
      includeSaveToGoogleDocs = getBoolean()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    if csvPF:
      printGettingEntityItemForWhom(Ent.PRINTER, user, i, count)
    for query in queries:
      printers = callGCP(cp.printers(), 'list',
                         q=query, type=printer_type, connection_status=connection_status, extra_fields=extra_fields)
      j = 0
      jcount = len(printers['printers'])
      for printer in printers['printers']:
        j += 1
        if includeSaveToGoogleDocs or printer['id'] != '__google__docs':
          if not csvPF:
            _showPrinter(printer, False, j, jcount)
          else:
            printer['createTime'] = formatLocalTimestamp(printer['createTime'])
            printer['accessTime'] = formatLocalTimestamp(printer['accessTime'])
            printer['updateTime'] = formatLocalTimestamp(printer['updateTime'])
            printer['tags'] = delimiter.join(printer['tags'])
            csvPF.WriteRowTitles(flattenJSON(printer))
  if csvPF:
    csvPF.writeCSVfile('Printers')

def doPrintShowPrinters():
  printShowPrinters([None])

def normalizePrinterScopeList(rawScopeList):
  scopeList = []
  for scope in rawScopeList:
    scope = scope.lower()
    if scope != 'public':
      if scope == 'domain':
        scope = f'/hd/domain/{GC.Values[GC.DOMAIN]}'
      elif scope.startswith('domain:'):
        scope = f'/hd/domain/{scope[7:]}'
      elif scope.startswith('user:'):
        scope = normalizeEmailAddressOrUID(scope[5:], noUid=True)
      elif scope.startswith('group:'):
        scope = normalizeEmailAddressOrUID(scope[6:], noUid=True)
      else:
        scope = normalizeEmailAddressOrUID(scope, noUid=True)
    scopeList.append(scope)
  return scopeList

def getPrinterACLScopeEntity():
  groupMemberType = getChoice({'usersonly': Ent.TYPE_USER, 'groupsonly': Ent.TYPE_GROUP}, defaultChoice='ALL', mapChoice=True)
  _, scopeList = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS, groupMemberType=groupMemberType)
  printerScopeLists = scopeList if isinstance(scopeList, dict) else None
  if printerScopeLists is None:
    scopeList = normalizePrinterScopeList(scopeList)
  return scopeList, printerScopeLists

def userProcessPrinters(user, jcount, i, count):
  action = Act.Get()
  Act.Set(Act.PROCESS)
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.PRINTER, i, count)
  Act.Set(action)

def _batchCreatePrinterACLs(cp, printerId, i, count, scopeList, role, notify):
  Act.Set(Act.ADD)
  jcount = len(scopeList)
  entityPerformActionNumItems([Ent.PRINTER, printerId], jcount, role, i, count)
  Ind.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == 'public':
      public = True
      scope = None
      roleForScope = None
      skip_notification = None
    else:
      public = None
      roleForScope = role
      skip_notification = not notify if scope.find('@') != -1 else True
    try:
      callGCP(cp.printers(), 'share',
              throw_messages=[GCP.UNKNOWN_PRINTER, GCP.FAILED_TO_SHARE_THE_PRINTER, GCP.USER_IS_NOT_AUTHORIZED],
              printerid=printerId, role=roleForScope, scope=scope, public=public, skip_notification=skip_notification)
      if scope is not None:
        entityActionPerformed([Ent.PRINTER, printerId, roleForScope, scope], j, jcount)
      else:
        entityActionPerformed([Ent.PRINTER, printerId, Ent.SCOPE, 'public'], j, jcount)
    except GCP.userIsNotAuthorized:
      entityActionFailedWarning([Ent.PRINTER, printerId, roleForScope, scope], Msg.ONLY_ONE_OWNER_ALLOWED, j, jcount)
    except GCP.failedToShareThePrinter:
      entityActionFailedWarning([Ent.PRINTER, printerId, roleForScope, scope], Msg.INVALID_SCOPE, j, jcount)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
      break
  Ind.Decrement()

PRINTER_ROLE_MAP = {'manager': Ent.ROLE_MANAGER, 'owner': Ent.ROLE_OWNER, 'user': Ent.ROLE_USER}
PRINTER_ROLE_PRINT_MAP = {'manager': Ent.ROLE_MANAGER, 'owner': Ent.ROLE_OWNER, 'user': Ent.ROLE_USER, 'print': 'print'}
PRINTER_PUBLIC_SCOPE_LIST = ['public']

# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> create|add user|manager|owner <PrinterACLScopeEntity> [notify]
# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> create|add print public
def printerCreateACL(users, printerIdList):
  role = getChoice(PRINTER_ROLE_PRINT_MAP, mapChoice=True)
  if role != 'print':
    scopeList, printerScopeLists = getPrinterACLScopeEntity()
  else:
    role = Ent.ROLE_PUBLIC
    scopeList = PRINTER_PUBLIC_SCOPE_LIST
    printerScopeLists = None
    checkArgumentPresent(scopeList, required=True)
  notify = checkArgumentPresent('notify')
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(printerIdList)
    userProcessPrinters(user, jcount, i, count)
    Ind.Increment()
    for printerId in printerIdList:
      j += 1
      if printerScopeLists:
        scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
      _batchCreatePrinterACLs(cp, printerId, j, jcount, scopeList, role, notify)
    Ind.Decrement()

def _batchDeletePrinterACLs(cp, printerId, i, count, scopeList, role):
  Act.Set(Act.DELETE)
  jcount = len(scopeList)
  entityPerformActionNumItems([Ent.PRINTER, printerId], jcount, role, i, count)
  Ind.Increment()
  j = 0
  for scope in scopeList:
    j += 1
    if scope.lower() == 'public':
      public = True
      scope = None
    else:
      public = None
    try:
      callGCP(cp.printers(), 'unshare',
              throw_messages=[GCP.UNKNOWN_PRINTER],
              printerid=printerId, scope=scope, public=public)
      if scope is None:
        scope = 'public'
      entityActionPerformed([Ent.PRINTER, printerId, Ent.SCOPE, scope], j, jcount)
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
      break
  Ind.Decrement()

# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> delete [user|manager|owner] <PrinterACLScopeEntity>
# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> delete [print] public
def printerDeleteACLs(users, printerIdList):
  role = getChoice(PRINTER_ROLE_PRINT_MAP, defaultChoice=None, mapChoice=True)
  if role != 'print':
    scopeList, printerScopeLists = getPrinterACLScopeEntity()
  else:
    role = Ent.ROLE_PUBLIC
    scopeList = PRINTER_PUBLIC_SCOPE_LIST
    printerScopeLists = None
    checkArgumentPresent(scopeList, required=True)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(printerIdList)
    userProcessPrinters(user, jcount, i, count)
    Ind.Increment()
    for printerId in printerIdList:
      j += 1
      if printerScopeLists:
        scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
      _batchDeletePrinterACLs(cp, printerId, j, jcount, scopeList, Ent.SCOPE)
    Ind.Decrement()

def getPrinterScopeListsForRole(cp, printerId, i, count, role):
  try:
    result = callGCP(cp.printers(), 'get',
                     throw_messages=[GCP.UNKNOWN_PRINTER],
                     printerid=printerId)
    try:
      jcount = len(result['printers'][0]['access'])
    except KeyError:
      jcount = 0
    scopeList = []
    if jcount > 0:
      for acl in result['printers'][0]['access']:
        if acl.get('role') == role:
          scopeList.append(acl['scope'].lower())
    return scopeList
  except GCP.unknownPrinter as e:
    entityActionFailedWarning([Ent.PRINTER, printerId], str(e), i, count)
    return None

# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> sync user|manager|owner [addonly|removeonly] <PrinterACLScopeEntity> [notify]
def printerSyncACLs(users, printerIdList):
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  syncOperation = getChoice(['addonly', 'removeonly'], defaultChoice='addremove')
  scopeList, printerScopeLists = getPrinterACLScopeEntity()
  notify = checkArgumentPresent('notify')
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(printerIdList)
    userProcessPrinters(user, jcount, i, count)
    Ind.Increment()
    for printerId in printerIdList:
      j += 1
      if printerScopeLists:
        scopeList = normalizePrinterScopeList(printerScopeLists[printerId])
      currentScopeList = getPrinterScopeListsForRole(cp, printerId, j, jcount, role)
      if currentScopeList is not None:
        if syncOperation != 'removeonly':
          _batchCreatePrinterACLs(cp, printerId, j, jcount, list(set(scopeList)-set(currentScopeList)), role, notify)
        if syncOperation != 'addonly':
          _batchDeletePrinterACLs(cp, printerId, j, jcount, list(set(currentScopeList)-set(scopeList)), role)
    Ind.Decrement()

# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> wipe user|manager|owner
def printerWipeACLs(users, printerIdList):
  role = getChoice(PRINTER_ROLE_MAP, mapChoice=True)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(printerIdList)
    userProcessPrinters(user, jcount, i, count)
    Ind.Increment()
    for printerId in printerIdList:
      j += 1
      currentScopeList = getPrinterScopeListsForRole(cp, printerId, j, jcount, role)
      if currentScopeList is not None:
        _batchDeletePrinterACLs(cp, printerId, j, jcount, currentScopeList, role)
    Ind.Decrement()

PRINTACLS_SORT_TITLES = ['id', 'printerName', 'email', 'name', 'membership', 'is_pending', 'role', 'scope', 'type']

# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> printacls [todrive <ToDriveAttribute>*]
# gam [<UserTypeEntity>] printer|printers <PrinterIDEntity> showacls
def printerPrintShowACLs(users, printerIdList):
  csvPF = CSVPrintFile(['id', 'printerName'], PRINTACLS_SORT_TITLES) if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(printerIdList)
    if not csvPF:
      userProcessPrinters(user, jcount, i, count)
    Ind.Increment()
    for printerId in printerIdList:
      j += 1
      try:
        if csvPF:
          printGettingEntityItemForWhom(Ent.PRINTER_ACL, printerId, j, jcount)
        result = callGCP(cp.printers(), 'get',
                         throw_messages=[GCP.UNKNOWN_PRINTER],
                         printerid=printerId)
        try:
          kcount = len(result['printers'][0]['access'])
        except KeyError:
          kcount = 0
        if not csvPF:
          entityPerformActionNumItems([Ent.PRINTER, f'{result["printers"][0]["name"]} ({printerId})'], kcount, Ent.PRINTER_ACL, j, jcount)
        if kcount == 0:
          setSysExitRC(NO_ENTITIES_FOUND)
          continue
        if not csvPF:
          Ind.Increment()
          for acl in result['printers'][0]['access']:
            if 'key' in acl:
              acl['accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl['key'])
            showJSON(None, acl)
            printBlankLine()
          Ind.Decrement()
        else:
          for acl in result['printers'][0]['access']:
            if 'key' in acl:
              acl['accessURL'] = CLOUDPRINT_ACCESS_URL.format(printerId, acl['key'])
            csvPF.WriteRowTitles(flattenJSON(acl, flattened={'id': printerId, 'printerName': result['printers'][0]['name']}))
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e), j, jcount)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('PrinterACLs')

def userProcessPrintJobs(user, jcount, i, count):
  action = Act.Get()
  Act.Set(Act.PROCESS)
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.PRINTJOB, i, count)
  Act.Set(action)

# gam [<UserTypeEntity>] printjob|printjobs <PrintJobEntity> cancel
def doPrintJobCancel(users, jobIdList):
  checkForExtraneousArguments()
  ssd = '{"state": {"type": "ABORTED", "user_action_cause": {"action_code": "CANCELLED"}}}'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(jobIdList)
    userProcessPrintJobs(user, jcount, i, count)
    Ind.Increment()
    for jobId in jobIdList:
      j += 1
      try:
        callGCP(cp.jobs(), 'update',
                throw_messages=[GCP.UNKNOWN_JOB_ID],
                jobid=jobId, semantic_state_diff=ssd)
        entityActionPerformed([Ent.PRINTJOB, jobId], j, jcount)
      except GCP.unknownJobId as e:
        entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), j, jcount)
    Ind.Decrement()

# gam [<UserTypeEntity>] printjob|printjobs <PrintJobEntity> delete
def doPrintJobDelete(users, jobIdList):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(jobIdList)
    userProcessPrintJobs(user, jcount, i, count)
    Ind.Increment()
    for jobId in jobIdList:
      j += 1
      try:
        callGCP(cp.jobs(), 'delete',
                throw_messages=[GCP.UNKNOWN_JOB_ID],
                jobid=jobId)
        entityActionPerformed([Ent.PRINTJOB, jobId], j, jcount)
      except GCP.unknownJobId as e:
        entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), j, jcount)
    Ind.Decrement()

# gam [<UserTypeEntity>] printjob|printjobs <PrintJobEntity> resubmit <PrinterID>
def doPrintJobResubmit(users, jobIdList):
  printerId = getString(Cmd.OB_PRINTER_ID)
  ssd = '{"state": {"type": "HELD"}}'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    j = 0
    jcount = len(jobIdList)
    userProcessPrintJobs(user, jcount, i, count)
    Ind.Increment()
    for jobId in jobIdList:
      j += 1
      try:
        result = callGCP(cp.jobs(), 'update',
                         throw_messages=[GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                         jobid=jobId, semantic_state_diff=ssd)
        ticket = callGCP(cp.jobs(), 'getticket',
                         throw_messages=[GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                         jobid=jobId, use_cjt=True)
        result = callGCP(cp.jobs(), 'resubmit',
                         throw_messages=[GCP.UNKNOWN_PRINTER, GCP.UNKNOWN_JOB_ID, GCP.CANT_MODIFY_FINISHED_JOB],
                         printerid=printerId, jobid=jobId, ticket=ticket)
        entityActionPerformed([Ent.PRINTJOB, result['job']['id'], Ent.PRINTER, printerId], j, jcount)
      except GCP.unknownJobId as e:
        entityActionFailedWarning([Ent.PRINTJOB, jobId], str(e), j, jcount)
      except (GCP.cantModifyFinishedJob, GCP.unknownPrinter) as e:
        entityActionFailedWarning([Ent.PRINTJOB, jobId, Ent.PRINTER, printerId], str(e), j, jcount)
    Ind.Decrement()

# gam [<UserTypeEntity>] printjob <PrinterID> submit
#	(<FileName> [charset  <String>])|<URL> [name|title <String>] (tag <String>)*
def doPrintJobSubmit(users, printerIdList):
  printerId = printerIdList[0]
  content = getString(Cmd.OB_FILE_NAME_OR_URL)
  form_fields = {'printerid': printerId,
                 'title': content,
                 'ticket': '{"version": "1.0"}',
                 'tags': [GAM, GAM_URL]}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'tag':
      form_fields['tags'].append(getString(Cmd.OB_STRING))
    elif myarg in {'name', 'title'}:
      form_fields['title'] = getString(Cmd.OB_STRING)
    else:
      unknownArgumentExit()
  if content[:4] == 'http':
    form_fields['content'] = content
    form_fields['contentType'] = 'url'
    filepath = None
  else:
    filepath = content
    encoding = getCharSet()
  body, headers = encode_multipart(form_fields, filepath, encoding)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    userProcessPrintJobs(user, 1, i, count)
    Ind.Increment()
    try:
      resp, result = cp._http.request(uri='https://www.google.com/cloudprint/submit', method='POST', body=body, headers=headers)
      if resp['status'] == '200':
        result = checkCloudPrintResult(result)
        entityActionPerformed([Ent.PRINTER, printerId, Ent.PRINTJOB, result['job']['id']])
      else:
        entityActionFailedWarning([Ent.PRINTER, printerId], getCloudPrintError(resp, result))
    except GCP.unknownPrinter as e:
      entityActionFailedWarning([Ent.PRINTER, printerId], str(e))
    Ind.Decrement()
#
PRINTJOB_STATUS_MAP = {
  'done': 'DONE',
  'error': 'ERROR',
  'held': 'HELD',
  'inprogress': 'IN_PROGRESS',
  'queued': 'QUEUED',
  'submitted': 'SUBMITTED',
  }
# Map argument to API value
PRINTJOB_ASCENDINGORDER_MAP = {
  'createtime': 'CREATE_TIME',
  'status': 'STATUS',
  'title': 'TITLE',
  }
# Map API value from ascending to descending
PRINTJOB_DESCENDINGORDER_MAP = {
  'CREATE_TIME': 'CREATE_TIME_DESC',
  'STATUS': 'STATUS_DESC',
  'TITLE': 'TITLE_DESC',
  }

PRINTJOBS_DEFAULT_JOB_LIMIT = 0
PRINTJOBS_DEFAULT_MAX_RESULTS = 100

def initPrintjobListParameters():
  return {'older_or_newer': 0,
          'age': None,
          'sortorder': None,
          'owner': None,
          'queries': [None],
          'status': None,
          'jobLimit': PRINTJOBS_DEFAULT_JOB_LIMIT,
         }

def getPrintjobListParameters(myarg, parameters):
  if myarg == 'olderthan':
    parameters['older_or_newer'] = 1
    parameters['age'] = getAgeTime()
  elif myarg == 'newerthan':
    parameters['older_or_newer'] = -1
    parameters['age'] = getAgeTime()
  elif myarg in {'query', 'queries'}:
    parameters['queries'] = getQueries(myarg)
  elif myarg == 'status':
    parameters['status'] = getChoice(PRINTJOB_STATUS_MAP, mapChoice=True)
  elif myarg == 'orderby':
    parameters['sortorder'] = getChoice(PRINTJOB_ASCENDINGORDER_MAP, mapChoice=True)
    if getChoice(SORTORDER_CHOICE_MAP, defaultChoice='ASCENDING', mapChoice=True) == 'DESCENDING':
      parameters['sortorder'] = PRINTJOB_DESCENDINGORDER_MAP[parameters['sortorder']]
  elif myarg in {'owner', 'user'}:
    parameters['owner'] = getEmailAddress(noUid=True)
  elif myarg == 'limit':
    parameters['jobLimit'] = getInteger(minVal=0)
  else:
    unknownArgumentExit()

# gam [<UserTypeEntity>] printjob <PrinterID>|any fetch
#	[olderthan|newerthan <PrintJobAge>] [(query <QueryPrintJob>)|(queries <QueryPrintJobList>)]
#	[status done|error|held|in_progress|queued|submitted]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [drivedir|(targetfolder <FilePath>)]
def doPrintJobFetch(users, printerIdList):
  printerId = printerIdList[0]
  if printerId.lower() == 'any':
    printerId = None
  parameters = initPrintjobListParameters()
  targetFolder = os.getcwd()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'drivedir':
      targetFolder = GC.Values[GC.DRIVE_DIR]
    elif myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    else:
      getPrintjobListParameters(myarg, parameters)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    if printerId:
      try:
        callGCP(cp.printers(), 'get',
                throw_messages=[GCP.UNKNOWN_PRINTER],
                printerid=printerId)
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e))
        return
    ssd = '{"state": {"type": "DONE"}}'
    if ((not parameters['sortorder']) or (parameters['sortorder'] == 'CREATE_TIME_DESC')) and (parameters['older_or_newer'] < 0):
      timeExit = True
    elif (parameters['sortorder'] == 'CREATE_TIME') and (parameters['older_or_newer'] > 0):
      timeExit = True
    else:
      timeExit = False
    for query in parameters['queries']:
      jobCount = offset = 0
      exitLoop = False
      while not exitLoop:
        if parameters['jobLimit'] == 0:
          limit = PRINTJOBS_DEFAULT_MAX_RESULTS
        else:
          limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters['jobLimit']-jobCount)
          if limit == 0:
            break
        result = callGCP(cp.jobs(), 'list',
                         throw_messages=[GCP.UNKNOWN_PRINTER, GCP.NO_PRINT_JOBS],
                         printerid=printerId, q=query, status=parameters['status'], sortorder=parameters['sortorder'],
                         owner=parameters['owner'], offset=offset, limit=limit)
        newJobs = result['range']['jobsCount']
        if newJobs == 0:
          break
        jobCount += newJobs
        offset += newJobs
        for job in result['jobs']:
          createTime = int(job['createTime'])
          if parameters['older_or_newer'] > 0:
            if createTime > parameters['age']:
              if timeExit:
                exitLoop = True
                break
              continue
          elif parameters['older_or_newer'] < 0:
            if createTime < parameters['age']:
              if timeExit:
                exitLoop = True
                break
              continue
          jobId = job['id']
          fileName = os.path.join(targetFolder, f'{cleanFilename(job["title"])}-{jobId}')
          _, content = cp._http.request(job['fileUrl'], method='GET')
          if writeFile(fileName, content, mode='wb', continueOnError=True):
  #          ticket = callGCP(cp.jobs(), 'getticket',
  #                           jobid=jobId, use_cjt=True)
            result = callGCP(cp.jobs(), 'update',
                             jobid=jobId, semantic_state_diff=ssd)
            entityModifierNewValueActionPerformed([Ent.PRINTER, printerId, Ent.PRINTJOB, jobId], Act.MODIFIER_TO, fileName)
      if jobCount == 0:
        entityActionFailedWarning([Ent.PRINTER, printerId, Ent.PRINTJOB, ''], Msg.NO_PRINT_JOBS)

PRINTJOB_SORT_TITLES = ['printerid', 'id', 'printerName', 'title', 'ownerId', 'createTime', 'updateTime']

# gam [<UserTypeEntity>] print printjobs [todrive <ToDriveAttribute>*] [printer|printerid <PrinterID>]
#	[olderthan|newerthan <PrintJobAge>] [(query <QueryPrintJob>)|(queries <QueryPrintJobList>)]
#	[status <PrintJobStatus>]
#	[orderby <PrintJobOrderByFieldName> [ascending|descending]]
#	[owner|user <EmailAddress>]
#	[limit <Number>] [delimiter <Character>]
def printPrintJobs(users):
  csvPF = CSVPrintFile(['printerid', 'id'], PRINTJOB_SORT_TITLES)
  printerId = None
  parameters = initPrintjobListParameters()
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'printer', 'printerid'}:
      printerId = getString(Cmd.OB_PRINTER_ID)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      getPrintjobListParameters(myarg, parameters)
  if ((not parameters['sortorder']) or (parameters['sortorder'] == 'CREATE_TIME_DESC')) and (parameters['older_or_newer'] < 0):
    timeExit = True
  elif (parameters['sortorder'] == 'CREATE_TIME') and (parameters['older_or_newer'] > 0):
    timeExit = True
  else:
    timeExit = False
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cp = buildGAPICloudprintObject(user, i, count)
    if not cp:
      continue
    if printerId:
      try:
        callGCP(cp.printers(), 'get',
                throw_messages=[GCP.UNKNOWN_PRINTER],
                printerid=printerId)
      except GCP.unknownPrinter as e:
        entityActionFailedWarning([Ent.PRINTER, printerId], str(e))
        return
    for query in parameters['queries']:
      jobCount = offset = 0
      exitLoop = False
      while not exitLoop:
        if parameters['jobLimit'] == 0:
          limit = PRINTJOBS_DEFAULT_MAX_RESULTS
        else:
          limit = min(PRINTJOBS_DEFAULT_MAX_RESULTS, parameters['jobLimit']-jobCount)
          if limit == 0:
            break
        result = callGCP(cp.jobs(), 'list',
                         printerid=printerId, q=query, status=parameters['status'], sortorder=parameters['sortorder'],
                         owner=parameters['owner'], offset=offset, limit=limit)
        newJobs = result['range']['jobsCount']
        if GC.Values[GC.DEBUG_LEVEL] > 0:
          sys.stderr.write(f'Debug: jobCount: {jobCount}, jobLimit: {parameters["jobLimit"]}, jobsCount: {newJobs}, jobsTotal: {int(result["range"]["jobsTotal"])}\n')
        if newJobs == 0:
          break
        jobCount += newJobs
        offset += newJobs
        for job in result['jobs']:
          createTime = int(job['createTime'])
          if parameters['older_or_newer'] > 0:
            if createTime > parameters['age']:
              if timeExit:
                exitLoop = True
                break
              continue
          elif parameters['older_or_newer'] < 0:
            if createTime < parameters['age']:
              if timeExit:
                exitLoop = True
                break
              continue
          job['createTime'] = formatLocalTimestamp(job['createTime'])
          job['updateTime'] = formatLocalTimestamp(job['updateTime'])
          job['tags'] = delimiter.join(job['tags'])
          csvPF.WriteRowTitles(flattenJSON(job))
  csvPF.writeCSVfile('Print Jobs')

def doPrintPrintJobs():
  printPrintJobs([None])

def _showASPs(user, asps, i=0, count=0):
  Act.Set(Act.SHOW)
  jcount = len(asps)
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  for asp in asps:
    if asp['creationTime'] == '0':
      created_date = 'Unknown'
    else:
      created_date = formatLocalTimestamp(asp['creationTime'])
    if asp['lastTimeUsed'] == '0':
      used_date = GC.NEVER
    else:
      used_date = formatLocalTimestamp(asp['lastTimeUsed'])
    printKeyValueList(['ID', asp['codeId']])
    Ind.Increment()
    printKeyValueList(['Name', asp['name']])
    printKeyValueList(['Created', created_date])
    printKeyValueList(['Last Used', used_date])
    Ind.Decrement()
  Ind.Decrement()

# gam <UserTypeEntity> delete asps|applicationspecificpasswords all|<AspIDList>
def deleteASP(users):
  cd = buildGAPIObject(API.DIRECTORY)
  codeIdList = getString(Cmd.OB_ASP_ID_LIST).lower()
  if codeIdList == 'all':
    allCodeIds = True
  else:
    allCodeIds = False
    codeIds = codeIdList.replace(',', ' ').split()
    for codeId in codeIds:
      if not codeId.isdigit():
        Cmd.Backup()
        usageErrorExit(Msg.INVALID_ENTITY.format(Ent.Singular(Ent.APPLICATION_SPECIFIC_PASSWORD), Msg.MUST_BE_NUMERIC))
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if allCodeIds:
      try:
        asps = callGAPIitems(cd.asps(), 'list', 'items',
                             throwReasons=[GAPI.USER_NOT_FOUND],
                             userKey=user, fields='items(codeId)')
        codeIds = [asp['codeId'] for asp in asps]
      except GAPI.userNotFound:
        entityUnknownWarning(Ent.USER, user, i, count)
        continue
    jcount = len(codeIds)
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
      continue
    Ind.Increment()
    j = 0
    for codeId in codeIds:
      j += 1
      try:
        callGAPI(cd.asps(), 'delete',
                 throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.FORBIDDEN],
                 userKey=user, codeId=codeId)
        entityActionPerformed([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], j, jcount)
      except (GAPI.invalid, GAPI.invalidParameter, GAPI.forbidden) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], str(e), j, jcount)
      except GAPI.userNotFound:
        entityUnknownWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> print asps|applicationspecificpasswords [todrive <ToDriveAttribute>*]
#	[oneitemperrow]
# gam <UserTypeEntity> show asps|applicationspecificpasswords
def printShowASPs(users):
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['User']) if Act.csvFormat() else None
  oneItemPerRow = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif csvPF and myarg == 'oneitemperrow':
      oneItemPerRow = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if csvPF:
      printGettingEntityItemForWhom(Ent.APPLICATION_SPECIFIC_PASSWORD, user, i, count)
    try:
      asps = callGAPIitems(cd.asps(), 'list', 'items',
                           throwReasons=[GAPI.USER_NOT_FOUND],
                           userKey=user)
      if not csvPF:
        _showASPs(user, asps, i, count)
      else:
        for asp in asps:
          asp.pop('userKey', None)
          if asp['creationTime'] == '0':
            asp['creationTime'] = 'Unknown'
          else:
            asp['creationTime'] = formatLocalTimestamp(asp['creationTime'])
          if asp['lastTimeUsed'] == '0':
            asp['lastTimeUsed'] = GC.NEVER
          else:
            asp['lastTimeUsed'] = formatLocalTimestamp(asp['lastTimeUsed'])
        if not oneItemPerRow:
          csvPF.WriteRowTitles(flattenJSON({'asps': asps}, flattened={'User': user}))
        else:
          for asp in asps:
            csvPF.WriteRowTitles(flattenJSON({'asp': asp}, flattened={'User': user}))
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Application Specific Passwords')

def _showBackupCodes(user, codes, i, count):
  Act.Set(Act.SHOW)
  jcount = 0
  for code in codes:
    if code.get('verificationCode'):
      jcount += 1
  entityPerformActionNumItems([Ent.USER, user], jcount, Ent.BACKUP_VERIFICATION_CODES, i, count)
  if jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
    return
  Ind.Increment()
  j = 0
  for code in codes:
    j += 1
    printKeyValueList([f'{j:2}', code.get('verificationCode')])
  Ind.Decrement()

# gam <UserTypeEntity> update backupcodes|verificationcodes
def updateBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), 'generate',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_INPUT],
               userKey=user)
      codes = callGAPIitems(cd.verificationCodes(), 'list', 'items',
                            throwReasons=[GAPI.USER_NOT_FOUND],
                            userKey=user, fields='items(verificationCode)')
      _showBackupCodes(user, codes, i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.invalid, GAPI.invalidInput) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], str(e), i, count)

# gam <UserTypeEntity> delete backupcodes|verificationcodes
def deleteBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.verificationCodes(), 'invalidate',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_INPUT],
               userKey=user)
      printEntityKVList([Ent.USER, user], [Ent.Plural(Ent.BACKUP_VERIFICATION_CODES), '', 'Invalidated'], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.invalid, GAPI.invalidInput) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], str(e), i, count)

# gam <UserTypeEntity> print backupcodes|verificationcodes [todrive <ToDriveAttribute>*] [delimiter <Character>]
# gam <UserTypeEntity> show backupcodes|verificationcodes
def printShowBackupCodes(users):
  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['User', 'verificationCodes']) if Act.csvFormat() else None
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if csvPF:
      printGettingEntityItemForWhom(Ent.BACKUP_VERIFICATION_CODES, user, i, count)
    try:
      codes = callGAPIitems(cd.verificationCodes(), 'list', 'items',
                            throwReasons=[GAPI.USER_NOT_FOUND],
                            userKey=user, fields='items(verificationCode)')
      if not csvPF:
        _showBackupCodes(user, codes, i, count)
      else:
        csvPF.WriteRow({'User': user,
                        'verificationCodes': delimiter.join([code['verificationCode'] for code in codes if 'verificationCode' in code])})
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Backup Verification Codes')

def _getCalendarSelectProperty(myarg, kwargs):
  if myarg == 'minaccessrole':
    kwargs['minAccessRole'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
  elif myarg == 'showdeleted':
    kwargs['showDeleted'] = True
  elif myarg == 'showhidden':
    kwargs['showHidden'] = True
  else:
    return False
  return True

def initUserCalendarEntity():
  return {'list': [], 'kwargs': {}, 'dict': None, 'all': False, 'primary': False, 'resourceIds': []}

def getUserCalendarEntity(default='primary', noSelectionKwargs=None):

  def _initCourseCalendarSelectionParameters():
    return {'courseIds': [], 'teacherId': None, 'myCoursesAsTeacher': False,
            'studentId': None, 'myCoursesAsStudent': False, 'courseStates': []}

  def _getCourseCalendarSelectionParameters(myarg):
    if myarg in {'course', 'courses', 'class', 'classes'}:
      courseSelectionParameters['courseIds'].extend(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True))
    elif myarg == 'courseswithteacher':
      courseSelectionParameters['teacherId'] = getEmailAddress()
      courseSelectionParameters['myCoursesAsTeacher'] = False
    elif myarg == 'mycoursesasteacher':
      courseSelectionParameters['myCoursesAsTeacher'] = True
      courseSelectionParameters['teacherId'] = None
    elif myarg == 'courseswithstudent':
      courseSelectionParameters['studentId'] = getEmailAddress()
      courseSelectionParameters['myCoursesAsStudent'] = False
    elif myarg == 'mycoursesasstudent':
      courseSelectionParameters['myCoursesAsStudent'] = True
      courseSelectionParameters['studentId'] = None
    elif myarg in {'coursestate', 'coursestates', 'coursestatus'}:
      _getCourseStates(Cmd.OB_COURSE_STATE_LIST, courseSelectionParameters['courseStates'])
    else:
      return False
    return True

  def _noSelectionMade():
    return (not calendarEntity['list'] and not calendarEntity['kwargs'] and calendarEntity['dict'] is None and
            not calendarEntity['all'] and not calendarEntity['primary'] and not calendarEntity['resourceIds'] and
            not courseCalendarSelected)

  calendarEntity = initUserCalendarEntity()
  courseSelectionParameters = _initCourseCalendarSelectionParameters()
  courseCalendarSelected = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in {'calendar', 'calendars'}:
      entitySelector = getEntitySelector()
      if entitySelector:
        entityList = getEntitySelection(entitySelector, False)
        if isinstance(entityList, dict):
          calendarEntity['dict'] = entityList
        else:
          calendarEntity['list'] = entityList
      else:
        calendarEntity['list'].extend(convertEntityToList(getString(Cmd.OB_EMAIL_ADDRESS_LIST)))
    elif myarg == 'allcalendars':
      calendarEntity['all'] = True
    elif myarg == 'primary':
      calendarEntity['primary'] = True
    elif _getCalendarSelectProperty(myarg, calendarEntity['kwargs']):
      pass
    elif myarg == 'resource':
      calendarEntity['resourceIds'].append(getString(Cmd.OB_RESOURCE_ID))
    elif myarg == 'resources':
      calendarEntity['resourceIds'].extend(convertEntityToList(getString(Cmd.OB_RESOURCE_ID, minLen=0), shlexSplit=True))
    elif _getCourseCalendarSelectionParameters(myarg):
      courseCalendarSelected = True
    elif _noSelectionMade() and (myarg.find('@') != -1 or myarg.find('id:') != -1):
      Cmd.Backup()
      calendarEntity['list'].append(getEmailAddress())
    else:
      Cmd.Backup()
      break
  if _noSelectionMade():
    if not noSelectionKwargs:
      calendarEntity[default] = True
    else:
      calendarEntity['all'] = True
      calendarEntity['kwargs'].update(noSelectionKwargs)
  elif (courseCalendarSelected and
        (courseSelectionParameters['courseIds'] or
         courseSelectionParameters['teacherId'] or courseSelectionParameters['myCoursesAsTeacher'] or
         courseSelectionParameters['studentId'] or courseSelectionParameters['myCoursesAsStudent'])):
    calendarEntity['courseSelectionParameters'] = courseSelectionParameters
    calendarEntity['courseShowProperties'] = _initCourseShowProperties(['calendarId'])
    calendarEntity['croom'] = buildGAPIObject(API.CLASSROOM)
  return calendarEntity

def _validateUserGetCalendarIds(user, i, count, calendarEntity,
                                itemType=None, modifier=None, showAction=True, setRC=True, newCalId=None, secondaryCalendarsOnly=False):
  if user and calendarEntity['dict']:
    calIds = calendarEntity['dict'][user][:]
  else:
    calIds = calendarEntity['list'][:]
  user, cal = validateCalendar(user, i, count)
  if not cal:
    return (user, None, None, 0)
  if calendarEntity['resourceIds']:
    cd = buildGAPIObject(API.DIRECTORY)
    for resourceId in calendarEntity['resourceIds']:
      try:
        calIds.append(callGAPI(cd.resources().calendars(), 'get',
                               throwReasons=[GAPI.BAD_REQUEST, GAPI.RESOURCE_NOT_FOUND, GAPI.FORBIDDEN],
                               customer=GC.Values[GC.CUSTOMER_ID], calendarResourceId=resourceId,
                               fields='resourceEmail')['resourceEmail'])
      except (GAPI.badRequest, GAPI.resourceNotFound, GAPI.forbidden):
        checkEntityAFDNEorAccessErrorExit(cd, Ent.RESOURCE_CALENDAR, resourceId, i, count)
        return (user, None, None, 0)
  courseSelectionParameters = calendarEntity.get('courseSelectionParameters')
  if courseSelectionParameters is not None:
    if courseSelectionParameters['myCoursesAsTeacher']:
      courseSelectionParameters['teacherId'] = user
    if courseSelectionParameters['myCoursesAsStudent']:
      courseSelectionParameters['studentId'] = user
    coursesInfo = _getCoursesInfo(calendarEntity['croom'], courseSelectionParameters,
                                  calendarEntity['courseShowProperties'])
    if coursesInfo is None:
      return (user, None, None, 0)
    for course in coursesInfo:
      calIds.append(course['calendarId'])
  if calendarEntity['primary']:
    calIds.append(user)
  try:
    if calendarEntity['kwargs'] or calendarEntity['all']:
      result = callGAPIpages(cal.calendarList(), 'list', 'items',
                             throwReasons=GAPI.CALENDAR_THROW_REASONS,
                             fields='nextPageToken,items/id', **calendarEntity['kwargs'])
      calIds.extend([calId['id'] for calId in result if not secondaryCalendarsOnly or calId['id'].find('@group.calendar.google.com') != -1])
    else:
      callGAPI(cal.calendars(), 'get',
               throwReasons=GAPI.CALENDAR_THROW_REASONS,
               calendarId='primary', fields='')
  except GAPI.notACalendarUser as e:
    entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    return (user, None, None, 0)
  except (GAPI.serviceNotAvailable, GAPI.authError):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return (user, None, None, 0)
  if newCalId:
    newcal = buildGAPIObject(API.CALENDAR)
    if not checkCalendarExists(newcal, newCalId):
      entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, newCalId], Msg.DOES_NOT_EXIST, i, count)
      return (user, None, None, 0)
  jcount = len(calIds)
  if setRC and jcount == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if showAction:
    if not itemType:
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CALENDAR, i, count)
    elif not newCalId:
      entityPerformActionSubItemModifierNumItems([Ent.USER, user], itemType, modifier, jcount, Ent.CALENDAR, i, count)
    else:
      entityPerformActionSubItemModifierNumItemsModifierNewValue([Ent.USER, user], itemType, modifier, jcount, Ent.CALENDAR, Act.MODIFIER_TO, newCalId, i, count)
  return (user, cal, calIds, jcount)

CALENDAR_NOTIFICATION_METHODS = ['email']
CALENDAR_NOTIFICATION_TYPES_MAP = {
  'eventcreation': 'eventCreation',
  'eventchange': 'eventChange',
  'eventcancellation': 'eventCancellation',
  'eventresponse': 'eventResponse',
  'agenda': 'agenda',
  }

def _getCalendarAttributes(body):
  colorRgbFormat = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'selected':
      body['selected'] = getBoolean()
    elif myarg == 'hidden':
      body['hidden'] = getBoolean()
    elif myarg == 'summary':
      body['summaryOverride'] = getString(Cmd.OB_STRING)
    elif myarg == 'color':
      body['colorId'] = getChoice(CALENDAR_COLOR_MAP, mapChoice=True)
    elif myarg in {'colorindex', 'colorid'}:
      body['colorId'] = getInteger(minVal=CALENDAR_MIN_COLOR_INDEX, maxVal=CALENDAR_MAX_COLOR_INDEX)
    elif myarg == 'backgroundcolor':
      body['backgroundColor'] = getColor()
      body.setdefault('foregroundColor', '#000000')
      colorRgbFormat = True
    elif myarg == 'foregroundcolor':
      body['foregroundColor'] = getColor()
      colorRgbFormat = True
    elif myarg == 'reminder':
      body.setdefault('defaultReminders', [])
      if not checkArgumentPresent(Cmd.CLEAR_NONE_ARGUMENT):
        body['defaultReminders'].append(getCalendarReminder(True))
    elif myarg == 'notification':
      body.setdefault('notificationSettings', {'notifications': []})
      method = getChoice(CALENDAR_NOTIFICATION_METHODS+Cmd.CLEAR_NONE_ARGUMENT)
      if method not in Cmd.CLEAR_NONE_ARGUMENT:
        body['notificationSettings']['notifications'].append({'method': method,
                                                              'type': getChoice(CALENDAR_NOTIFICATION_TYPES_MAP, mapChoice=True)})
    else:
      unknownArgumentExit()
  return colorRgbFormat

def _showCalendar(calendar, j, jcount, FJQC, acls=None):
  if FJQC.formatJSON:
    if acls:
      calendar['acls'] = [{'id': rule['id'], 'role': rule['role']} for rule in acls]
    printLine(json.dumps(cleanJSON(calendar), ensure_ascii=False, sort_keys=True))
    return
  _showCalendarSettings(calendar, j, jcount)
  Ind.Increment()
  printKeyValueList(['Primary', calendar.get('primary', FALSE)])
  if 'accessRole' in calendar:
    printKeyValueList(['Access Level', calendar['accessRole']])
  if 'deleted' in calendar:
    printKeyValueList(['Deleted', calendar['deleted']])
  if 'hidden' in calendar:
    printKeyValueList(['Hidden', calendar['hidden']])
  if 'selected' in calendar:
    printKeyValueList(['Selected', calendar['selected']])
  if 'colorId' in calendar:
    printKeyValueList(['Color ID', calendar['colorId'], 'Background Color', calendar['backgroundColor'], 'Foreground Color', calendar['foregroundColor']])
  printKeyValueList(['Default Reminders', None])
  Ind.Increment()
  for reminder in calendar.get('defaultReminders', []):
    printKeyValueList(['Method', reminder['method'], 'Minutes', reminder['minutes']])
  Ind.Decrement()
  printKeyValueList(['Notifications', None])
  Ind.Increment()
  if 'notificationSettings' in calendar:
    for notification in calendar['notificationSettings'].get('notifications', []):
      printKeyValueList(['Method', notification['method'], 'Type', notification['type']])
  Ind.Decrement()
  if acls:
    j = 0
    jcount = len(acls)
    printEntitiesCount(Ent.CALENDAR_ACL, acls)
    Ind.Increment()
    for rule in acls:
      j += 1
      printKeyValueListWithCount(ACLRuleKeyValueList(rule), j, jcount)
    Ind.Decrement()
  Ind.Decrement()

# Process CalendarList functions
def _processCalendarList(user, calId, j, jcount, cal, function, **kwargs):
  try:
    callGAPI(cal.calendarList(), function,
             throwReasons=[GAPI.NOT_FOUND, GAPI.DUPLICATE,
                           GAPI.CANNOT_CHANGE_OWN_ACL, GAPI.CANNOT_CHANGE_OWN_PRIMARY_SUBSCRIPTION],
             **kwargs)
    entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], j, jcount)
  except (GAPI.notFound, GAPI.duplicate,
          GAPI.cannotChangeOwnAcl, GAPI.cannotChangeOwnPrimarySubscription) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)

# gam <UserTypeEntity> add calendars <UserCalendarAddEntity> <CalendarAttribute>
def addCalendars(users):
  calendarEntity = getUserCalendarEntity()
  body = {'selected': True, 'hidden': False}
  colorRgbFormat = _getCalendarAttributes(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      body['id'] = calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, 'insert',
                           body=body, colorRgbFormat=colorRgbFormat, fields='')
    Ind.Decrement()

def _updateDeleteCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      _processCalendarList(user, calId, j, jcount, cal, function,
                           calendarId=calId, **kwargs)
    Ind.Decrement()

# gam <UserTypeEntity> update calendars <UserCalendarEntity> <CalendarAttribute>
def updateCalendars(users):
  calendarEntity = getUserCalendarEntity()
  body = {}
  colorRgbFormat = _getCalendarAttributes(body)
  _updateDeleteCalendars(users, calendarEntity, 'patch', body=body, colorRgbFormat=colorRgbFormat, fields='')

# gam <UserTypeEntity> delete calendars <UserCalendarEntity>
def deleteCalendars(users):
  calendarEntity = getUserCalendarEntity()
  checkForExtraneousArguments()
  _updateDeleteCalendars(users, calendarEntity, 'delete')

# gam <UserTypeEntity> info calendars <UserCalendarEntity> [formatjson]
def infoCalendars(users):
  calendarEntity = getUserCalendarEntity()
  FJQC = FormatJSONQuoteChar(formatJSONOnly=True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      try:
        result = callGAPI(cal.calendarList(), 'get',
                          throwReasons=[GAPI.NOT_FOUND],
                          calendarId=calId)
        _showCalendar(result, j, jcount, FJQC)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> create calendars <CalendarSettings>
def createCalendar(users):
  calendarEntity = initUserCalendarEntity()
  body = getCalendarSettings(summaryRequired=True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, _, _ = _validateUserGetCalendarIds(user, i, count, calendarEntity, showAction=False, setRC=False)
    if not cal:
      continue
    try:
      calId = callGAPI(cal.calendars(), 'insert',
                       throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.FORBIDDEN],
                       body=body, fields='id')['id']
      entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], i, count)
    except (GAPI.notACalendarUser, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def addCreateCalendars(users):
  if Act.Get() == Act.ADD:
    addCalendars(users)
  else:
    createCalendar(users)

def _modifyRemoveCalendars(users, calendarEntity, function, **kwargs):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = normalizeCalendarId(calId, user)
      try:
        callGAPI(cal.calendars(), function,
                 throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.CANNOT_DELETE_PRIMARY_CALENDAR,
                                                           GAPI.FORBIDDEN, GAPI.INVALID, GAPI.REQUIRED_ACCESS_LEVEL],
                 calendarId=calId, **kwargs)
        entityActionPerformed([Ent.USER, user, Ent.CALENDAR, calId], j, jcount)
      except (GAPI.notFound, GAPI.cannotDeletePrimaryCalendar, GAPI.forbidden, GAPI.invalid, GAPI.requiredAccessLevel) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.CALENDAR, calId], str(e), j, jcount)
      except GAPI.notACalendarUser as e:
        entityActionFailedWarning([Ent.USER, user], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> modify calendars <UserCalendarEntity> <CalendarSettings>
def modifyCalendars(users):
  calendarEntity = getUserCalendarEntity()
  body = getCalendarSettings(summaryRequired=False)
  _modifyRemoveCalendars(users, calendarEntity, 'patch', body=body)

# gam <UserTypeEntity> remove calendars <UserCalendarEntity>
def removeCalendars(users):
  calendarEntity = getUserCalendarEntity()
  checkForExtraneousArguments()
  _modifyRemoveCalendars(users, calendarEntity, 'delete')

CALENDAR_SIMPLE_LISTS = {'allowedConferenceSolutionTypes'}
CALENDAR_EXCLUDE_OPTIONS = {'noprimary', 'nogroups', 'noresources', 'nosystem', 'nousers'}
CALENDAR_EXCLUDE_DOMAINS = {
  'nogroups': 'group.calendar.google.com',
  'noresources': 'resource.calendar.google.com',
  'nosystem': 'group.v.calendar.google.com',
  }

# gam <UserTypeEntity> print calendars <UserCalendarEntity> [todrive <ToDriveAttribute>*] [permissions]
#	[primary] <CalendarSelectProperty>* [noprimary] [nogroups] [noresources] [nosystem] [nousers]
#	[formatjson] [delimiter <Character>] [quotechar <Character>}
# gam <UserTypeEntity> show calendars <UserCalendarEntity> [permissions]
#	[primary] <CalendarSelectProperty>* [noprimary] [nogroups] [noresources] [nosystem] [nousers]
#	[formatjson]
def printShowCalendars(users):

  def _getPermissions(cal, userCalendar):
    if userCalendar['accessRole'] == 'owner':
      try:
        return callGAPIpages(cal.acl(), 'list', 'items',
                             throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND],
                             calendarId=userCalendar['id'], fields='nextPageToken,items(id,role,scope)')
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.notACalendarUser, GAPI.notFound):
        pass
    return []

  acls = []
  getCalPermissions = noPrimary = primaryOnly = False
  excludes = set()
  excludeDomains = set()
  csvPF = CSVPrintFile(['primaryEmail', 'calendarId'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  kwargs = {}
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in [Cmd.ARG_ACLS, Cmd.ARG_CALENDARACLS, Cmd.ARG_PERMISSIONS]:
      getCalPermissions = True
    elif myarg == 'allcalendars':
      pass
    elif myarg == 'primary':
      primaryOnly = True
    elif _getCalendarSelectProperty(myarg, kwargs):
      pass
    elif myarg in CALENDAR_EXCLUDE_OPTIONS:
      excludes.add(myarg)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  for exclude in excludes:
    if exclude == 'noprimary':
      noPrimary = True
    elif exclude == 'nousers':
      excludeDomains.add(GC.Values[GC.DOMAIN])
    else:
      excludeDomains.add(CALENDAR_EXCLUDE_DOMAINS[exclude])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      calendars = callGAPIpages(cal.calendarList(), 'list', 'items',
                                throwReasons=GAPI.CALENDAR_THROW_REASONS,
                                **kwargs)
    except GAPI.notACalendarUser as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
      continue
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
      continue
    if primaryOnly:
      for calendar in calendars:
        if calendar.get('primary', False):
          calendars = [calendar]
          break
      else:
        calendars = []
    elif noPrimary or excludeDomains:
      allCalendars = calendars[:]
      calendars = []
      for calendar in allCalendars:
        primary = calendar.get('primary', False)
        if noPrimary and primary:
          continue
        if not primary and excludeDomains:
          _, domain = splitEmailAddress(calendar['id'])
          if domain in excludeDomains:
            continue
        calendars.append(calendar)
    jcount = len(calendars)
    if not csvPF:
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.CALENDAR, i, count)
      Ind.Increment()
      j = 0
      for calendar in calendars:
        j += 1
        if getCalPermissions:
          acls = _getPermissions(cal, calendar)
        _showCalendar(calendar, j, jcount, FJQC, acls)
      Ind.Decrement()
    else:
      printGettingEntityItemForWhom(Ent.CALENDAR, user, i, count)
      if calendars:
        for calendar in calendars:
          row = {'primaryEmail': user, 'calendarId': calendar['id']}
          if getCalPermissions:
            flattenJSON({'permissions': _getPermissions(cal, calendar)}, flattened=row)
          flattenJSON(calendar, flattened=row, simpleLists=CALENDAR_SIMPLE_LISTS, delimiter=delimiter)
          if not FJQC.formatJSON:
            row.pop('id')
            csvPF.WriteRowTitles(row)
          elif csvPF.CheckRowTitles(row):
            csvPF.WriteRowNoFilter({'primaryEmail': user, 'calendarId': calendar['id'],
                                    'JSON': json.dumps(cleanJSON(calendar), ensure_ascii=False, sort_keys=True)})
      elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
        csvPF.WriteRowNoFilter({'primaryEmail': user})
  if csvPF:
    csvPF.writeCSVfile('Calendars')

# gam <UserTypeEntity> print calsettings  [todrive <ToDriveAttribute>*] [formatjson] [quotechar <Character>}
# gam <UserTypeEntity> show calsettings [formatjson]
def printShowCalSettings(users):
  csvPF = CSVPrintFile(['User'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal = validateCalendar(user, i, count)
    if not cal:
      continue
    try:
      feed = callGAPIpages(cal.settings(), 'list', 'items',
                           throwReasons=GAPI.CALENDAR_THROW_REASONS)
    except GAPI.notACalendarUser as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
      continue
    except (GAPI.serviceNotAvailable, GAPI.authError):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
      continue
    settings = {}
    for setting in feed:
      settings[setting['id']] = setting['value']
    if not csvPF:
      if not FJQC.formatJSON:
        printEntityKVList([Ent.USER, user], [Ent.Plural(Ent.CALENDAR_SETTINGS), None], i, count)
        Ind.Increment()
        for attr in sorted(settings):
          printKeyValueList([attr, settings[attr]])
        Ind.Decrement()
      else:
        printLine(json.dumps({'User': user, 'settings': settings}, ensure_ascii=False, sort_keys=True))
    else:
      row = flattenJSON(settings, flattened={'User': user})
      if not FJQC.formatJSON:
        csvPF.WriteRowTitles(row)
      elif csvPF.CheckRowTitles(row):
        csvPF.WriteRowNoFilter({'User': user, 'JSON': json.dumps(settings, ensure_ascii=False, sort_keys=True)})
  if csvPF:
    csvPF.writeCSVfile('Calendar Settings')

# gam <UserTypeEntity> create|add calendaracls <UserCalendarEntity> <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def createCalendarACLs(users):
  calendarEntity = getUserCalendarEntity()
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_TO)
    if jcount == 0:
      continue
    Ind.Increment()
    _doCalendarsCreateACLs(origUser, user, cal, calIds, jcount, role, ACLScopeEntity, sendNotifications)
    Ind.Decrement()

def updateDeleteCalendarACLs(users, calendarEntity, function, modifier, ACLScopeEntity, role, sendNotifications):
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, modifier)
    if jcount == 0:
      continue
    Ind.Increment()
    _doUpdateDeleteCalendarACLs(origUser, user, cal, function, calIds, jcount, ACLScopeEntity, role, sendNotifications)
    Ind.Decrement()

# gam <UserTypeEntity> update calendaracls <UserCalendarEntity> <CalendarACLRole> <CalendarACLScopeEntity> [sendnotifications <Boolean>]
def updateCalendarACLs(users):
  calendarEntity = getUserCalendarEntity()
  role, ACLScopeEntity, sendNotifications = getCalendarCreateUpdateACLsOptions(True)
  updateDeleteCalendarACLs(users, calendarEntity, 'patch', Act.MODIFIER_IN, ACLScopeEntity, role, sendNotifications)

# gam <UserTypeEntity> delete calendaracls <UserCalendarEntity> [<CalendarACLRole>] <CalendarACLScopeEntity>
def deleteCalendarACLs(users):
  calendarEntity = getUserCalendarEntity()
  role, ACLScopeEntity = getCalendarDeleteACLsOptions(True)
  updateDeleteCalendarACLs(users, calendarEntity, 'delete', Act.MODIFIER_FROM, ACLScopeEntity, role, False)

# gam <UserTypeEntity> info calendaracls <UserCalendarEntity> <CalendarACLScopeEntity> [formatjson]
def infoCalendarACLs(users):
  calendarEntity = getUserCalendarEntity()
  ACLScopeEntity = getCalendarSiteACLScopeEntity()
  FJQC = _getCalendarInfoACLOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_FROM, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _doInfoCalendarACLs(origUser, user, cal, calIds, jcount, ACLScopeEntity, FJQC)
    Ind.Decrement()

# gam <UserTypeEntity> print calendaracls <UserCalendarEntity> [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam <UserTypeEntity> show calendaracls <UserCalendarEntity> [formatjson]
def printShowCalendarACLs(users):
  calendarEntity = getUserCalendarEntity(default='all')
  csvPF, FJQC = _getCalendarPrintShowACLOptions(Ent.USER, ['primaryEmail', 'calendarId'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.CALENDAR_ACL, Act.MODIFIER_FROM, showAction=not csvPF and not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      calId = convertUIDtoEmailAddress(calId)
      _printShowCalendarACLs(cal, user, Ent.CALENDAR, calId, j, jcount, csvPF, FJQC)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Calendar ACLs')

TRANSFER_CALENDAR_APPEND_FIELDS = ['description', 'location', 'summary']

# gam <UserTypeEntity> transfer calendars <UserItem> <UserCalendarEntity>
#	[keepuser | (retainrole <CalendarACLRole>)] [sendnotifications <Boolean>] [noretentionmessages]
#	[<CalendarSettings>] [append description|location|summary] [noupdatemessages]
# gam <UserTypeEntity> transfer seccals <UserItem> [keepuser] [sendnotifications <Boolean>]
def transferCalendars(users):
  targetUser = getEmailAddress()
  calendarEntity = getUserCalendarEntity(noSelectionKwargs={'minAccessRole': 'owner', 'showHidden': True})
  notAllowedForbidden = Msg.FORBIDDEN if (not calendarEntity['all']) and (not calendarEntity.get('kwargs', {}).get('minAccessRole', '') == 'owner') else Msg.NOT_ALLOWED
  retainRoleBody = {'role': 'none'}
  sendNotifications = showUpdateMessages = showRetentionMessages = True
  updateBody = {}
  appendFieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'keepuser':
      retainRoleBody['role'] = 'owner'
    elif myarg == 'retainrole':
      retainRoleBody['role'] = getChoice(CALENDAR_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == 'sendnotifications':
      sendNotifications = getBoolean()
    elif myarg == 'noretentionmessages':
      showRetentionMessages = False
    elif _getCalendarSetting(myarg, updateBody):
      pass
    elif myarg == 'append':
      for field in _getFieldsList():
        if field in TRANSFER_CALENDAR_APPEND_FIELDS:
          appendFieldsList.append(field)
        else:
          invalidChoiceExit(field, TRANSFER_CALENDAR_APPEND_FIELDS, True)
    elif myarg == 'noupdatemessages':
      showUpdateMessages = False
    else:
      unknownArgumentExit()
  targetUser, targetCal = validateCalendar(targetUser)
  if not targetCal:
    return
  if updateBody:
    timestamp = currentISOformatTimeStamp('seconds')
    appendFields = ','.join(set(appendFieldsList))
  targetRoleBody = {'role': 'owner', 'scope': {'type': 'user', 'value': targetUser}}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    Act.Set(Act.TRANSFER_OWNERSHIP)
    user, sourceCal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, secondaryCalendarsOnly=True)
    if jcount == 0:
      continue
    if updateBody:
      userName, domain = splitEmailAddress(user)
      for field in updateBody:
        updateBody[field] = _substituteForUser(updateBody[field], user, userName)
        updateBody[field] = updateBody[field].replace('#domain#', domain)
        updateBody[field] = updateBody[field].replace('#timestamp#', timestamp)
    sourceRuleId = f'user:{user}'
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Act.Set(Act.TRANSFER_OWNERSHIP)
      if calId.find('@group.calendar.google.com') == -1:
        entityActionNotPerformedWarning([Ent.CALENDAR, calId], notAllowedForbidden, j, jcount)
        continue
      try:
        callGAPI(sourceCal.acl(), 'insert',
                 throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.FORBIDDEN, GAPI.REQUIRED_ACCESS_LEVEL],
                 calendarId=calId, body=targetRoleBody, sendNotifications=sendNotifications, fields='')
        entityModifierNewValueItemValueListActionPerformed([Ent.CALENDAR, calId], Act.MODIFIER_TO, None, [Ent.USER, targetUser], j, jcount)
      except (GAPI.forbidden, GAPI.requiredAccessLevel) as e:
        entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
        continue
      except (GAPI.notFound, GAPI.invalid):
        entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
        continue
      if updateBody:
        Act.Set(Act.UPDATE)
        try:
          if appendFields:
            body = callGAPI(targetCal.calendars(), 'get',
                            throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                            calendarId=calId, fields=appendFields)
            for field in appendFieldsList:
              if field in updateBody:
                body[field] += updateBody[field]
          else:
            body = {}
          for field in updateBody:
            if field not in appendFieldsList:
              body[field] = updateBody[field]
          callGAPI(targetCal.calendars(), 'patch',
                   throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                   calendarId=calId, body=body)
          if showUpdateMessages:
            entityActionPerformed([Ent.CALENDAR, calId], j, jcount)
        except (GAPI.notACalendarUser, GAPI.notFound) as e:
          entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError):
          entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
      Act.Set(Act.RETAIN)
      if retainRoleBody['role'] == 'owner':
        if showRetentionMessages:
          entityActionPerformed([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody['role'])], j, jcount)
      elif retainRoleBody['role'] != 'none':
        try:
          callGAPI(targetCal.acl(), 'patch',
                   throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.INVALID_SCOPE_VALUE, GAPI.ILLEGAL_ACCESS_ROLE_FOR_DEFAULT,
                                 GAPI.CANNOT_CHANGE_OWN_ACL, GAPI.CANNOT_CHANGE_OWNER_ACL, GAPI.FORBIDDEN],
                   calendarId=calId, ruleId=sourceRuleId, body=retainRoleBody, sendNotifications=sendNotifications, fields='')
          if showRetentionMessages:
            entityActionPerformed([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody['role'])], j, jcount)
        except GAPI.notFound as e:
          if not checkCalendarExists(targetCal, calId):
            entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
          else:
            entityActionFailedWarning([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody['role'])], str(e), j, jcount)
        except (GAPI.invalid, GAPI.invalidParameter, GAPI.invalidScopeValue, GAPI.illegalAccessRoleForDefault, GAPI.forbidden, GAPI.cannotChangeOwnAcl, GAPI.cannotChangeOwnerAcl) as e:
          entityActionFailedWarning([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody['role'])], str(e), j, jcount)
      else:
        try:
          callGAPI(targetCal.acl(), 'delete',
                   throwReasons=[GAPI.NOT_FOUND, GAPI.INVALID],
                   calendarId=calId, ruleId=sourceRuleId)
          if showRetentionMessages:
            entityActionPerformed([Ent.CALENDAR, calId, Ent.CALENDAR_ACL, formatACLScopeRole(sourceRuleId, retainRoleBody['role'])], j, jcount)
        except (GAPI.notFound, GAPI.invalid):
          entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
    Ind.Decrement()

def _createImportCalendarEvent(users, function):
  calendarEntity = getUserCalendarEntity()
  body, parameters = _getCalendarCreateImportUpdateEventOptions(function)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_TO)
    if jcount == 0:
      continue
    Ind.Increment()
    _createCalendarEvents(user, cal, function, calIds, jcount, body, parameters)
    Ind.Decrement()

# gam <UserTypeEntity> create|add event <UserCalendarEntity> [id <String>] <EventAddAttribute>+
def createCalendarEvent(users):
  _createImportCalendarEvent(users, 'insert')

# gam <UserTypeEntity> import event <UserCalendarEntity> icaluid <iCalUID> <EventImportAttribute>+
def importCalendarEvent(users):
  _createImportCalendarEvent(users, 'import')

# gam <UserTypeEntity> update events <UserCalendarEntity> [<EventEntity>] [replacemode] <EventUpdateAttribute>+ [<EventNotificationAttribute>]
def updateCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  body, parameters = _getCalendarCreateImportUpdateEventOptions('update')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_IN)
    if jcount == 0:
      continue
    Ind.Increment()
    _updateCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, body, parameters)
    Ind.Decrement()

# gam <UserTypeEntity> delete events <UserCalendarEntity> <EventEntity> [doit] [<EventNotificationAttribute>]
def deleteCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  parameters = _getCalendarDeleteEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _deleteCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, parameters)
    Ind.Decrement()

# gam <UserTypeEntity> purge events <UserCalendarEntity> <EventEntity> [doit] [<EventNotificationAttribute>]
def purgeCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  parameters = _getCalendarDeleteEventOptions()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _purgeCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, parameters, False)
    Ind.Decrement()

# gam <UserTypeEntity> wipe events <UserCalendarEntity>
def wipeCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _wipeCalendarEvents(user, cal, calIds, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> move events <UserCalendarEntity> <EventEntity> to <CalendarItem> [<EventNotificationAttribute>]
def moveCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  checkArgumentPresent('to')
  newCalId = convertUIDtoEmailAddress(getString(Cmd.OB_CALENDAR_ITEM))
  parameters, _ = _getCalendarMoveEventsOptions()
  if not checkCalendarExists(None, newCalId, True):
    return
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM, newCalId=newCalId)
    if jcount == 0:
      continue
    Ind.Increment()
    _moveCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, newCalId, parameters)
    Ind.Decrement()

# gam <UserTypeEntity> empty calendartrash <UserCalendarEntity>
def emptyCalendarTrash(users):
  calendarEntity = getUserCalendarEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    Act.Set(Act.PURGE)
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.TRASHED_EVENT, Act.MODIFIER_FROM)
    if jcount == 0:
      continue
    Ind.Increment()
    _emptyCalendarTrash(user, cal, calIds, jcount)
    Ind.Decrement()

# gam <UserTypeEntity> update calattendees <UserCalendarEntity> <EventEntity> [anyorganizer] [<EventNotificationAttribute>] [doit]
#	(csv <FileName>|(gsheet <UserGoogleSheet>))*
#	(delete <EmailAddress>)*
#	(deleteentity <EmailAddressEntity>)*
#	(add <EmailAddress>)*
#	(addentity <EmailAddressEntity>)*
#	(addstatus [<AttendeeAttendance>] [<AttendeeStatus>] <EmailAddress>)*
#	(addentitystatus [<AttendeeAttendance>] [<AttendeeStatus>] <EmailAddressEntity>)*
#	(replace <EmailAddress> <EmailAddress>)*
#	(replacestatus [<AttendeeAttendance>] [<AttendeeStatus>] <EmailAddress> <EmailAddress>)*
#	(updatestatus [<AttendeeAttendance>] [<AttendeeStatus>] <EmailAddress>)*
#	(updateentitystatus [<AttendeeAttendance>] [<AttendeeStatus>] <EmailAddressEntity>)*
def updateCalendarAttendees(users):
  def getStatus(option):
    if option.endswith('status'):
      return(getChoice(CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP, defaultChoice=None, mapChoice=True),
             getChoice(CALENDAR_ATTENDEE_STATUS_CHOICE_MAP, defaultChoice=None, mapChoice=True))
    return (None, None)

  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  anyOrganizer = doIt = False
  parameters = {'sendUpdates': 'none'}
  attendeeMap = {}
  errors = 0
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'csv':
      errors = 0
      f, csvFile, _ = openCSVFileReader(getString(Cmd.OB_FILE_NAME), fieldnames=['addr', 'op', 'optional', 'status'])
      for row in csvFile:
        updAddr = row['addr']
        updOp = row['op'].lower()
        updOptional = row['optional'].lower()
        updStatus = row['status'].lower()
        if not updAddr and not updOp:
          continue
        if (not updAddr or not updOp or
            (updOptional and updOptional not in CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP) or
            (updStatus and updStatus not in CALENDAR_ATTENDEE_STATUS_CHOICE_MAP)):
          stderrErrorMsg(Msg.INVALID_ATTENDEE_CHANGE.format(','.join([updAddr, updOp, updStatus, updOptional])))
          errors += 1
          continue
        updAddr = normalizeEmailAddressOrUID(updAddr, noUid=True)
        if updOp == 'delete':
          attendeeMap[updAddr] = {'op': updOp, 'done': False}
        else:
          updOptional = CALENDAR_ATTENDEE_OPTIONAL_CHOICE_MAP[updOptional] if updOptional else None
          updStatus = CALENDAR_ATTENDEE_STATUS_CHOICE_MAP[updStatus] if updStatus else None
          if updOp == 'add':
            attendeeMap[updAddr] = {'op': updOp, 'status': updStatus, 'optional': updOptional, 'done': False}
          elif updOp == 'update':
            attendeeMap[updAddr] = {'op': updOp, 'status': updStatus, 'optional': updOptional, 'done': False}
          else: #replace
            attendeeMap[updAddr] = {'op': 'replace', 'status': updStatus, 'optional': updOptional, 'email': normalizeEmailAddressOrUID(updOp, noUid=True), 'done': False}
      closeFile(f)
    elif myarg == 'delete':
      updAddr = getEmailAddress(noUid=True)
      attendeeMap[updAddr] = {'op': 'delete'}
    elif myarg == 'deleteentity':
      for updAddr in getNormalizedEmailAddressEntity(noUid=True):
        attendeeMap[updAddr] = {'op': 'delete'}
    elif myarg in {'add', 'addstatus'}:
      updOptional, updStatus = getStatus(myarg)
      updAddr = getEmailAddress(noUid=True)
      attendeeMap[updAddr] = {'op': 'add', 'status': updStatus, 'optional': updOptional, 'done': False}
    elif myarg in {'addentity', 'addentitystatus'}:
      updOptional, updStatus = getStatus(myarg)
      for updAddr in getNormalizedEmailAddressEntity(noUid=True):
        attendeeMap[updAddr] = {'op': 'add', 'status': updStatus, 'optional': updOptional, 'done': False}
    elif myarg in {'update', 'updatestatus'}:
      updOptional, updStatus = getStatus(myarg)
      updAddr = getEmailAddress(noUid=True)
      attendeeMap[updAddr] = {'op': 'update', 'status': updStatus, 'optional': updOptional, 'done': False}
    elif myarg in {'updateentity', 'updateentitystatus'}:
      updOptional, updStatus = getStatus(myarg)
      for updAddr in getNormalizedEmailAddressEntity(noUid=True):
        attendeeMap[updAddr] = {'op': 'update', 'status': updStatus, 'optional': updOptional, 'done': False}
    elif myarg in {'replace', 'replacestatus'}:
      updOptional, updStatus = getStatus(myarg)
      updAddr = getEmailAddress(noUid=True)
      newAddr = getEmailAddress(noUid=True)
      attendeeMap[updAddr] = {'op': 'replace', 'status': updStatus, 'optional': updOptional, 'email': newAddr, 'done': False}
    elif myarg in {'anyorganizer', 'allevents'}:
      anyOrganizer = True
    elif _getCalendarSendUpdates(myarg, parameters):
      pass
    elif myarg == 'doit':
      doIt = True
    else:
      unknownArgumentExit()
  if not attendeeMap:
    missingArgumentExit(Msg.UPDATE_ATTENDEE_CHANGES)
  ucount = len(attendeeMap)
  if errors:
    systemErrorExit(USAGE_ERROR_RC, '')
  fieldsList = ['attendees', 'id', 'organizer', 'status', 'summary']
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for calId in calIds:
      j += 1
      Act.Set(Act.UPDATE)
      calId, cal, events, kcount = _validateCalendarGetEvents(origUser, user, cal, calId, j, jcount, calendarEventEntity,
                                                              fieldsList, True)
      if kcount == 0:
        continue
      Ind.Increment()
      k = 0
      for event in events:
        k += 1
        eventSummary = event.get('summary', event['id'])
        if event['status'] == 'cancelled':
          entityActionNotPerformedWarning([Ent.EVENT, eventSummary], Msg.EVENT_IS_CANCELED, k, kcount)
          continue
        if not anyOrganizer and not event.get('organizer', {}).get('self'):
          entityActionNotPerformedWarning([Ent.EVENT, eventSummary], Msg.USER_IS_NOT_ORGANIZER, k, kcount)
          continue
        needsUpdate = False
        for _, v in sorted(iter(attendeeMap.items())):
          v['done'] = False
        updatedAttendees = []
        entityPerformActionNumItems([Ent.EVENT, eventSummary], ucount, Ent.ATTENDEE, k, kcount)
        Ind.Increment()
        u = 0
        for attendee in event.get('attendees', []):
          oldAddr = attendee.get('email', '').lower()
          if not oldAddr:
            updatedAttendees.append(attendee)
            continue
          update = attendeeMap.get(oldAddr)
          if not update:
            updatedAttendees.append(attendee)
            continue
          updOp = update['op']
          if updOp == 'delete':
            u += 1
            update['done'] = True
            Act.Set(Act.DELETE)
            entityPerformAction([Ent.EVENT, eventSummary, Ent.ATTENDEE, oldAddr], u, ucount)
            needsUpdate = True
          else:
            oldStatus = attendee.get('responseStatus')
            oldOptional = attendee.get('optional', False)
            updStatus = update['status']
            updOptional = update['optional']
            if updOp in {'add', 'update'}:
              u += 1
              update['done'] = True
              if ((updStatus is not None and updStatus != oldStatus) or
                  (updOptional is not None and updOptional != oldOptional)):
                attendee['responseStatus'] = updStatus if updStatus is not None else oldStatus
                attendee['optional'] = updOptional if updOptional is not None else oldOptional
                Act.Set(Act.UPDATE)
                entityPerformAction([Ent.EVENT, eventSummary, Ent.ATTENDEE, oldAddr], u, ucount)
                needsUpdate = True
              else:
                Act.Set(Act.SKIP)
                entityPerformAction([Ent.EVENT, eventSummary, Ent.ATTENDEE, oldAddr], u, ucount)
              updatedAttendees.append(attendee)
            else: #replace
              u += 1
              update['done'] = True
              attendee['email'] = update['email']
              attendee['responseStatus'] = updStatus if updStatus is not None else oldStatus
              attendee['optional'] = updOptional if updOptional is not None else oldOptional
              Act.Set(Act.REPLACE)
              entityPerformActionModifierNewValue([Ent.EVENT, eventSummary, Ent.ATTENDEE, oldAddr], Act.MODIFIER_WITH, update['email'], u, ucount)
              updatedAttendees.append(attendee)
              needsUpdate = True
        for newAddr, v in sorted(iter(attendeeMap.items())):
          if v['op'] == 'add' and not v['done']:
            u += 1
            v['done'] = True
            attendee = {'email': newAddr}
            if v['status'] is not None:
              attendee['responseStatus'] = v['status']
            if v['optional'] is not None:
              attendee['optional'] = v['optional']
            Act.Set(Act.ADD)
            entityPerformAction([Ent.EVENT, eventSummary, Ent.ATTENDEE, newAddr], u, ucount)
            updatedAttendees.append(attendee)
            needsUpdate = True
        for newAddr, v in sorted(iter(attendeeMap.items())):
          if not v['done']:
            u += 1
            Act.Set(Act.SKIP)
            entityPerformAction([Ent.EVENT, eventSummary, Ent.ATTENDEE, newAddr], u, ucount)
        Ind.Decrement()
        if needsUpdate:
          Act.Set(Act.UPDATE)
          if doIt:
            try:
              callGAPI(cal.events(), 'patch',
                       throwReasons=GAPI.CALENDAR_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID],
                       calendarId=calId, eventId=event['id'], body={'attendees': updatedAttendees},
                       sendUpdates=parameters['sendUpdates'], fields='')
              entityActionPerformed([Ent.EVENT, eventSummary], j, jcount)
            except GAPI.notFound as e:
              if not checkCalendarExists(cal, calId):
                entityUnknownWarning(Ent.CALENDAR, calId, j, jcount)
                break
              entityActionFailedWarning([Ent.CALENDAR, calId, Ent.EVENT, eventSummary], str(e), k, kcount)
            except (GAPI.notACalendarUser, GAPI.forbidden, GAPI.invalid) as e:
              entityActionFailedWarning([Ent.CALENDAR, calId], str(e), j, jcount)
              break
            except (GAPI.serviceNotAvailable, GAPI.authError):
              entityServiceNotApplicableWarning(Ent.CALENDAR, calId, j, jcount)
              break
          else:
            entityActionNotPerformedWarning([Ent.EVENT, eventSummary], Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> info events <UserCalendarEntity> <EventEntity> [maxinstances <Number>]
#	[fields <EventFieldNameList>] [showdayofweek]
#	[formatjson]
def infoCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity()
  FJQC, fieldsList = _getCalendarInfoEventOptions(calendarEventEntity)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_IN, showAction=not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _infoCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity, FJQC, fieldsList)
    Ind.Decrement()

# gam <UserTypeEntity> print events <UserCalendarEntity> <EventEntity> <EventDisplayProperties>*
#	[fields <EventFieldNameList>] [showdayofweek]
#	[countsonly] [formatjson [quotechar <Character>]] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show events <UserCalendarEntity> <EventEntity> <EventDisplayProperties>*
#	[fields <EventFieldNameList>] [showdayofweek]
#	[countsonly] [formatjson]
def printShowCalendarEvents(users):
  calendarEntity = getUserCalendarEntity()
  calendarEventEntity = getCalendarEventEntity(noIds=True)
  csvPF, FJQC, fieldsList = _getCalendarPrintShowEventOptions(calendarEventEntity, Ent.USER)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, cal, calIds, jcount = _validateUserGetCalendarIds(user, i, count, calendarEntity, Ent.EVENT, Act.MODIFIER_FROM,
                                                            showAction=not csvPF and not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    _printShowCalendarEvents(origUser, user, cal, calIds, jcount, calendarEventEntity,
                             csvPF, FJQC, fieldsList)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Calendar Events')

def _getEntityMimeType(fileEntry):
  return Ent.DRIVE_FOLDER if fileEntry['mimeType'] == MIMETYPE_GA_FOLDER else Ent.DRIVE_FILE

def _getTargetEntityMimeType(fileEntry):
  return Ent.DRIVE_FOLDER if fileEntry['shortcutDetails']['targetMimeType'] == MIMETYPE_GA_FOLDER else Ent.DRIVE_FILE

CORPORA_ALL_DRIVES = 'allDrives'
CORPORA_CHOICE_MAP = {
  'alldrives': CORPORA_ALL_DRIVES,
  'allshareddrives': CORPORA_ALL_DRIVES,
  'allteamdrives': CORPORA_ALL_DRIVES,
  'domain': 'domain',
  'onlyshareddrives': CORPORA_ALL_DRIVES,
  'onlyteamdrives': CORPORA_ALL_DRIVES,
  'user': 'user',
  }

QUERY_SHORTCUTS_MAP = {
  'allfiles': f"mimeType != '{MIMETYPE_GA_FOLDER}'",
  'allfolders': f"mimeType = '{MIMETYPE_GA_FOLDER}'",
  'allgooglefiles': f"mimeType != '{MIMETYPE_GA_FOLDER}' and mimeType contains 'vnd.google'",
  'allnongooglefiles': "not mimeType contains 'vnd.google'",
  'allshortcuts': f"mimeType = '{MIMETYPE_GA_SHORTCUT}'",
  'all3pshortcuts': f"mimeType = '{MIMETYPE_GA_3P_SHORTCUT}'",
  'allitems': 'allitems',
  'myfiles': ME_IN_OWNERS_AND+f"mimeType != '{MIMETYPE_GA_FOLDER}'",
  'myfolders': ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_FOLDER}'",
  'mygooglefiles': ME_IN_OWNERS_AND+f"mimeType != '{MIMETYPE_GA_FOLDER}' and mimeType contains 'vnd.google'",
  'mynongooglefiles': ME_IN_OWNERS_AND+"not mimeType contains 'vnd.google'",
  'myshortcuts': ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_SHORTCUT}'",
  'my3pshortcuts': ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_3P_SHORTCUT}'",
  'myitems': ME_IN_OWNERS,
  'othersfiles': NOT_ME_IN_OWNERS_AND+f"mimeType != '{MIMETYPE_GA_FOLDER}'",
  'othersfolders': NOT_ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_FOLDER}'",
  'othersgooglefiles': NOT_ME_IN_OWNERS_AND+f"mimeType != '{MIMETYPE_GA_FOLDER}' and mimeType contains 'vnd.google'",
  'othersnongooglefiles': NOT_ME_IN_OWNERS_AND+"not mimeType contains 'vnd.google'",
  'othersshortcuts': NOT_ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_SHORTCUT}'",
  'others3pshortcuts': NOT_ME_IN_OWNERS_AND+f"mimeType = '{MIMETYPE_GA_3P_SHORTCUT}'",
  'othersitems': NOT_ME_IN_OWNERS,
  'writablefiles': f"'me' in writers and mimeType != '{MIMETYPE_GA_FOLDER}'",
  }
TEAMDRIVE_QUERY_SHORTCUTS_MAP = {
  'allfiles': f"mimeType != '{MIMETYPE_GA_FOLDER}'",
  'allfolders': f"mimeType = '{MIMETYPE_GA_FOLDER}'",
  'allgooglefiles': f"mimeType != '{MIMETYPE_GA_FOLDER}' and mimeType contains 'vnd.google'",
  'allnongooglefiles': "not mimeType contains 'vnd.google'",
  'allitems': 'allitems',
  }

def doDriveSearch(drive, user, i, count, query=None, parentQuery=False, emptyQueryOK=False, orderBy=None, teamDriveOnly=False, **kwargs):
  if query == 'allitems':
    query = None
  if GC.Values[GC.SHOW_GETTINGS]:
    printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
  try:
    files = callGAPIpages(drive.files(), 'list', 'files',
                          pageMessage=getPageMessageForWhom(),
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.FILE_NOT_FOUND, GAPI.NOT_FOUND],
                          retryReasons=[GAPI.UNKNOWN_ERROR],
                          q=query, orderBy=orderBy, fields='nextPageToken,files(id,driveId)', pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **kwargs)
    if files or not parentQuery:
      return [f_file['id'] for f_file in files if not teamDriveOnly or f_file.get('driveId')]
    if emptyQueryOK:
      return []
    entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, None],
                                    emptyQuery(query, Ent.DRIVE_FILE_OR_FOLDER if not parentQuery else Ent.DRIVE_PARENT_FOLDER), i, count)
  except (GAPI.invalidQuery, GAPI.invalid):
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, None], invalidQuery(query), i, count)
  except GAPI.fileNotFound:
    printGotEntityItemsForWhom(0)
    if emptyQueryOK:
      return []
  except GAPI.notFound as e:
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, kwargs['driveId']], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def doTeamDriveSearch(drive, user, i, count, query, useDomainAdminAccess):
  if GC.Values[GC.SHOW_GETTINGS]:
    printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query=query)
  try:
    files = callGAPIpages(drive.drives(), 'list', 'drives',
                          pageMessage=getPageMessageForWhom(),
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID,
                                                                      GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS,
                                                                      GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                          q=query, useDomainAdminAccess=useDomainAdminAccess,
                          fields='nextPageToken,drives(id)', pageSize=100)
    if files:
      return [f_file['id'] for f_file in files]
    entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], emptyQuery(query, Ent.TEAMDRIVE), i, count)
  except (GAPI.invalidQuery, GAPI.invalid):
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], invalidQuery(query), i, count)
  except (GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def cleanFileIDsList(fileIdEntity, fileIds):
  def _getFileIdFromURL(fileId):
    loc = fileId.find('/d/')
    if loc > 0:
      fileId = fileId[loc+3:]
      loc = fileId.find('/')
      return fileId[:loc] if loc != -1 else fileId
    loc = fileId.find('?id=')
    if loc > 0:
      fileId = fileId[loc+4:]
      loc = fileId.find('&')
      return fileId[:loc] if loc != -1 else fileId
    loc = fileId.find('/files/')
    if loc > 0:
      fileId = fileId[loc+7:]
      loc = fileId.find('&')
      return fileId[:loc] if loc != -1 else fileId
    loc = fileId.find('/folders/')
    if loc > 0:
      fileId = fileId[loc+9:]
      loc = fileId.find('&')
      return fileId[:loc] if loc != -1 else fileId
    return None

  fileIdEntity['list'] = []
  fileIdEntity[ROOT] = []
  i = 0
  for fileId in fileIds:
    if fileId[:8].lower() == 'https://' or fileId[:7].lower() == 'http://':
      fileId = _getFileIdFromURL(fileId)
      if fileId is None:
        continue
    elif fileId.lower() == ROOT:
      fileIdEntity[ROOT].append(i)
      fileId = fileId.lower()
    fileIdEntity['list'].append(fileId)
    i += 1

TITLE_QUERY_PATTERN = re.compile(r'title((?: *!?=)|(?: +contains))', flags=re.IGNORECASE)

def _mapDrive2QueryToDrive3(query):
  if query:
    query = TITLE_QUERY_PATTERN.sub(r'name\1', query).replace('modifiedDate', 'modifiedTime').replace('lastViewedByMeDate', 'viewedByMeTime')
  return query

def escapeDriveFileName(filename):
  if filename.find("'") == -1 and filename.find('\\') == -1:
    return filename
  encfilename = ''
  for c in filename:
    if c == "'":
      encfilename += "\\'"
    elif c == '\\':
      encfilename += '\\\\'
    else:
      encfilename += c
  return encfilename

def getEscapedDriveFileName():
  return escapeDriveFileName(getString(Cmd.OB_DRIVE_FILE_NAME))

def getEscapedDriveFolderName():
  return escapeDriveFileName(getString(Cmd.OB_DRIVE_FOLDER_NAME))

def initDriveFileEntity():
  return {'list': [], 'teamdrivename': None, 'teamdriveadminquery': None, 'query': None, 'teamdrivefilequery': None, 'dict': None, ROOT: [], 'teamdrive': {}}

DRIVE_BY_NAME_CHOICE_MAP = {
  'anyname': WITH_ANY_FILE_NAME,
  'anydrivefilename': WITH_ANY_FILE_NAME,
  'anyownername': WITH_ANY_FILE_NAME,
  'anyownerdrivefilename': WITH_ANY_FILE_NAME,
  'sharedname': WITH_ANY_FILE_NAME,
  'shareddrivefilename': WITH_ANY_FILE_NAME,
  'name': WITH_MY_FILE_NAME,
  'drivefilename': WITH_MY_FILE_NAME,
  'othername': WITH_OTHER_FILE_NAME,
  'otherdrivefilename': WITH_ANY_FILE_NAME,
  }

LOCATION_ALL_DRIVES = 0
LOCATION_MYDRIVE = 1
LOCATION_ORPHANS = 2
LOCATION_OWNEDBY_ANY = 3
LOCATION_OWNEDBY_OTHERS = 4
LOCATION_SHARED_WITHME = 5
LOCATION_ONLY_SHARED_DRIVES = 6

LOCATION_CHOICE_MAP = {
  'alldrives': {'fileids': [ROOT, ORPHANS, SHARED_WITHME, SHARED_DRIVES], 'owner': None, 'location': LOCATION_ALL_DRIVES, 'setShowOwnedBy': True},
  'root': {'fileids': [ROOT], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': False},
  'rootwithorphans': {'fileids': [ROOT, ORPHANS], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': False},
  'mydrive': {'fileids': [ROOT], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': False},
  'mydrivewithorphans': {'fileids': [ROOT, ORPHANS], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': False},
  'mydriveany': {'fileids': [ROOT, ORPHANS], 'owner': None, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': True},
  'mydriveme': {'fileids': [ROOT, ORPHANS], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': True},
  'mydriveothers': {'fileids': [ROOT], 'owner': False, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': True},
  'onlyshareddrives': {'fileids': [SHARED_DRIVES], 'owner': False, 'location': LOCATION_ONLY_SHARED_DRIVES, 'setShowOwnedBy': True},
  'onlyteamdrives': {'fileids': [SHARED_DRIVES], 'owner': False, 'location': LOCATION_ONLY_SHARED_DRIVES, 'setShowOwnedBy': True},
  'orphans': {'fileids': [ORPHANS], 'owner': True, 'location': LOCATION_ORPHANS, 'setShowOwnedBy': True},
  'ownedbyany': {'fileids': [ROOT, ORPHANS, SHARED_WITHME], 'owner': None, 'location': LOCATION_OWNEDBY_ANY, 'setShowOwnedBy': True},
  'ownedbyme': {'fileids': [ROOT, ORPHANS], 'owner': True, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': True},
  'ownedbyothers': {'fileids': [ROOT, SHARED_WITHME], 'owner': False, 'location': LOCATION_OWNEDBY_OTHERS, 'setShowOwnedBy': True},
  'sharedwithme': {'fileids': [ROOT, SHARED_WITHME], 'owner': False, 'location': LOCATION_OWNEDBY_OTHERS, 'setShowOwnedBy': True},
  'sharedwithmemydrive': {'fileids': [ROOT], 'owner': False, 'location': LOCATION_MYDRIVE, 'setShowOwnedBy': True},
  'sharedwithmenotmydrive': {'fileids': [SHARED_WITHME], 'owner': False, 'location': LOCATION_SHARED_WITHME, 'setShowOwnedBy': True},
  }

def getDriveFileEntity(queryShortcutsOK=True, DLP=None):
  def _getKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(':', 1)
    kw = kw.lower().replace('_', '').replace('-', '')
    if kw == 'id':
      cleanFileIDsList(fileIdEntity, [value])
    elif kw == 'ids':
      cleanFileIDsList(fileIdEntity, value.replace(',', ' ').split())
    elif kw == 'query':
      fileIdEntity['query'] = _mapDrive2QueryToDrive3(value)
    elif kw in DRIVE_BY_NAME_CHOICE_MAP:
      fileIdEntity['query'] = DRIVE_BY_NAME_CHOICE_MAP[kw].format(escapeDriveFileName(value))
    else:
      return False
    return True

  def _getTDKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(':', 1)
    kw = kw.lower().replace('_', '').replace('-', '')
    if kw in {'teamdriveid', 'shareddriveid'}:
      fileIdEntity['teamdrive']['driveId'] = value
    elif kw in {'teamdrive', 'shareddrive'}:
      fileIdEntity['teamdrivename'] = value
    elif kw in {'teamdriveadminquery', 'shareddriveadminquery'}:
      fileIdEntity['teamdriveadminquery'] = value
    elif kw in {'teamdrivefilename', 'shareddrivefilename'}:
      fileIdEntity['teamdrivefilequery'] = WITH_ANY_FILE_NAME.format(escapeDriveFileName(value))
    elif kw in {'teamdrivequery', 'shareddrivequery'}:
      fileIdEntity['teamdrivefilequery'] = _mapDrive2QueryToDrive3(value)
    else:
      return False
    return True

  fileIdEntity = initDriveFileEntity()
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      fileIdEntity['dict'] = entityList
    else:
      cleanFileIDsList(fileIdEntity, entityList)
  else:
    myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
    mycmd = myarg.lower().replace('_', '').replace('-', '')
    if mycmd == 'id':
      cleanFileIDsList(fileIdEntity, getStringReturnInList(Cmd.OB_DRIVE_FILE_ID))
    elif mycmd == 'ids':
      cleanFileIDsList(fileIdEntity, getString(Cmd.OB_DRIVE_FILE_ID).replace(',', ' ').split())
    elif mycmd == 'query':
      fileIdEntity['query'] = _mapDrive2QueryToDrive3(getString(Cmd.OB_QUERY))
    elif queryShortcutsOK and mycmd in QUERY_SHORTCUTS_MAP:
      fileIdEntity['query'] = QUERY_SHORTCUTS_MAP[mycmd]
    elif mycmd in DRIVE_BY_NAME_CHOICE_MAP:
      fileIdEntity['query'] = DRIVE_BY_NAME_CHOICE_MAP[mycmd].format(getEscapedDriveFileName())
    elif not DLP and mycmd in {'root', 'mydrive'}:
      cleanFileIDsList(fileIdEntity, [ROOT])
    elif DLP and mycmd in LOCATION_CHOICE_MAP:
      DLP.SetLocation(LOCATION_CHOICE_MAP[mycmd])
      cleanFileIDsList(fileIdEntity, DLP.locationFileIds)
    elif mycmd.startswith('teamdrive') or mycmd.startswith('shareddrive'):
      fileIdEntity['teamdrive'] = {'driveId': None,
                                   'corpora': 'drive', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
      while True:
        if mycmd in {'teamdriveid', 'shareddriveid'}:
          fileIdEntity['teamdrive']['driveId'] = getString(Cmd.OB_TEAMDRIVE_ID)
        elif mycmd in {'teamdrive', 'shareddrive'}:
          fileIdEntity['teamdrivename'] = getString(Cmd.OB_TEAMDRIVE_NAME)
        elif mycmd in {'teamdriveadminquery', 'shareddriveadminquery'}:
          fileIdEntity['teamdriveadminquery'] = getString(Cmd.OB_QUERY)
        elif mycmd in {'teamdrivefilename', 'shareddrivefilename'}:
          fileIdEntity['teamdrivefilequery'] = WITH_ANY_FILE_NAME.format(getEscapedDriveFileName())
        elif mycmd in {'teamdrivequery', 'shareddrivequery'}:
          fileIdEntity['teamdrivefilequery'] = _mapDrive2QueryToDrive3(getString(Cmd.OB_QUERY))
        elif queryShortcutsOK and mycmd in TEAMDRIVE_QUERY_SHORTCUTS_MAP:
          fileIdEntity['teamdrivefilequery'] = TEAMDRIVE_QUERY_SHORTCUTS_MAP[mycmd]
        elif (mycmd.find(':') > 0) and _getTDKeywordColonValue(myarg):
          pass
        else:
          unknownArgumentExit()
        if Cmd.ArgumentsRemaining():
          myarg = getString(Cmd.OB_STRING)
          mycmd = myarg.lower().replace('_', '').replace('-', '')
          if (mycmd.startswith('teamdriveparent') or mycmd.startswith('shareddriveparent') or
              ((not (mycmd.startswith('teamdrive') or mycmd.startswith('shareddrive'))) and
               (not (queryShortcutsOK and mycmd in TEAMDRIVE_QUERY_SHORTCUTS_MAP)))):
            Cmd.Backup()
            break
        else:
          break
      if not fileIdEntity['teamdrive'].get('driveId'):
        fileIdEntity['teamdrive']['corpora'] = CORPORA_ALL_DRIVES
    elif (mycmd.find(':') > 0) and _getKeywordColonValue(myarg):
      pass
    else:
      cleanFileIDsList(fileIdEntity, [myarg])
  return fileIdEntity

def getDriveFileEntityTeamDriveOnly():
  def _getTDKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(':', 1)
    kw = kw.lower().replace('_', '').replace('-', '')
    if kw in {'teamdriveid', 'shareddriveid'}:
      fileIdEntity['teamdrive']['driveId'] = value
    elif kw in {'teamdrive', 'shareddrive'}:
      fileIdEntity['teamdrivename'] = value
    elif kw in {'teamdriveadminquery', 'shareddriveadminquery'}:
      fileIdEntity['teamdriveadminquery'] = value
    else:
      return False
    return True

  fileIdEntity = initDriveFileEntity()
  myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  mycmd = myarg.lower().replace('_', '').replace('-', '')
  if mycmd.startswith('teamdrive') or mycmd.startswith('shareddrive'):
    fileIdEntity['teamdrive'] = {'driveId': None,
                                 'corpora': 'drive', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
    if mycmd in {'teamdriveid', 'shareddriveid'}:
      fileIdEntity['teamdrive']['driveId'] = getString(Cmd.OB_TEAMDRIVE_ID)
    elif mycmd in {'teamdrive', 'shareddrive'}:
      fileIdEntity['teamdrivename'] = getString(Cmd.OB_TEAMDRIVE_NAME)
    elif mycmd in {'teamdriveadminquery', 'shareddriveadminquery'}:
      fileIdEntity['teamdriveadminquery'] = getString(Cmd.OB_QUERY)
    elif (mycmd.find(':') > 0) and _getTDKeywordColonValue(myarg):
      pass
    else:
      unknownArgumentExit()
    if not fileIdEntity['teamdrive'].get('driveId'):
      fileIdEntity['teamdrive']['corpora'] = CORPORA_ALL_DRIVES
  elif (mycmd.find(':') > 0) and _getTDKeywordColonValue(myarg):
    pass
  else:
    unknownArgumentExit()
  return fileIdEntity

def getTeamDriveEntity():
  def _getTDKeywordColonValue(kwColonValue):
    kw, value = kwColonValue.split(':', 1)
    kw = kw.lower().replace('_', '').replace('-', '')
    if kw in {'teamdriveid', 'shareddriveid'}:
      fileIdEntity['teamdrive']['driveId'] = value
    elif kw in {'teamdrive', 'shareddrive'}:
      fileIdEntity['teamdrivename'] = value
    else:
      return False
    return True

  fileIdEntity = initDriveFileEntity()
  myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  mycmd = myarg.lower().replace('_', '').replace('-', '')
  fileIdEntity['teamdrive'] = {'driveId': None,
                               'corpora': 'drive', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
  if mycmd in {'teamdriveid', 'shareddriveid'}:
    fileIdEntity['teamdrive']['driveId'] = getString(Cmd.OB_TEAMDRIVE_ID)
  elif mycmd in {'teamdrive', 'shareddrive'}:
    fileIdEntity['teamdrivename'] = getString(Cmd.OB_TEAMDRIVE_NAME)
  elif (mycmd.find(':') > 0) and _getTDKeywordColonValue(myarg):
    pass
  else:
    fileIdEntity['teamdrive']['driveId'] = myarg
  return fileIdEntity

def _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity, useDomainAdminAccess=False):
  try:
    feed = callGAPIpages(drive.drives(), 'list', 'drives',
                         throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                         #q=f"name = '{fileIdEntity['teamdrivename']}'",
                         useDomainAdminAccess=useDomainAdminAccess,
                         fields='nextPageToken,drives(id,name)', pageSize=100)
    tddrivenamelower = fileIdEntity['teamdrivename'].lower()
    for td in feed:
      if td['name'].lower() == tddrivenamelower:
        fileIdEntity['teamdrive']['driveId'] = td['id']
#        fileIdEntity['teamdrivename'] = None
        return True
  except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    pass
  entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_NAME, fileIdEntity['teamdrivename']], Msg.DOES_NOT_EXIST, i, count)
  return False

def _getTeamDriveNameFromId(drive, teamDriveId):
  try:
    return callGAPI(drive.drives(), 'get',
                    throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                    driveId=teamDriveId, fields='name')['name']
  except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    return TEAM_DRIVE

def _getDriveFileNameFromId(drive, fileId, combineTitleId=True, useDomainAdminAccess=False):
  try:
    result = callGAPI(drive.files(), 'get',
                      throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                      fileId=fileId, fields='name,mimeType,driveId', supportsAllDrives=True)
    if result:
      fileName = result['name']
      if (result['mimeType'] == MIMETYPE_GA_FOLDER) and (result['name'] == TEAM_DRIVE) and result.get('driveId'):
        fileName = _getTeamDriveNameFromId(drive, result['driveId'])
      if combineTitleId:
        fileName += '('+fileId+')'
      return (fileName, _getEntityMimeType(result))
  except GAPI.fileNotFound:
    if useDomainAdminAccess:
      try:
        result = callGAPI(drive.drives(), 'get',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                          useDomainAdminAccess=useDomainAdminAccess,
                          driveId=fileId, fields='name')
        if result:
          fileName = result['name']
          if combineTitleId:
            fileName += '('+fileId+')'
          return (fileName, Ent.DRIVE_FOLDER)
      except GAPI.notFound:
        pass
  except (GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.internalError,
          GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
    pass
  return (fileId, Ent.DRIVE_FILE_OR_FOLDER_ID)

def _simpleFileIdEntityList(fileIdEntityList):
  for fileId in fileIdEntityList:
    if fileId not in {ROOT, ORPHANS, SHARED_WITHME, SHARED_DRIVES}:
      return False
  return True

def _validateUserGetFileIDs(user, i, count, fileIdEntity, drive=None, entityType=None, orderBy=None, useDomainAdminAccess=False):
  def _identifyRoot():
    try:
      rootFolderId = callGAPI(drive.files(), 'get',
                              throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fileId=ROOT, fields='id')['id']
      for j in fileIdEntity[ROOT]:
        fileIdEntity['list'][j] = rootFolderId
      return True
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return False

  if fileIdEntity['dict']:
    cleanFileIDsList(fileIdEntity, fileIdEntity['dict'][user])
  if not drive:
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      return (user, None, 0)
  else:
    user = convertUIDtoEmailAddress(user)
  if fileIdEntity['list'] and _simpleFileIdEntityList(fileIdEntity['list']):
    l = len(fileIdEntity['list'])
    if ROOT in fileIdEntity['list'] and fileIdEntity[ROOT]:
      if not _identifyRoot():
        return (user, None, 0)
    if entityType:
      entityPerformActionNumItems([Ent.USER, user], l, entityType, i, count)
    return (user, drive, l)
  if fileIdEntity['teamdrivename'] and 'driveId' not in fileIdEntity:
    if not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity, useDomainAdminAccess):
      return (user, None, 0)
    if not fileIdEntity['teamdrivefilequery']:
      fileIdEntity['list'] = [fileIdEntity['teamdrive']['driveId']]
    fileIdEntity['teamdrive']['corpora'] = 'drive'
  elif fileIdEntity['teamdrive'].get('driveId'):
    if not fileIdEntity['teamdrivefilequery']:
      fileIdEntity['list'] = [fileIdEntity['teamdrive']['driveId']]
    fileIdEntity['teamdrive']['corpora'] = 'drive'
  if fileIdEntity['query']:
    fileIdEntity['list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity['query'], orderBy=orderBy)
    if fileIdEntity['list'] is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
  elif fileIdEntity['teamdriveadminquery']:
    fileIdEntity['list'] = doTeamDriveSearch(drive, user, i, count, fileIdEntity['teamdriveadminquery'], useDomainAdminAccess)
    if fileIdEntity['list'] is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
  elif fileIdEntity['teamdrivefilequery']:
    if not fileIdEntity['teamdrive'].get('driveId'):
      fileIdEntity['teamdrive']['corpora'] = CORPORA_ALL_DRIVES
    fileIdEntity['list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity['teamdrivefilequery'], orderBy=orderBy, teamDriveOnly=True, **fileIdEntity['teamdrive'])
    if fileIdEntity['list'] is None or not fileIdEntity['list']:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
    fileIdEntity['teamdrive'].pop('driveId', None)
    fileIdEntity['teamdrive'].pop('corpora', None)
  elif fileIdEntity[ROOT]:
    if not _identifyRoot():
      return (user, None, 0)
  l = len(fileIdEntity['list'])
  if l == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if entityType:
    entityPerformActionNumItems([Ent.USER, user], l, entityType, i, count)
  return (user, drive, l)

def _getDriveFileParentInfo(drive, user, i, count, body, parameters, emptyQueryOK=False, defaultToRoot=True):
  body.pop('parents', None)
  if parameters[DFA_PARENTID]:
    body.setdefault('parents', [])
    try:
      result = callGAPI(drive.files(), 'get',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                        fileId=parameters[DFA_PARENTID], fields='id,mimeType', supportsAllDrives=True)
      if result['mimeType'] != MIMETYPE_GA_FOLDER:
        entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                        f'parentid: {parameters[DFA_PARENTID]}, {Msg.NOT_AN_ENTITY.format((Ent.Singular(Ent.DRIVE_FOLDER)))}', i, count)
        return False
      body['parents'].append(result['id'])
    except GAPI.fileNotFound as e:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                      f'parentid: {parameters[DFA_PARENTID]}, {str(e)}', i, count)
      return False
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return False
  if parameters[DFA_PARENTQUERY]:
    parents = doDriveSearch(drive, user, i, count, query=parameters[DFA_PARENTQUERY], parentQuery=True, emptyQueryOK=emptyQueryOK)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return False
    body.setdefault('parents', [])
    for parent in parents:
      body['parents'].append(parent)
  if parameters[DFA_TEAMDRIVE_PARENTID]:
    try:
      if not parameters[DFA_TEAMDRIVE_PARENTQUERY]:
        body.setdefault('parents', [])
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                          fileId=parameters[DFA_TEAMDRIVE_PARENTID], fields='id,mimeType,driveId', supportsAllDrives=True)
        if result['mimeType'] != MIMETYPE_GA_FOLDER:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                          f'fteamdriveparentid: {parameters[DFA_TEAMDRIVE_PARENTID]}, {Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER))}', i, count)
          return False
        if not result.get('driveId'):
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                          f'teamdriveparentid: {parameters[DFA_TEAMDRIVE_PARENTID]}, {Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.TEAMDRIVE_FOLDER))}', i, count)
          return False
        body['parents'].append(result['id'])
        parameters[DFA_SEARCHARGS] = {'driveId': result['driveId'], 'corpora': 'drive',
                                      'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
      else:
        result = callGAPI(drive.drives(), 'get',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                          driveId=parameters[DFA_TEAMDRIVE_PARENTID], fields='id')
        parameters[DFA_KWARGS]['corpora'] = 'drive'
        parameters[DFA_KWARGS]['driveId'] = result['id']
        parameters[DFA_SEARCHARGS] = {'driveId': result['id'], 'corpora': 'drive',
                                      'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
    except (GAPI.fileNotFound, GAPI.notFound) as e:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None],
                                      f'teamdriveparentid: {parameters[DFA_TEAMDRIVE_PARENTID]}, {str(e)}', i, count)
      return False
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return False
  if parameters[DFA_TEAMDRIVE_PARENT]:
    tempIdEntity = {'teamdrivename': parameters[DFA_TEAMDRIVE_PARENT], 'teamdrive': {}}
    if not _convertTeamDriveNameToId(drive, user, i, count, tempIdEntity):
      return False
    if not parameters[DFA_TEAMDRIVE_PARENTQUERY]:
      body.setdefault('parents', [])
      body['parents'].append(tempIdEntity['teamdrive']['driveId'])
    else:
      parameters[DFA_KWARGS]['corpora'] = 'drive'
      parameters[DFA_KWARGS]['driveId'] = tempIdEntity['teamdrive']['driveId']
    parameters[DFA_SEARCHARGS] = {'driveId': tempIdEntity['teamdrive']['driveId'], 'corpora': 'drive',
                                  'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
  if parameters[DFA_TEAMDRIVE_PARENTQUERY]:
    parents = doDriveSearch(drive, user, i, count, query=parameters[DFA_TEAMDRIVE_PARENTQUERY], parentQuery=True, emptyQueryOK=emptyQueryOK,
                            teamDriveOnly=True, **parameters[DFA_KWARGS])
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return False
    body.setdefault('parents', [])
    for parent in parents:
      body['parents'].append(parent)
  if defaultToRoot and ('parents' not in body or not body['parents']):
    body['parents'] = [ROOT]
  return True

def _getDriveFileAddRemoveParentInfo(user, i, count, parameters, drive):
  addParents = parameters[DFA_ADD_PARENT_IDS][:]
  for query in parameters[DFA_ADD_PARENT_NAMES]:
    parents = doDriveSearch(drive, user, i, count, query=query, parentQuery=True)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (False, None, None)
    addParents.extend(parents)
  removeParents = parameters[DFA_REMOVE_PARENT_IDS][:]
  for query in parameters[DFA_REMOVE_PARENT_NAMES]:
    parents = doDriveSearch(drive, user, i, count, query=query, parentQuery=True)
    if parents is None:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (False, None, None)
    removeParents.extend(parents)
  return (True, addParents, removeParents)

def _validateUserGetTeamDriveFileIDs(user, i, count, fileIdEntity, drive=None, entityType=None):
  if fileIdEntity['dict']:
    cleanFileIDsList(fileIdEntity, fileIdEntity['dict'][user])
  if not drive:
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      return (user, None, 0)
  else:
    user = convertUIDtoEmailAddress(user)
  if fileIdEntity.get('teamdrivename') and not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity):
    return (user, None, 0)
  if fileIdEntity['teamdrivefilequery']:
    fileIdEntity['list'] = doDriveSearch(drive, user, i, count, query=fileIdEntity['teamdrivefilequery'], teamDriveOnly=True, **fileIdEntity['teamdrive'])
    if fileIdEntity['list'] is None or not fileIdEntity['list']:
      setSysExitRC(NO_ENTITIES_FOUND)
      return (user, None, 0)
    fileIdEntity['teamdrive'].pop('driveId', None)
    fileIdEntity['teamdrive'].pop('corpora', None)
  l = len(fileIdEntity['list'])
  if l == 0:
    setSysExitRC(NO_ENTITIES_FOUND)
  if entityType:
    entityPerformActionNumItems([Ent.USER, user], l, entityType, i, count)
  return (user, drive, l)

def _validateUserTeamDrive(user, i, count, fileIdEntity, useDomainAdminAccess=False):
  user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
  if not drive:
    return (user, None)
  if fileIdEntity.get('teamdrivename'):
    if not _convertTeamDriveNameToId(drive, user, i, count, fileIdEntity, useDomainAdminAccess):
      return (user, None)
    fileIdEntity['teamdrive']['corpora'] = 'drive'
  return (user, drive)

DRIVE_LABEL_CHOICE_MAP = {
  'modified': 'modifiedByMe',
  'modifiedbyme': 'modifiedByMe',
  'restrict': 'copyRequiresWriterPermission',
  'restricted': 'copyRequiresWriterPermission',
  'star': 'starred',
  'starred': 'starred',
  'trash': 'trashed',
  'trashed': 'trashed',
  'view': 'viewedByMe',
  'viewed': 'viewedByMe',
  'viewedbyme': 'viewedByMe',
  }

MIMETYPE_CHOICE_MAP = {
  'gdoc': MIMETYPE_GA_DOCUMENT,
  'gdocument': MIMETYPE_GA_DOCUMENT,
  'gdrawing': MIMETYPE_GA_DRAWING,
  'gfile': MIMETYPE_GA_FILE,
  'gfolder': MIMETYPE_GA_FOLDER,
  'gdirectory': MIMETYPE_GA_FOLDER,
  'gform': MIMETYPE_GA_FORM,
  'gfusion': MIMETYPE_GA_FUSIONTABLE,
  'gfusiontable': MIMETYPE_GA_FUSIONTABLE,
  'gmap': MIMETYPE_GA_MAP,
  'gpresentation': MIMETYPE_GA_PRESENTATION,
  'gscript': MIMETYPE_GA_SCRIPT,
  'gshortcut': MIMETYPE_GA_SHORTCUT,
  'g3pshortcut': MIMETYPE_GA_3P_SHORTCUT,
  'gsite': MIMETYPE_GA_SITE,
  'gsheet': MIMETYPE_GA_SPREADSHEET,
  'gspreadsheet': MIMETYPE_GA_SPREADSHEET,
  }

MIMETYPE_TYPES = ['application', 'audio', 'font', 'image', 'message', 'model', 'multipart', 'text', 'video']

def validateMimeType(mimeType):
  if mimeType in MIMETYPE_CHOICE_MAP:
    return MIMETYPE_CHOICE_MAP[mimeType]
  if mimeType.startswith(APPLICATION_VND_GOOGLE_APPS):
    return mimeType
  if mimeType.find('/') > 0:
    mediaType, subType = mimeType.split('/', 1)
    if mediaType in MIMETYPE_TYPES and subType:
      return mimeType
  invalidChoiceExit(mimeType, list(MIMETYPE_CHOICE_MAP)+[f'({formatChoiceList(MIMETYPE_TYPES)})/mediatype'], True)

def getMimeType():
  return validateMimeType(getString(Cmd.OB_MIMETYPE).lower())

class MimeTypeCheck():

  def __init__(self):
    self.mimeTypes = set()
    self.reverse = False

  def Get(self):
    self.reverse = checkArgumentPresent('not')
    for mimeType in getString(Cmd.OB_MIMETYPE_LIST).lower().replace(',', ' ').split():
      self.mimeTypes.add(validateMimeType(mimeType))

  def AddMimeTypeToQuery(self, query):
    if query:
      query += ' and ('
    else:
      query = '('
    if not self.reverse:
      for mimeType in self.mimeTypes:
        query += f"mimeType = '{mimeType}' or "
      query = query[:-4]
    else:
      for mimeType in self.mimeTypes:
        query += f"mimeType != '{mimeType}' and "
      query = query[:-5]
    query += ')'
    return query

  def Check(self, fileEntry):
    if not self.mimeTypes:
      return True
    if not self.reverse:
      return fileEntry['mimeType'] in self.mimeTypes
    return fileEntry['mimeType'] not in self.mimeTypes

def initDriveFileAttributes():
  return {DFA_CREATED_TIME: None,
          DFA_MODIFIED_TIME: None,
          DFA_PRESERVE_FILE_TIMES: False,
          DFA_IGNORE_DEFAULT_VISIBILITY: False,
          DFA_KEEP_REVISION_FOREVER: False,
          DFA_LOCALFILEPATH: None,
          DFA_LOCALFILENAME: None,
          DFA_LOCALMIMETYPE: None,
          DFA_OCRLANGUAGE: None,
          DFA_ENFORCE_SINGLE_PARENT: False,
          DFA_PARENTID: None,
          DFA_PARENTQUERY: None,
          DFA_ADD_PARENT_IDS: [],
          DFA_ADD_PARENT_NAMES: [],
          DFA_REMOVE_PARENT_IDS: [],
          DFA_REMOVE_PARENT_NAMES: [],
          DFA_TEAMDRIVE_PARENT: None,
          DFA_TEAMDRIVE_PARENTID: None,
          DFA_TEAMDRIVE_PARENTQUERY: None,
          DFA_KWARGS: {},
          DFA_SEARCHARGS: {},
          DFA_USE_CONTENT_AS_INDEXABLE_TEXT: False}

DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP = {
  'private': 'appProperties',
  'public': 'properties'
  }

def getDriveFileProperty(visibility=None):
  key = getString(Cmd.OB_PROPERTY_KEY)
  value = getString(Cmd.OB_PROPERTY_VALUE, minLen=0) or None
  if visibility is None:
    if Cmd.PeekArgumentPresent(DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP):
      visibility = getChoice(DRIVEFILE_PROPERTY_VISIBILITY_CHOICE_MAP, mapChoice=True)
    else:
      visibility = 'properties'
  return {'key': key, 'value': value, 'visibility': visibility}

def getDriveFileParentAttribute(myarg, parameters):
  if myarg == 'parentid':
    parameters[DFA_PARENTID] = getString(Cmd.OB_DRIVE_FOLDER_ID)
  elif myarg == 'parentname':
    parameters[DFA_PARENTQUERY] = MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
  elif myarg in {'anyownerparentname', 'sharedparentname'}:
    parameters[DFA_PARENTQUERY] = ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
  elif myarg in {'teamdriveparent', 'shareddriveparent'}:
    parameters[DFA_TEAMDRIVE_PARENT] = getString(Cmd.OB_TEAMDRIVE_NAME)
  elif myarg in {'teamdriveparentid', 'shareddriveparentid'}:
    parameters[DFA_TEAMDRIVE_PARENTID] = getString(Cmd.OB_DRIVE_FOLDER_ID)
  elif myarg in {'teamdriveparentname', 'shareddriveparentname'}:
    parameters[DFA_TEAMDRIVE_PARENTQUERY] = ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName())
    parameters[DFA_KWARGS]['corpora'] = CORPORA_ALL_DRIVES
    parameters[DFA_KWARGS]['includeItemsFromAllDrives'] = True
    parameters[DFA_KWARGS]['supportsAllDrives'] = True
  elif myarg == 'enforcesingleparent':
    parameters[DFA_ENFORCE_SINGLE_PARENT] = getBoolean(defaultValue=None)
  else:
    return False
  return True

def getDriveFileAddRemoveParentAttribute(myarg, parameters):
  if myarg in {'addparent', 'addparents'}:
    parameters[DFA_ADD_PARENT_IDS].extend(getString(Cmd.OB_DRIVE_FOLDER_ID_LIST).replace(',', ' ').split())
  elif myarg in {'removeparent', 'removeparents'}:
    parameters[DFA_REMOVE_PARENT_IDS].extend(getString(Cmd.OB_DRIVE_FOLDER_ID_LIST).replace(',', ' ').split())
  elif myarg == 'addparentname':
    parameters[DFA_ADD_PARENT_NAMES].append(MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg == 'removeparentname':
    parameters[DFA_REMOVE_PARENT_NAMES].append(MY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg in {'addanyownerparentname', 'addsharedparentname'}:
    parameters[DFA_ADD_PARENT_NAMES].append(ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg in {'removeanyownerparentname', 'removesharedparentname'}:
    parameters[DFA_REMOVE_PARENT_NAMES].append(ANY_NON_TRASHED_FOLDER_NAME.format(getEscapedDriveFolderName()))
  elif myarg == 'enforcesingleparent':
    parameters[DFA_ENFORCE_SINGLE_PARENT] = getBoolean(defaultValue=None)
  else:
    return False
  return True

def getDriveFileAttribute(myarg, body, parameters, assignLocalName, updateCmd):
  if myarg == 'localfile':
    parameters[DFA_LOCALFILEPATH] = os.path.expanduser(getString(Cmd.OB_FILE_NAME))
    try:
      f = open(parameters[DFA_LOCALFILEPATH], 'rb')
      f.close()
      # See http://stackoverflow.com/a/39501288/1709587 for explanation.
      mtime = os.path.getmtime(parameters[DFA_LOCALFILEPATH])
      parameters[DFA_MODIFIED_TIME] = formatLocalSecondsTimestamp(mtime)
      if not updateCmd:
        if platform.system() == 'Windows':
          ctime = os.path.getctime(parameters[DFA_LOCALFILEPATH])
        else:
          stat = os.stat(parameters[DFA_LOCALFILEPATH])
          if hasattr(stat, 'st_birthtime'):
            ctime = stat.st_birthtime
          else:
            # We're probably on Linux. No easy way to get creation dates here,
            # so we'll settle for when its content was last modified.
            ctime = stat.st_mtime
        parameters[DFA_CREATED_TIME] = formatLocalSecondsTimestamp(ctime)
    except IOError as e:
      Cmd.Backup()
      usageErrorExit(f'{parameters[DFA_LOCALFILEPATH]}: {str(e)}')
    parameters[DFA_LOCALFILENAME] = os.path.basename(parameters[DFA_LOCALFILEPATH])
    if assignLocalName:
      body.setdefault('name', parameters[DFA_LOCALFILENAME])
    body['mimeType'] = mimetypes.guess_type(parameters[DFA_LOCALFILEPATH])[0]
    if body['mimeType'] is None:
      body['mimeType'] = 'application/octet-stream'
    parameters[DFA_LOCALMIMETYPE] = body['mimeType']
  elif myarg in {'convert', 'ocr'}:
    deprecatedArgument(myarg)
  elif myarg == 'ocrlanguage':
    parameters[DFA_OCRLANGUAGE] = getLanguageCode()
  elif myarg == 'viewerscancopycontent':
    body['copyRequiresWriterPermission'] = not getBoolean()
  elif myarg in {'copyrequireswriterpermission', 'restrict', 'restricted'}:
    body['copyRequiresWriterPermission'] = getBoolean()
  elif myarg in DRIVE_LABEL_CHOICE_MAP:
    myarg = DRIVE_LABEL_CHOICE_MAP[myarg]
    body[myarg] = getBoolean()
  elif myarg in {'lastviewedbyme', 'lastviewedbyuser', 'lastviewedbymedate', 'lastviewedbymetime'}:
    body['viewedByMeTime'] = getTimeOrDeltaFromNow()
  elif not updateCmd and myarg in {'createddate', 'createdtime'}:
    body['createdTime'] = getTimeOrDeltaFromNow()
  elif myarg in {'modifieddate', 'modifiedtime'}:
    body['modifiedTime'] = getTimeOrDeltaFromNow()
  elif myarg == 'preservefiletimes':
    parameters[DFA_PRESERVE_FILE_TIMES] = getBoolean()
  elif myarg == 'description':
    body['description'] = getStringWithCRsNLs()
  elif myarg == 'mimetype':
    body['mimeType'] = getMimeType()
  elif getDriveFileParentAttribute(myarg, parameters):
    pass
  elif myarg == 'writerscanshare':
    body['writersCanShare'] = getBoolean()
  elif myarg == 'writerscantshare':
    body['writersCanShare'] = not getBoolean()
  elif myarg == 'foldercolorrgb':
    body['folderColorRgb'] = getColor()
  elif myarg == 'ignoredefaultvisibility':
    parameters[DFA_IGNORE_DEFAULT_VISIBILITY] = getBoolean()
  elif myarg in {'keeprevisionforever', 'pinned'}:
    parameters[DFA_KEEP_REVISION_FOREVER] = getBoolean()
  elif myarg == 'usecontentasindexabletext':
    parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT] = getBoolean()
  elif myarg == 'indexabletext':
    body.setdefault('contentHints', {})
    body['contentHints']['indexableText'] = getString(Cmd.OB_STRING)
  elif myarg == 'property':
    driveprop = getDriveFileProperty()
    body.setdefault(driveprop['visibility'], [])
    body[driveprop['visibility']].append({driveprop['key']: driveprop['value']})
  elif myarg == 'privateproperty':
    driveprop = getDriveFileProperty('appProperties')
    body.setdefault(driveprop['visibility'], [])
    body[driveprop['visibility']].append({driveprop['key']: driveprop['value']})
  elif myarg == 'publicproperty':
    driveprop = getDriveFileProperty('properties')
    body.setdefault(driveprop['visibility'], [])
    body[driveprop['visibility']].append({driveprop['key']: driveprop['value']})
  else:
    unknownArgumentExit()

def setPreservedFileTimes(body, parameters, updateCmd):
  body['modifiedTime'] = parameters[DFA_MODIFIED_TIME]
  if not updateCmd:
    body['createdTime'] = parameters[DFA_CREATED_TIME]

def getMediaBody(parameters):
  try:
    media_body = googleapiclient.http.MediaFileUpload(parameters[DFA_LOCALFILEPATH], mimetype=parameters[DFA_LOCALMIMETYPE], resumable=True)
    if media_body.size() == 0:
      media_body = None
    return media_body
  except IOError as e:
    systemErrorExit(FILE_ERROR_RC, fileErrorMessage(parameters[DFA_LOCALFILEPATH], e))

DRIVE_ACTIVITY_V1_TITLES = ['user.name', 'user.permissionId', 'target.id', 'target.name', 'target.mimeType', 'eventTime']
DRIVE_ACTIVITY_V2_TITLES = ['user.name', 'user.emailAddress', 'target.id', 'target.name', 'target.mimeType', 'eventTime']
DRIVE_ACTIVITY_ACTION_MAP = {
  'comment': ('comment', 'COMMENT'),
  'create': ('create', 'CREATE'),
  'delete': ('trash', 'DELETE'),
  'dlpchange': (None, 'DLP_CHANGE'),
  'edit': ('edit', 'EDIT'),
  'emptytrash': ('emptyTrash', 'DELETE'),
  'move': ('move', 'MOVE'),
  'permissionchange': ('permissionChange', 'PERMISSION_CHANGE'),
  'reference': (None, 'REFERENCE'),
  'rename': ('rename', 'RENAME'),
  'restore': ('untrash', 'RESTORE'),
  'settingschange': (None, 'SETTINGS_CHANGE'),
  'trash': ('trash', 'DELETE'),
  'untrash': ('untrash', 'RESTORE'),
  'upload': ('upload', 'CREATE'),
  }

CONSOLIDATION_GROUPING_STRATEGY_CHOICE_MAP = {
  False: {'driveui': 'driveUi', 'legacy': 'driveUi', 'none': 'none'}, #v1
  True: {'driveui': 'legacy', 'legacy': 'legacy', 'none': 'none'} #v2
  }

# gam <UserTypeEntity> print|show driveactivity [v2] [todrive <ToDriveAttribute>*]
#	[(fileid <DriveFileID>) | (folderid <DriveFolderID>) |
#	 (drivefilename <DriveFileName>) | (drivefoldername <DriveFolderName>) | (query <QueryDriveFile>)]
#	[start|starttime <Date>|<Time>] [end|endtime <Date>|<Time>] [action|actions [not] <DriveActivityActionList>]
#	[allevents|combinedevents|singleevents] [groupingstrategy driveui|none]
#	[consolidationstrategy legacy|none]
#	[idmapfile <FileName>|(gsheet <UserGoogleSheet>) [charset <String>] [columndelimiter <Character>] [quotechar <Character>]]
#	[formatjson [quotechar <Character>]]
def printDriveActivity(users):
  def _getUserInfo(userId):
    if userId.startswith('people/'):
      userId = userId[7:]
    entry = userInfo.get(userId)
    if entry is None:
      try:
        result = callGAPI(drive.about(), 'get',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                          fields='user(displayName,emailAddress)')
        entry = (result['user']['emailAddress'], result['user']['displayName'])
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        entry = (f'uid:{userId}', 'Unknown')
      userInfo[userId] = entry
    return entry

  def _updateKnownUsers(structure):
    if isinstance(structure, list):
      for v in structure:
        if isinstance(v, (dict, list)):
          _updateKnownUsers(v)
    elif isinstance(structure, dict):
      for k, v in sorted(iter(structure.items())):
        if k != 'knownUser':
          if isinstance(v, (dict, list)):
            _updateKnownUsers(v)
        else:
          entry = _getUserInfo(v['personName'])
          v['emailAddress'] = entry[0]
          v['personName'] = entry[1]
          break

  def _processV1Event(event):
    event['eventTime'] = formatLocalTimestamp(event['eventTimeMillis'])
    if filterTime:
      timeValue, _ = iso8601.parse_date(event['eventTime'])
      if not (((startEndTime.startDateTime is None) or (timeValue >= startEndTime.startDateTime)) and
              ((startEndTime.endDateTime is None) or (timeValue <= startEndTime.endDateTime))):
        return
    if actions:
      if not negativeAction:
        if event['primaryEventType'] not in actions:
          return
      else:
        if event['primaryEventType'] in actions:
          return
    if 'user' in event and userInfo:
      permissionId = event['user']['permissionId']
      if permissionId not in userInfo:
        userInfo[permissionId] = 'Unknown'
      event['user']['emailAddress'] = userInfo[permissionId]
    eventRow = flattenJSON(event)
    if not FJQC.formatJSON:
      csvPF.WriteRowTitles(eventRow)
    elif csvPF.CheckRowTitles(eventRow):
      eventRow = {}
      if 'user' in event:
        eventRow['user.name'] = event['user']['name']
        eventRow['user.permissionId'] = event['user']['permissionId']
        if userInfo:
          eventRow['user.emailAddress'] = event['user']['emailAddress']
      eventRow['target.id'] = event['target']['id']
      eventRow['target.name'] = event['target']['name']
      eventRow['target.mimeType'] = event['target']['mimeType']
      eventRow['eventTime'] = event['eventTime']
      eventRow['JSON'] = json.dumps(cleanJSON(event), ensure_ascii=False, sort_keys=True)
      csvPF.WriteRowNoFilter(eventRow)

  startEndTime = StartEndTime()
  baseFileList = []
  query = ''
  activityFilter = ''
  actions = set()
  v1fields = 'nextPageToken,activities(combinedEvent)'
  strategy = 'none'
  negativeAction = False
  filterTime = False
  v2 = checkArgumentPresent(['v2'])
  csvPF = CSVPrintFile(DRIVE_ACTIVITY_V2_TITLES if v2 else DRIVE_ACTIVITY_V1_TITLES, 'sortall')
  FJQC = FormatJSONQuoteChar(csvPF)
  userInfo = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'fileid':
      baseFileList.append({'id': getString(Cmd.OB_DRIVE_FILE_ID), 'mimeType': MIMETYPE_GA_DOCUMENT})
    elif myarg == 'folderid':
      baseFileList.append({'id': getString(Cmd.OB_DRIVE_FOLDER_ID), 'mimeType': MIMETYPE_GA_FOLDER})
    elif myarg == 'drivefilename':
      query = f"mimeType != '{MIMETYPE_GA_FOLDER}' and name = '{getEscapedDriveFileName()}'"
    elif myarg == 'drivefoldername':
      query = f"mimeType = '{MIMETYPE_GA_FOLDER}' and name = '{getEscapedDriveFileName()}'"
    elif myarg == 'query':
      query = getString(Cmd.OB_QUERY)
    elif myarg in {'start', 'starttime', 'end', 'endtime'}:
      startEndTime.Get(myarg)
      filterTime = True
    elif myarg in {'action', 'actions'}:
      negativeAction = checkArgumentPresent('not')
      for action in _getFieldsList():
        if action in DRIVE_ACTIVITY_ACTION_MAP:
          mappedAction = DRIVE_ACTIVITY_ACTION_MAP[action][v2]
          if mappedAction:
            actions.add(mappedAction)
        else:
          invalidChoiceExit(action, DRIVE_ACTIVITY_ACTION_MAP, True)
    elif not v2 and myarg == 'allevents':
      v1fields = 'nextPageToken,activities(combinedEvent,singleEvents)'
    elif not v2 and myarg == 'combinedevents':
      v1fields = 'nextPageToken,activities(combinedEvent)'
    elif not v2 and myarg == 'singleevents':
      v1fields = 'nextPageToken,activities(singleEvents)'
    elif myarg in {'consolidationstrategy', 'groupingstrategy'}:
      strategy = getChoice(CONSOLIDATION_GROUPING_STRATEGY_CHOICE_MAP[v2], mapChoice=True)
    elif myarg == 'idmapfile':
      f, csvFile, _ = openCSVFileReader(getString(Cmd.OB_FILE_NAME))
      if not v2:
        for row in csvFile:
          userInfo[row['permissionId']] = row['email']
      else:
        for row in csvFile:
          userInfo[row['id']] = (row['primaryEmail'], row.get('name.fullName', 'Unknown'))
      closeFile(f)
      if not v2:
        titles = DRIVE_ACTIVITY_V1_TITLES[:]
        titles.insert(1, 'user.emailAddress')
        csvPF.SetTitles(titles)
        csvPF.SetSortAllTitles()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if not baseFileList and not query:
    baseFileList = [{'id': ROOT, 'mimeType': MIMETYPE_GA_FOLDER}]
  if v2:
    if startEndTime.startTime:
      if activityFilter:
        activityFilter += ' AND '
      activityFilter += f'time >= "{startEndTime.startTime}"'
    if startEndTime.endTime:
      if activityFilter:
        activityFilter += ' AND '
      activityFilter += f'time <= "{startEndTime.endTime}"'
    if actions:
      if activityFilter:
        activityFilter += ' AND '
      activityFilter += f'{"-" if negativeAction else ""}detail.action_detail_case:({" ".join(actions)})'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, activity = buildGAPIServiceObject([API.DRIVEACTIVITY_V1, API.DRIVEACTIVITY_V2][v2], user, i, count)
    if not activity:
      continue
    _, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    fileList = baseFileList[:]
    if query:
      if GC.Values[GC.SHOW_GETTINGS]:
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=query)
      try:
        fileList.extend(callGAPIpages(drive.files(), 'list', 'files',
                                      pageMessage=getPageMessageForWhom(),
                                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.FILE_NOT_FOUND],
                                      retryReasons=[GAPI.UNKNOWN_ERROR],
                                      q=query, fields='nextPageToken,files(id,mimeType)', pageSize=GC.Values[GC.DRIVE_MAX_RESULTS]))
        if not fileList:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], emptyQuery(query, Ent.DRIVE_FILE_OR_FOLDER), i, count)
          continue
      except (GAPI.invalidQuery, GAPI.invalid):
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(query), i, count)
        continue
      except GAPI.fileNotFound:
        printGotEntityItemsForWhom(0)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    for f_file in fileList:
      fileId = f_file['id']
      entityType = Ent.DRIVE_FOLDER_ID if f_file['mimeType'] == MIMETYPE_GA_FOLDER else Ent.DRIVE_FILE_ID
      if entityType == Ent.DRIVE_FILE_ID:
        drive_key = 'itemName' if v2 else  'drive_fileId'
      else:
        drive_key = 'ancestorName' if v2 else 'drive_ancestorId'
      qualifier = f' for {Ent.Singular(entityType)}: {fileId}'
      printGettingAllEntityItemsForWhom(Ent.ACTIVITY, user, i, count, qualifier=qualifier)
      pageMessage = getPageMessageForWhom()
      pageToken = None
      totalItems = 0
      if v2:
        kwargs = {
          'consolidationStrategy': {strategy: {}},
          'pageSize': GC.Values[GC.ACTIVITY_MAX_RESULTS],
          'pageToken': pageToken,
          drive_key: f'items/{fileId}',
          'filter': activityFilter}
      else:
        kwargs = {
          'groupingStrategy': strategy,
          'pageSize': GC.Values[GC.ACTIVITY_MAX_RESULTS],
          'pageToken': pageToken,
          drive_key: fileId,
          'source': 'drive.google.com',
          'userId': 'me'}
      while True:
        try:
          if v2:
            feed = callGAPI(activity.activity(), 'query',
                            throwReasons=GAPI.ACTIVITY_THROW_REASONS,
                            fields='nextPageToken,activities', body=kwargs)
          else:
            feed = callGAPI(activity.activities(), 'list',
                            throwReasons=GAPI.ACTIVITY_THROW_REASONS,
                            fields=v1fields, **kwargs)
        except GAPI.badRequest as e:
          entityActionFailedWarning([Ent.USER, user, entityType, fileId], str(e), i, count)
          break
        except GAPI.serviceNotAvailable:
          entityServiceNotApplicableWarning(Ent.USER, user, i, count)
          break
        pageToken, totalItems = _processGAPIpagesResult(feed, 'activities', None, totalItems, pageMessage, None, Ent.ACTIVITY)
        kwargs['pageToken'] = pageToken
        if feed:
          if v2:
            for activityEvent in feed.get('activities', []):
              eventRow = {}
              actors = activityEvent.get('actors', [])
              if actors:
                userId = actors[0].get('user', {}).get('knownUser', {}).get('personName', '')
                if userId:
                  entry = _getUserInfo(userId)
                  eventRow['user.name'] = entry[1]
                  eventRow['user.emailAddress'] = entry[0]
              targets = activityEvent.get('targets', [])
              if targets:
                driveItem = targets[0].get('driveItem')
                if driveItem:
                  eventRow['target.id'] = driveItem['name'][6:]
                  eventRow['target.name'] = driveItem['title']
                  eventRow['target.mimeType'] = driveItem['mimeType']
                else:
                  teamDrive = targets[0].get('teamDrive')
                  if teamDrive:
                    eventRow['target.id'] = teamDrive['name'][11:]
                    eventRow['target.name'] = teamDrive['title']
              if 'timestamp' in activityEvent:
                eventRow['eventTime'] = formatLocalTime(activityEvent['timestamp'])
              elif 'timeRange' in activityEvent:
                timeRange = activityEvent['timeRange']
                eventRow['eventTime'] = f'{formatLocalTime(timeRange["startTime"])}-{formatLocalTime(timeRange["endTime"])}'
              _updateKnownUsers(activityEvent)
              if not FJQC.formatJSON:
                activityEvent.pop('timestamp', None)
                activityEvent.pop('timeRange', None)
                flattenJSON(activityEvent, flattened=eventRow)
                csvPF.WriteRowTitles(eventRow)
              else:
                checkRow = eventRow.copy()
                flattenJSON(activityEvent, flattened=checkRow)
                if csvPF.CheckRowTitles(checkRow):
                  eventRow['JSON'] = json.dumps(cleanJSON(activityEvent), ensure_ascii=False, sort_keys=True)
                  csvPF.WriteRowNoFilter(eventRow)
          else:
            for activityEvent in feed.get('activities', []):
              if 'combinedEvent' in activityEvent:
                _processV1Event(activityEvent['combinedEvent'])
              for event in activityEvent.get('singleEvents', []):
                _processV1Event(event)
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          break
  csvPF.writeCSVfile('Drive Activity')

DRIVESETTINGS_FIELDS_CHOICE_MAP = {
  'appinstalled': 'appInstalled',
  'exportformats': 'exportFormats',
  'foldercolorpalette': 'folderColorPalette',
  'importformats': 'importFormats',
  'largestchangeid': 'largestChangeId',
  'limit': 'limit',
  'maximportsizes': 'maxImportSizes',
  'maxuploadsize': 'maxUploadSize',
  'name': 'name',
  'permissionid': 'permissionId',
  'rootfolderid': 'rootFolderId',
  'drivethemes': 'driveThemes',
  'teamdrivethemes': 'driveThemes',
  'usage': 'usage',
  'usageindrive': 'usageInDrive',
  'usageindrivetrash': 'usageInDriveTrash',
  }

DRIVESETTINGS_SCALAR_FIELDS = [
  'name',
  'appInstalled',
  'largestChangeId',
  'limit',
  'maxUploadSize',
  'permissionId',
  'rootFolderId',
  'usage',
  'usageInDrive',
  'usageInDriveTrash',
  ]

def _showTeamDriveThemeSettings(themes):
  Ind.Increment()
  for theme in themes:
    printKeyValueList(['id', theme['id']])
    Ind.Increment()
    printKeyValueList(['backgroundImageLink', theme['backgroundImageLink']])
    printKeyValueList(['colorRgb', theme['colorRgb']])
    Ind.Decrement()
  Ind.Decrement()

# gam <UserTypeEntity> print drivesettings [todrive <ToDriveAttribute>*] [allfields|<DriveSettingsFieldName>*|(fields <DriveSettingsFieldNameList>)] [delimiter <Character>]
# gam <UserTypeEntity> show drivesettings [allfields|<DriveSettingsFieldName>*|(fields <DriveSettingsFieldNameList>)] [delimiter <Character>]
def printShowDriveSettings(users):
  def _showFormats(title):
    if title in fieldsList and title in feed:
      printKeyValueList([title, None])
      Ind.Increment()
      for item, value in sorted(iter(feed[title].items())):
        printKeyValueList([item, delimiter.join(value)])
      Ind.Decrement()

  def _showSetting(title):
    if title in fieldsList and title in feed:
      if not isinstance(feed[title], list):
        printKeyValueList([title, feed[title]])
      else:
        printKeyValueList([title, delimiter.join(feed[title])])

  def _addFormats(row, title):
    if title in fieldsList and title in feed:
      jcount = len(feed[title])
      row[title] = jcount
      j = 0
      for item, value in sorted(iter(feed[title].items())):
        row[f'{title}.{j:02d}.{item}'] = delimiter.join(value)
        j += 1

  def _addSetting(row, title):
    if title in fieldsList and title in feed:
      if not isinstance(feed[title], list):
        row[title] = feed[title]
      else:
        row[title] = delimiter.join(feed[title])

  csvPF = CSVPrintFile(['email'], ['email']+DRIVESETTINGS_SCALAR_FIELDS) if Act.csvFormat() else None
  fieldsList = []
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'allfields':
      for field in DRIVESETTINGS_FIELDS_CHOICE_MAP:
        fieldsList.append(DRIVESETTINGS_FIELDS_CHOICE_MAP[field])
    elif getFieldsList(myarg, DRIVESETTINGS_FIELDS_CHOICE_MAP, fieldsList):
      pass
    else:
      unknownArgumentExit()
  if not fieldsList:
    fieldsList = DRIVESETTINGS_SCALAR_FIELDS[:]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    if csvPF:
      printGettingEntityItemForWhom(Ent.DRIVE_SETTINGS, user, i, count)
    try:
      feed = callGAPI(drive.about(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields='*')
      feed['name'] = feed['user']['displayName']
      feed['maxUploadSize'] = formatFileSize(int(feed['maxUploadSize']))
      feed['permissionId'] = feed['user']['permissionId']
      if 'limit' in feed['storageQuota']:
        feed['limit'] = formatFileSize(int(feed['storageQuota']['limit']))
      else:
        feed['limit'] = 'UNLIMITED'
      for setting in ['usage', 'usageInDrive', 'usageInDriveTrash']:
        feed[setting] = formatFileSize(int(feed['storageQuota'].get(setting, '0')))
      if 'rootFolderId' in fieldsList:
        feed['rootFolderId'] = callGAPI(drive.files(), 'get',
                                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                        fileId=ROOT, fields='id')['id']
      if 'largestChangeId' in fieldsList:
        feed['largestChangeId'] = callGAPI(drive.changes(), 'getStartPageToken',
                                           throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                           fields='startPageToken')['startPageToken']
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], 1, Ent.DRIVE_SETTINGS, i, count)
        Ind.Increment()
        for setting in DRIVESETTINGS_SCALAR_FIELDS:
          _showSetting(setting)
        _showSetting('folderColorPalette')
        _showFormats('exportFormats')
        _showFormats('importFormats')
        if 'maxImportSizes' in fieldsList and 'maxImportSizes' in fieldsList:
          printKeyValueList(['maxImportSizes', None])
          Ind.Increment()
          for setting, value in iter(feed['maxImportSizes'].items()):
            printKeyValueList([setting, formatFileSize(int(value))])
          Ind.Decrement()
        if 'driveThemes' in fieldsList and 'driveThemes' in feed:
          printKeyValueList(['driveThemes', None])
          _showTeamDriveThemeSettings(feed['driveThemes'])
        Ind.Decrement()
      else:
        row = {'email': user}
        for setting in DRIVESETTINGS_SCALAR_FIELDS:
          _addSetting(row, setting)
        _addSetting(row, 'folderColorPalette')
        _addFormats(row, 'exportFormats')
        _addFormats(row, 'importFormats')
        if 'maxImportSizes' in fieldsList and 'maxImportSizes' in fieldsList:
          jcount = len(feed['maxImportSizes'])
          row['maxImportSizes'] = jcount
          j = 0
          for setting, value in iter(feed['maxImportSizes'].items()):
            row[f'maxImportSizes.{j}.{setting}'] = formatFileSize(int(value))
            j += 1
        if 'driveThemes' in fieldsList and 'driveThemes' in feed:
          jcount = len(feed['driveThemes'])
          row['driveThemes'] = jcount
          j = 0
          for setting in feed['driveThemes']:
            row[f'driveThemes.{j:02d}.id'] = setting['id']
            row[f'driveThemes.{j:02d}.backgroundImageLink'] = setting['backgroundImageLink']
            row[f'driveThemes.{j:02d}.colorRgb'] = setting['colorRgb']
            j += 1
        csvPF.WriteRowTitles(row)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('User Drive Settings')

# gam <UserTypeEntity> show teamdrivethemes
def showTeamDriveThemes(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    try:
      themes = callGAPIitems(drive.about(), 'get', 'driveThemes',
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                             fields='driveThemes')
      jcount = len(themes)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE_THEME, i, count)
      _showTeamDriveThemeSettings(themes)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

def doShowTeamDriveThemes():
  showTeamDriveThemes([_getAdminEmail()])

def initFilePathInfo():
  return {'ids': {}, 'allPaths': {}, 'localPaths': None}

def getFilePaths(drive, fileTree, initialResult, filePathInfo, addParentsToTree=False, showDepth=False):
  def _getParentName(result):
    if (result['mimeType'] == MIMETYPE_GA_FOLDER) and (result['name'] == TEAM_DRIVE) and result.get('driveId'):
      parentName = _getTeamDriveNameFromId(drive, result['driveId'])
      if parentName != TEAM_DRIVE:
        return f'SharedDrive({parentName})'
    return result['name']

  def _followParent(paths, parentId):
    result = None
    paths.setdefault(parentId, {})
    if fileTree:
      parentEntry = fileTree.get(parentId)
      if not parentEntry:
        if not addParentsToTree:
          return
        parentEntry = fileTree[parentId] = {'info': {'id': parentId, 'name': parentId, 'mimeType': MIMETYPE_GA_FOLDER}, 'children': []}
      if parentEntry['info']['name'] == parentEntry['info']['id']:
        try:
          result = callGAPI(drive.files(), 'get',
                            throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                            fileId=parentId, fields='name,parents,mimeType,driveId', supportsAllDrives=True)
          parentEntry['info']['name'] = _getParentName(result)
          parentEntry['info']['parents'] = result.get('parents', [])
        except (GAPI.fileNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
          pass
      filePathInfo['ids'][parentId] = parentEntry['info']['name']
      parents = parentEntry['info'].get('parents', [])
    else:
      try:
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=parentId, fields='name,parents,mimeType,driveId', supportsAllDrives=True)
        filePathInfo['ids'][parentId] = _getParentName(result)
        parents = result.get('parents', [])
      except (GAPI.fileNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        return
    for lparentId in parents:
      if lparentId not in filePathInfo['allPaths']:
        _followParent(paths[parentId], lparentId)
        filePathInfo['allPaths'][lparentId] = paths[parentId][lparentId]
      else:
        paths[parentId][lparentId] = filePathInfo['allPaths'][lparentId]

  def _makeFilePaths(localPaths, fplist, filePaths, name, maxDepth):
    for k, v in iter(localPaths.items()):
      fplist.append(filePathInfo['ids'].get(k, ''))
      if not v:
        fp = fplist[:]
        if showDepth:
          depth = len(fp)
          if depth > maxDepth:
            maxDepth = depth-1
        fp.reverse()
        fp.append(name)
        filePaths.append(os.path.join(*fp))
      else:
        maxDepth = _makeFilePaths(v, fplist, filePaths, name, maxDepth)
      fplist.pop()
    return maxDepth

  filePaths = []
  parents = initialResult.get('parents', [])
  if parents:
    filePathInfo['localPaths'] = {}
    for parentId in parents:
      if parentId not in filePathInfo['allPaths']:
        _followParent(filePathInfo['allPaths'], parentId)
      filePathInfo['localPaths'][parentId] = filePathInfo['allPaths'][parentId]
    fplist = []
    maxDepth = _makeFilePaths(filePathInfo['localPaths'], fplist, filePaths, initialResult['name'], -1)
  else:
    maxDepth = 0
  return (_getEntityMimeType(initialResult), filePaths, maxDepth)

DRIVEFILE_ORDERBY_CHOICE_MAP = {
  'createddate': 'createdTime',
  'createdtime': 'createdTime',
  'folder': 'folder',
  'lastviewedbyme': 'viewedByMeTime',
  'lastviewedbymedate': 'viewedByMeTime',
  'lastviewedbymetime': 'viewedByMeTime',
  'lastviewedbyuser': 'viewedByMeTime',
  'modifiedbyme': 'modifiedByMeTime',
  'modifiedbymedate': 'modifiedByMeTime',
  'modifiedbymetime': 'modifiedByMeTime',
  'modifiedbyuser': 'modifiedByMeTime',
  'modifieddate': 'modifiedTime',
  'modifiedtime': 'modifiedTime',
  'name': 'name',
  'namenatural': 'name_natural',
  'quotabytesused': 'quotaBytesUsed',
  'quotaused': 'quotaBytesUsed',
  'recency': 'recency',
  'sharedwithmedate': 'sharedWithMeTime',
  'sharedwithmetime': 'sharedWithMeTime',
  'starred': 'starred',
  'title': 'name',
  'titlenatural': 'name_natural',
  'viewedbymedate': 'viewedByMeTime',
  'viewedbymetime': 'viewedByMeTime',
  }

def _mapDrive3TitlesToDrive2(titles, drive3TitlesMap):
  for i, title in enumerate(titles):
    if title in drive3TitlesMap:
      titles[i] = drive3TitlesMap[title]

def _mapDriveUser(field):
  if 'me' in field:
    field['isAuthenticatedUser'] = field.pop('me')
  if 'photoLink' in field:
    field['picture'] = {'url': field.pop('photoLink')}

def _mapDrivePermissionNames(permission):
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    if 'displayName' in permission:
      permission['name'] = permission.pop('displayName')
    if 'expirationTime' in permission:
      permission['expirationDate'] = formatLocalTime(permission.pop('expirationTime'))
    if 'allowFileDiscovery' in permission:
      permission['withLink'] = not permission.pop('allowFileDiscovery')
  emailAddress = permission.get('emailAddress')
  if emailAddress:
    _, permission['domain'] = splitEmailAddress(emailAddress)

def _mapDriveParents(f_file, parentsSubFields):
  if 'parents' in f_file:
    parents = f_file['parents'][:]
    f_file['parents'] = []
    for parentId in parents:
      parent = {}
      if parentsSubFields['id']:
        parent['id'] = parentId
      if parentsSubFields['isRoot']:
        parent['isRoot'] = parentId == parentsSubFields['rootFolderId']
      f_file['parents'].append(parent)

def _mapDriveProperties(f_file):
  appProperties = f_file.pop('appProperties', [])
  properties = f_file.pop('properties', [])
  if appProperties:
    f_file.setdefault('properties', [])
    for key, value in sorted(iter(appProperties.items())):
      f_file['properties'].append({'key': key, 'value': value, 'visibility': 'PRIVATE'})
  if properties:
    f_file.setdefault('properties', [])
    for key, value in sorted(iter(properties.items())):
      f_file['properties'].append({'key': key, 'value': value, 'visibility': 'PUBLIC'})

def _mapDriveFieldNames(f_file, user, parentsSubFields, mapToLabels):
  if mapToLabels:
    for attrib in API.DRIVE3_TO_DRIVE2_LABELS_MAP:
      if attrib in f_file:
        f_file.setdefault('labels', {})
        f_file['labels'][API.DRIVE3_TO_DRIVE2_LABELS_MAP[attrib]] = f_file.pop(attrib)
  for attrib in API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP:
    if attrib in f_file:
      f_file[API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP[attrib]] = f_file.pop(attrib)
  capabilities = f_file.get('capabilities')
  if capabilities:
    for attrib in API.DRIVE3_TO_DRIVE2_CAPABILITIES_FIELDS_MAP:
      if attrib in capabilities:
        f_file[API.DRIVE3_TO_DRIVE2_CAPABILITIES_FIELDS_MAP[attrib]] = capabilities[attrib]
    for attrib in API.DRIVE3_TO_DRIVE2_CAPABILITIES_NAMES_MAP:
      if attrib in capabilities:
        capabilities[API.DRIVE3_TO_DRIVE2_CAPABILITIES_NAMES_MAP[attrib]] = capabilities.pop(attrib)
  if 'spaces' in f_file:
    f_file['appDataContents'] = 'appDataFolder' in f_file['spaces']
  if 'lastModifyingUser' in f_file:
    if 'displayName' in f_file['lastModifyingUser']:
      f_file['lastModifyingUserName'] = f_file['lastModifyingUser']['displayName']
    _mapDriveUser(f_file['lastModifyingUser'])
  if 'owners' in f_file:
    for owner in f_file['owners']:
      _mapDriveUser(owner)
      if 'displayName' in owner:
        f_file.setdefault('ownerNames', [])
        f_file['ownerNames'].append(owner['displayName'])
  _mapDriveUser(f_file.get('sharingUser', {}))
  _mapDriveParents(f_file, parentsSubFields)
  _mapDriveProperties(f_file)
  for permission in f_file.get('permissions', []):
    if (permission.get('type') == 'user') and (permission.get('emailAddress', '').lower() == user) and ('role' in permission):
      f_file['userPermission'] = {'id': 'me', 'role': permission['role'], 'type': permission['type']}
    _mapDrivePermissionNames(permission)

def _mapDriveRevisionNames(revision):
  for attrib in API.DRIVE3_TO_DRIVE2_REVISIONS_FIELDS_MAP:
    if attrib in revision:
      revision[API.DRIVE3_TO_DRIVE2_REVISIONS_FIELDS_MAP[attrib]] = revision.pop(attrib)
  if 'lastModifyingUser' in revision:
    if 'displayName' in revision['lastModifyingUser']:
      revision['lastModifyingUserName'] = revision['lastModifyingUser']['displayName']
    _mapDriveUser(revision['lastModifyingUser'])

DRIVE_FIELDS_CHOICE_MAP = {
  'alternatelink': 'webViewLink',
  'appdatacontents': 'spaces',
  'appproperties': 'appProperties',
  'basicpermissions': ['permissions.id', 'permissions.emailAddress', 'permissions.domain',
                       'permissions.role', 'permissions.type', 'permissions.allowFileDiscovery',
                       'permissions.expirationTime', 'permissions.deleted'],
  'cancomment': 'capabilities.canComment',
  'canreadrevisions': 'capabilities.canReadRevisions',
  'capabilities': 'capabilities',
  'contenthints': 'contentHints',
  'copyable': 'capabilities.canCopy',
  'copyrequireswriterpermission': 'copyRequiresWriterPermission',
  'createddate': 'createdTime',
  'createdtime': 'createdTime',
  'description': 'description',
  'driveid': 'driveId',
  'drivename': 'driveId',
  'editable': 'capabilities.canEdit',
  'explicitlytrashed': 'explicitlyTrashed',
  'exportlinks': 'exportLinks',
  'fileextension': 'fileExtension',
  'filesize': 'size',
  'foldercolorrgb': 'folderColorRgb',
  'fullfileextension': 'fullFileExtension',
  'hasaugmentedpermissions': 'hasAugmentedPermissions',
  'hasthumbnail': 'hasThumbnail',
  'headrevisionid': 'headRevisionId',
  'iconlink': 'iconLink',
  'id': 'id',
  'imagemediametadata': 'imageMediaMetadata',
  'isappauthorized': 'isAppAuthorized',
  'labels': ['modifiedByMe', 'copyRequiresWriterPermission', 'starred', 'trashed', 'viewedByMe'],
  'lastmodifyinguser': 'lastModifyingUser',
  'lastmodifyingusername': 'lastModifyingUser.displayName',
  'lastviewedbyme': 'viewedByMeTime',
  'lastviewedbymedate': 'viewedByMeTime',
  'lastviewedbymetime': 'viewedByMeTime',
  'lastviewedbyuser': 'viewedByMeTime',
  'md5': 'md5Checksum',
  'md5checksum': 'md5Checksum',
  'md5sum': 'md5Checksum',
  'mime': 'mimeType',
  'mimetype': 'mimeType',
  'modifiedbymedate': 'modifiedByMeTime',
  'modifiedbymetime': 'modifiedByMeTime',
  'modifiedbyuser': 'modifiedByMeTime',
  'modifieddate': 'modifiedTime',
  'modifiedtime': 'modifiedTime',
  'name': 'name',
  'originalfilename': 'originalFilename',
  'ownedbyme': 'ownedByMe',
  'ownernames': 'owners.displayName',
  'owners': 'owners',
  'parents': 'parents',
  'permissions': 'permissions',
  'permissionids': 'permissionIds',
  'properties': 'properties',
  'quotabytesused': 'quotaBytesUsed',
  'quotaused': 'quotaBytesUsed',
  'shareable': 'capabilities.canShare',
  'shared': 'shared',
  'shareddriveid': 'driveId',
  'shareddrivename': 'driveId',
  'sharedwithmedate': 'sharedWithMeTime',
  'sharedwithmetime': 'sharedWithMeTime',
  'sharinguser': 'sharingUser',
  'shortcutdetails': 'shortcutDetails',
  'size': 'size',
  'spaces': 'spaces',
  'teamdriveid': 'driveId',
  'teamdrivename': 'driveId',
  'thumbnaillink': 'thumbnailLink',
  'thumbnailversion': 'thumbnailVersion',
  'title': 'name',
  'trasheddate': 'trashedTime',
  'trashedtime': 'trashedTime',
  'trashinguser': 'trashingUser',
  'userpermission': 'ownedByMe,capabilities.canEdit,capabilities.canComment',
  'version': 'version',
  'videomediametadata': 'videoMediaMetadata',
  'viewedbymedate': 'viewedByMeTime',
  'viewedbymetime': 'viewedByMeTime',
  'viewerscancopycontent': 'copyRequiresWriterPermission',
  'webcontentlink': 'webContentLink',
  'webviewlink': 'webViewLink',
  'writerscanshare': 'writersCanShare',
  }

DRIVE_CAPABILITIES_SUBFIELDS_CHOICE_MAP = {
  'canaddchildren': 'canAddChildren',
  'canaddmydriveparent': 'canAddMyDriveParent',
  'canchangecopyrequireswriterpermission': 'canChangeCopyRequiresWriterPermission',
  'canchangeviewerscancopycontent': 'canChangeViewersCanCopyContent',
  'cancomment': 'canComment',
  'cancopy': 'canCopy',
  'candelete': 'canDelete',
  'candownload': 'canDownload',
  'canedit': 'canEdit',
  'canlistchildren': 'canListChildren',
  'canmodifycontent': 'canModifyContent',
  'canmovechildrenoutofdrive': 'canMoveChildrenOutOfDrive',
  'canmovechildrenoutofteamdrive': 'canMoveChildrenOutOfDrive',
  'canmovechildrenwithindrive': 'canMoveChildrenWithinDrive',
  'canmovechildrenwithinteamdrive': 'canMoveChildrenWithinDrive',
  'canmoveitemintoteamdrive': 'canMoveItemOutOfDrive',
  'canmoveitemoutofdrive': 'canMoveItemOutOfDrive',
  'canmoveitemoutofteamdrive': 'canMoveItemOutOfDrive',
  'canmoveitemwithindrive': 'canMoveItemWithinDrive',
  'canmoveitemwithinteamdrive': 'canMoveItemWithinDrive',
  'canmoveteamdriveitem': ['canMoveItemOutOfDrive', 'canMoveItemWithinDrive'],
  'canreaddrive': 'canReadDrive',
  'canreadrevisions': 'canReadRevisions',
  'canreadteamdrive': 'canReadDrive',
  'canremovechildren': 'canRemoveChildren',
  'canremovemydriveparent': 'canRemoveMyDriveParent',
  'canrename': 'canRename',
  'canshare': 'canShare',
  'cantrash': 'canTrash',
  'cantrashchildren': 'canTrashChildren',
  'canuntrash': 'canUntrash',
  }

DRIVE_OWNERS_SUBFIELDS_CHOICE_MAP = {
  'displayname': 'displayName',
  'emailaddress': 'emailAddress',
  'isauthenticateduser': 'me',
  'me': 'me',
  'permissionid': 'permissionId',
  'photolink': 'photoLink',
  'picture': 'photoLink',
  }

DRIVE_PARENTS_SUBFIELDS_CHOICE_MAP = {
  'id': 'id',
  'isroot': 'isRoot',
  }

DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP = {
  'additionalroles': 'role',
  'allowfilediscovery': 'allowFileDiscovery',
  'deleted': 'deleted',
  'displayname': 'displayName',
  'domain': 'domain',
  'emailaddress': 'emailAddress',
  'expirationdate': 'expirationTime',
  'expirationtime': 'expirationTime',
  'id': 'id',
  'name': 'displayName',
  'permissiondetails': 'permissionDetails',
  'photolink': 'photoLink',
  'role': 'role',
  'teamdrivepermissiondetails': 'teamDrivePermissionDetails',
  'type': 'type',
  'withlink': 'allowFileDiscovery',
  }

DRIVE_SHARINGUSER_SUBFIELDS_CHOICE_MAP = {
  'displayname': 'displayName',
  'emailaddress': 'emailAddress',
  'isauthenticateduser': 'me',
  'me': 'me',
  'name': 'displayName',
  'permissionid': 'permissionId',
  'photolink': 'photoLink',
  'picture': 'photoLink',
  }

DRIVE_SHORTCUTDETAILS_SUBFIELDS_CHOICE_MAP = {
  'targetid': 'targetId',
  'targetmimetype': 'targetMimeType',
  }

DRIVE_SUBFIELDS_CHOICE_MAP = {
  'capabilities': DRIVE_CAPABILITIES_SUBFIELDS_CHOICE_MAP,
  'labels': DRIVE_LABEL_CHOICE_MAP,
  'lastmodifyinguser': DRIVE_SHARINGUSER_SUBFIELDS_CHOICE_MAP,
  'owners': DRIVE_OWNERS_SUBFIELDS_CHOICE_MAP,
  'parents': DRIVE_PARENTS_SUBFIELDS_CHOICE_MAP,
  'permissions': DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP,
  'sharinguser': DRIVE_SHARINGUSER_SUBFIELDS_CHOICE_MAP,
  'trashinguser': DRIVE_SHARINGUSER_SUBFIELDS_CHOICE_MAP,
  'shortcutdetails': DRIVE_SHORTCUTDETAILS_SUBFIELDS_CHOICE_MAP,
}

DRIVE_LIST_FIELDS = {'owners', 'parents', 'permissions', 'permissionIds', 'spaces'}

FILEINFO_FIELDS_TITLES = ['name', 'mimeType']
FILEPATH_FIELDS_TITLES = ['name', 'id', 'mimeType', 'parents']

def _getDriveTimeObjects():
  timeObjects = ['createdTime', 'viewedByMeTime', 'modifiedByMeTime', 'modifiedTime', 'sharedWithMeTime']
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return set(timeObjects)

def _getDriveFieldSubField(field, fieldsList, parentsSubFields):
  field, subField = field.split('.', 1)
  if field in DRIVE_SUBFIELDS_CHOICE_MAP:
    if field == 'parents':
      fieldsList.append(DRIVE_FIELDS_CHOICE_MAP[field])
      parentsSubFields[DRIVE_SUBFIELDS_CHOICE_MAP[field][subField]] = True
    elif subField in DRIVE_SUBFIELDS_CHOICE_MAP[field]:
      if field != 'labels':
        if not isinstance(DRIVE_SUBFIELDS_CHOICE_MAP[field][subField], list):
          fieldsList.append(f'{DRIVE_FIELDS_CHOICE_MAP[field]}.{DRIVE_SUBFIELDS_CHOICE_MAP[field][subField]}')
        else:
          for subSubField in DRIVE_SUBFIELDS_CHOICE_MAP[field][subField]:
            fieldsList.append(f'{DRIVE_FIELDS_CHOICE_MAP[field]}.{subSubField}')
      else:
        fieldsList.append(DRIVE_SUBFIELDS_CHOICE_MAP[field][subField])
    else:
      invalidChoiceExit(subField, list(DRIVE_SUBFIELDS_CHOICE_MAP[field]), True)
  else:
    invalidChoiceExit(field, list(DRIVE_SUBFIELDS_CHOICE_MAP), True)

class DriveFileFields():
  def __init__(self):
    self.showTeamDriveNames = False
    self.allFields = False
    self.OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
    self.fieldsList = []
    self.parentsSubFields = {'id': False, 'isRoot': False, 'rootFolderId': None}
    self.teamDriveNames = {}
    self.drive = None

  def SetAllParentsSubFields(self):
    self.parentsSubFields['id'] = self.parentsSubFields['isRoot'] = True

  def ProcessArgument(self, myarg):
    if myarg == 'allfields':
      self.fieldsList = []
      self.allFields = True
    elif myarg in DRIVE_LABEL_CHOICE_MAP:
      addFieldToFieldsList(myarg, DRIVE_LABEL_CHOICE_MAP, self.fieldsList)
    elif myarg in DRIVE_FIELDS_CHOICE_MAP:
      addFieldToFieldsList(myarg, DRIVE_FIELDS_CHOICE_MAP, self.fieldsList)
      if myarg == 'parents':
        self.SetAllParentsSubFields()
      elif myarg in {'drivename', 'shareddrivename', 'teamdrivename'}:
        self.showTeamDriveNames = True
    elif myarg == 'fields':
      for field in _getFieldsList():
        if field in DRIVE_LABEL_CHOICE_MAP:
          addFieldToFieldsList(field, DRIVE_LABEL_CHOICE_MAP, self.fieldsList)
        elif field.find('.') == -1:
          if field in DRIVE_FIELDS_CHOICE_MAP:
            addFieldToFieldsList(field, DRIVE_FIELDS_CHOICE_MAP, self.fieldsList)
            if field == 'parents':
              self.SetAllParentsSubFields()
            elif field in {'drivename', 'shareddrivename', 'teamdrivename'}:
              self.showTeamDriveNames = True
          else:
            invalidChoiceExit(field, list(DRIVE_FIELDS_CHOICE_MAP)+list(DRIVE_LABEL_CHOICE_MAP), True)
        else:
          _getDriveFieldSubField(field, self.fieldsList, self.parentsSubFields)
    elif myarg.find('.') != -1:
      _getDriveFieldSubField(myarg, self.fieldsList, self.parentsSubFields)
    elif myarg == 'orderby':
      self.OBY.GetChoice()
    elif myarg in {'showdrivename', 'showshareddrivename', 'showteamdrivename'}:
      self.showTeamDriveNames = True
    else:
      return False
    return True

  @property
  def orderBy(self):
    return self.OBY.orderBy

  def TeamDriveName(self, driveId):
    if driveId not in self.teamDriveNames:
      if not self.drive:
        _, self.drive = buildGAPIServiceObject(API.DRIVE3, _getAdminEmail())
        if not self.drive:
          self.teamDriveNames[driveId] = TEAM_DRIVE
          return TEAM_DRIVE
      try:
        self.teamDriveNames[driveId] = callGAPI(self.drive.drives(), 'get',
                                                throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                                                useDomainAdminAccess=True, driveId=driveId, fields='name')['name']
      except (GAPI.notFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        self.teamDriveNames[driveId] = TEAM_DRIVE
    return self.teamDriveNames[driveId]

def _setSkipObjects(skipObjects, skipTitles, fieldsList):
  for field in skipTitles:
    if field != 'parents':
      if field not in fieldsList:
        skipObjects.add(field)
      fieldsList.append(field)
    else:
      for xfield in fieldsList:
        if xfield.startswith('parents'):
          break
      else:
        skipObjects.add(field)
      fieldsList.append('parents')

def _setGetPermissionsForTeamDrives(fieldsList):
  getPermissionsForTeamDrives = False
  permissionsFieldsList = []
  permissionsFields = None
  for field in fieldsList:
    if field.startswith('permissions'):
      getPermissionsForTeamDrives = True
      if field.find('.') != -1:
        field, subField = field.split('.', 1)
        permissionsFieldsList.append(subField)
  if getPermissionsForTeamDrives:
    permissionsFields = getItemFieldsFromFieldsList('permissions', permissionsFieldsList, True)
  return (getPermissionsForTeamDrives, permissionsFields)

# gam <UserTypeEntity> info drivefile <DriveFileEntity>
#	[filepath] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)] [formatjson]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [showparentsidsaslist]
# gam <UserTypeEntity> show fileinfo <DriveFileEntity>
#	[filepath] [allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)] [formatjson]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [showparentsidsaslist]
def showFileInfo(users):
  def _setSelectionFields():
    _setSkipObjects(skipObjects, FILEINFO_FIELDS_TITLES, DFF.fieldsList)
    if filepath:
      _setSkipObjects(skipObjects, FILEPATH_FIELDS_TITLES, DFF.fieldsList)
    if getPermissionsForTeamDrives:
      if 'driveId' not in DFF.fieldsList:
        skipObjects.add('driveId')
        DFF.fieldsList.append('driveId')
    if DFF.showTeamDriveNames:
      if 'driveId' not in DFF.fieldsList:
        skipObjects.add('driveId')
        DFF.fieldsList.append('driveId')

  filepath = showParentsIdsAsList = showNoParents = False
  simpleLists = []
  skipObjects = set()
  fileIdEntity = getDriveFileEntity()
  DFF = DriveFileFields()
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'filepath':
      filepath = True
    elif myarg == 'showparentsidsaslist':
      showParentsIdsAsList = True
      simpleLists.append('parentsIds')
    elif DFF.ProcessArgument(myarg):
      pass
    else:
      FJQC.GetFormatJSON(myarg)
  getPermissionsForTeamDrives = False
  if DFF.fieldsList:
    getPermissionsForTeamDrives, permissionsFields = _setGetPermissionsForTeamDrives(DFF.fieldsList)
    _setSelectionFields()
    fields = getFieldsFromFieldsList(DFF.fieldsList)
    showNoParents = 'parents' in DFF.fieldsList
  else:
    fields = '*'
    DFF.SetAllParentsSubFields()
    skipObjects = skipObjects.union(DEFAULT_SKIP_OBJECTS)
    showNoParents = True
  timeObjects = _getDriveTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=Ent.DRIVE_FILE_OR_FOLDER if not FJQC.formatJSON else None,
                                                  orderBy=DFF.orderBy)
    if jcount == 0:
      continue
    if not showParentsIdsAsList and DFF.parentsSubFields['isRoot']:
      try:
        DFF.parentsSubFields['rootFolderId'] = callGAPI(drive.files(), 'get',
                                                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                                        fileId=ROOT, fields='id')['id']
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    if filepath:
      filePathInfo = initFilePathInfo()
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields=fields, supportsAllDrives=True)
        driveId = result.get('driveId')
        if driveId:
          if result['mimeType'] == MIMETYPE_GA_FOLDER and result['name'] == TEAM_DRIVE:
            result['name'] = DFF.TeamDriveName(driveId)
          if DFF.showTeamDriveNames:
            result['driveName'] = DFF.TeamDriveName(driveId)
        if showNoParents:
          result.setdefault('parents', [])
        if getPermissionsForTeamDrives and driveId and 'permissions' not in result:
          try:
            result['permissions'] = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                                  throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                                  fileId=fileId, fields=permissionsFields, supportsAllDrives=True)
          except GAPI.insufficientFilePermissions as e:
            if fields != '*':
              entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
              continue
        if not FJQC.formatJSON:
          printEntity([_getEntityMimeType(result), f'{result["name"]} ({fileId})'], j, jcount)
          Ind.Increment()
        if filepath:
          if not FJQC.formatJSON:
            _, paths, _ = getFilePaths(drive, None, result, filePathInfo)
            kcount = len(paths)
            printKeyValueList(['paths', kcount])
            Ind.Increment()
            for path in sorted(paths):
              printKeyValueList(['path', path])
            Ind.Decrement()
          else:
            addFilePathsToInfo(drive, None, result, filePathInfo)
        if showParentsIdsAsList and 'parents' in result:
          result['parentsIds'] = result.pop('parents')
        if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
          _mapDriveFieldNames(result, user, DFF.parentsSubFields, True)
        else:
          _mapDriveParents(result, DFF.parentsSubFields)
          _mapDriveProperties(result)
        if not FJQC.formatJSON:
          showJSON(None, result, skipObjects, timeObjects, simpleLists,
                   {'owners': 'displayName', 'parents': 'id', 'permissions': ['name', 'displayName'][GC.Values[GC.DRIVE_V3_NATIVE_NAMES]]})
          Ind.Decrement()
        else:
          printLine(json.dumps(cleanJSON(result, skipObjects=skipObjects, timeObjects=timeObjects), ensure_ascii=False, sort_keys=True))
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def getRevisionsEntity():
  revisionsEntity = {'list': [], 'dict': None, 'count': None, 'time': None, 'range': None}
  startEndTime = StartEndTime()
  entitySelector = getEntitySelector()
  if entitySelector:
    entityList = getEntitySelection(entitySelector, False)
    if isinstance(entityList, dict):
      revisionsEntity['dict'] = entityList
    else:
      revisionsEntity['list'] = entityList
  else:
    myarg = getString(Cmd.OB_DRIVE_FILE_REVISION_ID, checkBlank=True)
    mycmd = myarg.lower()
    if mycmd == 'id':
      revisionsEntity['list'] = getStringReturnInList(Cmd.OB_DRIVE_FILE_REVISION_ID)
    elif mycmd[:3] == 'id:':
      revisionsEntity['list'] = [myarg[3:]]
    elif mycmd == 'ids':
      revisionsEntity['list'] = getString(Cmd.OB_DRIVE_FILE_REVISION_ID).replace(',', ' ').split()
    elif mycmd[:4] == 'ids:':
      revisionsEntity['list'] = myarg[4:].replace(',', ' ').split()
    elif mycmd in {'first', 'last', 'allexceptfirst', 'allexceptlast'}:
      revisionsEntity['count'] = (mycmd, getInteger(minVal=1))
    elif mycmd in {'before', 'after'}:
      dateTime, _, _ = getTimeOrDeltaFromNow(True)
      revisionsEntity['time'] = (mycmd, dateTime)
    elif mycmd == 'range':
      startEndTime.Get(mycmd)
      revisionsEntity['range'] = (mycmd, startEndTime.startDateTime, startEndTime.endDateTime)
    else:
      revisionsEntity['list'] = [myarg]
  return revisionsEntity

def _selectRevisionIds(drive, fileId, origUser, user, i, count, j, jcount, revisionsEntity):
  if revisionsEntity['list']:
    return revisionsEntity['list']
  if revisionsEntity['dict']:
    if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
      return revisionsEntity['dict'][fileId]
    return revisionsEntity['dict'][origUser][fileId]
  try:
    results = callGAPIpages(drive.revisions(), 'list', 'revisions',
                            throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISIONS_NOT_SUPPORTED],
                            fileId=fileId, fields='nextPageToken,revisions(id,modifiedTime)',
                            pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
  except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
          GAPI.badRequest, GAPI.revisionsNotSupported) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
    return []
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    return []
  numRevisions = len(results)
  if numRevisions == 0:
    return []
  if revisionsEntity['count']:
    countType = revisionsEntity['count'][0]
    count = revisionsEntity['count'][1]
    revisionIds = [revision['id'] for revision in results]
    if countType == 'first':
      if count >= numRevisions:
        return revisionIds[:-1]
      return revisionIds[:count]
    if countType == 'last':
      if count >= numRevisions:
        return revisionIds[1:]
      return revisionIds[-count:]
    if countType == 'allexceptfirst':
      if count >= numRevisions:
        return []
      return revisionIds[count:]
# count: allexceptlast
    if count >= numRevisions:
      return []
    return revisionIds[:-count]
  revisionIds = []
  if revisionsEntity['time']:
    dateTime = revisionsEntity['time'][1]
    count = 0
    if revisionsEntity['time'][0] == 'before':
      for revision in results:
        modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
        if modifiedDateTime >= dateTime:
          break
        revisionIds.append(revision['id'])
        count += 1
      if count >= numRevisions:
        return revisionIds[:-1]
      return revisionIds
# time: after
    for revision in results:
      modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
      if modifiedDateTime >= dateTime:
        revisionIds.append(revision['id'])
        count += 1
    if count >= numRevisions:
      return revisionIds[1:]
    return revisionIds
# range
  startDateTime = revisionsEntity['range'][1]
  endDateTime = revisionsEntity['range'][2]
  count = 0
  for revision in results:
    modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
    if modifiedDateTime >= startDateTime:
      if modifiedDateTime >= endDateTime:
        break
      revisionIds.append(revision['id'])
      count += 1
  if count >= numRevisions:
    return revisionIds[1:]
  return revisionIds

# gam <UserTypeEntity> delete filerevisions <DriveFileEntity> select <DriveFileRevisionIdEntity> [previewdelete]
#	[showtitles] [doit] [max_to_delete <Number>]
def deleteFileRevisions(users):
  fileIdEntity = getDriveFileEntity()
  revisionsEntity = None
  previewDelete = showTitles = doIt = False
  maxToProcess = 1
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'select':
      revisionsEntity = getRevisionsEntity()
    elif myarg == 'previewdelete':
      previewDelete = True
    elif myarg == 'showtitles':
      showTitles = True
    elif myarg == 'doit':
      doIt = True
    elif myarg in {'maxtodelete', 'maxtoprocess'}:
      maxToProcess = getInteger(minVal=0)
    else:
      unknownArgumentExit()
  if not revisionsEntity:
    missingArgumentExit('select <DriveFileRevisionIdEntity>')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if jcount == 0:
      continue
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      fileName = fileId
      entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
      if showTitles:
        fileName, entityType = _getDriveFileNameFromId(drive, fileId)
      revisionIds = _selectRevisionIds(drive, fileId, origUser, user, i, count, j, jcount, revisionsEntity)
      kcount = len(revisionIds)
      if kcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                   Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(Ent.DRIVE_FILE_REVISION)), j, jcount)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not previewDelete:
        if maxToProcess and kcount > maxToProcess:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                     Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(kcount, Act.ToPerform(), maxToProcess), j, jcount)
          continue
        if not doIt:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user, entityType, fileName], Ent.DRIVE_FILE_REVISION, kcount,
                                                     Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, j, jcount)
          continue
        entityPerformActionNumItems([Ent.USER, user, entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, j, jcount)
      else:
        entityPerformActionNumItemsModifier([Ent.USER, user, entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, Msg.PREVIEW_ONLY, j, jcount)
      Ind.Increment()
      k = 0
      for revisionId in revisionIds:
        k += 1
        if not previewDelete:
          try:
            callGAPI(drive.revisions(), 'delete',
                     throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISION_NOT_FOUND, GAPI.REVISION_DELETION_NOT_SUPPORTED,
                                                                   GAPI.CANNOT_DELETE_ONLY_REVISION, GAPI.REVISIONS_NOT_SUPPORTED],
                     fileId=fileId, revisionId=revisionId)
            entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], k, kcount)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.badRequest, GAPI.revisionDeletionNotSupported, GAPI.cannotDeleteOnlyRevision, GAPI.revisionsNotSupported) as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
          except GAPI.revisionNotFound:
            entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], k, kcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
            break
        else:
          entityActionNotPerformedWarning([Ent.USER, user, entityType, fileName, Ent.DRIVE_FILE_REVISION, revisionId], Msg.PREVIEW_ONLY, k, kcount)
      Ind.Decrement()

def _selectRevisionResults(results, fileId, origUser, revisionsEntity, previewDelete):
  numRevisions = len(results)
  if numRevisions == 0:
    return results
  if revisionsEntity['count']:
    countType = revisionsEntity['count'][0]
    count = revisionsEntity['count'][1]
    if countType == 'first':
      if count >= numRevisions:
        if previewDelete:
          return results[:-1]
        return results
      return results[:count]
    if countType == 'last':
      if count >= numRevisions:
        if previewDelete:
          return results[1:]
        return results
      return results[-count:]
    if countType == 'allexceptfirst':
      if count >= numRevisions:
        return []
      return results[count:]
# count: allexceptlast
    if count >= numRevisions:
      return []
    return results[:-count]
  if revisionsEntity['time']:
    dateTime = revisionsEntity['time'][1]
    count = 0
    if revisionsEntity['time'][0] == 'before':
      for revision in results:
        modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
        if modifiedDateTime >= dateTime:
          break
        count += 1
      if count >= numRevisions:
        if previewDelete:
          return results[:-1]
        return results
      return results[:count]
# time: after
    for revision in results:
      modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
      if modifiedDateTime >= dateTime:
        break
      count += 1
    if count == 0:
      if previewDelete:
        return results[1:]
      return results
    if count >= numRevisions:
      return []
    return results[count:]
  if revisionsEntity['range']:
    startDateTime = revisionsEntity['range'][1]
    endDateTime = revisionsEntity['range'][2]
    count = 0
    selectedResults = []
    for revision in  results:
      modifiedDateTime, _ = iso8601.parse_date(revision['modifiedTime'])
      if modifiedDateTime >= startDateTime:
        if modifiedDateTime >= endDateTime:
          break
        selectedResults.append(revision)
        count += 1
    if count >= numRevisions:
      if previewDelete:
        return selectedResults[1:]
    return selectedResults
# revisionsIds
  selectedResults = []
  if revisionsEntity['dict']:
    if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
      revisionIds = revisionsEntity['dict'][fileId]
    else:
      revisionIds = revisionsEntity['dict'][origUser][fileId]
  else:
    revisionIds = revisionsEntity['list']
  return [revision for revision in results if revision['id'] in revisionIds]

FILEREVISIONS_FIELDS_CHOICE_MAP = {
  'filesize': 'size',
  'id': 'id',
  'keepforever': 'keepForever',
  'lastmodifyinguser': 'lastModifyingUser',
  'lastmodifyingusername': 'lastModifyingUser.displayName',
  'md5checksum': 'md5Checksum',
  'mimetype': 'mimeType',
  'modifieddate': 'modifiedTime',
  'modifiedtime': 'modifiedTime',
  'originalfilename': 'originalFilename',
  'pinned': 'keepForever',
  'published': 'published',
  'publishauto': 'publishAuto',
  'publishedoutsidedomain': 'publishedOutsideDomain',
  'size': 'size',
  }

def _getFileRevisionsTimeObjects():
  timeObjects = ['modifiedTime']
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return set(timeObjects)

def _showRevision(revision, timeObjects, i=0, count=0):
  printEntity([Ent.DRIVE_FILE_REVISION, revision['id']], i, count)
  Ind.Increment()
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDriveRevisionNames(revision)
  showJSON(None, revision, ['id'], timeObjects)
  Ind.Decrement()

DRIVE_REVISIONS_INDEXED_TITLES = ['revisions']

# gam <UserTypeEntity> print filerevisions <DriveFileEntity> [todrive <ToDriveAttribute>*] [oneitemperrow] [select <DriveFileRevisionIDEntity>] [previewdelete]
#	[showtitles] [<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
# gam <UserTypeEntity> show filerevisions <DriveFileEntity> [select <DriveFileRevisionIDEntity>] [previewdelete]
#	[showtitles] [<DriveFieldName>*|(fields <DriveFieldNameList>)] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def printShowFileRevisions(users):
  csvPF = CSVPrintFile(['Owner', 'id']) if Act.csvFormat() else None
  fieldsList = []
  fileIdEntity = getDriveFileEntity()
  revisionsEntity = None
  oneItemPerRow = previewDelete = showTitles = False
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  fileNameTitle = 'title' if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES] else 'name'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'select':
      revisionsEntity = getRevisionsEntity()
    elif csvPF and myarg == 'oneitemperrow':
      oneItemPerRow = True
      if csvPF:
        csvPF.AddTitles('revision.id')
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'previewdelete':
      previewDelete = True
    elif myarg == 'showtitles':
      showTitles = True
      if csvPF:
        csvPF.AddTitles(fileNameTitle)
    elif getFieldsList(myarg, FILEREVISIONS_FIELDS_CHOICE_MAP, fieldsList, initialField='id'):
      pass
    else:
      unknownArgumentExit()
  if fieldsList:
    fields = getItemFieldsFromFieldsList('revisions', fieldsList)
  else:
    fields = '*'
  timeObjects = _getFileRevisionsTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvPF is not None],
                                                  orderBy=OBY.orderBy)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      fileName = fileId
      entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
      if showTitles:
        fileName, entityType = _getDriveFileNameFromId(drive, fileId, not csvPF)
      try:
        results = callGAPIpages(drive.revisions(), 'list', 'revisions',
                                throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.REVISIONS_NOT_SUPPORTED],
                                fileId=fileId, fields=fields, pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.revisionsNotSupported) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      if revisionsEntity:
        results = _selectRevisionResults(results, fileId, origUser, revisionsEntity, previewDelete)
      if not csvPF:
        kcount = len(results)
        entityPerformActionNumItems([entityType, fileName], kcount, Ent.DRIVE_FILE_REVISION, j, jcount)
        Ind.Increment()
        k = 0
        for revision in results:
          k += 1
          _showRevision(revision, timeObjects, k, kcount)
        Ind.Decrement()
      elif results:
        if oneItemPerRow:
          for revision in results:
            row = {'Owner': user, 'id': fileId}
            if showTitles:
              row[fileNameTitle] = fileName
            if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
              _mapDriveRevisionNames(revision)
            csvPF.WriteRowTitles(flattenJSON({'revision': revision}, flattened=row, timeObjects=timeObjects))
        else:
          if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
            for revision in results:
              _mapDriveRevisionNames(revision)
          if showTitles:
            csvPF.WriteRowTitles(flattenJSON({'revisions': results}, flattened={'Owner': user, 'id': fileId, fileNameTitle: fileName}, timeObjects=timeObjects))
          else:
            csvPF.WriteRowTitles(flattenJSON({'revisions': results}, flattened={'Owner': user, 'id': fileId}, timeObjects=timeObjects))
    Ind.Decrement()
  if csvPF:
    if oneItemPerRow:
      csvPF.SetSortTitles(['Owner', 'id', fileNameTitle, 'revision.id'])
    else:
      csvPF.SetSortTitles(['Owner', 'id', 'revisions'])
      csvPF.SetIndexedTitles(DRIVE_REVISIONS_INDEXED_TITLES)
    csvPF.writeCSVfile('Drive File Revisions')

def _stripMeInOwners(query):
  if not query:
    return query
  query = query.replace(ME_IN_OWNERS_AND, '')
  query = query.replace(AND_ME_IN_OWNERS, '')
  return query.replace(ME_IN_OWNERS, '').strip()

def _stripNotMeInOwners(query):
  if not query:
    return query
  query = query.replace(NOT_ME_IN_OWNERS_AND, '')
  query = query.replace(AND_NOT_ME_IN_OWNERS, '')
  return query.replace(NOT_ME_IN_OWNERS, '').strip()

def _updateAnyOwnerQuery(query):
  query = _stripNotMeInOwners(query)
  return _stripMeInOwners(query)

OWNED_BY_ME_FIELDS_TITLES = ['ownedByMe']

def initFileTree(drive, teamdrive, DLP, teamdriveFields, showParent):
  fileTree = {
    ORPHANS: {'info': {'id': ORPHANS, 'name': ORPHANS, 'mimeType': MIMETYPE_GA_FOLDER, 'ownedByMe': True},
              'noParents': True, 'children': []},
    SHARED_WITHME: {'info': {'id': SHARED_WITHME, 'name': SHARED_WITHME, 'mimeType': MIMETYPE_GA_FOLDER, 'ownedByMe': False},
                    'noParents': True, 'children': []},
    SHARED_DRIVES: {'info': {'id': SHARED_DRIVES, 'name': SHARED_DRIVES, 'mimeType': MIMETYPE_GA_FOLDER, 'ownedByMe': False, 'driveId': SHARED_DRIVES},
                    'noParents': True, 'children': []},
    }
  try:
    if not teamdrive:
      f_file = callGAPI(drive.files(), 'get',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                        fileId=ROOT, fields=','.join(FILEPATH_FIELDS_TITLES+OWNED_BY_ME_FIELDS_TITLES))
      fileTree[f_file['id']] = {'info': f_file, 'noParents': True, 'children': []}
    elif 'driveId' in teamdrive:
      f_file = callGAPI(drive.files(), 'get',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                        fileId=teamdrive['driveId'], supportsAllDrives=True, fields=','.join(FILEPATH_FIELDS_TITLES+OWNED_BY_ME_FIELDS_TITLES))
      fileTree[f_file['id']] = {'info': f_file, 'noParents': True, 'children': []}
      name = callGAPI(drive.drives(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                      driveId=teamdrive['driveId'], fields='name')['name']
      fileTree[f_file['id']]['info']['name'] = f'SharedDrive({name})'
    if DLP.getTeamDriveNames or DLP.checkLocation in {LOCATION_ALL_DRIVES, LOCATION_ONLY_SHARED_DRIVES}:
      tdrives = callGAPIpages(drive.drives(), 'list', 'drives',
                              throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID, GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                              fields='nextPageToken,drives(id,name)', pageSize=100)
      for tdrive in tdrives:
        fileId = tdrive['id']
        if fileId not in fileTree:
          fileTree[fileId] = {'info': {'id': fileId, 'name': f'SharedDrive({tdrive["name"]})', 'mimeType': MIMETYPE_GA_FOLDER},
                              'noParents': True, 'children': []}
        for field in teamdriveFields:
          if field in tdrive:
            fileTree[fileId]['info'][field] = tdrive[field]
        if showParent:
          fileTree[fileId]['info']['driveId'] = fileId
        fileTree[SHARED_DRIVES]['children'].append(fileId)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy,
          GAPI.notFound, GAPI.invalid, GAPI.noListTeamDrivesAdministratorPrivilege):
    return (None, False)
  return (fileTree, True)

def extendFileTree(fileTree, feed, DLP):
  for f_file in feed:
    if not DLP.CheckOnlyTeamDrives(f_file) or not DLP.CheckExcludeTrashed(f_file):
      continue
    if not f_file.get('parents', []):
      f_file['parents'] = [ORPHANS] if f_file.get('ownedByMe', False) else [SHARED_WITHME]
    fileId = f_file['id']
    if fileId not in fileTree:
      fileTree[fileId] = {'info': f_file, 'children': []}
    else:
      fileTree[fileId]['info'] = f_file
    for parentId in f_file['parents']:
      if parentId not in fileTree:
        fileTree[parentId] = {'info': {'id': parentId, 'name': parentId, 'mimeType': MIMETYPE_GA_FOLDER}, 'children': []}
      fileTree[parentId]['children'].append(fileId)

def extendFileTreeParents(drive, fileTree, fields):
  def _followParent(fileId):
    try:
      result = callGAPI(drive.files(), 'get',
                        throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                        fileId=fileId, fields=fields, supportsAllDrives=True)
      if not result.get('parents', []):
        result['parents'] = [ORPHANS] if result.get('ownedByMe', False) else [SHARED_WITHME]
      fileTree[fileId]['info'] = result
      fileTree[fileId]['info']['noDisplay'] = True
      for parentId in result['parents']:
        if parentId not in fileTree:
          fileTree[parentId] = {'info': {'id': parentId, 'name': parentId, 'mimeType': MIMETYPE_GA_FOLDER}, 'children': []}
          _followParent(parentId)
        fileTree[parentId]['children'].append(fileId)
    except (GAPI.fileNotFound, GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
      fileTree[fileId] = {'info': {'id': fileId, 'name': fileId, 'mimeType': MIMETYPE_GA_FOLDER, 'parents': [], 'noDisplay': True},
                          'children': []}

  for fileId in list(fileTree):
    f_file = fileTree[fileId]
    if 'parents' not in f_file['info'] and not f_file.get('noParents', False):
      f_file['info']['noDisplay'] = True
      _followParent(fileId)

def buildFileTree(feed, drive):
  fileTree = {
    ORPHANS: {'info': {'id': ORPHANS, 'name': ORPHANS, 'mimeType': MIMETYPE_GA_FOLDER, 'ownedByMe': True}, 'children': []},
    }
  try:
    f_file = callGAPI(drive.files(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fileId=ROOT, fields=','.join(FILEPATH_FIELDS_TITLES+OWNED_BY_ME_FIELDS_TITLES))
    fileTree[f_file['id']] = {'info': f_file, 'children': []}
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy,
          GAPI.notFound, GAPI.invalid, GAPI.noListTeamDrivesAdministratorPrivilege):
    pass
  for f_file in feed:
    if 'parents' not in f_file:
      f_file['parents'] = []
    fileId = f_file['id']
    if fileId not in fileTree:
      fileTree[fileId] = {'info': f_file, 'children': []}
    else:
      fileTree[fileId]['info'] = f_file
    parents = f_file['parents']
    if not parents:
      parents = [ORPHANS]
    for parentId in parents:
      if parentId not in fileTree:
        fileTree[parentId] = {'info': {'id': parentId, 'name': parentId, 'mimeType': MIMETYPE_GA_FOLDER}, 'children': []}
      fileTree[parentId]['children'].append(fileId)
  return fileTree

def addFilePathsToRow(drive, fileTree, fileEntryInfo, filePathInfo, csvPF, row, showDepth=False):
  _, paths, maxDepth = getFilePaths(drive, fileTree, fileEntryInfo, filePathInfo, showDepth=showDepth)
  kcount = len(paths)
  if showDepth:
    row['depth'] = maxDepth
  row['paths'] = kcount
  k = 0
  for path in sorted(paths):
    key = f'path.{k}'
    csvPF.AddTitles(key)
    if GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL] and (path.find('\n') >= 0 or path.find('\r') >= 0):
      row[key] = escapeCRsNLs(path)
    else:
      row[key] = path
    k += 1

def addFilePathsToInfo(drive, fileTree, fileEntryInfo, filePathInfo):
  _, paths, _ = getFilePaths(drive, fileTree, fileEntryInfo, filePathInfo, showDepth=False)
  fileEntryInfo['paths'] = []
  for path in sorted(paths):
    if GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL] and (path.find('\n') >= 0 or path.find('\r') >= 0):
      fileEntryInfo['paths'].append(escapeCRsNLs(path))
    else:
      fileEntryInfo['paths'].append(path)

def _validatePermissionOwnerType(location, body):
  if body.get('role', '') == 'owner' and body['type'] != 'user':
    Cmd.SetLocation(location)
    usageErrorExit(Msg.INVALID_PERMISSION_ATTRIBUTE_TYPE.format(f'role {body["role"]}', body['type']))

def _validatePermissionAttributes(myarg, location, body, field, validTypes):
  if field in body and body['type'] not in validTypes:
    Cmd.SetLocation(location-1)
    usageErrorExit(Msg.INVALID_PERMISSION_ATTRIBUTE_TYPE.format(myarg, body['type']))

DRIVEFILE_ACL_ROLES_MAP = {
  'commenter': 'commenter',
  'contentmanager': 'fileOrganizer',
  'contributor': 'writer',
  'editor': 'writer',
  'fileorganizer': 'fileOrganizer',
  'manager': 'organizer',
  'organizer': 'organizer',
  'owner': 'owner',
  'read': 'reader',
  'reader': 'reader',
  'viewer': 'reader',
  'writer': 'writer',
  }

DRIVEFILE_ACL_PERMISSION_TYPES = ['anyone', 'domain', 'group', 'user'] # anyone must be first element

class PermissionMatch():
  _PERMISSION_MATCH_ACTION_MAP = {'process': True, 'skip': False}
  _PERMISSION_MATCH_MODE_MAP = {'or': True, 'and': False}

  def __init__(self):
    self.permissionMatches = []
    self.permissionMatchKeep = self.permissionMatchOr = True
    self.permissionFields = set()
    self.clearDefaultMatch = False

  def GetMatch(self):
    startEndTime = StartEndTime('expirationstart', 'expirationend')
    roleLocation = withLinkLocation = expirationStartLocation = expirationEndLocation = deletedLocation = None
    requiredMatch = not checkArgumentPresent('not')
    body = {}
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'type':
        body['type'] = getChoice(DRIVEFILE_ACL_PERMISSION_TYPES)
        self.permissionFields.add('type')
      elif myarg == 'role':
        roleLocation = Cmd.Location()
        body['role'] = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
        self.permissionFields.add('role')
      elif myarg == 'emailaddress':
        body['emailAddress'] = getREPattern(re.IGNORECASE)
        self.permissionFields.add('emailAddress')
      elif myarg == 'domain':
        body['domain'] = getREPattern(re.IGNORECASE)
        self.permissionFields.add('domain')
      elif myarg == 'withlink':
        withLinkLocation = Cmd.Location()
        body['allowFileDiscovery'] = not getBoolean()
        self.permissionFields.add('allowFileDiscovery')
      elif myarg in {'allowfilediscovery', 'discoverable'}:
        withLinkLocation = Cmd.Location()
        body['allowFileDiscovery'] = getBoolean()
        self.permissionFields.add('allowFileDiscovery')
      elif myarg in {'name', 'displayname'}:
        body['displayName'] = getREPattern(re.IGNORECASE)
        self.permissionFields.add('displayName')
      elif myarg == 'expirationstart':
        expirationStartLocation = Cmd.Location()
        startEndTime.Get(myarg)
        body[myarg] = startEndTime.startDateTime
        self.permissionFields.add('expirationTime')
      elif myarg == 'expirationend':
        expirationEndLocation = Cmd.Location()
        startEndTime.Get(myarg)
        body[myarg] = startEndTime.endDateTime
        self.permissionFields.add('expirationTime')
      elif myarg == 'deleted':
        deletedLocation = Cmd.Location()
        body['deleted'] = getBoolean()
        self.permissionFields.add('deleted')
      elif myarg in {'em', 'endmatch'}:
        break
      else:
        unknownArgumentExit()
    if self.clearDefaultMatch:
      self.permissionMatches = []
      self.clearDefaultMatch = False
    if body:
      if 'type' in body:
        _validatePermissionOwnerType(roleLocation, body)
        _validatePermissionAttributes('allowfilediscovery/withlink', withLinkLocation, body, 'allowFileDiscovery', {'anyone', 'domain'})
        _validatePermissionAttributes('expirationstart', expirationStartLocation, body, 'expirationstart', {'user', 'group'})
        _validatePermissionAttributes('expirationend', expirationEndLocation, body, 'expirationend', {'user', 'group'})
        _validatePermissionAttributes('deleted', deletedLocation, body, 'deleted', {'user', 'group'})
      self.permissionMatches.append((requiredMatch, body))

  def SetDefaultMatch(self, requiredMatch, body):
    self.clearDefaultMatch = True
    self.permissionMatches.append((requiredMatch, body))

  def ProcessArgument(self, myarg):
    if myarg in {'pm', 'permissionmatch'}:
      self.GetMatch()
    elif myarg in {'pma', 'permissionmatchaction'}:
      self.permissionMatchKeep = getChoice(PermissionMatch._PERMISSION_MATCH_ACTION_MAP, mapChoice=True)
    elif myarg in {'pmm', 'permissionmatchmode'}:
      self.permissionMatchOr = getChoice(PermissionMatch._PERMISSION_MATCH_MODE_MAP, mapChoice=True)
    else:
      return False
    return True

  @staticmethod
  def CheckPermissionMatch(permission, permissionMatch):
    match = False
    for field, value in iter(permissionMatch[1].items()):
      if field in {'type', 'role'}:
        if value != permission.get(field, ''):
          break
      elif field in {'allowFileDiscovery', 'deleted'}:
        if value != permission.get(field, False):
          break
      elif field in {'expirationstart', 'expirationend'}:
        if 'expirationTime' in permission:
          expirationDateTime, _ = iso8601.parse_date(permission['expirationTime'])
          if field == 'expirationstart':
            if expirationDateTime < value:
              break
          else:
            if expirationDateTime > value:
              break
        else:
          break
      elif field != 'domain':
        if not value.match(permission.get(field, '')):
          break
      else:
        if field in permission:
          if not value.match(permission[field]):
            break
        elif 'emailAddress' in permission:
          _, domain = splitEmailAddress(permission['emailAddress'])
          if not value.match(domain):
            break
        else:
          break
    else:
      match = True
    return match == permissionMatch[0]

  def GetMatchingPermissions(self, permissions):
    if not self.permissionMatches:
      return permissions
    matchingPermissions = []
    for permission in permissions:
      for permissionMatch in self.permissionMatches:
        if self.CheckPermissionMatch(permission, permissionMatch):
          if self.permissionMatchKeep:
            matchingPermissions.append(permission)
          break
      else:
        if not self.permissionMatchKeep:
          matchingPermissions.append(permission)
    return matchingPermissions

  def CheckPermissionMatches(self, fileInfo):
    if not self.permissionMatches:
      return True
    permissions = fileInfo.get('permissions', [])
    if permissions:
      requiredMatches = 1 if self.permissionMatchOr else len(self.permissionMatches)
      for permission in permissions:
        for permissionMatch in self.permissionMatches:
          if self.CheckPermissionMatch(permission, permissionMatch):
            requiredMatches -= 1
            if requiredMatches == 0:
              return self.permissionMatchKeep
    return not self.permissionMatchKeep

def noFileSelectFileIdEntity(fileIdEntity):
  return (not fileIdEntity
          or (not fileIdEntity['dict']
              and not fileIdEntity['query']
              and not fileIdEntity['teamdrivefilequery']
              and not fileIdEntity['list']))

class DriveListParameters():
  def __init__(self, myargOptions):
    self.PM = PermissionMatch()
    self.myargOptions = myargOptions
    self.checkLocation = None
    self.excludeTrashed = False
    self.filenameMatchPattern = None
    self.getTeamDriveNames = False
    self.kwargs = {}
    self.fileIdEntity = {}
    self.locationFileIds = []
    self.locationSet = False
    self.maxItems = 0
    self.mimeTypeCheck = MimeTypeCheck()
    self.minimumFileSize = None
    self.onlyTeamDrives = False
    self.queryTimes = {}
    self.showOwnedBy = True
    self.showSharedByMe = None

  SHOW_OWNED_BY_CHOICE_MAP = {'any': None, 'me': True, 'others': False}
  SHOW_SHARED_BY_ME_CHOICE_MAP = {'any': None, 'true': True, 'false': False}

  def ProcessArgument(self, myarg, fileIdEntity):
    if myarg == 'maxfiles':
      self.maxItems = getInteger(minVal=0)
    elif myarg == 'minimumfilesize':
      self.minimumFileSize = getInteger(minVal=0)
    elif myarg == 'showsharedbyme':
      self.showSharedByMe = getChoice(self.SHOW_SHARED_BY_ME_CHOICE_MAP, mapChoice=True)
    elif myarg == 'filenamematchpattern':
      self.filenameMatchPattern = getREPattern(re.IGNORECASE)
    elif self.PM.ProcessArgument(myarg):
      pass
    elif myarg == 'anyowner':
      self.showOwnedBy = None
      self.UpdateAnyOwnerQuery()
    elif myarg == 'showownedby':
      self.showOwnedBy = getChoice(self.SHOW_OWNED_BY_CHOICE_MAP, mapChoice=True)
      self.UpdateQueryWithShowOwnedBy()
    elif myarg == 'showmimetype':
      self.mimeTypeCheck.Get()
      if self.myargOptions['mimeTypeInQuery']:
        self.fileIdEntity['query'] = self.mimeTypeCheck.AddMimeTypeToQuery(self.fileIdEntity['query'])
    elif myarg == 'excludetrashed':
      self.excludeTrashed = True
    elif myarg.startswith('querytime'):
      self.queryTimes[myarg] = getTimeOrDeltaFromNow()
    elif noFileSelectFileIdEntity(fileIdEntity):
      if self.myargOptions['allowQuery'] and myarg == 'query':
        self.AppendToQuery(getString(Cmd.OB_QUERY))
      elif self.myargOptions['allowQuery'] and myarg.startswith('query:'):
        self.AppendToQuery(Cmd.Previous().strip()[6:])
      elif self.myargOptions['allowQuery'] and myarg == 'fullquery':
        self.SetQuery(getString(Cmd.OB_QUERY, minLen=0))
      elif self.myargOptions['allowQuery'] and myarg in QUERY_SHORTCUTS_MAP:
        self.UpdateAnyOwnerQuery()
        self.AppendToQuery(QUERY_SHORTCUTS_MAP[myarg])
      elif self.myargOptions['allowChoose'] and myarg == 'choose':
        myarg = getArgument()
        if myarg in DRIVE_BY_NAME_CHOICE_MAP:
          self.SetQuery(DRIVE_BY_NAME_CHOICE_MAP[myarg].format(getEscapedDriveFileName()))
        elif myarg in LOCATION_CHOICE_MAP:
          self.locationSet = True
          self.SetLocation(LOCATION_CHOICE_MAP[myarg])
        elif myarg.find(':') > 0:
          kw, value = myarg.split(':', 1)
          if kw in DRIVE_BY_NAME_CHOICE_MAP:
            self.SetQuery(DRIVE_BY_NAME_CHOICE_MAP[kw].format(escapeDriveFileName(value)))
          else:
            invalidChoiceExit(myarg, list(DRIVE_BY_NAME_CHOICE_MAP), True)
        else:
          invalidChoiceExit(myarg, list(DRIVE_BY_NAME_CHOICE_MAP)+list(LOCATION_CHOICE_MAP), True)
      elif self.myargOptions['allowCorpora'] and myarg == 'corpora':
        corpora = getChoice(CORPORA_CHOICE_MAP)
        self.kwargs['corpora'] = CORPORA_CHOICE_MAP[corpora]
        self.kwargs['includeItemsFromAllDrives'] = self.kwargs['supportsAllDrives'] = True
        self.onlyTeamDrives = corpora in {'onlyshareddrives', 'onlyteamdrives'}
        self.getTeamDriveNames = True
        self.UpdateAnyOwnerQuery()
        self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['alldrives' if not self.onlyTeamDrives else 'onlyshareddrives'])
      else:
        return False
    else:
      if (myarg == 'query' or
          myarg.startswith('query:') or
          myarg == 'fullquery' or
          myarg in QUERY_SHORTCUTS_MAP or
          myarg in DRIVE_BY_NAME_CHOICE_MAP):
        usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format('select', myarg))
      return False
    return True

  def InitDriveIdEntity(self):
    if not self.fileIdEntity:
      self.fileIdEntity = initDriveFileEntity()
      self.fileIdEntity['query'] = ME_IN_OWNERS

  def AppendToQuery(self, query):
    self.InitDriveIdEntity()
    if self.fileIdEntity['query']:
      self.fileIdEntity['query'] += ' and ('+query+')'
    else:
      self.fileIdEntity['query'] = query

  def SetQuery(self, query):
    self.InitDriveIdEntity()
    self.fileIdEntity['query'] = query

  def UpdateAnyOwnerQuery(self):
    self.InitDriveIdEntity()
    self.fileIdEntity['query'] = _updateAnyOwnerQuery(self.fileIdEntity['query'])

  def UpdateQueryWithShowOwnedBy(self):
    self.InitDriveIdEntity()
    if self.showOwnedBy is None:
      self.fileIdEntity['query'] = _updateAnyOwnerQuery(self.fileIdEntity['query'])
    elif not self.showOwnedBy:
      if self.fileIdEntity['query'].find(NOT_ME_IN_OWNERS) >= 0:
        pass
      else:
        self.fileIdEntity['query'] = _stripMeInOwners(self.fileIdEntity['query'])
        if self.fileIdEntity['query']:
          self.fileIdEntity['query'] = NOT_ME_IN_OWNERS_AND+self.fileIdEntity['query']
        else:
          self.fileIdEntity['query'] = NOT_ME_IN_OWNERS
    else:
      if self.fileIdEntity['query'].find(ME_IN_OWNERS) >= 0:
        pass
      else:
        self.fileIdEntity['query'] = _stripNotMeInOwners(self.fileIdEntity['query'])
        if self.fileIdEntity['query']:
          self.fileIdEntity['query'] = ME_IN_OWNERS_AND+self.fileIdEntity['query']
        else:
          self.fileIdEntity['query'] = ME_IN_OWNERS

  def CheckShowOwnedBy(self, fileInfo):
    return self.showOwnedBy is None or fileInfo.get('ownedByMe', self.showOwnedBy) == self.showOwnedBy

  def CheckShowSharedByMe(self, fileInfo):
    return self.showSharedByMe is None or (fileInfo.get('shared', self.showSharedByMe) == self.showSharedByMe and fileInfo.get('ownedByMe', False))

  def SetLocationFileIDsList(self, location):
    self.locationFileIds = location['fileids']
    self.checkLocation = location['location']
    self.InitDriveIdEntity()
    cleanFileIDsList(self.fileIdEntity, self.locationFileIds)

  def SetLocation(self, location):
    self.SetLocationFileIDsList(location)
    if self.checkLocation in {LOCATION_ALL_DRIVES, LOCATION_ONLY_SHARED_DRIVES}:
      self.kwargs = {'corpora': 'allDrives', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
      self.showOwnedBy = None
      self.fileIdEntity['query'] = ''
      self.onlyTeamDrives = self.checkLocation == LOCATION_ONLY_SHARED_DRIVES
    elif location['setShowOwnedBy']:
      self.showOwnedBy = location['owner']
      if self.showOwnedBy is None:
        self.fileIdEntity['query'] = ''
      elif self.showOwnedBy:
        self.fileIdEntity['query'] = ME_IN_OWNERS
      else:
        self.fileIdEntity['query'] = NOT_ME_IN_OWNERS
    else:
      if self.fileIdEntity['query'].find(NOT_ME_IN_OWNERS) >= 0:
        self.fileIdEntity['query'] = NOT_ME_IN_OWNERS
      elif self.fileIdEntity['query'].find(ME_IN_OWNERS) >= 0:
        self.fileIdEntity['query'] = ME_IN_OWNERS

  def SetShowOwnedBy(self, showOwnedBy):
    self.showOwnedBy = showOwnedBy

  def GetFileIdEntity(self):
    if not self.fileIdEntity:
      self.fileIdEntity = initDriveFileEntity()
      self.fileIdEntity['query'] = ME_IN_OWNERS
    return self.fileIdEntity

  def AddMimeTypeToQuery(self):
    if not self.fileIdEntity:
      self.fileIdEntity = initDriveFileEntity()
    if self.mimeTypeCheck.mimeTypes:
      self.fileIdEntity['query'] = self.mimeTypeCheck.AddMimeTypeToQuery(self.fileIdEntity['query'])

  def Finalize(self, fileIdEntity):
    self.fileIdEntity.setdefault('query', '')
    if self.excludeTrashed:
      self.AppendToQuery('trashed=false')
    if self.fileIdEntity['query']:
      for queryTimeName, queryTimeValue in iter(self.queryTimes.items()):
        self.fileIdEntity['query'] = self.fileIdEntity['query'].replace(f'#{queryTimeName}#', queryTimeValue)
      self.fileIdEntity['query'] = _mapDrive2QueryToDrive3(self.fileIdEntity['query'])
    if not fileIdEntity.get('teamdrive'):
      if self.fileIdEntity['query']:
        if self.fileIdEntity['query'].find(NOT_ME_IN_OWNERS) >= 0 or (not self.showOwnedBy and self.showOwnedBy is not None):
          if not self.locationFileIds:
            self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['ownedbyothers'])
          self.SetShowOwnedBy(False)
        elif self.fileIdEntity['query'].find(ME_IN_OWNERS) >= 0 or self.showOwnedBy:
          if not self.locationFileIds:
            self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['ownedbyme'])
          self.SetShowOwnedBy(True)
        else:
          if not self.locationFileIds:
            self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['ownedbyany'])
          self.SetShowOwnedBy(None)
      else:
        if not self.locationFileIds:
          self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['ownedbyany'])
        self.SetShowOwnedBy(None)
    else:
      self.UpdateAnyOwnerQuery()
#      if not self.locationFileIds:
#        self.SetLocationFileIDsList(LOCATION_CHOICE_MAP['onlyshareddrives'])
      self.SetShowOwnedBy(None)

  def GetLocationFileIdsFromTree(self, fileTree, fileIdEntity):
    cleanList = []
    for fileId in self.locationFileIds:
      if fileId == ROOT or (fileId in fileTree and fileTree[fileId]['children']):
        cleanList.append(fileId)
    cleanFileIDsList(fileIdEntity, cleanList)

  def CheckExcludeTrashed(self, fileInfo):
    return not self.excludeTrashed or not fileInfo.get('trashed', False)

  def CheckFilenameMatch(self, fileInfo):
    return not self.filenameMatchPattern or self.filenameMatchPattern.match(fileInfo['name'])

  def CheckMimeType(self, fileInfo):
    return self.mimeTypeCheck.Check(fileInfo)

  def CheckMinimumFileSize(self, fileInfo):
    return self.minimumFileSize is None or int(fileInfo.get('size', '0')) >= self.minimumFileSize

  def CheckOnlyTeamDrives(self, fileInfo):
    return not self.onlyTeamDrives or fileInfo.get('driveId') is not None

  def CheckPermissionMatches(self, fileInfo):
    return self.PM.CheckPermissionMatches(fileInfo)

FILELIST_FIELDS_TITLES = ['id', 'name', 'mimeType', 'parents']
DRIVE_INDEXED_TITLES = ['parents', 'path', 'permissions']
CHECK_LOCATION_FIELDS_TITLES = ['driveId', 'id', 'mimeType', 'ownedByMe', 'parents', 'shared']

FILECOUNT_SUMMARY_NONE = 0
FILECOUNT_SUMMARY_ONLY = -1
FILECOUNT_SUMMARY_PLUS = 1
FILECOUNT_SUMMARY_CHOICE_MAP = {
  'none': FILECOUNT_SUMMARY_NONE,
  'only': FILECOUNT_SUMMARY_ONLY,
  'plus': FILECOUNT_SUMMARY_PLUS
  }
FILECOUNT_SUMMARY_USER = 'Summary'

# gam <UserTypeEntity> print filelist [todrive <ToDriveAttribute>*]
#	[((query <QueryDriveFile>) | (fullquery <QueryDriveFile>) | <DriveFileQueryShortcut>) (querytime.* <Time>)*]
#	[choose <DriveFileNameEntity>|<DriveFileEntityShortcut>]
#	[corpora <CorporaAttribute>]
#	[select <DriveFileEntity>> [selectsubquery <QueryDriveFile>]
#	    [norecursion|(depth <Number>)] [showparent]]
#	[anyowner|(showownedby any|me|others)]
#	[showmimetype [not] <MimeTypeList>] [minimumfilesize <Integer>]
#	[filenamematchpattern <RegularExpression>]
#	<PermissionMatch>* [<PermissionMatchMode>] [<PermissionMatchAction>]
#	[excludetrashed]
#	[maxfiles <Integer>] [nodataheaders <String>]
#	[countsonly [summary none|only|plus]] [countsrowfilter]
#	[filepath|fullpath [addpathstojson] [showdepth]] [buildtree]
#	[allfields|<DriveFieldName>*|(fields <DriveFieldNameList>)]
#	[showdrivename] [showparentsidsaslist] [showpermissionslast]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [delimiter <Character>]
#	[formatjson [quotechar <Character>]]
def printFileList(users):
  def _setSelectionFields():
    if fileIdEntity or filepath:
      _setSkipObjects(skipObjects, FILELIST_FIELDS_TITLES, DFF.fieldsList)
    if DLP.showOwnedBy is not None:
      _setSkipObjects(skipObjects, OWNED_BY_ME_FIELDS_TITLES, DFF.fieldsList)
    if DLP.showSharedByMe is not None or DLP.checkLocation is not None:
      _setSkipObjects(skipObjects, CHECK_LOCATION_FIELDS_TITLES, DFF.fieldsList)
    if DLP.mimeTypeCheck.mimeTypes:
      _setSkipObjects(skipObjects, ['mimeType'], DFF.fieldsList)
    if countsOnly:
      skipObjects.discard('mimeType')
      if 'mimeType' not in DFF.fieldsList:
        DFF.fieldsList.append('mimeType')
    if DLP.minimumFileSize is not None:
      _setSkipObjects(skipObjects, ['size'], DFF.fieldsList)
    if DLP.filenameMatchPattern or showParent:
      _setSkipObjects(skipObjects, ['name'], DFF.fieldsList)
    if DLP.excludeTrashed:
      _setSkipObjects(skipObjects, ['trashed'], DFF.fieldsList)
    if DLP.PM.permissionMatches:
      for field in DFF.fieldsList:
        if field.startswith('permissions'):
          break
      else:
        skipObjects.add('permissions')
      if 'permissions' not in DFF.fieldsList:
        for field in DLP.PM.permissionFields:
          permfield = 'permissions.'+field
          if permfield not in DFF.fieldsList:
            DFF.fieldsList.append(permfield)
    if DLP.onlyTeamDrives or getPermissionsForTeamDrives or DFF.showTeamDriveNames:
      _setSkipObjects(skipObjects, ['driveId'], DFF.fieldsList)

  def _printFileInfo(drive, user, f_file):
    driveId = f_file.get('driveId')
    checkTeamDrivePermissions = getPermissionsForTeamDrives and driveId and 'permissions' not in f_file
    if (f_file.get('noDisplay', False) or
        not DLP.CheckShowOwnedBy(f_file) or
        not DLP.CheckShowSharedByMe(f_file) or
        not DLP.CheckExcludeTrashed(f_file) or
        not DLP.CheckMimeType(f_file) or
        not DLP.CheckMinimumFileSize(f_file) or
        not DLP.CheckFilenameMatch(f_file) or
        (not checkTeamDrivePermissions and not DLP.CheckPermissionMatches(f_file)) or
        (DLP.onlyTeamDrives and not driveId)):
      return
    if checkTeamDrivePermissions:
      try:
        f_file['permissions'] = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                              fileId=f_file['id'], fields=permissionsFields, supportsAllDrives=True)
        if not DLP.CheckPermissionMatches(f_file):
          return
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.internalError,
              GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
        pass
    row = {'Owner': user}
    fileInfo = f_file.copy()
    if DFF.showTeamDriveNames and driveId:
      fileInfo['driveName'] = DFF.TeamDriveName(driveId)
    if filepath:
      if not FJQC.formatJSON or not addPathsToJSON:
        addFilePathsToRow(drive, fileTree, fileInfo, filePathInfo, csvPF, row, showDepth=showDepth)
      else:
        addFilePathsToInfo(drive, fileTree, fileInfo, filePathInfo)
    if showParentsIdsAsList and 'parents' in fileInfo:
      fileInfo['parentsIds'] = fileInfo.pop('parents')
    if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
      _mapDriveFieldNames(fileInfo, user, DFF.parentsSubFields, False)
    else:
      _mapDriveParents(fileInfo, DFF.parentsSubFields)
      _mapDriveProperties(fileInfo)
      for permission in fileInfo.get('permissions', []):
        _mapDrivePermissionNames(permission)
    if showParentsIdsAsList and 'parentsIds' in fileInfo:
      fileInfo['parents'] = len(fileInfo['parentsIds'])
    if not countsOnly:
      if not FJQC.formatJSON:
        csvPF.WriteRowTitles(flattenJSON(fileInfo, flattened=row, skipObjects=skipObjects, timeObjects=timeObjects,
                                         simpleLists=simpleLists, delimiter=delimiter))
      else:
        if 'id' in fileInfo:
          row['id'] = fileInfo['id']
        if fileNameTitle in fileInfo:
          row[fileNameTitle] = fileInfo[fileNameTitle]
        if 'owners' in fileInfo:
          flattenJSON({'owners': fileInfo['owners']}, flattened=row, skipObjects=skipObjects)
        row['JSON'] = json.dumps(fileInfo, ensure_ascii=False, sort_keys=False)
        csvPF.WriteRowTitlesJSONNoFilter(row)
    else:
      if not countsRowFilter:
        csvPF.UpdateMimeTypeCounts(flattenJSON(fileInfo, flattened=row, skipObjects=skipObjects, timeObjects=timeObjects,
                                               simpleLists=simpleLists, delimiter=delimiter), mimeTypeCounts)
      else:
        mimeTypeCounts.setdefault(fileInfo['mimeType'], 0)
        mimeTypeCounts[fileInfo['mimeType']] += 1

  def _printChildDriveFolderContents(drive, fileEntry, user, i, count, depth):
    parentFileEntry = fileTree.get(fileEntry['id'])
    if parentFileEntry and 'children' in parentFileEntry:
      for childFileId in parentFileEntry['children']:
        childEntry = fileTree.get(childFileId)
        if childEntry:
          if not DLP.CheckExcludeTrashed(childEntry['info']):
            continue
          if childFileId not in filesPrinted:
            filesPrinted.add(childFileId)
            # Don't show My Drive/Shared Drive unless asked
            if showParent or parentFileEntry['info']['id'] != parentFileEntry['info'].get('driveId', ''):
              _printFileInfo(drive, user, childEntry['info'].copy())
          if childEntry['info']['mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
            _printChildDriveFolderContents(drive, childEntry['info'], user, i, count, depth+1)
      return
    q = WITH_PARENTS.format(fileEntry['id'])
    if selectSubQuery:
      q += ' and ('+selectSubQuery+')'
    try:
      children = callGAPIpages(drive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID],
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               q=q, orderBy=DFF.orderBy, fields=pagesFields,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], includeItemsFromAllDrives=True, supportsAllDrives=True)
    except (GAPI.invalidQuery, GAPI.invalid):
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(selectSubQuery), i, count)
      return
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo['id']
      if filepath:
        fileTree.setdefault(childFileId, {'info': childEntryInfo})
      if childFileId not in filesPrinted:
        filesPrinted.add(childFileId)
        _printFileInfo(drive, user, childEntryInfo.copy())
      if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
        _printChildDriveFolderContents(drive, childEntryInfo, user, i, count, depth+1)

  def writeMimeTypeCountsRow(user, mimeTypeCounts):
    total = 0
    for mimeTypeCount in iter(mimeTypeCounts.values()):
      total += mimeTypeCount
    row = {'Owner': user, 'Total': total}
    row.update(mimeTypeCounts)
    if not countsRowFilter:
      csvPFco.WriteRowTitlesNoFilter(row)
    else:
      csvPFco.WriteRowTitles(row)

  csvPF = CSVPrintFile('Owner', indexedTitles=DRIVE_INDEXED_TITLES)
  FJQC = FormatJSONQuoteChar(csvPF)
  addPathsToJSON = countsRowFilter = buildTree = countsOnly = filepath = fullpath = noRecursion = \
    showParentsIdsAsList = showDepth = showParent = False
  maxdepth = -1
  nodataFields = []
  simpleLists = ['permissionIds', 'spaces']
  skipObjects = set()
  fileIdEntity = {}
  selectSubQuery = ''
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  DLP = DriveListParameters({'allowChoose': True, 'allowCorpora': True, 'allowQuery': True, 'mimeTypeInQuery': False})
  DFF = DriveFileFields()
  summary = FILECOUNT_SUMMARY_NONE
  summaryMimeTypeCounts = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif DFF.ProcessArgument(myarg):
      pass
    elif DLP.ProcessArgument(myarg, fileIdEntity):
      pass
    elif myarg == 'select':
      if fileIdEntity:
        usageErrorExit(Msg.CAN_NOT_BE_SPECIFIED_MORE_THAN_ONCE.format('select'))
      if not DLP.fileIdEntity:
        fileIdEntity = getDriveFileEntity(DLP=DLP)
      else:
        fileIdEntity = getDriveFileEntityTeamDriveOnly()
    elif myarg == 'selectsubquery':
      selectSubQuery = getString(Cmd.OB_QUERY, minLen=0)
    elif myarg == 'norecursion':
      noRecursion = getBoolean()
    elif myarg == 'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == 'showdepth':
      showDepth = True
    elif myarg == 'showparent':
      showParent = getBoolean()
    elif myarg == 'nodataheaders':
      nodataFields = getString(Cmd.OB_FIELD_NAME_LIST).replace('_', '').replace(',', ' ').split()
    elif myarg == 'filepath':
      filepath = True
    elif myarg == 'fullpath':
      filepath = fullpath = True
    elif myarg == 'addpathstojson':
      addPathsToJSON = True
    elif myarg == 'buildtree':
      buildTree = True
    elif myarg == 'countsrowfilter':
      countsRowFilter = True
    elif myarg == 'countsonly':
      countsOnly = True
      csvPFco = CSVPrintFile(['Owner', 'Total'], 'sortall')
      csvPFco.SetZeroBlankMimeTypeCounts(True)
    elif myarg == 'summary':
      summary = getChoice(FILECOUNT_SUMMARY_CHOICE_MAP, mapChoice=True)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'showparentsidsaslist':
      showParentsIdsAsList = True
      simpleLists.append('parentsIds')
    elif myarg == 'showpermissionslast':
      csvPF.SetShowPermissionsLast(True)
    else:
      FJQC.GetFormatJSONQuoteChar(myarg)
  if not filepath and not fullpath:
    showDepth = False
  noSelect = noFileSelectFileIdEntity(fileIdEntity)
  if noSelect:
    buildTree = True
    if maxdepth != -1 or filepath:
      if not fileIdEntity:
        fileIdEntity = initDriveFileEntity()
        DLP.GetFileIdEntity()
      if not fileIdEntity['teamdrive']:
        cleanFileIDsList(fileIdEntity, [ROOT, ORPHANS])
      noSelect = False
    elif not fileIdEntity:
      fileIdEntity = DLP.GetFileIdEntity()
  elif not buildTree:
    buildTree = (not fileIdEntity['dict']
                 and not fileIdEntity['query']
                 and not fileIdEntity['teamdrivefilequery']
                 and _simpleFileIdEntityList(fileIdEntity['list']))
  incrementalPrint = buildTree and (not filepath) and noSelect and not DLP.locationSet
  if incrementalPrint:
    DLP.AddMimeTypeToQuery()
  if buildTree:
    if not fileIdEntity.get('teamdrive'):
      btkwargs = DLP.kwargs
    else:
      btkwargs = fileIdEntity['teamdrive']
    DLP.Finalize(fileIdEntity)
  if DLP.PM.permissionMatches:
    getPermissionsForTeamDrives = True
    permissionsFields = 'nextPageToken,permissions'
  elif DFF.fieldsList:
    getPermissionsForTeamDrives, permissionsFields = _setGetPermissionsForTeamDrives(DFF.fieldsList)
  else:
    getPermissionsForTeamDrives = False
  if DFF.fieldsList:
    _setSelectionFields()
    fields = getFieldsFromFieldsList(DFF.fieldsList)
    pagesFields = getItemFieldsFromFieldsList('files', DFF.fieldsList)
  elif not DFF.allFields:
    _setSelectionFields()
    if not countsOnly and not set(DFF.fieldsList)-skipObjects:
      for field in ['name', 'webviewlink']:
        skipObjects.discard(DRIVE_FIELDS_CHOICE_MAP[field])
        csvPF.AddField(field, DRIVE_FIELDS_CHOICE_MAP, DFF.fieldsList)
    fields = getFieldsFromFieldsList(DFF.fieldsList)
    pagesFields = getItemFieldsFromFieldsList('files', DFF.fieldsList)
  else:
    fields = pagesFields = '*'
    DFF.SetAllParentsSubFields()
    skipObjects = skipObjects.union(DEFAULT_SKIP_OBJECTS)
  teamdriveFields = []
  for field in ['capabilities', 'createdTime']:
    if fields == '*' or field in DFF.fieldsList:
      teamdriveFields.append(field)
  if filepath and not countsOnly:
    csvPF.AddTitles('paths')
    csvPF.SetFixPaths(True)
  timeObjects = _getDriveTimeObjects()
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    fileNameTitle = 'title'
    _mapDrive3TitlesToDrive2(csvPF.titlesList, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
    _mapDrive3TitlesToDrive2(csvPF.titlesList, API.DRIVE3_TO_DRIVE2_CAPABILITIES_TITLES_MAP)
    csvPF.UpdateMappedTitles()
  else:
    fileNameTitle = 'name'
  csvPF.RemoveTitles(['capabilities'])
  if DLP.queryTimes and selectSubQuery:
    for queryTimeName, queryTimeValue in iter(DLP.queryTimes.items()):
      selectSubQuery = selectSubQuery.replace(f'#{queryTimeName}#', queryTimeValue)
    selectSubQuery = _mapDrive2QueryToDrive3(selectSubQuery)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    if not showParentsIdsAsList and DFF.parentsSubFields['isRoot']:
      try:
        DFF.parentsSubFields['rootFolderId'] = callGAPI(drive.files(), 'get',
                                                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                                        fileId=ROOT, fields='id')['id']
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    if filepath:
      filePathInfo = initFilePathInfo()
    filesPrinted = set()
    mimeTypeCounts = {}
    if buildTree:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=DLP.fileIdEntity['query'])
      pageMessage = getPageMessageForWhom()
      pageToken = None
      totalItems = 0
      maxResults = GC.Values[GC.DRIVE_MAX_RESULTS]
      tweakMaxResults = DLP.maxItems and maxResults
      if not incrementalPrint:
        fileTree, status = initFileTree(drive, fileIdEntity.get('teamdrive'), DLP, teamdriveFields, showParent)
        if not status:
          continue
      queryError = False
      userError = False
      while True:
        if tweakMaxResults and DLP.maxItems-totalItems < GC.Values[GC.DRIVE_MAX_RESULTS]:
          maxResults = DLP.maxItems-totalItems
        try:
          feed = callGAPI(drive.files(), 'list',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.FILE_NOT_FOUND,
                                                                      GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                          retryReasons=[GAPI.UNKNOWN_ERROR],
                          pageToken=pageToken,
                          q=DLP.fileIdEntity['query'], orderBy=DFF.orderBy,
                          fields=pagesFields, pageSize=maxResults, **btkwargs)
        except (GAPI.invalidQuery, GAPI.invalid):
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(DLP.fileIdEntity['query']), i, count)
          queryError = True
          break
        except GAPI.fileNotFound:
          printGotEntityItemsForWhom(0)
          break
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity['teamdrive']['driveId']], str(e), i, count)
          break
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          userError = True
          break
        pageToken, totalItems = _processGAPIpagesResult(feed, 'files', None, totalItems, pageMessage, None, Ent.DRIVE_FILE_OR_FOLDER)
        if feed:
          if not incrementalPrint:
            extendFileTree(fileTree, feed.get('files', []), DLP)
          else:
            for f_file in feed.get('files', []):
              _printFileInfo(drive, user, f_file)
          del feed
        if not pageToken or (DLP.maxItems and totalItems >= DLP.maxItems):
          _finalizeGAPIpagesResult(pageMessage)
          break
      if queryError:
        break
      if userError:
        continue
      if incrementalPrint:
        if countsOnly:
          if summary != FILECOUNT_SUMMARY_NONE:
            for mimeType, mtcount in iter(mimeTypeCounts.items()):
              summaryMimeTypeCounts.setdefault(mimeType, 0)
              summaryMimeTypeCounts[mimeType] += mtcount
          if summary != FILECOUNT_SUMMARY_ONLY:
            writeMimeTypeCountsRow(user, mimeTypeCounts)
        continue
      extendFileTreeParents(drive, fileTree, fields)
      DLP.GetLocationFileIdsFromTree(fileTree, fileIdEntity)
    else:
      fileTree = {}
    user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, drive=drive)
    if jcount == 0:
      continue
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      fileEntry = fileTree.get(fileId)
      if fileEntry:
        fileEntryInfo = fileEntry['info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), 'get',
                                   throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields=fields, supportsAllDrives=True)
          if filepath:
            fileTree[fileId] = {'info': fileEntryInfo}
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity['teamdrive']['driveId']], str(e), j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      if fullpath:
        getFilePaths(drive, fileTree, fileEntryInfo, filePathInfo, addParentsToTree=True, showDepth=showDepth)
      if (showParent and fileEntryInfo['id'] != ORPHANS) or fileEntryInfo['mimeType'] != MIMETYPE_GA_FOLDER or noRecursion:
        if fileId not in filesPrinted:
          filesPrinted.add(fileId)
          _printFileInfo(drive, user, fileEntryInfo.copy())
      if fileEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER and not noRecursion:
        _printChildDriveFolderContents(drive, fileEntryInfo, user, i, count, 0)
    if countsOnly:
      if summary != FILECOUNT_SUMMARY_ONLY:
        writeMimeTypeCountsRow(user, mimeTypeCounts)
  if not countsOnly:
    if not csvPF.rows:
      setSysExitRC(NO_ENTITIES_FOUND)
      if not nodataFields:
        if DFF.fieldsList:
          nodataFields = ['Owner']+list(set(DFF.fieldsList)-skipObjects)
        else:
          nodataFields = ['Owner', 'id', fileNameTitle, 'owners.emailAddress', 'permissions']
        if filepath:
          nodataFields.append('paths')
        if FJQC.formatJSON:
          nodataFields.append('JSON')
        titles = []
        for field in nodataFields:
          if field.find('(') != -1:
            field, subFields = field.split('(', 1)
            if field in DRIVE_LIST_FIELDS:
              titles.append(field)
              titles.extend([f'{field}.0.{subField}' for subField in subFields[:-1].split(',') if subField])
            else:
              titles.extend([f'{field}.{subField}' for subField in subFields[:-1].split(',') if subField])
          elif field.find('.') != -1:
            field, subField = field.split('.', 1)
            if field in DRIVE_LIST_FIELDS:
              titles.append(f'{field}.0.{subField}')
            else:
              titles.append(f'{field}.{subField}')
          elif field.lower() in DRIVE_SUBFIELDS_CHOICE_MAP:
            if field in DRIVE_LIST_FIELDS:
              titles.append(field)
              for subField in iter(DRIVE_SUBFIELDS_CHOICE_MAP[field.lower()].values()):
                if not isinstance(subField, list):
                  titles.append(f'{field}.0.{subField}')
                else:
                  titles.extend([f'{field}.0.{subSubField}' for subSubField in subField])
            else:
              for subField in iter(DRIVE_SUBFIELDS_CHOICE_MAP[field.lower()].values()):
                if not isinstance(subField, list):
                  titles.append(f'{field}.{subField}')
                else:
                  titles.extend([f'{field}.{subSubField}' for subSubField in subField])
          else:
            titles.append(field)
        csvPF.SetTitles(titles)
      else:
        csvPF.SetTitles(nodataFields)
      if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
        _mapDrive3TitlesToDrive2(csvPF.titlesList, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
        _mapDrive3TitlesToDrive2(csvPF.titlesList, API.DRIVE3_TO_DRIVE2_CAPABILITIES_TITLES_MAP)
        csvPF.UpdateMappedTitles()
    if not FJQC.formatJSON:
      csvPF.SetSortTitles(['Owner', 'id', fileNameTitle])
    else:
      csvPF.JSONtitlesList.sort()
      csvPF.FixPathsTitles(csvPF.JSONtitlesList)
      csvPF.MoveJSONTitlesToEnd(['JSON'])
    csvPF.writeCSVfile(f'{Cmd.Argument(GM.Globals[GM.ENTITY_CL_START])} {Cmd.Argument(GM.Globals[GM.ENTITY_CL_START]+1)} Drive Files')
  else:
    if not csvPFco.rows:
      setSysExitRC(NO_ENTITIES_FOUND)
    if summary != FILECOUNT_SUMMARY_NONE:
      writeMimeTypeCountsRow(FILECOUNT_SUMMARY_USER, summaryMimeTypeCounts)
    csvPFco.todrive = csvPF.todrive
    if not countsRowFilter:
      csvPFco.SetRowFilter([])
    csvPFco.writeCSVfile(f'{Cmd.Argument(GM.Globals[GM.ENTITY_CL_START])} {Cmd.Argument(GM.Globals[GM.ENTITY_CL_START]+1)} Drive File Counts')

# gam <UserTypeEntity> print filepaths <DriveFileEntity> [todrive <ToDriveAttribute>*] [oneitemperrow] (orderby <DriveFileOrderByFieldName> [ascending|descending])*
# gam <UserTypeEntity> show filepaths <DriveFileEntity> (orderby <DriveFileOrderByFieldName> [ascending|descending])*
def printShowFilePaths(users):
  fileNameTitle = 'title' if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES] else 'name'
  csvPF = CSVPrintFile(['Owner', 'id', fileNameTitle, 'paths'], 'sortall', ['paths']) if Act.csvFormat() else None
  fileIdEntity = getDriveFileEntity()
  oneItemPerRow = False
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif csvPF and myarg == 'oneitemperrow':
      oneItemPerRow = True
      csvPF.RemoveTitles('paths')
      csvPF.AddTitles('path')
      csvPF.SetSortAllTitles()
      csvPF.SetIndexedTitles([])
    elif myarg == 'orderby':
      OBY.GetChoice()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvPF is not None], orderBy=OBY.orderBy)
    if jcount == 0:
      continue
    filePathInfo = initFilePathInfo()
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields='name,parents,mimeType', supportsAllDrives=True)
        entityType, paths, _ = getFilePaths(drive, None, result, filePathInfo)
        if not csvPF:
          kcount = len(paths)
          entityPerformActionNumItems([entityType, f'{result["name"]} ({fileId})'], kcount, Ent.DRIVE_PATH, j, jcount)
          Ind.Increment()
          k = 0
          for path in paths:
            k += 1
            printEntity([Ent.DRIVE_PATH, path], k, kcount)
          Ind.Decrement()
        else:
          if oneItemPerRow:
            if paths:
              for path in paths:
                csvPF.WriteRow({'Owner': user, 'id': fileId, fileNameTitle: result['name'], 'path': path})
            else:
              csvPF.WriteRow({'Owner': user, 'id': fileId, fileNameTitle: result['name']})
          else:
            csvPF.WriteRowTitles(flattenJSON({'paths': paths}, flattened={'Owner': user, 'id': fileId, fileNameTitle: result['name']}))
      except GAPI.fileNotFound:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], Msg.DOES_NOT_EXIST, j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Drive File Paths')

# gam <UserTypeEntity> print filecounts [todrive <ToDriveAttribute>*]
#	[((query <QueryDriveFile>) | (fullquery <QueryDriveFile>) | <DriveFileQueryShortcut>) (querytime.* <Time>)*]
#	[corpora <CorporaAttribute>]
#	[select <TeamDriveEntity>]
#	[anyowner|(showownedby any|me|others)]
#	[showmimetype [not] <MimeTypeList>] [minimumfilesize <Integer>]
#	[filenamematchpattern <RegularExpression>]
#	<PermissionMatch>* [<PermissionMatchMode>] [<PermissionMatchAction>]
#	[excludetrashed]
#	[summary none|only|plus]
# gam <UserTypeEntity> show filecounts
#	[((query <QueryDriveFile>) | (fullquery <QueryDriveFile>) | <DriveFileQueryShortcut>) (querytime.* <Time>)*]
#	[corpora <CorporaAttribute>]
#	[select <TeamDriveEntity>]
#	[anyowner|(showownedby any|me|others)]
#	[showmimetype [not] <MimeTypeList>] [minimumfilesize <Integer>]
#	[filenamematchpattern <RegularExpression>]
#	<PermissionMatch>* [<PermissionMatchMode>] [<PermissionMatchAction>]
#	[excludetrashed]
#	[summary none|only|plus]
def printShowFileCounts(users):
  def _setSelectionFields():
    if DLP.showOwnedBy is not None:
      fieldsList.extend(OWNED_BY_ME_FIELDS_TITLES)
    if DLP.minimumFileSize is not None:
      fieldsList.append('size')
    if DLP.filenameMatchPattern:
      fieldsList.append('name')
    if DLP.excludeTrashed:
      fieldsList.append('trashed')
    if DLP.PM.permissionMatches:
      fieldsList.extend(['id', 'permissions'])
    if DLP.onlyTeamDrives or getPermissionsForTeamDrives:
      fieldsList.append('driveId')

  def showMimeTypeCounts(user, mimeTypeCounts, teamDriveId, teamDriveName, i, count):
    total = 0
    for mimeTypeCount in iter(mimeTypeCounts.values()):
      total += mimeTypeCount
    if summary != FILECOUNT_SUMMARY_NONE:
      if user != FILECOUNT_SUMMARY_USER:
        for mimeType, mtcount in iter(mimeTypeCounts.items()):
          summaryMimeTypeCounts.setdefault(mimeType, 0)
          summaryMimeTypeCounts[mimeType] += mtcount
        if summary == FILECOUNT_SUMMARY_ONLY:
          return
    if not csvPF:
      if teamDriveId:
        printEntityKVList([Ent.USER, user, Ent.TEAMDRIVE, f'{teamDriveName} ({teamDriveId})'], [Ent.Choose(Ent.DRIVE_FILE_OR_FOLDER, total), total], i, count)
      else:
        printEntityKVList([Ent.USER, user], [Ent.Choose(Ent.DRIVE_FILE_OR_FOLDER, total), total], i, count)
      Ind.Increment()
      for mimeType, mimeTypeCount in sorted(iter(mimeTypeCounts.items())):
        printKeyValueList([mimeType, mimeTypeCount])
      Ind.Decrement()
    else:
      if teamDriveId:
        row = {'User': user, 'id': teamDriveId, 'name': teamDriveName, 'Total': total}
      else:
        row = {'User': user, 'Total': total}
      row.update(mimeTypeCounts)
      csvPF.WriteRowTitles(row)

  csvPF = CSVPrintFile() if Act.csvFormat() else None
  if csvPF:
    csvPF.SetZeroBlankMimeTypeCounts(True)
  fieldsList = ['mimeType']
  DLP = DriveListParameters({'allowChoose': False, 'allowCorpora': True, 'allowQuery': True, 'mimeTypeInQuery': True})
  summary = FILECOUNT_SUMMARY_NONE
  summaryMimeTypeCounts = {}
  fileIdEntity = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif DLP.ProcessArgument(myarg, fileIdEntity):
      pass
    elif myarg == 'select':
      if fileIdEntity:
        usageErrorExit(Msg.CAN_NOT_BE_SPECIFIED_MORE_THAN_ONCE.format('select'))
      fileIdEntity = getTeamDriveEntity()
    elif myarg == 'summary':
      summary = getChoice(FILECOUNT_SUMMARY_CHOICE_MAP, mapChoice=True)
    else:
      unknownArgumentExit()
  if not fileIdEntity:
    fileIdEntity = DLP.GetFileIdEntity()
  if not fileIdEntity.get('teamdrive'):
    btkwargs = DLP.kwargs
  else:
    btkwargs = fileIdEntity['teamdrive']
    fieldsList.append('driveId')
  DLP.Finalize(fileIdEntity)
  if DLP.PM.permissionMatches:
    getPermissionsForTeamDrives = True
    permissionsFields = 'nextPageToken,permissions'
  else:
    getPermissionsForTeamDrives = False
  _setSelectionFields()
  if csvPF:
    csvPF.SetTitles(['User', 'id', 'name', 'Total'] if fileIdEntity.get('teamdrive') else ['User', 'Total'])
    csvPF.SetSortAllTitles()
  pagesFields = getItemFieldsFromFieldsList('files', fieldsList)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    teamDriveId = fileIdEntity.get('teamdrive', {}).get('driveId', None)
    if teamDriveId:
      teamDriveName = _getTeamDriveNameFromId(drive, teamDriveId)
    else:
      teamDriveName = ''
    mimeTypeCounts = {}
    printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=DLP.fileIdEntity['query'])
    pageMessage = getPageMessageForWhom()
    pageToken = None
    totalItems = 0
    maxResults = GC.Values[GC.DRIVE_MAX_RESULTS]
    queryError = userError = False
    while True:
      try:
        feed = callGAPI(drive.files(), 'list',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID, GAPI.FILE_NOT_FOUND,
                                                                    GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                        retryReasons=[GAPI.UNKNOWN_ERROR],
                        pageToken=pageToken,
                        q=DLP.fileIdEntity['query'],
                        fields=pagesFields, pageSize=maxResults, **btkwargs)
      except (GAPI.invalidQuery, GAPI.invalid):
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, None], invalidQuery(DLP.fileIdEntity['query']), i, count)
        queryError = True
        break
      except GAPI.fileNotFound:
        printGotEntityItemsForWhom(0)
        break
      except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        userError = True
        break
      pageToken, totalItems = _processGAPIpagesResult(feed, 'files', None, totalItems, pageMessage, None, Ent.DRIVE_FILE_OR_FOLDER)
      if feed:
        for f_file in feed.get('files', []):
          driveId = f_file.get('driveId')
          checkTeamDrivePermissions = getPermissionsForTeamDrives and driveId and 'permissions' not in f_file
          if (not DLP.CheckShowOwnedBy(f_file) or
              not DLP.CheckShowSharedByMe(f_file) or
              not DLP.CheckExcludeTrashed(f_file) or
              not DLP.CheckMinimumFileSize(f_file) or
              not DLP.CheckFilenameMatch(f_file) or
              (not checkTeamDrivePermissions and not DLP.CheckPermissionMatches(f_file)) or
              (DLP.onlyTeamDrives and not driveId)):
            continue
          if checkTeamDrivePermissions:
            try:
              f_file['permissions'] = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                                    throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST],
                                                    fileId=f_file['id'], fields=permissionsFields, supportsAllDrives=True)
              if not DLP.CheckPermissionMatches(f_file):
                continue
            except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.internalError,
                    GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy, GAPI.badRequest):
              continue
          mimeTypeCounts.setdefault(f_file['mimeType'], 0)
          mimeTypeCounts[f_file['mimeType']] += 1
      if not pageToken or (DLP.maxItems and totalItems >= DLP.maxItems):
        _finalizeGAPIpagesResult(pageMessage)
        break
    if queryError:
      break
    if userError:
      continue
    showMimeTypeCounts(user, mimeTypeCounts, teamDriveId, teamDriveName, i, count)
  if summary != FILECOUNT_SUMMARY_NONE:
    showMimeTypeCounts(FILECOUNT_SUMMARY_USER, summaryMimeTypeCounts, '', '', 0, 0)
  if csvPF:
    csvPF.writeCSVfile('Drive File Counts')

FILETREE_FIELDS_CHOICE_MAP = {
  'explicitlytrashed': 'explicitlyTrashed',
  'filesize': 'size',
  'id': 'id',
  'mime': 'mimeType',
  'mimetype': 'mimeType',
  'owners': 'owners',
  'parents': 'parents',
  'size': 'size',
  'trashed': 'trashed',
  }

FILETREE_FIELDS_PRINT_ORDER = ['id', 'parents', 'owners', 'mimeType', 'size', 'explicitlyTrashed', 'trashed']

# gam <UserTypeEntity> print filetree [todrive <ToDriveAttribute>*]
#	[select <DriveFileEntity>> [selectsubquery <QueryDriveFile>] [depth <Number>]]
#	[anyowner|(showownedby any|me|others)]
#	[showmimetype [not] <MimeTypeList>] [minimumfilesize <Integer>]
#	[filenamematchpattern <RegularExpression>]
#	<PermissionMatch>* [<PermissionMatchMode>] [<PermissionMatchAction>]
#	[excludetrashed]
#	[fields <FileTreeFieldNameList>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [delimiter <Character>]
#	[noindent]
# gam <UserTypeEntity> show filetree
#	[select <DriveFileEntity>> [selectsubquery <QueryDriveFile>] [depth <Number>]]
#	[anyowner|(showownedby any|me|others)]
#	[showmimetype [not] <MimeTypeList>] [minimumfilesize <Integer>]
#	[filenamematchpattern <RegularExpression>]
#	<PermissionMatch>* [<PermissionMatchMode>] [<PermissionMatchAction>]
#	[excludetrashed]
#	[fields <FileTreeFieldNameList>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])* [delimiter <Character>]
def printShowFileTree(users):
  def _showFileInfo(fileEntry, depth, j=0, jcount=0):
    if not DLP.CheckExcludeTrashed(fileEntry):
      return
    if not csvPF:
      fileInfoList = []
      for field in FILETREE_FIELDS_PRINT_ORDER:
        if showFields[field]:
          if field == 'parents':
            parents = fileEntry.get(field, [])
            fileInfoList.extend([field, f'{len(parents)} [{delimiter.join(parents)}]'])
          elif field == 'owners':
            owners = [owner['emailAddress'] for owner in fileEntry.get(field, [])]
            if owners:
              fileInfoList.extend([field, delimiter.join(owners)])
          elif field in {'explicitlyTrashed', 'trashed'}:
            trashed = fileEntry.get(field, False)
            if trashed:
              fileInfoList.extend([field, trashed])
          else:
            fileInfoList.extend([field, fileEntry.get(field, '')])
      if fileInfoList:
        printKeyValueListWithCount([fileEntry['name'], formatKeyValueList('(', fileInfoList, ')')], j, jcount)
      else:
        printKeyValueList([fileEntry['name']])
    else:
      userInfo['index'] += 1
      row = userInfo.copy()
      row['depth'] = depth
      row[fileNameTitle] = ('' if noindent else Ind.SpacesSub1())+fileEntry['name']
      for field in FILETREE_FIELDS_PRINT_ORDER:
        if showFields[field]:
          if field == 'parents':
            row[field] = delimiter.join(fileEntry.get(field, []))
          elif field == 'owners':
            row[field] = delimiter.join([owner['emailAddress'] for owner in fileEntry.get(field, [])])
          elif field == 'size':
            row[fileSize] = fileEntry.get(field, '')
          else:
            row[field] = fileEntry.get(field, '')
      csvPF.WriteRow(row)

  def _showDriveFolderContents(fileEntry, depth):
    for childId in fileEntry['children']:
      childEntry = fileTree.get(childId)
      if childEntry:
        if not DLP.CheckExcludeTrashed(childEntry['info']):
          continue
        if (DLP.CheckMimeType(childEntry['info']) and
            DLP.CheckMinimumFileSize(childEntry['info']) and
            DLP.CheckFilenameMatch(childEntry['info']) and
            DLP.CheckPermissionMatches(childEntry['info'])):
          _showFileInfo(childEntry['info'], depth)
        if childEntry['info']['mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
          Ind.Increment()
          _showDriveFolderContents(childEntry, depth+1)
          Ind.Decrement()

  def _showChildDriveFolderContents(drive, fileEntry, user, i, count, depth):
    if not DLP.CheckExcludeTrashed(fileEntry):
      return
    q = WITH_PARENTS.format(fileEntry['id'])
    if selectSubQuery:
      q += ' and ('+selectSubQuery+')'
    try:
      children = callGAPIpages(drive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID],
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               q=q, orderBy=OBY.orderBy, fields=pagesFields,
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], supportsAllDrives=True, includeItemsFromAllDrives=True)
    except (GAPI.invalidQuery, GAPI.invalid):
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, None], invalidQuery(selectSubQuery), i, count)
      return
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      if not DLP.CheckExcludeTrashed(childEntryInfo):
        continue
      if (DLP.CheckMimeType(childEntryInfo) and
          DLP.CheckMinimumFileSize(childEntryInfo) and
          DLP.CheckFilenameMatch(childEntryInfo) and
          DLP.CheckPermissionMatches(childEntryInfo)):
        _showFileInfo(childEntryInfo, depth)
      if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER and (maxdepth == -1 or depth < maxdepth):
        Ind.Increment()
        _showChildDriveFolderContents(drive, childEntryInfo, user, i, count, depth+1)
        Ind.Decrement()

  csvPF = CSVPrintFile(['User', 'index', 'depth', 'name']) if Act.csvFormat() else None
  maxdepth = -1
  fileIdEntity = {}
  selectSubQuery = ''
  fieldsList = ['driveId', 'id', 'name', 'parents', 'mimeType', 'ownedByMe', 'owners(emailAddress)',
                'shared', 'size', 'explicitlyTrashed', 'trashed']
  showFields = {}
  for field in FILETREE_FIELDS_CHOICE_MAP:
    showFields[FILETREE_FIELDS_CHOICE_MAP[field]] = False
  buildTree = noindent = False
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  DLP = DriveListParameters({'allowChoose': False, 'allowCorpora': False, 'allowQuery': False, 'mimeTypeInQuery': False})
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif DLP.ProcessArgument(myarg, fileIdEntity):
      pass
    elif myarg == 'select':
      if fileIdEntity:
        usageErrorExit(Msg.CAN_NOT_BE_SPECIFIED_MORE_THAN_ONCE.format('select'))
      fileIdEntity = getDriveFileEntity(DLP=DLP)
    elif myarg == 'selectsubquery':
      selectSubQuery = getString(Cmd.OB_QUERY, minLen=0)
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == 'fields':
      for field in _getFieldsList():
        if field in FILETREE_FIELDS_CHOICE_MAP:
          showFields[FILETREE_FIELDS_CHOICE_MAP[field]] = True
          if csvPF:
            csvPF.AddTitle(FILETREE_FIELDS_CHOICE_MAP[field])
        else:
          invalidChoiceExit(field, FILETREE_FIELDS_CHOICE_MAP, True)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif csvPF and myarg == 'noindent':
      noindent = True
    else:
      unknownArgumentExit()
  if csvPF:
    if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
      fileNameTitle = 'title'
      fileSize = 'fileSize'
      _mapDrive3TitlesToDrive2(csvPF.titlesList, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
      csvPF.UpdateMappedTitles()
    else:
      fileNameTitle = 'name'
      fileSize = 'size'
  buildTree = (not fileIdEntity
               or (not fileIdEntity['dict']
                   and not fileIdEntity['query']
                   and not fileIdEntity['teamdrivefilequery']
                   and _simpleFileIdEntityList(fileIdEntity['list'])))
  if buildTree:
    if not fileIdEntity:
      fileIdEntity = initDriveFileEntity()
      DLP.GetFileIdEntity()
    if not fileIdEntity.get('teamdrive'):
      btkwargs = DLP.kwargs
      btkwargs['q'] = DLP.fileIdEntity['query']
      cleanFileIDsList(fileIdEntity, [ROOT, ORPHANS])
    else:
      btkwargs = fileIdEntity['teamdrive']
    DLP.Finalize(fileIdEntity)
  elif not fileIdEntity:
    fileIdEntity = initDriveFileEntity()
  if DLP.PM.permissionMatches:
    fieldsList.append('permissions')
  fields = getFieldsFromFieldsList(fieldsList)
  pagesFields = getItemFieldsFromFieldsList('files', fieldsList)
  teamdriveFields = []
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    if buildTree:
      fileTree, status = initFileTree(drive, fileIdEntity.get('teamdrive'), DLP, teamdriveFields, True)
      if not status:
        continue
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count, query=DLP.fileIdEntity['query'])
      pageMessage = getPageMessageForWhom()
      pageToken = None
      totalItems = 0
      userError = False
      while True:
        try:
          feed = callGAPI(drive.files(), 'list',
                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                          retryReasons=[GAPI.UNKNOWN_ERROR],
                          pageToken=pageToken,
                          orderBy=OBY.orderBy,
                          fields=pagesFields, pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **btkwargs)
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity['teamdrive']['driveId']], str(e), i, count)
          userError = True
          break
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          userError = True
          break
        pageToken, totalItems = _processGAPIpagesResult(feed, 'files', None, totalItems, pageMessage, None, Ent.DRIVE_FILE_OR_FOLDER)
        if feed:
          extendFileTree(fileTree, feed.get('files', []), DLP)
          del feed
        if not pageToken:
          _finalizeGAPIpagesResult(pageMessage)
          break
      if userError:
        continue
      extendFileTreeParents(drive, fileTree, fields)
      DLP.GetLocationFileIdsFromTree(fileTree, fileIdEntity)
    else:
      fileTree = {}
    user, drive, jcount = _validateUserGetFileIDs(origUser, i, count, fileIdEntity, drive=drive, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if csvPF:
      userInfo = {'User': user, 'index': 0, 'depth': 0, fileNameTitle: ''}
    j = 0
    Ind.Increment()
    for fileId in fileIdEntity['list']:
      j += 1
      fileEntry = fileTree.get(fileId)
      if fileEntry:
        fileEntryInfo = fileEntry['info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), 'get',
                                   throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields=fields, supportsAllDrives=True)
          if buildTree:
            fileTree[fileId] = {'info': fileEntryInfo}
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity['teamdrive']['driveId']], str(e), j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      _showFileInfo(fileEntryInfo, -1, j, jcount)
      Ind.Increment()
      if buildTree:
        _showDriveFolderContents(fileEntry, 0)
      else:
        _showChildDriveFolderContents(drive, fileEntryInfo, user, i, count, 0)
      Ind.Decrement()
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Drive File Tree')

def getCreationModificationTimes(path_to_file):
  """
  Try to get the date that a file was created, falling back to when it was
  last modified if that isn't possible.
  See http://stackoverflow.com/a/39501288/1709587 for explanation.
  """
  mtime = os.path.getmtime(path_to_file)
  if platform.system() == 'Windows':
    ctime = os.path.getctime(path_to_file)
  else:
    stat = os.stat(path_to_file)
    try:
      ctime = stat.st_birthtime
    except AttributeError:
      # We're probably on Linux. No easy way to get creation dates here,
      # so we'll settle for when its content was last modified.
      ctime = stat.st_mtime
  return (formatLocalSecondsTimestamp(ctime), formatLocalSecondsTimestamp(mtime))

# gam <UserTypeEntity> create|add drivefile [drivefilename <DriveFileName>]
#	<DriveFileCreateAttribute>* [enforcesingleparent <Boolean>]
#	[csv [todrive <ToDriveAttribute>*]] [returnidonly]
def createDriveFile(users):
  csvPF = media_body = None
  returnIdOnly = False
  body = {}
  parameters = initDriveFileAttributes()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'drivefilename':
      body['name'] = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == 'returnidonly':
      returnIdOnly = True
    elif myarg == 'csv':
      csvPF = CSVPrintFile()
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      getDriveFileAttribute(myarg, body, parameters, True, False)
  if parameters[DFA_LOCALFILEPATH]:
    if parameters[DFA_PRESERVE_FILE_TIMES]:
      setPreservedFileTimes(body, parameters, False)
    media_body = getMediaBody(parameters)
  if csvPF:
    fileNameTitle = 'title' if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES] else 'name'
    csvPF.SetTitles(['User', fileNameTitle, 'id'])
  body.setdefault('name', 'Untitled')
  Act.Set(Act.CREATE)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    if not _getDriveFileParentInfo(drive, user, i, count, body, parameters):
      continue
    try:
      result = callGAPI(drive.files(), 'create',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS,
                                                                    GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.CANNOT_ADD_PARENT,
                                                                    GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR,
                                                                    GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                        enforceSingleParent=parameters[DFA_ENFORCE_SINGLE_PARENT],
                        ocrLanguage=parameters[DFA_OCRLANGUAGE],
                        ignoreDefaultVisibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                        keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                        useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                        media_body=media_body, body=body, fields='id,name,mimeType', supportsAllDrives=True)
      if returnIdOnly:
        writeStdout(f'{result["id"]}\n')
      elif not csvPF:
        titleInfo = f'{result["name"]}({result["id"]})'
        if parameters[DFA_LOCALFILENAME]:
          entityModifierNewValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, titleInfo], Act.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], i, count)
        else:
          entityActionPerformed([Ent.USER, user, _getEntityMimeType(result), titleInfo], i, count)
      else:
        csvPF.WriteRow({'User': user, fileNameTitle: result['name'], 'id': result['id']})
    except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.invalid, GAPI.badRequest, GAPI.cannotAddParent,
            GAPI.fileNotFound, GAPI.unknownError, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, body['name']], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('Files')

# gam <UserTypeEntity> create|add drivefileshortcut <DriveFileEntity> [shortcutname <String>]
#	[<DriveFileParentAttribute>|convertparents]
#	[csv [todrive <ToDriveAttribute>*]] [returnidonly]
def createDriveFileShortcut(users):
  csvPF = baseShortcutName = None
  convertParents = newParentsSpecified = returnIdOnly = False
  fileIdEntity = getDriveFileEntity()
  parentBody = {}
  parentParms = initDriveFileAttributes()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'shortcutname':
      baseShortcutName = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif myarg == 'returnidonly':
      returnIdOnly = True
    elif myarg == 'csv':
      csvPF = CSVPrintFile(['User', 'name', 'id', 'targetName', 'targetId'], 'sortall')
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif getDriveFileParentAttribute(myarg, parentParms):
      if convertParents:
        usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format(myarg, 'convertparents'))
      newParentsSpecified = True
    elif myarg == 'convertparents':
      if newParentsSpecified:
        usageErrorExit(Msg.ARE_MUTUALLY_EXCLUSIVE.format(myarg, '<DriveFileParentAttribute>'))
      convertParents = True
    else:
      unknownArgumentExit()
  if fileIdEntity['query']:
    fileIdEntity['query'] = fileIdEntity['query']+AND_NOT_SHORTCUT
  elif fileIdEntity['teamdrivefilequery']:
    fileIdEntity['teamdrivefilequery'] = fileIdEntity['teamdrivefilequery']+AND_NOT_SHORTCUT
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if not returnIdOnly and not csvPF:
      entityPerformActionSubItemModifierNumItems([Ent.USER, user], Ent.DRIVE_FILE_SHORTCUT,
                                                 Act.MODIFIER_FOR, jcount, Ent.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(drive, user, i, count, parentBody, parentParms):
      continue
    if newParentsSpecified:
      newParents = parentBody['parents']
      numNewParents = len(newParents)
    elif not convertParents:
      newParents = [ROOT]
      numNewParents = 1
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      Act.Set(Act.CREATE)
      try:
        target = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields='mimeType,name,parents', supportsAllDrives=True)
      except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.invalid, GAPI.badRequest,
              GAPI.fileNotFound, GAPI.unknownError, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], str(e), j, jcount)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      targetName = target['name']
      if baseShortcutName:
        shortcutName = baseShortcutName.replace('#filename#', targetName)
      else:
        shortcutName = targetName
      targetEntityType = _getEntityMimeType(target)
      if convertParents:
        newParents = target.get('parents', [])[:-1]
        numNewParents = len(newParents)
        if numNewParents <= 1:
          entityActionNotPerformedWarning([Ent.USER, user, targetEntityType, targetName, Ent.DRIVE_FILE_SHORTCUT, None],
                                          Msg.NO_PARENTS_TO_CONVERT_TO_SHORTCUTS, j, jcount)
          continue
      removeParents = []
      body = {'name': shortcutName, 'mimeType': MIMETYPE_GA_SHORTCUT, 'parents': None, 'shortcutDetails': {'targetId': fileId}}
      if not returnIdOnly and not csvPF:
        entityPerformActionNumItems([Ent.USER, user, targetEntityType, targetName], numNewParents, Ent.DRIVE_FILE_SHORTCUT, j, jcount)
      Ind.Increment()
      k = 0
      for parentId in newParents:
        k += 1
        body['parents'] = [parentId]
        try:
          result = callGAPI(drive.files(), 'create',
                            throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS,
                                                                        GAPI.INVALID, GAPI.BAD_REQUEST, GAPI.FILE_NOT_FOUND, GAPI.UNKNOWN_ERROR,
                                                                        GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                            body=body, fields='id,name', supportsAllDrives=True)
          removeParents.append(parentId)
          if returnIdOnly:
            writeStdout(f'{result["id"]}\n')
          elif not csvPF:
            entityActionPerformed([Ent.USER, user, targetEntityType, targetName, Ent.DRIVE_FILE_SHORTCUT, f'{result["name"]}({result["id"]})'],
                                  k, numNewParents)
          else:
            csvPF.WriteRow({'User': user, 'name': result['name'], 'id': result['id'], 'targetName': targetName, 'targetId': fileId})
        except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.invalid, GAPI.badRequest,
                GAPI.fileNotFound, GAPI.unknownError, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
          entityActionFailedWarning([Ent.USER, user, targetEntityType, targetName, Ent.DRIVE_FILE_SHORTCUT, body['name']], str(e), k, numNewParents)
      Ind.Decrement()
      if convertParents and removeParents:
        if not returnIdOnly and not csvPF:
          lcount = len(removeParents)
          Act.Set(Act.DELETE)
          entityPerformActionNumItems([Ent.USER, user, targetEntityType, targetName], lcount, Ent.DRIVE_PARENT_FOLDER_REFERENCE, j, jcount)
        try:
          callGAPI(drive.files(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST],
                   fileId=fileId,
                   removeParents=','.join(removeParents), body={}, fields='id', supportsAllDrives=True)
          if not returnIdOnly and not csvPF:
            Ind.Increment()
            for l, parent in enumerate(removeParents):
              entityActionPerformed([Ent.USER, user, targetEntityType, targetName, Ent.DRIVE_PARENT_FOLDER_REFERENCE, parent], l+1, lcount)
            Ind.Decrement()
        except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.invalid, GAPI.badRequest,
                GAPI.fileNotFound, GAPI.unknownError, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
          entityActionFailedWarning([Ent.USER, user, targetEntityType, targetName, Ent.DRIVE_PARENT_FOLDER_REFERENCE, str(l)], str(e), j, jcount)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Shortcuts')

SHORTCUT_CODE_VALID = 0
SHORTCUT_CODE_SHORTCUT_NOT_FOUND = 1
SHORTCUT_CODE_NOT_A_SHORTCUT = 2
SHORTCUT_CODE_TARGET_NOT_FOUND = 3
SHORTCUT_CODE_MIMETYPE_MISMATCH = 4

# gam <UserTypeEntity> check drivefileshortcut <DriveFileEntity>
#	[csv [todrive <ToDriveAttribute>*]]
def checkDriveFileShortcut(users):
  csvPF = None
  fileIdEntity = getDriveFileEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'csv':
      csvPF = CSVPrintFile(['User', 'name', 'id', 'owner', 'parentId', 'shortcutDetails.targetId', 'shortcutDetails.targetMimeType',
                            'targetName', 'targetId', 'targetMimeType', 'code'], 'sortall')
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  scfields = 'id,name,mimeType,owners(emailAddress),parents,shortcutDetails'
  trfields = 'id,name,mimeType'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if not csvPF:
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.DRIVE_FILE_SHORTCUT, i, count)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      row = {'User': user, 'id': fileId}
      try:
        scresult = callGAPI(drive.files(), 'get',
                            throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                            fileId=fileId, fields=scfields, supportsAllDrives=True)
        row['name'] = scresult['name']
        if scresult['mimeType'] != MIMETYPE_GA_SHORTCUT:
          if not csvPF:
            entityActionFailedWarning([Ent.USER, user, _getEntityMimeType(scresult), fileId],
                                      Msg.INVALID_MIMETYPE.format(scresult['mimeType'], MIMETYPE_GA_SHORTCUT), j, jcount)
          else:
            row['code'] = SHORTCUT_CODE_NOT_A_SHORTCUT
            csvPF.WriteRow(row)
          continue
        row['owner'] = scresult['owners'][0]['emailAddress']
        row['parentId'] = scresult['parents'][0]
        row['shortcutDetails.targetId'] = scresult['shortcutDetails']['targetId']
        row['shortcutDetails.targetMimeType'] = scresult['shortcutDetails']['targetMimeType']
        trfileId = scresult['shortcutDetails']['targetId']
        try:
          trresult = callGAPI(drive.files(), 'get',
                              throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                              fileId=trfileId, fields=trfields, supportsAllDrives=True)
          row['targetName'] = trresult['name']
          row['targetId'] = trresult['id']
          row['targetMimeType'] = trresult['mimeType']
          entityList = [Ent.USER, user, Ent.DRIVE_FILE_SHORTCUT, f"{scresult['name']}({fileId})",
                        _getEntityMimeType(trresult), f"{trresult['name']}({trfileId})"]
          if scresult['shortcutDetails']['targetMimeType'] == trresult['mimeType']:
            if not csvPF:
              entityActionPerformed(entityList, j, jcount)
            else:
              row['code'] = SHORTCUT_CODE_VALID
          else:
            if not csvPF:
              entityActionFailedWarning(entityList, Msg.MIMETYPE_MISMATCH.format(scresult['shortcutDetails']['targetMimeType'], trresult['mimeType']), j, jcount)
            else:
              row['code'] = SHORTCUT_CODE_MIMETYPE_MISMATCH
        except GAPI.fileNotFound:
          if not csvPF:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_SHORTCUT, f"{scresult['name']}({fileId})",
                                       _getTargetEntityMimeType(scresult), trfileId], Msg.NOT_FOUND, j, jcount)
          else:
            row['code'] = SHORTCUT_CODE_TARGET_NOT_FOUND
      except GAPI.fileNotFound:
        if not csvPF:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_SHORTCUT, fileId], Msg.NOT_FOUND, j, jcount)
        else:
          row['code'] = SHORTCUT_CODE_SHORTCUT_NOT_FOUND
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      if csvPF:
        csvPF.WriteRow(row)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Check Shortcuts')

# gam <UserTypeEntity> update drivefile <DriveFileEntity> [copy] [returnidonly]
#	[retainname | (newfilename <DriveFileName>)]
#	<DriveFileUpdateAttribute>* [enforcesingleparent <Boolean>]
#	[gsheet|csvsheet <SheetEntity>] [charset <String>] [columndelimiter <Character>]
def updateDriveFile(users):
  fileIdEntity = getDriveFileEntity()
  body = {}
  parameters = initDriveFileAttributes()
  media_body = None
  sheetEntity = None
  encoding = GC.Values[GC.CHARSET]
  columnDelimiter = GC.Values[GC.CSV_INPUT_COLUMN_DELIMITER]
  assignLocalName = True
  returnIdOnly = False
  operation = 'update'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'copy':
      operation = 'copy'
      Act.Set(Act.COPY)
    elif myarg == 'returnidonly':
      returnIdOnly = True
    elif myarg == 'retainname':
      assignLocalName = False
    elif myarg == 'newfilename':
      body['name'] = getString(Cmd.OB_DRIVE_FILE_NAME)
    elif getDriveFileAddRemoveParentAttribute(myarg, parameters):
      pass
    elif myarg in {'gsheet', 'csvsheet'}:
      sheetEntity = getSheetEntity()
    elif myarg == 'charset':
      encoding = getString(Cmd.OB_CHAR_SET)
    elif myarg == 'columndelimiter':
      columnDelimiter = getCharacter()
    else:
      getDriveFileAttribute(myarg, body, parameters, assignLocalName, True)
  if operation == 'update' and parameters[DFA_LOCALFILEPATH]:
    if parameters[DFA_PRESERVE_FILE_TIMES]:
      setPreservedFileTimes(body, parameters, True)
    if not sheetEntity:
      media_body = getMediaBody(parameters)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=Ent.DRIVE_FILE_OR_FOLDER if not returnIdOnly else None)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(drive, user, i, count, body, parameters, defaultToRoot=False):
      continue
    newParents = body.pop('parents', [])
    if operation == 'update':
      status, addParentsBase, removeParentsBase = _getDriveFileAddRemoveParentInfo(user, i, count, parameters, drive)
      if not status:
        continue
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity['list']:
        j += 1
        try:
          addParents = addParentsBase[:]
          removeParents = removeParentsBase[:]
          if newParents:
            result = callGAPI(drive.files(), 'get',
                              throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                              fileId=fileId, fields='parents', supportsAllDrives=True)
            addParents.extend(newParents)
            removeParents.extend(result.get('parents', []))
          if sheetEntity:
            entityValueList = [Ent.USER, user, Ent.DRIVE_FILE_ID, fileId]
            try:
              result = callGAPI(drive.files(), 'get',
                                throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND],
                                fileId=fileId, fields='id,mimeType,capabilities(canEdit)', supportsAllDrives=True)
              if result['mimeType'] != MIMETYPE_GA_SPREADSHEET:
                entityActionNotPerformedWarning(entityValueList, f'{Msg.NOT_A} {Ent.Singular(Ent.SPREADSHEET)}', j, jcount)
                continue
              if not result['capabilities']['canEdit']:
                entityActionNotPerformedWarning(entityValueList, Msg.NOT_WRITABLE, j, jcount)
                continue
              _, sheet = buildGAPIServiceObject(API.SHEETS, user)
              if sheet is None:
                continue
              entityValueList.extend([sheetEntity['sheetType'], sheetEntity['sheetValue']])
              spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                                     throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                                     spreadsheetId=fileId,
                                     fields='spreadsheetUrl,sheets(properties(sheetId,title),protectedRanges(range(sheetId),requestingUserCanEdit))')
              sheetId = getSheetIdFromSheetEntity(spreadsheet, sheetEntity)
              if sheetId is None:
                entityActionNotPerformedWarning(entityValueList, Msg.NOT_FOUND, j, jcount)
                continue
              if protectedSheetId(spreadsheet, sheetId):
                entityActionNotPerformedWarning(entityValueList, Msg.NOT_WRITABLE, j, jcount)
                continue
              result = callGAPI(drive.files(), 'update',
                                throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.CANNOT_ADD_PARENT,
                                                                              GAPI.CANNOT_MODIFY_VIEWERS_CAN_COPY_CONTENT,
                                                                              GAPI.TEAMDRIVES_PARENT_LIMIT, GAPI.TEAMDRIVES_FOLDER_MOVE_IN_NOT_SUPPORTED,
                                                                              GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                                fileId=fileId, enforceSingleParent=parameters[DFA_ENFORCE_SINGLE_PARENT],
                                ocrLanguage=parameters[DFA_OCRLANGUAGE],
                                keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                                useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                                addParents=','.join(addParents), removeParents=','.join(removeParents),
                                body=body, fields='id,name,mimeType', supportsAllDrives=True)
### File size check??
              sbody = {
                'requests': [
                  {'updateCells': {'range': {'sheetId': sheetId}, 'fields': '*'}},
                  {'pasteData': {'coordinate': {'sheetId': sheetId, 'rowIndex': '0', 'columnIndex': '0'},
                                 'data': readFile(parameters[DFA_LOCALFILEPATH], encoding=encoding), 'type': 'PASTE_NORMAL', 'delimiter': columnDelimiter}}
                  ]
                }
              callGAPI(sheet.spreadsheets(), 'batchUpdate',
                       throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                       spreadsheetId=fileId, body=sbody)
              entityModifierNewValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, result['name'], sheetEntity['sheetType'], sheetEntity['sheetValue']],
                                                    Act.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], j, jcount)
            except GAPI.fileNotFound as e:
              entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_ID, fileId], str(e), j, jcount)
            except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
                    GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
              entityActionFailedWarning(entityValueList, str(e), j, jcount)
            except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
              userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
              break
          elif media_body:
            result = callGAPI(drive.files(), 'update',
                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.CANNOT_ADD_PARENT,
                                                                            GAPI.FILE_NEVER_WRITABLE, GAPI.CANNOT_MODIFY_VIEWERS_CAN_COPY_CONTENT,
                                                                            GAPI.TEAMDRIVES_PARENT_LIMIT, GAPI.TEAMDRIVES_FOLDER_MOVE_IN_NOT_SUPPORTED,
                                                                            GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                              fileId=fileId, enforceSingleParent=parameters[DFA_ENFORCE_SINGLE_PARENT],
                              ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=','.join(addParents), removeParents=','.join(removeParents),
                              media_body=media_body, body=body, fields='id,name,mimeType',
                              supportsAllDrives=True)
            entityModifierNewValueActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, result['name']], Act.MODIFIER_WITH_CONTENT_FROM, parameters[DFA_LOCALFILENAME], j, jcount)
          else:
            result = callGAPI(drive.files(), 'update',
                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.CANNOT_ADD_PARENT,
                                                                            GAPI.FILE_NEVER_WRITABLE, GAPI.CANNOT_MODIFY_VIEWERS_CAN_COPY_CONTENT,
                                                                            GAPI.TEAMDRIVES_PARENT_LIMIT, GAPI.TEAMDRIVES_FOLDER_MOVE_IN_NOT_SUPPORTED,
                                                                            GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                              fileId=fileId, enforceSingleParent=parameters[DFA_ENFORCE_SINGLE_PARENT],
                              ocrLanguage=parameters[DFA_OCRLANGUAGE],
                              keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                              useContentAsIndexableText=parameters[DFA_USE_CONTENT_AS_INDEXABLE_TEXT],
                              addParents=','.join(addParents), removeParents=','.join(removeParents),
                              body=body, fields='id,name,mimeType',
                              supportsAllDrives=True)
            if result:
              entityActionPerformed([Ent.USER, user, _getEntityMimeType(result), result['name']], j, jcount)
            else:
              entityActionPerformed([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
                GAPI.unknownError, GAPI.invalid, GAPI.badRequest, GAPI.cannotAddParent,
                GAPI.fileNeverWritable, GAPI.cannotModifyViewersCanCopyContent,
                GAPI.teamDrivesParentLimit, GAPI.teamDrivesFolderMoveInNotSupported, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
    else:
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity['list']:
        j += 1
        try:
          result = callGAPI(drive.files(), 'copy',
                            throwReasons=GAPI.DRIVE_COPY_THROW_REASONS+[GAPI.CANNOT_MODIFY_VIEWERS_CAN_COPY_CONTENT],
                            fileId=fileId, enforceSingleParent=parameters[DFA_ENFORCE_SINGLE_PARENT],
                            ignoreDefaultVisibility=parameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            keepRevisionForever=parameters[DFA_KEEP_REVISION_FOREVER],
                            body=body, fields='id,name', supportsAllDrives=True)
          if returnIdOnly:
            writeStdout(f'{result["id"]}\n')
          else:
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, fileId],
                                                               Act.MODIFIER_TO, result['name'], [Ent.DRIVE_FILE_ID, result['id']], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
                GAPI.unknownError, GAPI.invalid, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.cannotModifyViewersCanCopyContent) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()

STAT_FOLDER_TOTAL = 0
STAT_FOLDER_COPIED_MOVED = 1
STAT_FOLDER_MERGED = 2
STAT_FOLDER_DUPLICATE = 3
STAT_FOLDER_FAILED = 4
STAT_FOLDER_NOT_WRITABLE = 5
STAT_FOLDER_PERMISSIONS_FAILED = 6
STAT_FILE_TOTAL = 7
STAT_FILE_COPIED_MOVED = 8
STAT_FILE_DUPLICATE = 9
STAT_FILE_FAILED = 10
STAT_FILE_NOT_COPYABLE_MOVABLE = 11
STAT_FILE_PERMISSIONS_FAILED = 12
STAT_LENGTH = 13

FOLDER_SUBTOTAL_STATS = [STAT_FOLDER_COPIED_MOVED, STAT_FOLDER_DUPLICATE, STAT_FOLDER_MERGED, STAT_FOLDER_FAILED, STAT_FOLDER_NOT_WRITABLE]
FILE_SUBTOTAL_STATS = [STAT_FILE_COPIED_MOVED, STAT_FILE_DUPLICATE, STAT_FILE_FAILED, STAT_FILE_NOT_COPYABLE_MOVABLE]

def _initStatistics():
  return [0] * STAT_LENGTH

def _incrStatistic(statistics, stat):
  statistics[stat] += 1
  if stat in FOLDER_SUBTOTAL_STATS:
    statistics[STAT_FOLDER_TOTAL] += 1
  elif stat in FILE_SUBTOTAL_STATS:
    statistics[STAT_FILE_TOTAL] += 1

def _printStatistics(user, statistics, i, count, copy):
  if statistics[STAT_FOLDER_TOTAL]:
    if copy:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FOLDER),
                         Msg.STATISTICS_COPY_FOLDER.format(statistics[STAT_FOLDER_TOTAL],
                                                           statistics[STAT_FOLDER_COPIED_MOVED],
                                                           statistics[STAT_FOLDER_DUPLICATE],
                                                           statistics[STAT_FOLDER_MERGED],
                                                           statistics[STAT_FOLDER_FAILED],
                                                           statistics[STAT_FOLDER_NOT_WRITABLE],
                                                           statistics[STAT_FOLDER_PERMISSIONS_FAILED])],
                        i, count)
    else:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FOLDER),
                         Msg.STATISTICS_MOVE_FOLDER.format(statistics[STAT_FOLDER_TOTAL],
                                                           statistics[STAT_FOLDER_COPIED_MOVED],
                                                           statistics[STAT_FOLDER_DUPLICATE],
                                                           statistics[STAT_FOLDER_MERGED],
                                                           statistics[STAT_FOLDER_FAILED],
                                                           statistics[STAT_FOLDER_NOT_WRITABLE])],
                        i, count)
  if statistics[STAT_FILE_TOTAL]:
    if copy:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FILE),
                         Msg.STATISTICS_COPY_FILE.format(statistics[STAT_FILE_TOTAL],
                                                         statistics[STAT_FILE_COPIED_MOVED],
                                                         statistics[STAT_FILE_DUPLICATE],
                                                         statistics[STAT_FILE_FAILED],
                                                         statistics[STAT_FILE_NOT_COPYABLE_MOVABLE],
                                                         statistics[STAT_FILE_PERMISSIONS_FAILED])],
                        i, count)
    else:
      printEntityKVList([Ent.USER, user],
                        [Ent.Plural(Ent.DRIVE_FILE),
                         Msg.STATISTICS_MOVE_FILE.format(statistics[STAT_FILE_TOTAL],
                                                         statistics[STAT_FILE_COPIED_MOVED],
                                                         statistics[STAT_FILE_DUPLICATE],
                                                         statistics[STAT_FILE_FAILED],
                                                         statistics[STAT_FILE_NOT_COPYABLE_MOVABLE])],
                        i, count)

DUPLICATE_FILE_OVERWRITE_OLDER = 0
DUPLICATE_FILE_OVERWRITE_ALL = 1
DUPLICATE_FILE_DUPLICATE_NAME = 2
DUPLICATE_FILE_UNIQUE_NAME = 3
DUPLICATE_FILE_SKIP = 4
DUPLICATE_FOLDER_MERGE = 0
DUPLICATE_FOLDER_DUPLICATE_NAME = 1
DUPLICATE_FOLDER_UNIQUE_NAME = 2
DUPLICATE_FOLDER_SKIP = 3
COPY_NO_PARENTS = 0
COPY_NONPATH_PARENTS = 1
COPY_ALL_PARENTS = 2

def initCopyMoveOptions(move):
  return {
    'move': move,
    'sourceDriveId': None,
    'destDriveId': None,
    'newFilename': None,
    'summary': False,
    'mergeWithParent': False,
    'mergeWithParentRetain': False,
    'retainSourceFolders': False,
    'duplicateFiles': DUPLICATE_FILE_OVERWRITE_OLDER,
    'duplicateFolders': DUPLICATE_FOLDER_MERGE,
    'copyTopFileParents': COPY_NO_PARENTS,
    'copySubFileParents': COPY_NONPATH_PARENTS,
    'copyTopFolderParents': COPY_NO_PARENTS,
    'copySubFolderParents': COPY_NONPATH_PARENTS,
    'copyFilePermissions': False,
    'copyTopFolderPermissions': True,
    'copySubFolderPermissions': True,
    }

def getCopyMoveOptions(myarg, copyMoveOptions, copyCmd):
  if myarg == 'newfilename':
    copyMoveOptions['newFilename'] = getString(Cmd.OB_DRIVE_FILE_NAME)
  elif myarg == 'summary':
    copyMoveOptions['summary'] = getBoolean()
  elif myarg == 'mergewithparent':
    copyMoveOptions['mergeWithParent'] = getBoolean()
    if copyMoveOptions['mergeWithParent']:
      copyMoveOptions['mergeWithParentRetain'] = False
  elif myarg == 'duplicatefiles':
    copyMoveOptions['duplicateFiles'] = getChoice(DUPLICATE_FILE_CHOICES, mapChoice=True)
  elif myarg == 'duplicatefolders':
    copyMoveOptions['duplicateFolders'] = getChoice(DUPLICATE_FOLDER_CHOICES, mapChoice=True)
  elif myarg == 'copysubfileparents':
    copyMoveOptions['copySubFileParents'] = getChoice(COPY_SUB_PARENTS_CHOICES, mapChoice=True)
  elif myarg == 'copysubfolderparents':
    copyMoveOptions['copySubFolderParents'] = getChoice(COPY_SUB_PARENTS_CHOICES, mapChoice=True)
  else:
    if not copyCmd:
      if myarg == 'retainsourcefolders':
        copyMoveOptions['retainSourceFolders'] = getBoolean()
      elif myarg == 'mergewithparentretain':
        copyMoveOptions['mergeWithParentRetain'] = getBoolean()
        if copyMoveOptions['mergeWithParentRetain']:
          copyMoveOptions['mergeWithParent'] = False
      else:
        return False
    else:
      if myarg == 'copytopfileparents':
        copyMoveOptions['copyTopFileParents'] = getChoice(COPY_TOP_PARENTS_CHOICES, mapChoice=True)
      elif myarg == 'copytopfolderparents':
        copyMoveOptions['copyTopFolderParents'] = getChoice(COPY_TOP_PARENTS_CHOICES, mapChoice=True)
      elif myarg == 'copyfilepermissions':
        copyMoveOptions['copyFilePermissions'] = getBoolean()
      elif myarg == 'copytopfolderpermissions':
        copyMoveOptions['copyTopFolderPermissions'] = getBoolean()
      elif myarg == 'copysubfolderpermissions':
        copyMoveOptions['copySubFolderPermissions'] = getBoolean()
      else:
        return False
  return True

CLEAR_COPY_MOVE_PARENT_OPTIONS = {
  'copyTopFileParents': COPY_NO_PARENTS,
  'copySubFileParents': COPY_NO_PARENTS,
  'copyTopFolderParents': COPY_NO_PARENTS,
  'copySubFolderParents': COPY_NO_PARENTS,
  }
CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS = {
  'copyTopFolderPermissions': False,
  'copySubFolderPermissions': False,
  }

def _targetFilenameExists(destFilename, mimeType, targetChildren):
  destFilenameLower = destFilename.lower()
  for target in targetChildren:
    if destFilenameLower == target['name'].lower() and mimeType == target['mimeType']:
      return True
  return False

UNIQUE_PREFIX_PATTERN = re.compile(r'^(.+)\(\d+\)$')

def _getFilenamePrefix(destFilename):
  if destFilename.find('.') != -1:
    (base, _) = destFilename.rsplit('.', 1)
  else:
    base = destFilename
  mg = UNIQUE_PREFIX_PATTERN.match(base)
  if mg:
    return mg.group(1)
  return base

def _getUniqueFilename(destFilename, mimeType, targetChildren):
  if not _targetFilenameExists(destFilename, mimeType, targetChildren):
    return destFilename
  if destFilename.find('.') != -1:
    (base, ext) = destFilename.rsplit('.', 1)
    mg = UNIQUE_PREFIX_PATTERN.match(base)
    if mg:
      base = mg.group(1)
    pattern = re.compile(fr'^{base}\((\d+)\)\.{ext}$', flags=re.IGNORECASE)
  else:
    base = destFilename
    ext = None
    mg = UNIQUE_PREFIX_PATTERN.match(base)
    if mg:
      base = mg.group(1)
    pattern = re.compile(fr'^{base}\((\d+)\)$', flags=re.IGNORECASE)
  n = 0
  for target in targetChildren:
    mg = pattern.match(target['name'])
    if mg:
      v = int(mg.group(1))
      if v > n:
        n = v
  if ext is not None:
    return f'{base}({n+1}).{ext}'
  return f'{base}({n+1})'

def _copyPermissions(drive, user, i, count, j, jcount, entityType, fileId, fileTitle, newFileId, newFileTitle,
                     statistics, stat, copyMoveOptions):
  try:
    try:
      permissions = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                  throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                  fileId=fileId,
                                  fields='nextPageToken,permissions(allowFileDiscovery,domain,emailAddress,expirationTime,id,role,type,deleted)',
                                  supportsAllDrives=True)
    except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
      entityActionFailedWarning([Ent.USER, user, entityType, fileTitle], str(e), j, jcount)
      _incrStatistic(statistics, stat)
      return
    for permission in permissions:
      if permission.get('deleted', False):
        continue
      if ((permission['role'] not in {'owner', 'organizer', 'fileOrganizer'}) and
          not (copyMoveOptions['destDriveId'] and permission['id'] == 'anyone')):
        permission.pop('id')
        try:
          callGAPI(drive.permissions(), 'create',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST,
                                                                 GAPI.OWNER_ON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                 GAPI.ORGANIZER_ON_NON_TEAMDRIVE_ITEM_NOT_SUPPORTED,
                                                                 GAPI.FILE_ORGANIZER_ON_NON_TEAMDRIVE_NOT_SUPPORTED,
                                                                 GAPI.TEAMDRIVES_SHARING_RESTRICTION_NOT_ALLOWED],
                   fileId=newFileId, sendNotificationEmail=False, emailMessage=None,
                   body=permission, fields='', supportsAllDrives=True)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                GAPI.ownerOnTeamDriveItemNotSupported,
                GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.fileOrganizerOnNonTeamDriveNotSupported, GAPI.teamDrivesSharingRestrictionNotAllowed) as e:
          entityActionFailedWarning([Ent.USER, user, entityType, newFileTitle], str(e), j, jcount)
        except GAPI.invalidSharingRequest as e:
          entityActionFailedWarning([Ent.USER, user, entityType, newFileTitle], Ent.TypeNameMessage(Ent.PERMISSION_ID, permission['id'], str(e)), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    _incrStatistic(statistics, stat)

def _identicalSourceTarget(fileId, targetChildren):
  for target in targetChildren:
    if fileId == target['id']:
      return True
  return False

def _checkForDuplicateTargetFile(drive, user, k, kcount, child, destFilename, targetChildren, copyMoveOptions, statistics):
  destFilenameLower = destFilename.lower()
  for target in targetChildren:
    if not target.get('processed', False) and destFilenameLower == target['name'].lower() and child['mimeType'] == target['mimeType']:
      target['processed'] = True
      if copyMoveOptions['duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER]:
        if (copyMoveOptions['duplicateFiles'] == DUPLICATE_FILE_OVERWRITE_OLDER) and (child['modifiedTime'] <= target['modifiedTime']):
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child['name'], Ent.DRIVE_FILE, target['name']], Msg.DUPLICATE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_DUPLICATE)
          return True
        if not target['capabilities']['canDelete']:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child['name'], Ent.DRIVE_FILE, target['name']], Msg.NOT_DELETABLE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_FAILED)
          return True
        try:
          callGAPI(drive.files(), 'delete',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                   fileId=target['id'], supportsAllDrives=True)
          child['name'] = destFilename
          return False
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileNeverWritable) as e:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child['name'], Ent.DRIVE_FILE, target['name']], f'{Msg.NOT_DELETABLE}: {str(e)}', k, kcount)
          _incrStatistic(statistics, STAT_FILE_FAILED)
          return True
      if copyMoveOptions['duplicateFiles'] == DUPLICATE_FILE_DUPLICATE_NAME:
        child['name'] = destFilename
        return False
      if copyMoveOptions['duplicateFiles'] == DUPLICATE_FILE_UNIQUE_NAME:
        child['name'] = _getUniqueFilename(destFilename, child['mimeType'], targetChildren)
        return False
      #copyMoveOptions['duplicateFiles'] == DUPLICATE_FILE_SKIP
      entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, child['name'], Ent.DRIVE_FILE, target['name']], Msg.DUPLICATE, k, kcount)
      _incrStatistic(statistics, STAT_FILE_DUPLICATE)
      return True
  child['name'] = destFilename
  return False

def _getCopyMoveParentInfo(drive, user, i, count, j, jcount, newParentId, statistics):
  try:
    return callGAPI(drive.files(), 'get',
                    throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                    fileId=newParentId, fields='name,driveId', supportsAllDrives=True)
  except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
          GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.fileNeverWritable) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, newParentId], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  _incrStatistic(statistics, STAT_FILE_FAILED)
  return None

def _getCopyMoveTargetInfo(drive, user, i, count, j, jcount, source, destFilename, newParentId, statistics, parentParms):
  try:
    return callGAPIpages(drive.files(), 'list', 'files',
                         throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                         retryReasons=[GAPI.UNKNOWN_ERROR],
                         q=f"mimeType = '{source['mimeType']}' and name contains '{escapeDriveFileName(_getFilenamePrefix(destFilename))}' and trashed = false and '{newParentId}' in parents",
                         orderBy='folder desc,name,modifiedTime desc',
                         fields='nextPageToken,files(id,name,capabilities,mimeType,modifiedTime)',
                         **parentParms[DFA_SEARCHARGS])
  except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
          GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.fileNeverWritable) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, newParentId], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  _incrStatistic(statistics, STAT_FILE_FAILED)
  return None

DUPLICATE_FILE_CHOICES = {
  'overwriteall': DUPLICATE_FILE_OVERWRITE_ALL,
  'overwriteolder': DUPLICATE_FILE_OVERWRITE_OLDER,
  'duplicatename': DUPLICATE_FILE_DUPLICATE_NAME,
  'uniquename': DUPLICATE_FILE_UNIQUE_NAME,
  'skip': DUPLICATE_FILE_SKIP,
  }
DUPLICATE_FOLDER_CHOICES = {
  'merge': DUPLICATE_FOLDER_MERGE,
  'duplicatename': DUPLICATE_FOLDER_DUPLICATE_NAME,
  'uniquename': DUPLICATE_FOLDER_UNIQUE_NAME,
  'skip': DUPLICATE_FOLDER_SKIP,
  }
COPY_TOP_PARENTS_CHOICES = {'all': COPY_ALL_PARENTS, 'none': COPY_NO_PARENTS}
COPY_SUB_PARENTS_CHOICES = {'all': COPY_ALL_PARENTS, 'none': COPY_NO_PARENTS, 'nonpath': COPY_NONPATH_PARENTS}

# gam <UserTypeEntity> copy drivefile <DriveFileEntity> [newfilename <DriveFileName>]
#	[summary [<Boolean>]] [excludetrashed] [returnidonly]
#	<DriveFileCopyAttribute>*
#	[mergewithparent [<Boolean>]] [recursive [depth <Number>]]
#	[duplicatefiles overwriteolder|overwriteall|duplicatename|uniquename|skip]
#	[duplicatefolders merge|duplicatename|uniquename|skip]
#	[copytopfileparents none|all] [copytopfolderparents none|all]
#	[copysubfileparents nonpath|none|all] [copysubfolderparents nonpath|none|all]
#	[copyfilepermissions [<Boolean>]]
#	[copytopfolderpermissions [<Boolean>]] [copysubfolderpermissions [<Boolean>]]
def copyDriveFile(users):
  def _cloneFolderCopy(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren,
                       atTop, newParentId, copyMoveOptions, statistics):
    folderId = source.pop('id')
    folderTitle = source['name']
    if atTop and copyMoveOptions['mergeWithParent']:
      action = Act.Get()
      Act.Set(Act.MERGE)
      entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                         Act.MODIFIER_WITH, newFolderTitle,
                                                         [Ent.DRIVE_FOLDER_ID, newParentId], j, jcount)
      Act.Set(action)
      _incrStatistic(statistics, STAT_FOLDER_MERGED)
      source.pop('oldparents', None)
      return (newParentId, True)
    if copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
      newFolderTitleLower = newFolderTitle.lower()
      for target in targetChildren:
        if not target.get('processed', False) and newFolderTitleLower == target['name'].lower() and source['mimeType'] == target['mimeType']:
          target['processed'] = True
          if target['capabilities']['canAddChildren']:
            newFolderId = target['id']
            action = Act.Get()
            Act.Set(Act.MERGE)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                               Act.MODIFIER_WITH, newFolderTitle,
                                                               [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
            Act.Set(action)
            _incrStatistic(statistics, STAT_FOLDER_MERGED)
            if copyMoveOptions[['copySubFolderPermissions', 'copyTopFolderPermissions'][atTop]]:
              _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FOLDER, folderId, folderTitle, newFolderId, newFolderTitle,
                               statistics, STAT_FOLDER_PERMISSIONS_FAILED, copyMoveOptions)
            return (newFolderId, True)
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], Msg.NOT_WRITABLE, j, jcount)
          _incrStatistic(statistics, STAT_FOLDER_NOT_WRITABLE)
          return (None, False)
    source.pop('oldparents', None)
    body = source.copy()
    body.pop('capabilities', None)
    if copyMoveOptions['sourceDriveId'] or copyMoveOptions['destDriveId']:
      body.pop('copyRequiresWriterPermission', None)
      body.pop('writersCanShare', None)
    body.pop('trashed', None)
    if not copyMoveOptions['destDriveId']:
      body.pop('driveId', None)
    if copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
      newFolderTitle = _getUniqueFilename(newFolderTitle, source['mimeType'], targetChildren)
    elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
      if _targetFilenameExists(newFolderTitle, source['mimeType'], targetChildren):
        entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], Msg.DUPLICATE, j, jcount)
        _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
        return (None, False)
    body['name'] = newFolderTitle
    try:
      newFolderId = callGAPI(drive.files(), 'create',
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS, GAPI.INTERNAL_ERROR],
                             body=body, fields='id', supportsAllDrives=True)['id']
      if returnIdOnly:
        writeStdout(f'{newFolderId}\n')
      else:
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                           Act.MODIFIER_TO, newFolderTitle,
                                                           [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
      _incrStatistic(statistics, STAT_FOLDER_COPIED_MOVED)
      if copyMoveOptions[['copySubFolderPermissions', 'copyTopFolderPermissions'][atTop]]:
        _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FOLDER, folderId, folderTitle, newFolderId, newFolderTitle,
                         statistics, STAT_FOLDER_PERMISSIONS_FAILED, copyMoveOptions)
      return (newFolderId, False)
    except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.internalError) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], str(e), j, jcount)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    _incrStatistic(statistics, STAT_FOLDER_FAILED)
    copyMoveOptions['retainSourceFolders'] = True
    return (None, False)

  def _recursiveFolderCopy(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, depth, atTop, newParentId):
    folderId = source['id']
    newFolderId, existingTargetFolder = _cloneFolderCopy(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren,
                                                         atTop, newParentId, copyMoveOptions, statistics)
    if newFolderId is None:
      return
    if maxdepth != -1 and depth > maxdepth:
      return
    depth += 1
    copiedFiles[newFolderId] = 1
    sourceChildren = callGAPIpages(drive.files(), 'list', 'files',
                                   throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                   retryReasons=[GAPI.UNKNOWN_ERROR],
                                   q=WITH_PARENTS.format(folderId),
                                   fields='nextPageToken,files(id,name,parents,appProperties,capabilities,contentHints,copyRequiresWriterPermission,'\
                                     'description,folderColorRgb,mimeType,modifiedTime,properties,starred,driveId,trashed,viewedByMeTime,writersCanShare)',
                                   orderBy='folder desc,name,modifiedTime desc',
                                   pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **sourceSearchArgs)
    kcount = len(sourceChildren)
    if kcount > 0:
      if existingTargetFolder:
        subTargetChildren = callGAPIpages(drive.files(), 'list', 'files',
                                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                          retryReasons=[GAPI.UNKNOWN_ERROR],
                                          q=ANY_NON_TRASHED_WITH_PARENTS.format(newFolderId),
                                          orderBy='folder desc,name,modifiedTime desc',
                                          fields='nextPageToken,files(id,name,capabilities,mimeType,modifiedTime)',
                                          **parentParms[DFA_SEARCHARGS])
      else:
        subTargetChildren = []
      Ind.Increment()
      k = 0
      for child in sourceChildren:
        k += 1
        childId = child['id']
        childTitle = child['name']
        if copiedFiles.get(childId):
          continue
        trashed = child.pop('trashed', False)
        if excludeTrashed and trashed:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(child), childTitle],
                                          Msg.IN_TRASH_AND_EXCLUDE_TRASHED, k, kcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        if childId == newFolderId:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(child), childTitle], Msg.NOT_COPYABLE, k, kcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        childParents = child.pop('parents', [])
        child['parents'] = [newFolderId]
        if child['mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions['copySubFolderParents'] != COPY_NO_PARENTS:
            for parentId in childParents:
              if parentId != folderId or copyMoveOptions['copySubFolderParents'] == COPY_ALL_PARENTS:
                child['parents'].append(parentId)
          _recursiveFolderCopy(drive, user, i, count, k, kcount, child, childTitle, subTargetChildren, depth, False, newFolderId)
        else:
          if not child.pop('capabilities')['canCopy']:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], Msg.NOT_COPYABLE, k, kcount)
            _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
            continue
          if existingTargetFolder and _checkForDuplicateTargetFile(drive, user, k, kcount, child, child['name'], subTargetChildren, copyMoveOptions, statistics):
            continue
          if copyMoveOptions['copySubFileParents'] != COPY_NO_PARENTS:
            for parentId in childParents:
              if parentId != folderId or copyMoveOptions['copySubFileParents'] == COPY_ALL_PARENTS:
                child['parents'].append(parentId)
          child.pop('id')
          if copyMoveOptions['destDriveId']:
            child.pop('copyRequiresWriterPermission', None)
            child.pop('writersCanShare', None)
          try:
            result = callGAPI(drive.files(), 'copy',
                              throwReasons=GAPI.DRIVE_COPY_THROW_REASONS,
                              fileId=childId, body=child, fields='id,name', supportsAllDrives=True)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, childTitle],
                                                               Act.MODIFIER_TO, result['name'], [Ent.DRIVE_FILE_ID, result['id']], k, kcount)
            _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
            copiedFiles[result['id']] = 1
            if copyMoveOptions['copyFilePermissions']:
              _copyPermissions(drive, user, i, count, k, kcount, Ent.DRIVE_FILE, childId, childTitle, result['id'], result['name'],
                               statistics, STAT_FILE_PERMISSIONS_FAILED, copyMoveOptions)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.cannotCopyFile, GAPI.badRequest, GAPI.responsePreparationFailure, GAPI.rateLimitExceeded, GAPI.userRateLimitExceeded) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], str(e), k, kcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
      Ind.Decrement()

  fileIdEntity = getDriveFileEntity()
  copyBody = {}
  parentBody = {}
  parentParms = initDriveFileAttributes()
  copyParameters = initDriveFileAttributes()
  copyMoveOptions = initCopyMoveOptions(False)
  excludeTrashed = newParentsSpecified = recursive = returnIdOnly = False
  maxdepth = -1
  copiedFiles = {}
  statistics = _initStatistics()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if getCopyMoveOptions(myarg, copyMoveOptions, True):
      pass
    elif getDriveFileParentAttribute(myarg, parentParms):
      newParentsSpecified = True
    elif myarg == 'returnidonly':
      returnIdOnly = True
    elif myarg == 'excludetrashed':
      excludeTrashed = True
    elif myarg == 'recursive':
      recursive = getBoolean()
    elif myarg == 'depth':
      maxdepth = getInteger(minVal=-1)
    elif myarg == 'convert':
      deprecatedArgument(myarg)
    elif myarg == 'mimetype':
      copyBody['mimeType'] = getMimeType()
    elif myarg == 'ignoredefaultvisibility':
      copyParameters[DFA_IGNORE_DEFAULT_VISIBILITY] = getBoolean()
    elif myarg in {'keeprevisionforever', 'pinned'}:
      copyParameters[DFA_KEEP_REVISION_FOREVER] = getBoolean()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=Ent.DRIVE_FILE_OR_FOLDER if not returnIdOnly else None)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(drive, user, i, count, parentBody, parentParms):
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        source = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId,
                          fields='id,name,parents,appProperties,capabilities,contentHints,copyRequiresWriterPermission,'\
                            'description,mimeType,modifiedTime,properties,starred,driveId,trashed,viewedByMeTime,writersCanShare',
                          supportsAllDrives=True)
        sourceFilename = source['name']
        copyMoveOptions['sourceDriveId'] = source.get('driveId')
        if excludeTrashed and source['trashed']:
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename],
                                          Msg.IN_TRASH_AND_EXCLUDE_TRASHED, j, jcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        if copyMoveOptions['sourceDriveId']:
          sourceSearchArgs = {'driveId': copyMoveOptions['sourceDriveId'], 'corpora': 'drive', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
        else:
          sourceSearchArgs = {}
        sourceParents = source.pop('parents', [])
        if newParentsSpecified:
          newParents = parentBody['parents']
          numNewParents = len(newParents)
          if numNewParents > 1:
            entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename],
                                            Msg.MULTIPLE_PARENTS_SPECIFIED.format(numNewParents), j, jcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
        else:
          newParents = sourceParents if sourceParents else [ROOT]
        newParentId = newParents[0]
        source['parents'] = newParents
        dest = _getCopyMoveParentInfo(drive, user, i, count, j, jcount, newParentId, statistics)
        if dest is None:
          continue
        copyMoveOptions['destDriveId'] = dest.get('driveId')
        if copyMoveOptions['destDriveId'] and not parentParms[DFA_SEARCHARGS]:
          parentParms[DFA_SEARCHARGS] = {'driveId': copyMoveOptions['destDriveId'], 'corpora': 'drive',
                                         'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
        if copyMoveOptions['newFilename']:
          destFilename = copyMoveOptions['newFilename']
        elif copyMoveOptions['mergeWithParent']:
          destFilename = dest['name']
        elif ((newParentsSpecified and newParentId not in sourceParents) or
              ((newParentId in sourceParents and
                (source['mimeType'] == MIMETYPE_GA_FOLDER and copyMoveOptions['duplicateFolders'] != DUPLICATE_FOLDER_MERGE) or
                (source['mimeType'] != MIMETYPE_GA_FOLDER and copyMoveOptions['duplicateFiles'] not in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER])))):
          destFilename = sourceFilename
        else:
          destFilename = f'Copy of {sourceFilename}'
        targetChildren = _getCopyMoveTargetInfo(drive, user, i, count, j, jcount, source, destFilename, newParentId, statistics, parentParms)
        if targetChildren is None:
          continue
        if copyMoveOptions['sourceDriveId'] or copyMoveOptions['destDriveId']:
          copyMoveOptions.update(CLEAR_COPY_MOVE_PARENT_OPTIONS)
        if copyMoveOptions['destDriveId']:
          copyMoveOptions.update(CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS)
        if source['mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
            if _identicalSourceTarget(fileId, targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, sourceFilename], Msg.NOT_COPYABLE_SAME_NAME_CURRENT_FOLDER_MERGE, j, jcount)
              _incrStatistic(statistics, STAT_FOLDER_FAILED)
              continue
          elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
            destFilename = _getUniqueFilename(destFilename, source['mimeType'], targetChildren)
          elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
            if _targetFilenameExists(destFilename, source['mimeType'], targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, destFilename], Msg.DUPLICATE, j, jcount)
              _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
              continue
          if copyMoveOptions['copyTopFolderParents'] == COPY_ALL_PARENTS:
            for parentId in sourceParents:
              if parentId not in newParents:
                source['parents'].append(parentId)
          if recursive:
            _recursiveFolderCopy(drive, user, i, count, j, jcount, source, destFilename, targetChildren, 0, True, newParentId)
          else:
            _cloneFolderCopy(drive, user, i, count, j, jcount, source, destFilename, targetChildren,
                             True, newParentId, copyMoveOptions, statistics)
        else:
          if not source.pop('capabilities')['canCopy']:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_COPYABLE, j, jcount)
            _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
            continue
          if copyMoveOptions['duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER] and _identicalSourceTarget(fileId, targetChildren):
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_COPYABLE_SAME_NAME_CURRENT_FOLDER_OVERWRITE, j, jcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
          if _checkForDuplicateTargetFile(drive, user, j, jcount, source, destFilename, targetChildren, copyMoveOptions, statistics):
            continue
          if copyMoveOptions['copyTopFileParents'] == COPY_ALL_PARENTS:
            for parentId in sourceParents:
              if parentId not in newParents:
                source['parents'].append(parentId)
          sourceId = source.pop('id')
          source.pop('trashed', None)
          if copyMoveOptions['destDriveId']:
            source.pop('copyRequiresWriterPermission', None)
            source.pop('writersCanShare', None)
          source.update(copyBody)
          result = callGAPI(drive.files(), 'copy',
                            throwReasons=GAPI.DRIVE_COPY_THROW_REASONS,
                            fileId=fileId,
                            ignoreDefaultVisibility=copyParameters[DFA_IGNORE_DEFAULT_VISIBILITY],
                            keepRevisionForever=copyParameters[DFA_KEEP_REVISION_FOREVER],
                            body=source, fields='id,name', supportsAllDrives=True)
          if returnIdOnly:
            writeStdout(f'{result["id"]}\n')
          else:
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename],
                                                               Act.MODIFIER_TO, result['name'], [Ent.DRIVE_FILE_ID, result['id']], j, jcount)
          _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
          if copyMoveOptions['copyFilePermissions']:
            _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FILE, sourceId, sourceFilename, result['id'], result['name'],
                             statistics, STAT_FILE_PERMISSIONS_FAILED, copyMoveOptions)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
              GAPI.unknownError, GAPI.cannotCopyFile, GAPI.badRequest, GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        _incrStatistic(statistics, STAT_FILE_FAILED)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        _incrStatistic(statistics, STAT_FILE_FAILED)
        break
    Ind.Decrement()
    if copyMoveOptions['summary']:
      _printStatistics(user, statistics, i, count, True)

# gam <UserTypeEntity> move drivefile <DriveFileEntity> [newfilename <DriveFileName>]
#	[summary [<Boolean>]]
#	[<DriveFileParentAttribute>]
#       [mergewithparent|mergewithparentretain [<Boolean>]]
#	[duplicatefiles overwriteolder|overwriteall|duplicatename|uniquename|skip]
#	[duplicatefolders merge|duplicatename|uniquename|skip]
#	[copysubfileparents nonpath|none|all] [copysubfolderparents nonpath|none|all]
#	[retainsourcefolders [<Boolean>]]
def moveDriveFile(users):
  def _cloneFolderMove(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren,
                       atTop, newParentId, copyMoveOptions, statistics):
    folderId = source.pop('id')
    folderTitle = source['name']
    if atTop and (copyMoveOptions['mergeWithParent'] or copyMoveOptions['mergeWithParentRetain']):
      action = Act.Get()
      Act.Set(Act.MERGE)
      entityPerformActionModifierNewValueItemValueList([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                       Act.MODIFIER_CONTENTS_WITH, newFolderTitle,
                                                       [Ent.DRIVE_FOLDER_ID, newParentId], j, jcount)
      Act.Set(action)
      _incrStatistic(statistics, STAT_FOLDER_MERGED)
      source.pop('oldparents', None)
      return (newParentId, True)
    if copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
      newFolderTitleLower = newFolderTitle.lower()
      for target in targetChildren:
        if not target.get('processed', False) and newFolderTitleLower == target['name'].lower() and source['mimeType'] == target['mimeType']:
          target['processed'] = True
          if target['capabilities']['canAddChildren']:
            newFolderId = target['id']
            action = Act.Get()
            Act.Set(Act.MERGE)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                               Act.MODIFIER_WITH, newFolderTitle,
                                                               [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
            Act.Set(action)
            _incrStatistic(statistics, STAT_FOLDER_MERGED)
            return (newFolderId, True)
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], Msg.NOT_WRITABLE, j, jcount)
          _incrStatistic(statistics, STAT_FOLDER_NOT_WRITABLE)
          return (None, False)
    elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
      newFolderTitle = _getUniqueFilename(newFolderTitle, source['mimeType'], targetChildren)
    elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
      if _targetFilenameExists(newFolderTitle, source['mimeType'], targetChildren):
        entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], Msg.DUPLICATE, j, jcount)
        _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
        return (None, False)
    if (not copyMoveOptions['retainSourceFolders'] and
        (copyMoveOptions['copySubFileParents'] == COPY_NONPATH_PARENTS) and (copyMoveOptions['copySubFolderParents'] == COPY_NONPATH_PARENTS) and
        (copyMoveOptions['sourceDriveId'] or not copyMoveOptions['destDriveId'])):
      body = {'name': newFolderTitle}
      removeParents = ','.join([parentId for parentId in source.pop('oldparents', []) if parentId not in source['parents']])
      try:
        callGAPI(drive.files(), 'update',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST,
                                                               GAPI.FILE_OWNER_NOT_MEMBER_OF_TEAMDRIVE,
                                                               GAPI.FILE_OWNER_NOT_MEMBER_OF_WRITER_DOMAIN,
                                                               GAPI.FILE_WRITER_TEAMDRIVE_MOVE_IN_DISABLED,
                                                               GAPI.CANNOT_MOVE_TRASHED_ITEM_INTO_TEAMDRIVE,
                                                               GAPI.CANNOT_MOVE_TRASHED_ITEM_OUT_OF_TEAMDRIVE],
                 fileId=folderId,
                 addParents=newParentId, removeParents=removeParents,
                 body=body, fields='id', supportsAllDrives=True)
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                           Act.MODIFIER_TO, newFolderTitle,
                                                           [Ent.DRIVE_FOLDER_ID, newParentId], j, jcount)
        _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
        return (None, False)
      except (GAPI.badRequest, GAPI.fileOwnerNotMemberOfTeamDrive, GAPI.fileOwnerNotMemberOfWriterDomain,
              GAPI.fileWriterTeamDriveMoveInDisabled,
              GAPI.cannotMoveTrashedItemIntoTeamDrive, GAPI.cannotMoveTrashedItemOutOfTeamDrive) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, folderTitle], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      _incrStatistic(statistics, STAT_FILE_FAILED)
      copyMoveOptions['retainSourceFolders'] = True
      return (None, False)
    source.pop('oldparents', None)
    body = source.copy()
    body.pop('capabilities', None)
    if copyMoveOptions['sourceDriveId'] or copyMoveOptions['destDriveId']:
      body.pop('copyRequiresWriterPermission', None)
      body.pop('writersCanShare', None)
    body.pop('trashed', None)
    if not copyMoveOptions['destDriveId']:
      body.pop('driveId', None)
    body['name'] = newFolderTitle
    try:
      newFolderId = callGAPI(drive.files(), 'create',
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS, GAPI.INTERNAL_ERROR],
                             body=body, fields='id', supportsAllDrives=True)['id']
      entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folderTitle],
                                                         Act.MODIFIER_TO, newFolderTitle,
                                                         [Ent.DRIVE_FOLDER_ID, newFolderId], j, jcount)
      _incrStatistic(statistics, STAT_FOLDER_COPIED_MOVED)
      if copyMoveOptions[['copySubFolderPermissions', 'copyTopFolderPermissions'][atTop]]:
        _copyPermissions(drive, user, i, count, j, jcount, Ent.DRIVE_FOLDER, folderId, folderTitle, newFolderId, newFolderTitle,
                         statistics, STAT_FOLDER_PERMISSIONS_FAILED, copyMoveOptions)
      return (newFolderId, False)
    except (GAPI.forbidden, GAPI.insufficientFilePermissions, GAPI.internalError) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, newFolderTitle], str(e), j, jcount)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    _incrStatistic(statistics, STAT_FOLDER_FAILED)
    copyMoveOptions['retainSourceFolders'] = True
    return (None, False)

  def _recursiveFolderMove(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren, atTop, newParentId):
    folderId = source['id']
    newFolderId, existingTargetFolder = _cloneFolderMove(drive, user, i, count, j, jcount, source, newFolderTitle, targetChildren,
                                                         atTop, newParentId, copyMoveOptions, statistics)
    if newFolderId is None:
      return
    movedFiles[newFolderId] = 1
    sourceChildren = callGAPIpages(drive.files(), 'list', 'files',
                                   throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                   retryReasons=[GAPI.UNKNOWN_ERROR],
                                   q=WITH_PARENTS.format(folderId),
                                   orderBy='folder desc,name,modifiedTime desc',
                                   fields='nextPageToken,files(id,name,parents,appProperties,capabilities,contentHints,copyRequiresWriterPermission,'\
                                     'description,folderColorRgb,mimeType,modifiedTime,properties,starred,driveId,trashed,viewedByMeTime,writersCanShare)',
                                   pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **sourceSearchArgs)
    kcount = len(sourceChildren)
    if kcount > 0:
      if existingTargetFolder:
        subTargetChildren = callGAPIpages(drive.files(), 'list', 'files',
                                          throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                          retryReasons=[GAPI.UNKNOWN_ERROR],
                                          q=ANY_NON_TRASHED_WITH_PARENTS.format(newFolderId),
                                          orderBy='folder desc,name,modifiedTime desc',
                                          fields='nextPageToken,files(id,name,capabilities,mimeType,modifiedTime)',
                                          **parentParms[DFA_SEARCHARGS])
      else:
        subTargetChildren = []
      Ind.Increment()
      k = 0
      for child in sourceChildren:
        k += 1
        childId = child['id']
        childTitle = child['name']
        if movedFiles.get(childId):
          continue
        trashed = child.pop('trashed', False)
        if (childId == newFolderId) or (copyMoveOptions['destDriveId'] and trashed):
          entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(child), childTitle],
                                          [Msg.NOT_MOVABLE, Msg.NOT_MOVABLE_IN_TRASH][trashed], k, kcount)
          _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
          continue
        childParents = child.pop('parents', [])
        child['parents'] = [newFolderId]
        if child['mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions['copySubFolderParents'] != COPY_NO_PARENTS:
            for parentId in childParents:
              if parentId != folderId or copyMoveOptions['copySubFolderParents'] == COPY_ALL_PARENTS:
                child['parents'].append(parentId)
          child['oldparents'] = childParents
          _recursiveFolderMove(drive, user, i, count, k, kcount, child, childTitle, subTargetChildren, False, newFolderId)
        else:
          if existingTargetFolder and _checkForDuplicateTargetFile(drive, user, k, kcount, child, childTitle, subTargetChildren, copyMoveOptions, statistics):
            copyMoveOptions['retainSourceFolders'] = True
            continue
          body = {'name': child['name']}
          if copyMoveOptions['copySubFileParents'] == COPY_NONPATH_PARENTS:
            removeParents = folderId
          elif copyMoveOptions['copySubFileParents'] == COPY_NO_PARENTS:
            removeParents = ','.join(childParents)
          else: #COPY_ALL_PARENTS
            removeParents = ''
          try:
            result = callGAPI(drive.files(), 'update',
                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST,
                                                                            GAPI.FILE_OWNER_NOT_MEMBER_OF_TEAMDRIVE,
                                                                            GAPI.FILE_OWNER_NOT_MEMBER_OF_WRITER_DOMAIN,
                                                                            GAPI.FILE_WRITER_TEAMDRIVE_MOVE_IN_DISABLED,
                                                                            GAPI.CANNOT_MOVE_TRASHED_ITEM_INTO_TEAMDRIVE,
                                                                            GAPI.CANNOT_MOVE_TRASHED_ITEM_OUT_OF_TEAMDRIVE],
                              fileId=childId,
                              addParents=newFolderId, removeParents=removeParents,
                              body=body, fields='id,name', supportsAllDrives=True)
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, childTitle],
                                                               Act.MODIFIER_TO, result['name'],
                                                               [Ent.DRIVE_FILE_ID, result['id']], k, kcount)
            _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.badRequest, GAPI.fileOwnerNotMemberOfTeamDrive, GAPI.fileOwnerNotMemberOfWriterDomain,
                  GAPI.fileWriterTeamDriveMoveInDisabled,
                  GAPI.cannotMoveTrashedItemIntoTeamDrive, GAPI.cannotMoveTrashedItemOutOfTeamDrive) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE, childTitle], str(e), k, kcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            copyMoveOptions['retainSourceFolders'] = True
      Ind.Decrement()
    if (atTop and copyMoveOptions['mergeWithParentRetain']) or copyMoveOptions['retainSourceFolders'] or source['name'] in [MY_DRIVE, TEAM_DRIVE]:
      Act.Set(Act.RETAIN)
      entityActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, source['name'], Ent.DRIVE_FOLDER_ID, folderId], i, count)
    else:
      Act.Set(Act.DELETE)
      try:
        callGAPI(drive.files(), 'delete',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                 fileId=folderId, supportsAllDrives=True)
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, source['name'], Ent.DRIVE_FOLDER_ID, folderId], i, count)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER_ID, folderId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Act.Set(Act.MOVE)
    return

  fileIdEntity = getDriveFileEntity()
  parentBody = {}
  parentParms = initDriveFileAttributes()
  copyMoveOptions = initCopyMoveOptions(True)
  newParentsSpecified = False
  movedFiles = {}
  statistics = _initStatistics()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if getCopyMoveOptions(myarg, copyMoveOptions, False):
      pass
    elif getDriveFileParentAttribute(myarg, parentParms):
      newParentsSpecified = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    if not _getDriveFileParentInfo(drive, user, i, count, parentBody, parentParms):
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        source = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId,
                          fields='id,name,parents,appProperties,capabilities,contentHints,copyRequiresWriterPermission,'\
                            'description,mimeType,modifiedTime,properties,starred,driveId,trashed,viewedByMeTime,writersCanShare',
                          supportsAllDrives=True)
        sourceFilename = source['name']
        copyMoveOptions['sourceDriveId'] = source.get('driveId')
        if copyMoveOptions['sourceDriveId']:
          if source['trashed']:
            entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename],
                                            Msg.NOT_MOVABLE_IN_TRASH, j, jcount)
            _incrStatistic(statistics, STAT_FILE_NOT_COPYABLE_MOVABLE)
            continue
          sourceSearchArgs = {'driveId': copyMoveOptions['sourceDriveId'], 'corpora': 'drive', 'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
        else:
          sourceSearchArgs = {}
        sourceParents = source.pop('parents', [])
        if newParentsSpecified:
          newParents = parentBody['parents']
          numNewParents = len(newParents)
          if numNewParents > 1:
            entityActionNotPerformedWarning([Ent.USER, user, _getEntityMimeType(source), sourceFilename],
                                            Msg.MULTIPLE_PARENTS_SPECIFIED.format(numNewParents), j, jcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
        else:
          newParents = sourceParents if sourceParents else [ROOT]
        newParentId = newParents[0]
        source['parents'] = newParents
        dest = _getCopyMoveParentInfo(drive, user, i, count, j, jcount, newParentId, statistics)
        if dest is None:
          continue
        copyMoveOptions['destDriveId'] = dest.get('driveId')
        if copyMoveOptions['destDriveId'] and not parentParms[DFA_SEARCHARGS]:
          parentParms[DFA_SEARCHARGS] = {'driveId': copyMoveOptions['destDriveId'], 'corpora': 'drive',
                                         'includeItemsFromAllDrives': True, 'supportsAllDrives': True}
        if copyMoveOptions['newFilename']:
          destFilename = copyMoveOptions['newFilename']
        elif copyMoveOptions['mergeWithParent'] or copyMoveOptions['mergeWithParentRetain']:
          destFilename = dest['name']
        else:
          destFilename = sourceFilename
        targetChildren = _getCopyMoveTargetInfo(drive, user, i, count, j, jcount, source, destFilename, newParentId, statistics, parentParms)
        if targetChildren is None:
          continue
        if copyMoveOptions['sourceDriveId'] or copyMoveOptions['destDriveId']:
          copyMoveOptions.update(CLEAR_COPY_MOVE_PARENT_OPTIONS)
        copyMoveOptions.update(CLEAR_COPY_MOVE_FOLDER_PERMISSION_OPTIONS)
        if source['mimeType'] == MIMETYPE_GA_FOLDER:
          if copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_MERGE:
            if _identicalSourceTarget(fileId, targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, sourceFilename], Msg.NOT_MOVABLE_SAME_NAME_CURRENT_FOLDER_MERGE, j, jcount)
              _incrStatistic(statistics, STAT_FOLDER_FAILED)
              continue
          elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_UNIQUE_NAME:
            destFilename = _getUniqueFilename(destFilename, source['mimeType'], targetChildren)
          elif copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_SKIP:
            if _targetFilenameExists(destFilename, source['mimeType'], targetChildren):
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, destFilename], Msg.DUPLICATE, j, jcount)
              _incrStatistic(statistics, STAT_FOLDER_DUPLICATE)
              continue
          if ((copyMoveOptions['sourceDriveId'] != copyMoveOptions['destDriveId']) or
              copyMoveOptions['mergeWithParent'] or copyMoveOptions['mergeWithParentRetain'] or copyMoveOptions['retainSourceFolders'] or
              (copyMoveOptions['copySubFileParents'] != COPY_NONPATH_PARENTS) or (copyMoveOptions['copySubFolderParents'] != COPY_NONPATH_PARENTS) or
              (copyMoveOptions['duplicateFolders'] == DUPLICATE_FOLDER_MERGE and _targetFilenameExists(destFilename, source['mimeType'], targetChildren))):
            source['oldparents'] = sourceParents
            _recursiveFolderMove(drive, user, i, count, j, jcount, source, destFilename, targetChildren, True, newParentId)
            continue
          body = {'name': destFilename}
        else:
          if copyMoveOptions['duplicateFiles'] in [DUPLICATE_FILE_OVERWRITE_ALL, DUPLICATE_FILE_OVERWRITE_OLDER] and _identicalSourceTarget(fileId, targetChildren):
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename], Msg.NOT_MOVABLE_SAME_NAME_CURRENT_FOLDER_OVERWRITE, j, jcount)
            _incrStatistic(statistics, STAT_FILE_FAILED)
            continue
          if _checkForDuplicateTargetFile(drive, user, j, jcount, source, destFilename, targetChildren, copyMoveOptions, statistics):
            continue
          body = {'name': source['name']}
# All parents removed from top level moved item as non-path parents can't be determined
        removeParents = ','.join(sourceParents)
        result = callGAPI(drive.files(), 'update',
                          throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST,
                                                                        GAPI.FILE_OWNER_NOT_MEMBER_OF_TEAMDRIVE,
                                                                        GAPI.FILE_OWNER_NOT_MEMBER_OF_WRITER_DOMAIN,
                                                                        GAPI.FILE_WRITER_TEAMDRIVE_MOVE_IN_DISABLED,
                                                                        GAPI.CANNOT_MOVE_TRASHED_ITEM_INTO_TEAMDRIVE,
                                                                        GAPI.CANNOT_MOVE_TRASHED_ITEM_OUT_OF_TEAMDRIVE],
                          fileId=fileId,
                          addParents=newParentId, removeParents=removeParents,
                          body=body, fields='name', supportsAllDrives=True)
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, Ent.DRIVE_FILE, sourceFilename],
                                                           Act.MODIFIER_TO, result['name'], [Ent.DRIVE_FOLDER_ID, newParentId], j, jcount)
        _incrStatistic(statistics, STAT_FILE_COPIED_MOVED)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
              GAPI.unknownError, GAPI.cannotCopyFile,
              GAPI.badRequest, GAPI.fileOwnerNotMemberOfTeamDrive, GAPI.fileOwnerNotMemberOfWriterDomain,
              GAPI.fileWriterTeamDriveMoveInDisabled,
              GAPI.cannotMoveTrashedItemIntoTeamDrive, GAPI.cannotMoveTrashedItemOutOfTeamDrive) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        _incrStatistic(statistics, STAT_FILE_FAILED)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        _incrStatistic(statistics, STAT_FILE_FAILED)
        break
    Ind.Decrement()
    if copyMoveOptions['summary']:
      _printStatistics(user, statistics, i, count, False)

DELETE_DRIVEFILE_CHOICE_MAP = {'purge': 'delete', 'trash': 'trash', 'untrash': 'untrash'}
DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP = {'delete': Act.PURGE, 'trash': Act.TRASH, 'untrash': Act.UNTRASH}

# gam <UserTypeEntity> delete drivefile <DriveFileEntity> [purge|trash|untrash]
def deleteDriveFile(users, function=None):
  fileIdEntity = getDriveFileEntity()
  if not function:
    function = getChoice(DELETE_DRIVEFILE_CHOICE_MAP, defaultChoice='trash', mapChoice=True)
  checkForExtraneousArguments()
  Act.Set(DELETE_DRIVEFILE_FUNCTION_TO_ACTION_MAP[function])
  if function != 'delete':
    trash_body = {'trashed': function == 'trash'}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        if function != 'delete':
          result = callGAPI(drive.files(), 'update',
                            throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                            fileId=fileId, body=trash_body, fields='name', supportsAllDrives=True)
          if result and 'name' in result:
            fileName = result['name']
          else:
            fileName = fileId
        else:
          callGAPI(drive.files(), function,
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                   fileId=fileId, supportsAllDrives=True)
          fileName = fileId
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileName], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.fileNeverWritable) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> purge drivefile <DriveFileEntity>
def purgeDriveFile(users):
  deleteDriveFile(users, 'delete')

# gam <UserTypeEntity> trash drivefile <DriveFileEntity>
def trashDriveFile(users):
  deleteDriveFile(users, 'trash')

# gam <UserTypeEntity> untrash drivefile <DriveFileEntity>
def untrashDriveFile(users):
  deleteDriveFile(users, 'untrash')

NON_DOWNLOADABLE_MIMETYPES = [MIMETYPE_GA_FORM, MIMETYPE_GA_FUSIONTABLE, MIMETYPE_GA_MAP]

GOOGLEDOC_VALID_EXTENSIONS_MAP = {
  MIMETYPE_GA_DRAWING: ['.jpeg', '.jpg', '.pdf', '.png', '.svg'],
  MIMETYPE_GA_DOCUMENT: ['.docx', '.html', '.odt', '.pdf', '.rtf', '.txt', '.zip'],
  MIMETYPE_GA_PRESENTATION: ['.pdf', '.pptx', '.odp', '.txt'],
  MIMETYPE_GA_SPREADSHEET: ['.csv', '.ods', '.pdf', '.xlsx', '.zip'],
  }

MICROSOFT_FORMATS_LIST = [{'mime': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'ext': '.docx'},
                          {'mime': 'application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'ext': '.dotx'},
                          {'mime': 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'ext': '.pptx'},
                          {'mime': 'application/vnd.openxmlformats-officedocument.presentationml.template', 'ext': '.potx'},
                          {'mime': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'ext': '.xlsx'},
                          {'mime': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'ext': '.xltx'},
                          {'mime': 'application/msword', 'ext': '.doc'},
                          {'mime': 'application/msword', 'ext': '.dot'},
                          {'mime': 'application/vnd.ms-powerpoint', 'ext': '.ppt'},
                          {'mime': 'application/vnd.ms-powerpoint', 'ext': '.pot'},
                          {'mime': 'application/vnd.ms-excel', 'ext': '.xls'},
                          {'mime': 'application/vnd.ms-excel', 'ext': '.xlt'}]

DOCUMENT_FORMATS_MAP = {
  'csv': [{'mime': 'text/csv', 'ext': '.csv'}],
  'doc': [{'mime': 'application/msword', 'ext': '.doc'}],
  'dot': [{'mime': 'application/msword', 'ext': '.dot'}],
  'docx': [{'mime': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'ext': '.docx'}],
  'dotx': [{'mime': 'application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'ext': '.dotx'}],
  'epub': [{'mime': 'application/epub+zip', 'ext': '.epub'}],
  'html': [{'mime': 'text/html', 'ext': '.html'}],
  'jpeg': [{'mime': 'image/jpeg', 'ext': '.jpeg'}],
  'jpg': [{'mime': 'image/jpeg', 'ext': '.jpg'}],
  'mht': [{'mime': 'message/rfc822', 'ext': 'mht'}],
  'odp': [{'mime': 'application/vnd.oasis.opendocument.presentation', 'ext': '.odp'}],
  'ods': [{'mime': 'application/x-vnd.oasis.opendocument.spreadsheet', 'ext': '.ods'},
          {'mime': 'application/vnd.oasis.opendocument.spreadsheet', 'ext': '.ods'}],
  'odt': [{'mime': 'application/vnd.oasis.opendocument.text', 'ext': '.odt'}],
  'pdf': [{'mime': 'application/pdf', 'ext': '.pdf'}],
  'png': [{'mime': 'image/png', 'ext': '.png'}],
  'ppt': [{'mime': 'application/vnd.ms-powerpoint', 'ext': '.ppt'}],
  'pot': [{'mime': 'application/vnd.ms-powerpoint', 'ext': '.pot'}],
  'potx': [{'mime': 'application/vnd.openxmlformats-officedocument.presentationml.template', 'ext': '.potx'}],
  'pptx': [{'mime': 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'ext': '.pptx'}],
  'rtf': [{'mime': 'application/rtf', 'ext': '.rtf'}],
  'svg': [{'mime': 'image/svg+xml', 'ext': '.svg'}],
  'tsv': [{'mime': 'text/tab-separated-values', 'ext': '.tsv'},
          {'mime': 'text/tsv', 'ext': '.tsv'}],
  'txt': [{'mime': 'text/plain', 'ext': '.txt'}],
  'xls': [{'mime': 'application/vnd.ms-excel', 'ext': '.xls'}],
  'xlt': [{'mime': 'application/vnd.ms-excel', 'ext': '.xlt'}],
  'xlsx': [{'mime': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'ext': '.xlsx'}],
  'xltx': [{'mime': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'ext': '.xltx'}],
  'zip': [{'mime': 'application/zip', 'ext': '.zip'}],
  'ms': MICROSOFT_FORMATS_LIST,
  'microsoft': MICROSOFT_FORMATS_LIST,
  'micro$oft': MICROSOFT_FORMATS_LIST,
  'openoffice': [{'mime': 'application/vnd.oasis.opendocument.presentation', 'ext': '.odp'},
                 {'mime': 'application/x-vnd.oasis.opendocument.spreadsheet', 'ext': '.ods'},
                 {'mime': 'application/vnd.oasis.opendocument.spreadsheet', 'ext': '.ods'},
                 {'mime': 'application/vnd.oasis.opendocument.text', 'ext': '.odt'}],
  }

HTTP_ERROR_PATTERN = re.compile(r'^.*returned "(.*)">$')

# gam <UserTypeEntity> get drivefile <DriveFileEntity> [revision <DriveFileRevisionID>]
#	[(format <FileFormatList>)|(gsheet|csvsheet <SheetEntity>)] [exportsheetaspdf <String>]
#	[targetfolder <FilePath>] [targetname -|<FileName>] [overwrite [<Boolean>]] [showprogress [<Boolean>]]
def getDriveFile(users):
  def closeRemoveTargetFile():
    if fh and not targetStdout:
      closeFile(fh)
      os.remove(filename)

  fileIdEntity = getDriveFileEntity()
  sheetEntity = None
  exportSheetAsPDF = revisionId = ''
  exportFormatName = 'openoffice'
  exportFormatChoices = [exportFormatName]
  exportFormats = DOCUMENT_FORMATS_MAP[exportFormatName]
  targetFolderPattern = GC.Values[GC.DRIVE_DIR]
  targetNamePattern = None
  overwrite = showProgress = suppressStdoutMsgs = targetStdout = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'format':
      exportFormatChoices = getString(Cmd.OB_FORMAT_LIST).replace(',', ' ').lower().split()
      exportFormats = []
      for exportFormat in exportFormatChoices:
        if exportFormat in DOCUMENT_FORMATS_MAP:
          exportFormats.extend(DOCUMENT_FORMATS_MAP[exportFormat])
        else:
          invalidChoiceExit(exportFormat, DOCUMENT_FORMATS_MAP, True)
    elif myarg == 'targetfolder':
      targetFolderPattern = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
    elif myarg == 'targetname':
      targetNamePattern = getString(Cmd.OB_FILE_NAME)
      targetStdout = targetNamePattern == '-'
      suppressStdoutMsgs = False if not targetStdout else GM.Globals[GM.STDOUT][GM.REDIRECT_STD]
    elif myarg == 'overwrite':
      overwrite = getBoolean()
    elif myarg == 'revision':
      revisionId = getString(Cmd.OB_DRIVE_FILE_REVISION_ID)
    elif myarg in {'gsheet', 'csvsheet'}:
      sheetEntity = getSheetEntity()
    elif myarg == 'exportsheetaspdf':
      exportSheetAsPDF = getString(Cmd.OB_STRING, minLen=0)
    elif myarg == 'nocache':
      pass
    elif myarg == 'showprogress':
      showProgress = getBoolean()
    else:
      unknownArgumentExit()
  if exportSheetAsPDF:
    exportFormatName = 'pdf'
    exportFormatChoices = [exportFormatName]
    exportFormats = DOCUMENT_FORMATS_MAP[exportFormatName]
  elif sheetEntity:
    exportFormatName = 'csv'
    exportFormatChoices = [exportFormatName]
    exportFormats = DOCUMENT_FORMATS_MAP[exportFormatName]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE if not suppressStdoutMsgs else None)
    if jcount == 0:
      continue
    _, userName, _ = splitEmailAddressOrUID(user)
    if exportSheetAsPDF or sheetEntity:
      _, sheet = buildGAPIServiceObject(API.SHEETS, user, i, count)
      if not sheet:
        continue
    targetFolder = _substituteForUser(targetFolderPattern, user, userName)
    if not os.path.isdir(targetFolder):
      os.makedirs(targetFolder)
    targetName = _substituteForUser(targetNamePattern, user, userName) if targetNamePattern else None
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      fileExtension = None
      try:
        result = callGAPI(drive.files(), 'get',
                          throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                          fileId=fileId, fields='name,fileExtension,mimeType,size', supportsAllDrives=True)
        if revisionId:
          callGAPI(drive.revisions(), 'get',
                   throwReasons=GAPI.DRIVE_GET_THROW_REASONS+[GAPI.REVISION_NOT_FOUND],
                   fileId=fileId, revisionId=revisionId, fields='id')
        fileExtension = result.get('fileExtension')
        mimeType = result['mimeType']
        if mimeType == MIMETYPE_GA_FOLDER:
          entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, result['name']], Msg.CAN_NOT_BE_DOWNLOADED, j, jcount)
          continue
        entityValueList = [Ent.USER, user, Ent.DRIVE_FILE, result['name']]
        if mimeType in NON_DOWNLOADABLE_MIMETYPES:
          entityActionNotPerformedWarning(entityValueList, Msg.FORMAT_NOT_DOWNLOADABLE, j, jcount)
          continue
        validExtensions = GOOGLEDOC_VALID_EXTENSIONS_MAP.get(mimeType)
        if validExtensions:
          my_line = ['Type', 'Google Doc']
          googleDoc = True
        else:
          if 'size' in result:
            my_line = ['Size', formatFileSize(int(result['size']))]
          else:
            my_line = ['Size', 'Unknown']
          googleDoc = False
        csvSheetNotFound = fileDownloaded = fileDownloadFailed = False
        for exportFormat in exportFormats:
          extension = fileExtension or exportFormat['ext']
          if googleDoc and (extension not in validExtensions):
            continue
          if targetStdout:
            filename = 'stdout'
          else:
            safe_file_title = targetName or cleanFilename(result['name'])
            filename = os.path.join(targetFolder, safe_file_title)
            y = 0
            while True:
              if filename.lower()[-len(extension):] != extension.lower():
                filename += extension
              if overwrite or not os.path.isfile(filename):
                break
              y += 1
              filename = os.path.join(targetFolder, f'({y})-{safe_file_title}')
          spreadsheetUrl = None
          try:
            if googleDoc:
              if (not exportSheetAsPDF and not sheetEntity) or mimeType != MIMETYPE_GA_SPREADSHEET:
                request = drive.files().export_media(fileId=fileId, mimeType=exportFormat['mime'])
                if revisionId:
                  request.uri = f'{request.uri}&revision={revisionId}'
              else:
                spreadsheet = callGAPI(sheet.spreadsheets(), 'get',
                                       throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                                       spreadsheetId=fileId, fields='spreadsheetUrl,sheets(properties(sheetId,title))')
                spreadsheetUrl = f'{re.sub("/edit.*$", "/export", spreadsheet["spreadsheetUrl"])}?exportFormat={exportFormatName}&format={exportFormatName}&id={fileId}'
                if sheetEntity:
                  entityValueList.extend([sheetEntity['sheetType'], sheetEntity['sheetValue']])
                  sheetId = getSheetIdFromSheetEntity(spreadsheet, sheetEntity)
                  if sheetId is None:
                    entityActionNotPerformedWarning(entityValueList, Msg.NOT_FOUND, j, jcount)
                    csvSheetNotFound = True
                    continue
                  spreadsheetUrl += f'&gid={sheetId}'
                spreadsheetUrl += exportSheetAsPDF
            else:
              if revisionId:
                entityValueList.extend([Ent.DRIVE_FILE_REVISION, revisionId])
                request = drive.revisions().get_media(fileId=fileId, revisionId=revisionId)
              else:
                request = drive.files().get_media(fileId=fileId)
            fh = None
            if not spreadsheetUrl:
              if not targetStdout:
                fh = open(filename, 'wb')
              else:
                fh = os.fdopen(os.dup(sys.stdout.fileno()), 'wb')
              downloader = googleapiclient.http.MediaIoBaseDownload(fh, request)
              done = False
              while not done:
                status, done = downloader.next_chunk()
                if showProgress and not suppressStdoutMsgs:
                  entityActionPerformedMessage(entityValueList, f'{status.progress():>7.2%}', j, jcount)
            else:
              fh = open(filename, 'w', encoding=UTF8, newline='') if not targetStdout else sys.stdout
              if GC.Values[GC.DEBUG_LEVEL] > 0:
                sys.stderr.write(f'Debug: spreadsheetUrl: {spreadsheetUrl}\n')
              status, content = drive._http.request(uri=spreadsheetUrl, method='GET')
              if status['status'] == '200':
                fh.write(content.decode(UTF8_SIG))
                if targetStdout and content[-1] != '\n':
                  fh.write('\n')
              else:
                entityModifierNewValueActionFailedWarning(entityValueList, Act.MODIFIER_TO, filename, f'HTTP Error: {status["status"]}', j, jcount)
                fileDownloadFailed = True
                break
            if not targetStdout:
              closeFile(fh)
            if not suppressStdoutMsgs:
              entityModifierNewValueKeyValueActionPerformed(entityValueList, Act.MODIFIER_TO, filename, my_line[0], my_line[1], j, jcount)
            fileDownloaded = True
            break
          except (IOError, httplib2.HttpLib2Error) as e:
            entityModifierNewValueActionFailedWarning(entityValueList, Act.MODIFIER_TO, filename, str(e), j, jcount)
            fileDownloadFailed = True
            closeRemoveTargetFile()
            break
          except googleapiclient.http.HttpError as e:
            mg = HTTP_ERROR_PATTERN.match(str(e))
            if mg:
              entityModifierNewValueActionFailedWarning(entityValueList, Act.MODIFIER_TO, filename, mg.group(1), j, jcount)
            else:
              entityModifierNewValueActionFailedWarning(entityValueList, Act.MODIFIER_TO, filename, str(e), j, jcount)
            fileDownloadFailed = True
            closeRemoveTargetFile()
            break
          closeRemoveTargetFile()
        if not fileDownloaded and not fileDownloadFailed and not csvSheetNotFound:
          entityActionNotPerformedWarning(entityValueList, Msg.FORMAT_NOT_AVAILABLE.format(','.join(exportFormatChoices)), j, jcount)
      except GAPI.fileNotFound:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], Msg.DOES_NOT_EXIST, j, jcount)
      except GAPI.revisionNotFound:
        entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId, Ent.DRIVE_FILE_REVISION, revisionId], Msg.DOES_NOT_EXIST, j, jcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, fileId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> collect orphans (orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[(targetuserfoldername <DriveFolderName>)(targetuserfolderid <DriveFolderID>)] [preview] [todrive <ToDriveAttribute>*]
def collectOrphans(users):
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  csvPF = None
  targetParms = initDriveFileAttributes()
  targetUserFolderId = None
  targetUserFolderPattern = '#user# orphaned files'
  targetParentBody = {}
  query = ME_IN_OWNERS_AND+'trashed = false'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'targetuserfoldername':
      targetUserFolderPattern = getString(Cmd.OB_DRIVE_FOLDER_NAME)
      targetUserFolderId = None
    elif myarg == 'targetuserfolderid':
      targetUserFolderId = getString(Cmd.OB_DRIVE_FOLDER_ID)
      targetUserFolderPattern = None
# Removed 2020-04-19: misidentifies shareWithMe files as orphans
#    elif myarg == 'anyowner':
#      query = _updateAnyOwnerQuery(query)
#    elif myarg == 'showownedby':
#      showOwnedBy = getChoice(SHOW_OWNED_BY_CHOICE_MAP, mapChoice=True)
#      query = _updateQueryWithShowOwnedBy(showOwnedBy, query)
    elif myarg == 'preview':
      csvPF = CSVPrintFile(['Owner', 'type', 'id', 'name'])
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    userName, _ = splitEmailAddress(user)
    try:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, Ent.TypeName(Ent.USER, user), i, count, query=query)
      feed = callGAPIpages(drive.files(), 'list', 'files',
                           pageMessage=getPageMessageForWhom(),
                           throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                           retryReasons=[GAPI.UNKNOWN_ERROR],
                           q=query, orderBy=OBY.orderBy, fields='nextPageToken,files(id,name,parents,mimeType)',
                           pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      if targetUserFolderPattern:
        trgtUserFolderName = _substituteForUser(targetUserFolderPattern, user, userName)
        targetParms[DFA_PARENTQUERY] = MY_NON_TRASHED_FOLDER_NAME.format(escapeDriveFileName(trgtUserFolderName))
      else:
        targetParms[DFA_PARENTID] = targetUserFolderId
        trgtUserFolderName = targetUserFolderId
      if not _getDriveFileParentInfo(drive, user, i, count, targetParentBody, targetParms, True, False):
        continue
      orphanDriveFiles = []
      for fileEntry in feed:
        if not fileEntry.get('parents'):
          orphanDriveFiles.append(fileEntry)
      jcount = len(orphanDriveFiles)
      entityPerformActionNumItemsModifier([Ent.USER, user], jcount, Ent.DRIVE_ORPHAN_FILE_OR_FOLDER,
                                          f'{Act.MODIFIER_INTO} {Ent.Singular(Ent.DRIVE_FOLDER)}: {trgtUserFolderName}', i, count)
      if jcount == 0:
        continue
      if not csvPF:
        if 'parents' not in targetParentBody or not targetParentBody['parents']:
          try:
            newParentId = callGAPI(drive.files(), 'create',
                                   throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS, GAPI.UNKNOWN_ERROR],
                                   body={'name': trgtUserFolderName, 'mimeType': MIMETYPE_GA_FOLDER}, fields='id')['id']
          except (GAPI.forbidden, GAPI.insufficientPermissions, GAPI.unknownError) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, trgtUserFolderName], str(e), i, count)
            continue
        else:
          newParentId = targetParentBody['parents'][0]
      setSysExitRC(ORPHANS_COLLECTED_RC)
      Ind.Increment()
      j = 0
      for fileEntry in orphanDriveFiles:
        j += 1
        fileId = fileEntry['id']
        fileName = fileEntry['name']
        fileType = _getEntityMimeType(fileEntry)
        if csvPF:
          csvPF.WriteRow({'Owner': user, 'type': Ent.Singular(fileType), 'id': fileId, 'name': fileName})
          continue
        try:
          callGAPI(drive.files(), 'update',
                   bailOnInternalError=True,
                   throwReasons=GAPI.DRIVE_USER_THROW_REASONS, retryReasons=[GAPI.FILE_NOT_FOUND],
                   enforceSingleParent=True, fileId=fileId, body={}, addParents=newParentId, fields='')
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, fileType, fileName],
                                                             Act.MODIFIER_INTO, None, [Ent.DRIVE_FOLDER, trgtUserFolderName], j, jcount)
        except (GAPI.fileNotFound, GAPI.internalError) as e:
          entityActionFailedWarning([Ent.USER, user, fileType, fileName], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('Orphans to Collect')

TRANSFER_DRIVEFILE_ACL_ROLES_MAP = {
  'commenter': 'commenter',
  'contentmanager': 'fileOrganizer',
  'contributor': 'writer',
  'editor': 'writer',
  'fileorganizer': 'fileOrganizer',
  'manager': 'organizer',
  'organizer': 'organizer',
  'owner': 'organizer',
  'read': 'reader',
  'reader': 'reader',
  'viewer': 'reader',
  'writer': 'writer',
  'current': 'current',
  'none': 'none',
  'source': 'source',
  }

# gam <UserTypeEntity> transfer drive <UserItem> [select <DriveFileEntity>]
#	[(targetfolderid <DriveFolderID>)|(targetfoldername <DriveFolderName>)] [targetuserfoldername <DriveFolderName>]
#	[targetuserorphansfoldername <DriveFolderName>]
#	[skipids <DriveFileEntity>]
#	[keepuser | (retainrole reader|commenter|writer|editor|fileorganizer|none)] [noretentionmessages]
#	[nonowner_retainrole reader|commenter|writer|editor|fileorganizer|current|none] [nonowner_targetrole reader|commenter|writer|editor|fileorganizer|current|none|source]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[preview] [todrive <ToDriveAttribute>*]
def transferDrive(users):

  def _getOwnerUser(childEntryInfo):
    if 'owners' not in childEntryInfo or not childEntryInfo['owners']:
      return ('Unknown', None)
    ownerUser = childEntryInfo['owners'][0]['emailAddress']
    if ownerUser not in thirdPartyOwners:
      _, ownerDrive = buildGAPIServiceObject(API.DRIVE3, ownerUser, displayError=False)
      thirdPartyOwners[ownerUser] = ownerDrive
    else:
      ownerDrive = thirdPartyOwners[ownerUser]
    return (ownerUser, ownerDrive)

  TARGET_PARENT_ID = 0
  TARGET_ORPHANS_PARENT_ID = 1

  def _buildTargetFile(folderName, folderParentId):
    try:
      op = 'Find Target Folder"'
      result = callGAPIpages(targetDrive.files(), 'list', 'files',
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.BAD_REQUEST],
                             retryReasons=[GAPI.UNKNOWN_ERROR],
                             orderBy=OBY.orderBy,
                             q=MY_NON_TRASHED_FOLDER_NAME_WITH_PARENTS.format(escapeDriveFileName(folderName), folderParentId),
                             fields='nextPageToken,files(id)')
      if result:
        return result[0]['id']
      op = 'Create Target Folder'
      return callGAPI(targetDrive.files(), 'create',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FORBIDDEN, GAPI.INSUFFICIENT_PERMISSIONS, GAPI.UNKNOWN_ERROR, GAPI.BAD_REQUEST],
                      body={'parents': [folderParentId], 'name': folderName, 'mimeType': MIMETYPE_GA_FOLDER}, fields='id')['id']
    except (GAPI.forbidden, GAPI.insufficientPermissions, GAPI.unknownError, GAPI.badRequest) as e:
      entityActionFailedWarning([Ent.USER, targetUser, Ent.DRIVE_FOLDER, folderName], f'{op}: {str(e)}')
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(targetUser, str(e))
    return None

  def _buildTargetUserFolder():
    folderName = _substituteForUser(targetUserFolderPattern, sourceUser, sourceUserName)
    if not folderName:
      return targetFolderId
    return _buildTargetFile(folderName, targetFolderId)

  def _buildTargetUserOrphansFolder():
    folderName = _substituteForUser(targetUserOrphansFolderPattern, sourceUser, sourceUserName)
    if folderName:
      targetIds[TARGET_ORPHANS_PARENT_ID] = _buildTargetFile(folderName, targetIds[TARGET_PARENT_ID])
      if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
        targetIds[TARGET_ORPHANS_PARENT_ID] = targetIds[TARGET_PARENT_ID]
    else:
      targetIds[TARGET_ORPHANS_PARENT_ID] = targetIds[TARGET_PARENT_ID]

  def _getMappedParentForRootParentOrOrphan(childEntryInfo):
    if 'parents' not in childEntryInfo or not childEntryInfo['parents']:
      return targetIds[TARGET_ORPHANS_PARENT_ID]
    for parentId in childEntryInfo['parents']:
      if parentId == sourceRootId:
        return targetIds[TARGET_PARENT_ID]
    return None

  def _setUpdateRole(permission):
    return {'role': permission['role']}

  def _transferFile(childEntry, i, count, j, jcount):
    childEntryInfo = childEntry['info']
    childFileId = childEntryInfo['id']
    childFileName = childEntryInfo['name']
    childFileType = _getEntityMimeType(childEntryInfo)
    if childEntryInfo['ownedByMe']:
      childEntryInfo['sourcePermission'] = {'role': 'owner'}
      for permission in childEntryInfo.get('permissions', []):
        if targetPermissionId == permission['id']:
          childEntryInfo['targetPermission'] = _setUpdateRole(permission)
          updateTargetPermission = True
          break
      else:
        childEntryInfo['targetPermission'] = {'role': 'none'}
        updateTargetPermission = False
      if csvPF:
        csvPF.WriteRow({'OldOwner': sourceUser, 'NewOwner': targetUser, 'type': Ent.Singular(childFileType), 'id': childFileId, 'name': childFileName, 'role': 'owner'})
        return
      Act.Set(Act.TRANSFER_OWNERSHIP)
      addTargetParents = set()
      removeSourceParents = set()
      removeTargetParents = set()
      if 'parents' in childEntryInfo and childEntryInfo['parents']:
        for parentId in childEntryInfo['parents']:
          if parentId in parentIdMap:
            addTargetParents.add(parentIdMap[parentId])
            if parentId != sourceRootId:
              removeSourceParents.add(parentId)
            else:
              removeTargetParents.add(targetRootId)
      else:
        if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
          _buildTargetUserOrphansFolder()
        addTargetParents.add(targetIds[TARGET_ORPHANS_PARENT_ID])
        removeTargetParents.add(targetRootId)
      try:
        actionUser = sourceUser
        if not updateTargetPermission:
          op = 'Create Source ACL'
          callGAPI(sourceDrive.permissions(), 'create',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID_SHARING_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                   fileId=childFileId, sendNotificationEmail=False, body=targetWriterPermissionsBody, fields='')
        op = 'Update Source ACL'
        callGAPI(sourceDrive.permissions(), 'update',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID_OWNERSHIP_TRANSFER,
                                                               GAPI.PERMISSION_NOT_FOUND, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                 fileId=childFileId, permissionId=targetPermissionId,
                 transferOwnership=True, body={'role': 'owner'}, fields='')
        if removeSourceParents:
          op = 'Remove Source Parents'
          callGAPI(sourceDrive.files(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS, retryReasons=[GAPI.BAD_REQUEST, GAPI.FILE_NOT_FOUND], retries=3,
                   fileId=childFileId, removeParents=','.join(removeSourceParents), fields='')
        actionUser = targetUser
        if addTargetParents or removeTargetParents:
          op = 'Add/Remove Target Parents'
          callGAPI(targetDrive.files(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS, retryReasons=[GAPI.BAD_REQUEST, GAPI.FILE_NOT_FOUND], retries=3,
                   fileId=childFileId,
                   addParents=','.join(addTargetParents), removeParents=','.join(removeTargetParents), fields='')
        entityModifierNewValueItemValueListActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], Act.MODIFIER_TO, None, [Ent.USER, targetUser], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.sharingRateLimitExceeded) as e:
        entityActionFailedWarning([Ent.USER, actionUser, childFileType, childFileName], f'{op}: {str(e)}', j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, actionUser, childFileType, childFileName, Ent.PERMISSION_ID, targetPermissionId], j, jcount)
      except GAPI.invalidSharingRequest as e:
        entityActionFailedWarning([Ent.USER, actionUser, childFileType, childFileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, targetPermissionId, str(e)), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(actionUser, str(e), i, count)
    else:
      Act.Set(Act.PROCESS)
      for permission in childEntryInfo.get('permissions', []):
        if sourcePermissionId == permission['id']:
          childEntryInfo['sourcePermission'] = _setUpdateRole(permission)
          getSourcePermissionFromOwner = False
          break
      else:
        childEntryInfo['sourcePermission'] = nonOwnerRetainRoleBody
        getSourcePermissionFromOwner = True
      for permission in childEntryInfo.get('permissions', []):
        if targetPermissionId == permission['id']:
          childEntryInfo['targetPermission'] = _setUpdateRole(permission)
          getTargetPermissionFromOwner = False
          break
      else:
        childEntryInfo['targetPermission'] = {'role': 'none'}
        getTargetPermissionFromOwner = True
      ownerUser, ownerDrive = _getOwnerUser(childEntryInfo)
      if not ownerDrive:
        entityActionNotPerformedWarning([Ent.USER, sourceUser, childFileType, childFileName],
                                        Msg.SERVICE_NOT_APPLICABLE_THIS_ADDRESS.format(ownerUser), j, jcount)
        return
      if getSourcePermissionFromOwner or getTargetPermissionFromOwner:
        try:
          permissions = callGAPIpages(ownerDrive.permissions(), 'list', 'permissions',
                                      throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                      fileId=childFileId, fields='nextPageToken,permissions')
          if getSourcePermissionFromOwner:
            for permission in permissions:
              if sourcePermissionId == permission['id']:
                childEntryInfo['sourcePermission'] = _setUpdateRole(permission)
                break
            else:
              childEntryInfo['sourcePermission'] = nonOwnerRetainRoleBody
          if getTargetPermissionFromOwner:
            for permission in permissions:
              if targetPermissionId == permission['id']:
                childEntryInfo['targetPermission'] = _setUpdateRole(permission)
                break
            else:
              childEntryInfo['targetPermission'] = {'role': 'none'}
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
          return
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(ownerUser, str(e), i, count)
          return
      if csvPF:
        csvPF.WriteRow({'OldOwner': sourceUser, 'NewOwner': targetUser, 'type': Ent.Singular(childFileType),
                        'id': childFileId, 'name': childFileName, 'role': childEntryInfo['sourcePermission']['role']})
        return
      if (childFileType == Ent.DRIVE_FOLDER) and (childEntryInfo['targetPermission']['role'] == 'none') and (ownerRetainRoleBody['role'] == 'none'):
        if targetIds[TARGET_ORPHANS_PARENT_ID] is None:
          _buildTargetUserOrphansFolder()
        parentIdMap[childFileId] = _buildTargetFile(childFileName, targetIds[TARGET_ORPHANS_PARENT_ID])
        entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], j, jcount)
        return
      mappedParentId = _getMappedParentForRootParentOrOrphan(childEntryInfo)
      if mappedParentId is not None:
        if childEntryInfo['targetPermission']['role'] in {'none', 'reader'}:
          try:
            callGAPI(ownerDrive.permissions(), 'create',
                     throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                     fileId=childFileId, sendNotificationEmail=False, body=targetWriterPermissionsBody, fields='')
          except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                  GAPI.badRequest, GAPI.sharingRateLimitExceeded) as e:
            entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
            return
          except GAPI.invalidSharingRequest as e:
            entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName],
                                      Ent.TypeNameMessage(Ent.PERMISSION_ID, sourcePermissionId, str(e)), j, jcount)
            return
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(ownerUser, str(e), i, count)
            return
        try:
          callGAPI(targetDrive.files(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST], retryReasons=[GAPI.FILE_NOT_FOUND], retries=3,
                   fileId=childFileId,
                   addParents=mappedParentId, body={}, fields='')
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest) as e:
          entityActionFailedWarning([Ent.USER, targetUser, childFileType, childFileName], str(e), j, jcount)
          return
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(targetUser, str(e), i, count)
          return
      entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName], j, jcount)

  def _manageRoleRetention(childEntry, i, count, j, jcount):
    def _setTargetInsertBody(permission):
      return {'role': permission['role'], 'type': 'user', 'emailAddress': targetUser}

    def _checkForDiminishedTargetRole(currentPermission, newPermission):
      if currentPermission['role'] in {'owner', 'organizer', 'fileOrganizer', 'writer'}:
        return False
      if (currentPermission['role'] == 'commenter') and (newPermission['role'] == 'reader'):
        return False
      return True

    childEntryInfo = childEntry['info']
    childFileId = childEntryInfo['id']
    childFileName = childEntryInfo['name']
    childFileType = _getEntityMimeType(childEntryInfo)
    if childEntryInfo['ownedByMe']:
      try:
        if ownerRetainRoleBody['role'] != 'none':
          if ownerRetainRoleBody['role'] != 'writer':
            callGAPI(targetDrive.permissions(), 'update',
                     throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                     fileId=childFileId, permissionId=sourcePermissionId, body=ownerRetainRoleBody, fields='')
        else:
          callGAPI(targetDrive.permissions(), 'delete',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED, GAPI.CANNOT_REMOVE_OWNER],
                   fileId=childFileId, permissionId=sourcePermissionId)
        if showRetentionMessages:
          entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName, Ent.ROLE, ownerRetainRoleBody['role']], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.sharingRateLimitExceeded, GAPI.cannotRemoveOwner) as e:
        entityActionFailedWarning([Ent.USER, sourceUser, childFileType, childFileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, sourceUser, childFileType, childFileName, Ent.PERMISSION_ID, sourcePermissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
    else:
      ownerUser, ownerDrive = _getOwnerUser(childEntryInfo)
      if not ownerDrive:
        return
      if nonOwnerRetainRoleBody['role'] == 'current':
        sourceUpdateRole = childEntryInfo['sourcePermission']
      else:
        sourceUpdateRole = nonOwnerRetainRoleBody
      if 'targetPermission' not in childEntryInfo:
        childEntryInfo['targetPermission'] = {'role': 'current'}
        errorTargetRole = True
      else:
        errorTargetRole = False
      if nonOwnerTargetRoleBody['role'] == 'current':
        targetInsertBody = _setTargetInsertBody(childEntryInfo['targetPermission'])
        resetTargetRole = False
      elif nonOwnerTargetRoleBody['role'] == 'source':
        targetInsertBody = _setTargetInsertBody(childEntryInfo['sourcePermission'])
        resetTargetRole = True
      else:
        targetInsertBody = _setTargetInsertBody(nonOwnerTargetRoleBody)
        resetTargetRole = True
      if not errorTargetRole:
        if resetTargetRole:
          resetTargetRole = _checkForDiminishedTargetRole(childEntryInfo['targetPermission'], targetInsertBody)
        elif _getMappedParentForRootParentOrOrphan(childEntryInfo) is not None and childEntryInfo['targetPermission']['role'] in {'none', 'reader'}:
          resetTargetRole = True
      try:
        if nonOwnerRetainRoleBody['role'] != 'none':
          if nonOwnerRetainRoleBody['role'] != 'current':
            callGAPI(ownerDrive.permissions(), 'update',
                     throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                     fileId=childFileId, permissionId=sourcePermissionId, body=sourceUpdateRole, fields='')
        else:
          try:
            callGAPI(ownerDrive.permissions(), 'delete',
                     throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED, GAPI.CANNOT_REMOVE_OWNER],
                     fileId=childFileId, permissionId=sourcePermissionId)
          except GAPI.permissionNotFound:
            pass
        if showRetentionMessages:
          entityActionPerformed([Ent.USER, sourceUser, childFileType, childFileName, Ent.ROLE, sourceUpdateRole['role']], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.sharingRateLimitExceeded, GAPI.cannotRemoveOwner) as e:
        entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, ownerUser, childFileType, childFileName, Ent.PERMISSION_ID, sourcePermissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(ownerUser, str(e), i, count)
      if resetTargetRole and targetUser != ownerUser:
        try:
          if nonOwnerTargetRoleBody['role'] != 'none':
            if nonOwnerTargetRoleBody['role'] != 'current' and targetInsertBody['role'] not in {'current', 'none'}:
              callGAPI(ownerDrive.permissions(), 'create',
                       throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                       fileId=childFileId, sendNotificationEmail=False, body=targetInsertBody, fields='')
          else:
            try:
              callGAPI(ownerDrive.permissions(), 'delete',
                       throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST, GAPI.SHARING_RATE_LIMIT_EXCEEDED],
                       fileId=childFileId, permissionId=targetPermissionId)
            except GAPI.permissionNotFound:
              pass
          if showRetentionMessages:
            entityActionPerformed([Ent.USER, targetUser, childFileType, childFileName, Ent.ROLE, targetInsertBody['role']], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
                GAPI.badRequest, GAPI.sharingRateLimitExceeded) as e:
          entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], str(e), j, jcount)
        except GAPI.invalidSharingRequest as e:
          entityActionFailedWarning([Ent.USER, ownerUser, childFileType, childFileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, targetPermissionId, str(e)), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
      elif showRetentionMessages:
        entityActionPerformed([Ent.USER, targetUser, childFileType, childFileName, Ent.ROLE, childEntryInfo['targetPermission']['role']], j, jcount)

  def _transferDriveFilesFromTree(fileEntry, i, count):
    jcount = len(fileEntry['children'])
    if jcount == 0:
      return
    j = 0
    for childFileId in fileEntry['children']:
      j += 1
      childEntry = fileTree.get(childFileId)
      if not childEntry or childFileId in filesTransferred:
        continue
      if childFileId in skipFileIdEntity['list']:
        entityActionNotPerformedWarning([Ent.USER, sourceUser, _getEntityMimeType(childEntry['info']), f'{childEntry["info"]["name"]} ({childFileId})'],
                                        Msg.IN_SKIPIDS, j, jcount)
        continue
      filesTransferred.add(childFileId)
      _transferFile(childEntry, i, count, j, jcount)
      if childEntry['info']['mimeType'] == MIMETYPE_GA_FOLDER:
        Ind.Increment()
        _transferDriveFilesFromTree(childEntry, i, count)
        Ind.Decrement()

  def _manageRoleRetentionDriveFilesFromTree(fileEntry, i, count):
    jcount = len(fileEntry['children'])
    if jcount == 0:
      return
    j = 0
    for childFileId in fileEntry['children']:
      j += 1
      childEntry = fileTree.get(childFileId)
      if not childEntry or childFileId in filesTransferred or childFileId in skipFileIdEntity['list']:
        continue
      filesTransferred.add(childFileId)
      _manageRoleRetention(childEntry, i, count, j, jcount)
      if childEntry['info']['mimeType'] == MIMETYPE_GA_FOLDER:
        Ind.Increment()
        _manageRoleRetentionDriveFilesFromTree(childEntry, i, count)
        Ind.Decrement()

  def _identifyDriveFileAndChildren(fileEntry, i, count):
    fileId = fileEntry['id']
    if fileId not in fileTree:
      fileTree[fileId] = {'info': fileEntry, 'children': []}
    if fileEntry['mimeType'] != MIMETYPE_GA_FOLDER:
      return
    try:
      children = callGAPIpages(sourceDrive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               orderBy=OBY.orderBy, q=WITH_PARENTS.format(fileId),
                               fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,trashed,owners(emailAddress,permissionId),permissions(id,role))',
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
      return
    for childEntry in children:
      if not childEntry['trashed']:
        childId = childEntry['id']
        if childId in skipFileIdEntity['list']:
          entityActionNotPerformedWarning([Ent.USER, sourceUser, _getEntityMimeType(childEntry), f'{childEntry["name"]} ({childId})'],
                                          Msg.IN_SKIPIDS)
          continue
        fileTree[fileId]['children'].append(childId)
        _identifyDriveFileAndChildren(childEntry, i, count)

  def _transferDriveFileAndChildren(fileEntry, i, count, j, jcount):
    fileId = fileEntry['info']['id']
    if fileId in filesTransferred:
      return
    if fileEntry['info']['name'] != MY_DRIVE:
      filesTransferred.add(fileId)
      _transferFile(fileEntry, i, count, j, jcount)
    kcount = len(fileEntry['children'])
    if kcount == 0:
      return
    k = 0
    for childFileId in fileEntry['children']:
      k += 1
      childEntry = fileTree.get(childFileId)
      if childEntry:
        Ind.Increment()
        _transferDriveFileAndChildren(childEntry, i, count, k, kcount)
        Ind.Decrement()

  def _manageRoleRetentionDriveFileAndChildren(fileEntry, i, count, j, jcount):
    fileId = fileEntry['info']['id']
    if fileId in filesTransferred:
      return
    if fileEntry['info']['name'] != MY_DRIVE:
      filesTransferred.add(fileId)
      _manageRoleRetention(fileEntry, i, count, j, jcount)
    kcount = len(fileEntry['children'])
    if kcount == 0:
      return
    k = 0
    for childFileId in fileEntry['children']:
      k += 1
      childEntry = fileTree.get(childFileId)
      if childEntry:
        Ind.Increment()
        _manageRoleRetentionDriveFileAndChildren(childEntry, i, count, k, kcount)
        Ind.Decrement()

  targetUser = getEmailAddress()
  buildTree = True
  csvPF = None
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  ownerRetainRoleBody = {'role': 'none'}
  nonOwnerRetainRoleBody = {}
  nonOwnerTargetRoleBody = {'role': 'source'}
  showRetentionMessages = True
  targetFolderId = targetFolderName = None
  targetUserFolderPattern = '#user# old files'
  targetUserOrphansFolderPattern = '#user# orphaned files'
  targetIds = [None, None]
  thirdPartyOwners = {}
  skipFileIdEntity = initDriveFileEntity()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'keepuser':
      ownerRetainRoleBody['role'] = 'writer'
    elif myarg == 'retainrole':
      ownerRetainRoleBody['role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if ownerRetainRoleBody['role'] in {'source', 'current'}:
        ownerRetainRoleBody['role'] = 'writer'
    elif myarg == 'nonownerretainrole':
      nonOwnerRetainRoleBody['role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if nonOwnerRetainRoleBody['role'] == 'source':
        nonOwnerRetainRoleBody['role'] = 'current'
    elif myarg == 'nonownertargetrole':
      nonOwnerTargetRoleBody['role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == 'noretentionmessages':
      showRetentionMessages = False
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'targetfolderid':
      targetFolderIdLocation = Cmd.Location()
      targetFolderId = getString(Cmd.OB_DRIVE_FILE_ID, minLen=0)
    elif myarg == 'targetfoldername':
      targetFolderNameLocation = Cmd.Location()
      targetFolderName = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == 'targetuserfoldername':
      targetUserFolderPattern = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == 'targetuserorphansfoldername':
      targetUserOrphansFolderPattern = getString(Cmd.OB_DRIVE_FILE_NAME, minLen=0)
    elif myarg == 'select':
      fileIdEntity = getDriveFileEntity()
      buildTree = False
    elif myarg == 'skipids':
      skipFileIdEntity = getDriveFileEntity()
    elif myarg == 'preview':
      csvPF = CSVPrintFile(['OldOwner', 'NewOwner', 'type', 'id', 'name', 'role'])
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  if not nonOwnerRetainRoleBody:
    nonOwnerRetainRoleBody = ownerRetainRoleBody
  if not OBY.orderBy:
    OBY.SetItems('folder,createdTime')
  targetUser, targetDrive = buildGAPIServiceObject(API.DRIVE3, targetUser)
  if not targetDrive:
    return
  try:
    result = callGAPI(targetDrive.about(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields='storageQuota,user(permissionId)')
    if result['storageQuota'].get('limit'):
      targetDriveFree = int(result['storageQuota']['limit'])-int(result['storageQuota']['usageInDrive'])
    else:
      targetDriveFree = None
    targetPermissionId = result['user']['permissionId']
    result = callGAPI(targetDrive.files(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fileId=ROOT, fields='id,name')
    targetRootId = result['id']
    if not targetFolderId and not targetFolderName:
      targetFolderId = targetRootId
      targetFolderName = result['name']
    else:
      if targetFolderId:
        targetFolder = callGAPI(targetDrive.files(), 'get',
                                throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                fileId=targetFolderId, fields='id,name,mimeType,ownedByMe')
        if targetFolder['mimeType'] != MIMETYPE_GA_FOLDER:
          Cmd.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                             Msg.NOT_AN_ENTITY.format(Ent.Singular(Ent.DRIVE_FOLDER))],
                                            '\n'))
        if not targetFolder['ownedByMe']:
          Cmd.SetLocation(targetFolderIdLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                             Msg.NOT_OWNED_BY.format(targetUser)],
                                            '\n'))
        targetFolderName = targetFolder['name']
      elif targetFolderName:
        result = callGAPIpages(targetDrive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               q=MY_NON_TRASHED_FOLDER_NAME.format(escapeDriveFileName(targetFolderName)),
                               fields='nextPageToken,files(id)')
        if not result:
          Cmd.SetLocation(targetFolderNameLocation)
          usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                            [Ent.Singular(Ent.USER), targetUser,
                                             Ent.Singular(Ent.DRIVE_FOLDER), targetFolderName,
                                             Msg.DOES_NOT_EXIST],
                                            '\n'))
        targetFolderId = result[0]['id']
  except GAPI.fileNotFound:
    Cmd.SetLocation(targetFolderIdLocation)
    usageErrorExit(formatKeyValueList(Ind.Spaces(),
                                      [Ent.Singular(Ent.USER), targetUser,
                                       Ent.Singular(Ent.DRIVE_FOLDER_ID), targetFolderId,
                                       Msg.DOES_NOT_EXIST],
                                      '\n'))
  except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
    userSvcNotApplicableOrDriveDisabled(targetUser, str(e))
    return
  targetWriterPermissionsBody = {'role': 'writer', 'type': 'user', 'emailAddress': targetUser}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if buildTree:
      sourceUser, sourceDrive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not sourceDrive:
        continue
    else:
      sourceUser, sourceDrive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FOLDER)
      if jcount == 0:
        continue
    sourceUserName, _ = splitEmailAddress(sourceUser)
    try:
      result = callGAPI(sourceDrive.about(), 'get',
                        throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                        fields='storageQuota,user(permissionId)')
      sourceDriveSize = int(result['storageQuota']['usageInDrive'])
      sourcePermissionId = result['user']['permissionId']
      sourceRootId = callGAPI(sourceDrive.files(), 'get',
                              throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                              fileId=ROOT, fields='id')['id']
      if (targetDriveFree is not None) and (targetDriveFree < sourceDriveSize):
        printWarningMessage(TARGET_DRIVE_SPACE_ERROR_RC,
                            (f'{Msg.NO_TRANSFER_LACK_OF_DISK_SPACE} '
                             f'{formatKeyValueList("", ["Source drive size", formatFileSize(sourceDriveSize), "Target drive free", formatFileSize(targetDriveFree)], "")}'))
        continue
      printKeyValueList(['Source drive size', formatFileSize(sourceDriveSize),
                         'Target drive free', formatFileSize(targetDriveFree) if targetDriveFree is not None else 'UNLIMITED'])
      if targetDriveFree is not None:
        targetDriveFree = targetDriveFree-sourceDriveSize # prep targetDriveFree for next user
      if not csvPF:
        targetIds[TARGET_PARENT_ID] = _buildTargetUserFolder()
        if targetIds[TARGET_PARENT_ID] is None:
          return
      Ind.Increment()
      if buildTree:
        parentIdMap = {sourceRootId: targetIds[TARGET_PARENT_ID]}
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, Ent.TypeName(Ent.SOURCE_USER, user), i, count)
        sourceDriveFiles = callGAPIpages(sourceDrive.files(), 'list', 'files',
                                         pageMessage=getPageMessageForWhom(),
                                         throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                         retryReasons=[GAPI.UNKNOWN_ERROR],
                                         orderBy=OBY.orderBy, q=NON_TRASHED,
                                         fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,owners(emailAddress,permissionId),permissions(id,role))',
                                         pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
        fileTree = buildFileTree(sourceDriveFiles, sourceDrive)
        filesTransferred = set()
        _transferDriveFilesFromTree(fileTree[sourceRootId], i, count)
        if fileTree[ORPHANS]['children']:
          if not csvPF:
            _buildTargetUserOrphansFolder()
          _transferDriveFilesFromTree(fileTree[ORPHANS], i, count)
        if not csvPF:
          Act.Set(Act.RETAIN)
          filesTransferred = set()
          _manageRoleRetentionDriveFilesFromTree(fileTree[sourceRootId], i, count)
          if fileTree[ORPHANS]['children']:
            _manageRoleRetentionDriveFilesFromTree(fileTree[ORPHANS], i, count)
      else:
        j = 0
        for fileId in fileIdEntity['list']:
          j += 1
          fileTree = {}
          parentIdMap = {sourceRootId: targetIds[TARGET_PARENT_ID]}
          Act.Set(Act.TRANSFER_OWNERSHIP)
          try:
            fileEntry = callGAPI(sourceDrive.files(), 'get',
                                 throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                 fileId=fileId,
                                 fields='id,name,parents,mimeType,ownedByMe,trashed,owners(emailAddress,permissionId),permissions(id,role)')
            entityType = _getEntityMimeType(fileEntry)
            if fileId in skipFileIdEntity['list']:
              entityActionNotPerformedWarning([Ent.USER, sourceUser, entityType, f'{fileEntry["name"]} ({fileId})'],
                                              Msg.IN_SKIPIDS, j, jcount)
              continue
            entityPerformActionItemValue([Ent.USER, sourceUser], entityType, f'{fileEntry["name"]} ({fileId})', j, jcount)
            for parentId in fileEntry.get('parents', []):
              parentIdMap[parentId] = targetIds[TARGET_PARENT_ID]
            _identifyDriveFileAndChildren(fileEntry, i, count)
            filesTransferred = set()
            _transferDriveFileAndChildren(fileTree[fileId], i, count, j, jcount)
            if not csvPF:
              Act.Set(Act.RETAIN)
              filesTransferred = set()
              _manageRoleRetentionDriveFileAndChildren(fileTree[fileId], i, count, j, jcount)
          except GAPI.fileNotFound:
            entityActionFailedWarning([Ent.USER, sourceUser, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
            break
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(sourceUser, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('Files to Transfer')

def validateUserGetPermissionId(user, i=0, count=0):
  _, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
  if drive:
    try:
      return callGAPI(drive.about(), 'get',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      fields='user(permissionId)')['user']['permissionId']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  return None

def getPermissionIdForEmail(user, i, count, email):
  currentSvcAcctAPI = GM.Globals[GM.CURRENT_SVCACCT_API]
  currentSvcAcctAPIScopes = GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES]
  _, drive = buildGAPIServiceObject(API.DRIVE2, user, i, count)
  GM.Globals[GM.CURRENT_SVCACCT_API] = currentSvcAcctAPI
  GM.Globals[GM.CURRENT_SVCACCT_API_SCOPES] = currentSvcAcctAPIScopes
  if drive:
    try:
      return callGAPI(drive.permissions(), 'getIdForEmail',
                      throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                      email=email, fields='id')['id']
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
      entityActionNotPerformedWarning([Ent.USER, user], Msg.UNABLE_TO_GET_PERMISSION_ID.format(email), i, count)
      systemErrorExit(GM.Globals[GM.SYSEXITRC], None)
  return None

# gam <UserTypeEntity> transfer ownership <DriveFileEntity> <UserItem> [includetrashed]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[preview] [filepath] [buildtree] [todrive <ToDriveAttribute>*]
def transferOwnership(users):
  def _identifyFilesToTransfer(fileEntry):
    for childFileId in fileEntry['children']:
      if childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      childEntry = fileTree.get(childFileId)
      if childEntry:
        childEntryInfo = childEntry['info']
        if includeTrashed or not childEntryInfo['trashed']:
          if childEntryInfo['ownedByMe']:
            filesToTransfer[childFileId] = {'name': childEntryInfo['name'], 'type': _getEntityMimeType(childEntryInfo)}
          if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToTransfer(childEntry)

  def _identifyChildrenToTransfer(fileEntry, user, i, count):
    try:
      children = callGAPIpages(drive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               orderBy=OBY.orderBy, q=WITH_PARENTS.format(fileEntry['id']),
                               fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,trashed)',
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo['id']
      if filepath:
        fileTree[childFileId] = {'info': childEntryInfo}
      if childFileId in filesTransferred:
        continue
      filesTransferred.add(childFileId)
      if includeTrashed or not childEntryInfo['trashed']:
        if childEntryInfo['ownedByMe']:
          filesToTransfer[childFileId] = {'name': childEntryInfo['name'], 'type': _getEntityMimeType(childEntryInfo)}
        if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER:
          _identifyChildrenToTransfer(childEntryInfo, user, i, count)

  fileIdEntity = getDriveFileEntity()
  body = {}
  newOwner = getEmailAddress()
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  filepath = includeTrashed = False
  csvPF = fileTree = None
  buildTree = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'includetrashed':
      includeTrashed = True
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'filepath':
      filepath = True
    elif myarg == 'buildtree':
      buildTree = True
    elif myarg == 'preview':
      csvPF = CSVPrintFile(['OldOwner', 'NewOwner', 'type', 'id', 'name'])
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  Act.Set(Act.TRANSFER_OWNERSHIP)
  permissionId = validateUserGetPermissionId(newOwner)
  if not permissionId:
    return
  if csvPF:
    if filepath:
      csvPF.AddTitles('paths')
  else:
    filepath = False
  body = {'role': 'owner'}
  bodyAdd = {'role': 'writer', 'type': 'user', 'emailAddress': newOwner}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FOLDER)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    filesTransferred = set()
    if buildTree:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count)
      try:
        feed = callGAPIpages(drive.files(), 'list', 'files',
                             pageMessage=getPageMessageForWhom(),
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                             retryReasons=[GAPI.UNKNOWN_ERROR],
                             orderBy=OBY.orderBy,
                             fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,trashed)',
                             pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
      fileTree = buildFileTree(feed, drive)
    else:
      fileTree = {}
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      if buildTree:
        fileEntry = fileTree.get(fileId)
        if not fileEntry:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
        fileEntryInfo = fileEntry['info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), 'get',
                                   throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId, fields='id,name,parents,mimeType,ownedByMe,trashed')
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
        if filepath:
          fileTree[fileId] = {'info': fileEntryInfo}
      entityType = _getEntityMimeType(fileEntryInfo)
      entityPerformActionItemValue([Ent.USER, user], entityType, f'{fileEntryInfo["name"]} ({fileId})', j, jcount)
      if fileId in filesTransferred:
        continue
      filesTransferred.add(fileId)
      filesToTransfer = {}
      if includeTrashed or not fileEntryInfo['trashed']:
        if fileEntryInfo['ownedByMe'] and fileEntryInfo['name'] != MY_DRIVE:
          filesToTransfer[fileId] = {'name': fileEntryInfo['name'], 'type': entityType}
        if fileEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER:
          if buildTree:
            _identifyFilesToTransfer(fileEntry)
          else:
            _identifyChildrenToTransfer(fileEntryInfo, user, i, count)
      if csvPF:
        for xferFileId, fileInfo in iter(filesToTransfer.items()):
          row = {'OldOwner': user, 'NewOwner': newOwner, 'type': Ent.Singular(fileInfo['type']), 'id': xferFileId, 'name': fileInfo['name']}
          if filepath:
            addFilePathsToRow(drive, fileTree, fileTree[xferFileId]['info'], filePathInfo, csvPF, row)
          csvPF.WriteRow(row)
        continue
      Ind.Increment()
      kcount = len(filesToTransfer)
      entityPerformActionNumItemsModifier([Ent.USER, user], kcount, Ent.DRIVE_FILE_OR_FOLDER, f'{Act.MODIFIER_TO} {Ent.Singular(Ent.USER)}: {newOwner}', i, count)
      Ind.Increment()
      k = 0
      for xferFileId in filesToTransfer:
        k += 1
        entityType = filesToTransfer[xferFileId]['type']
        fileDesc = f'{filesToTransfer[xferFileId]["name"]} ({xferFileId})'
        try:
          callGAPI(drive.permissions(), 'update',
                   throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND, GAPI.FORBIDDEN],
                   fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields='')
          entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_TO, None, [Ent.USER, newOwner], k, kcount)
        except GAPI.permissionNotFound:
          # this might happen if target user isn't explicitly in ACL (i.e. shared with anyone)
          try:
            callGAPI(drive.permissions(), 'create',
                     throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.FILE_NOT_FOUND, GAPI.FORBIDDEN],
                     fileId=xferFileId, sendNotificationEmail=False, body=bodyAdd, fields='')
            callGAPI(drive.permissions(), 'update',
                     throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND],
                     fileId=xferFileId, permissionId=permissionId, transferOwnership=True, body=body, fields='')
            entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_TO, None, [Ent.USER, newOwner], k, kcount)
          except GAPI.invalidSharingRequest as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), k, kcount)
          except GAPI.permissionNotFound:
            entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileDesc, Ent.PERMISSION_ID, permissionId], k, kcount)
          except GAPI.fileNotFound:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, k, kcount)
          except GAPI.forbidden as e:
            entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), k, kcount)
          except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
            userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, k, kcount)
        except GAPI.forbidden as e:
          entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), k, kcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Files to Transfer Ownership')

# gam <UserTypeEntity> claim ownership <DriveFileEntity> [includetrashed]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[skipids <DriveFileEntity>] [skipusers <UserTypeEntity>] [subdomains <DomainNameEntity>]
#	[restricted [<Boolean>]] [writerscanshare|writerscantshare [<Boolean>]] [keepuser | (retainrole reader|commenter|writer|editor|none)] [noretentionmessages]
#	[preview] [filepath] [buildtree] [todrive <ToDriveAttribute>*]d
def claimOwnership(users):
  def _identifyFilesToClaim(fileEntry):
    for childFileId in fileEntry['children']:
      childEntry = fileTree.get(childFileId)
      if childEntry:
        childEntryInfo = childEntry['info']
        if childFileId not in skipFileIdEntity['list'] and (includeTrashed or not childEntryInfo['trashed']):
          owner = childEntryInfo['owners'][0]['emailAddress']
          if not childEntryInfo['ownedByMe'] and owner not in skipusers:
            oldOwnerPermissionIds[owner] = childEntryInfo['owners'][0]['permissionId']
            filesToClaim.setdefault(owner, {})
            if childFileId not in filesToClaim[owner]:
              filesToClaim[owner][childFileId] = {'name': childEntryInfo['name'], 'type': _getEntityMimeType(childEntryInfo)}
          if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER:
            _identifyFilesToClaim(childEntry)

  def _identifyChildrenToClaim(fileEntry, user, i, count):
    try:
      children = callGAPIpages(drive.files(), 'list', 'files',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               orderBy=OBY.orderBy, q=WITH_PARENTS.format(fileEntry['id']),
                               fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,trashed,owners(emailAddress,permissionId))',
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      return
    for childEntryInfo in children:
      childFileId = childEntryInfo['id']
      if childFileId not in skipFileIdEntity['list'] and (includeTrashed or not childEntryInfo['trashed']):
        if filepath:
          fileTree[childFileId] = {'info': childEntryInfo}
        owner = childEntryInfo['owners'][0]['emailAddress']
        if not childEntryInfo['ownedByMe'] and owner not in skipusers:
          oldOwnerPermissionIds[owner] = childEntryInfo['owners'][0]['permissionId']
          filesToClaim.setdefault(owner, {})
          if childFileId not in filesToClaim[owner]:
            filesToClaim[owner][childFileId] = {'name': childEntryInfo['name'], 'type': _getEntityMimeType(childEntryInfo)}
        if childEntryInfo['mimeType'] == MIMETYPE_GA_FOLDER:
          _identifyChildrenToClaim(childEntryInfo, user, i, count)

  def _processRetainedRole(user, i, count, oldOwner, entityType, ofileId, fileDesc, l, lcount):
    oldOwnerPermissionId = oldOwnerPermissionIds[oldOwner]
    Act.Set(Act.RETAIN)
    try:
      if sourceRetainRoleBody['role'] != 'none':
        if sourceRetainRoleBody['role'] != 'writer':
          callGAPI(sourceDrive.permissions(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                   fileId=ofileId, permissionId=oldOwnerPermissionId, body=sourceRetainRoleBody, fields='')
      else:
        callGAPI(sourceDrive.permissions(), 'delete',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.PERMISSION_NOT_FOUND, GAPI.BAD_REQUEST],
                 fileId=ofileId, permissionId=oldOwnerPermissionId)
      if showRetentionMessages:
        entityActionPerformed([Ent.USER, oldOwner, entityType, fileDesc, Ent.ROLE, sourceRetainRoleBody['role']], l, lcount)
    except GAPI.permissionNotFound:
      entityDoesNotHaveItemWarning([Ent.USER, oldOwner, entityType, fileDesc, Ent.PERMISSION_ID, oldOwnerPermissionId], l, lcount)
    except GAPI.badRequest as e:
      entityActionFailedWarning([Ent.USER, oldOwner, entityType, fileDesc], str(e), l, lcount)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Act.Set(Act.CLAIM_OWNERSHIP)

  fileIdEntity = getDriveFileEntity()
  skipFileIdEntity = initDriveFileEntity()
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  body = {}
  skipusers = []
  subdomains = []
  filepath = includeTrashed = False
  sourceRetainRoleBody = {'role': 'writer'}
  showRetentionMessages = True
  oldOwnerPermissionIds = {}
  csvPF = fileTree = None
  buildTree = False
  bodyShare = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'keepuser':
      sourceRetainRoleBody['role'] = 'writer'
    elif myarg == 'retainrole':
      sourceRetainRoleBody['role'] = getChoice(TRANSFER_DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
    elif myarg == 'noretentionmessages':
      showRetentionMessages = False
    elif myarg == 'skipids':
      skipFileIdEntity = getDriveFileEntity()
    elif myarg == 'skipusers':
      _, skipusers = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    elif myarg == 'subdomains':
      subdomains = getEntityList(Cmd.OB_DOMAIN_NAME_ENTITY)
    elif myarg == 'includetrashed':
      includeTrashed = True
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'restricted':
      bodyShare['copyRequiresWriterPermission'] = getBoolean()
    elif myarg == 'writerscanshare':
      bodyShare['writersCanShare'] = getBoolean()
    elif myarg == 'writerscantshare':
      bodyShare['writersCanShare'] = not getBoolean()
    elif myarg == 'filepath':
      filepath = True
    elif myarg == 'buildtree':
      buildTree = True
    elif myarg == 'preview':
      csvPF = CSVPrintFile(['OldOwner', 'NewOwner', 'type', 'id', 'name'])
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  Act.Set(Act.CLAIM_OWNERSHIP)
  if csvPF:
    if filepath:
      csvPF.AddTitles('paths')
  else:
    filepath = False
  body = {'role': 'owner'}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity)
    if not drive:
      continue
    permissionId = validateUserGetPermissionId(user, i, count)
    if not permissionId:
      continue
    entityPerformActionNumItems([Ent.USER, user], jcount, Ent.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    if filepath:
      filePathInfo = initFilePathInfo()
    bodyAdd = {'role': 'writer', 'type': 'user', 'emailAddress': user}
    if skipFileIdEntity['query'] or skipFileIdEntity[ROOT]:
      _validateUserGetFileIDs(origUser, i, count, skipFileIdEntity, drive=drive)
    if buildTree:
      printGettingAllEntityItemsForWhom(Ent.DRIVE_FILE_OR_FOLDER, user, i, count)
      try:
        feed = callGAPIpages(drive.files(), 'list', 'files',
                             pageMessage=getPageMessageForWhom(),
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                             retryReasons=[GAPI.UNKNOWN_ERROR],
                             orderBy=OBY.orderBy,
                             fields='nextPageToken,files(id,name,parents,mimeType,ownedByMe,trashed,owners(emailAddress,permissionId))',
                             pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
      fileTree = buildFileTree(feed, drive)
    else:
      fileTree = {}
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      filesToClaim = {}
      if buildTree:
        fileEntry = fileTree.get(fileId)
        if not fileEntry:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        fileEntryInfo = fileEntry['info']
      else:
        try:
          fileEntryInfo = callGAPI(drive.files(), 'get',
                                   throwReasons=GAPI.DRIVE_GET_THROW_REASONS,
                                   fileId=fileId,
                                   fields='id,name,parents,mimeType,ownedByMe,trashed,owners(emailAddress,permissionId)')
        except GAPI.fileNotFound:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileId], Msg.NOT_FOUND, j, jcount)
          continue
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
        if filepath:
          fileTree[fileId] = {'info': fileEntryInfo}
      entityType = _getEntityMimeType(fileEntryInfo)
      entityPerformActionItemValue([Ent.USER, user], entityType, f'{fileEntryInfo["name"]} ({fileId})', j, jcount)
      if fileId not in skipFileIdEntity['list'] and (includeTrashed or not fileEntryInfo['trashed']):
        owner = fileEntryInfo['owners'][0]['emailAddress']
        if not fileEntryInfo['ownedByMe'] and owner not in skipusers:
          oldOwnerPermissionIds[owner] = fileEntryInfo['owners'][0]['permissionId']
          filesToClaim.setdefault(owner, {})
          if fileId not in filesToClaim[owner]:
            filesToClaim[owner][fileId] = {'name': fileEntryInfo['name'], 'type': entityType}
        if buildTree:
          _identifyFilesToClaim(fileEntry)
        else:
          _identifyChildrenToClaim(fileEntryInfo, user, i, count)
      if csvPF:
        for oldOwner in filesToClaim:
          for claimFileId, fileInfo in iter(filesToClaim[oldOwner].items()):
            row = {'NewOwner': user, 'OldOwner': oldOwner, 'type': Ent.Singular(fileInfo['type']), 'id': claimFileId, 'name': fileInfo['name']}
            if filepath:
              addFilePathsToRow(drive, fileTree, fileTree[claimFileId]['info'], filePathInfo, csvPF, row)
            csvPF.WriteRow(row)
        continue
      Ind.Increment()
      kcount = len(filesToClaim)
      entityPerformActionNumItems([Ent.USER, user], kcount, Ent.USER, i, count)
      Ind.Increment()
      k = 0
      for oldOwner in filesToClaim:
        k += 1
        _, userDomain = splitEmailAddress(oldOwner)
        lcount = len(filesToClaim[oldOwner])
        if userDomain == GC.Values[GC.DOMAIN] or userDomain in subdomains:
          _, sourceDrive = buildGAPIServiceObject(API.DRIVE3, oldOwner, k, kcount)
          if not sourceDrive:
            continue
          entityPerformActionNumItemsModifier([Ent.USER, user], lcount, Ent.DRIVE_FILE_OR_FOLDER,
                                              f'{Act.MODIFIER_FROM} {Ent.Singular(Ent.USER)}: {oldOwner}', k, kcount)
          Ind.Increment()
          l = 0
          for ofileId, fileInfo in iter(filesToClaim[oldOwner].items()):
            l += 1
            if bodyShare:
              callGAPI(sourceDrive.files(), 'update',
                       fileId=ofileId, body=bodyShare, fields='')
            entityType = fileInfo['type']
            fileDesc = f'{fileInfo["name"]} ({ofileId})'
            try:
              callGAPI(sourceDrive.permissions(), 'update',
                       throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND, GAPI.FORBIDDEN],
                       fileId=ofileId, permissionId=permissionId, transferOwnership=True, body=body, fields='')
              entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_FROM, None, [Ent.USER, oldOwner], l, lcount)
              _processRetainedRole(user, i, count, oldOwner, entityType, ofileId, fileDesc, l, lcount)
            except GAPI.permissionNotFound:
              # if claimer not in ACL (file might be visible for all with link)
              try:
                callGAPI(sourceDrive.permissions(), 'create',
                         throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_SHARING_REQUEST, GAPI.FILE_NOT_FOUND, GAPI.FORBIDDEN],
                         fileId=ofileId, sendNotificationEmail=False, body=bodyAdd, fields='')
                callGAPI(sourceDrive.permissions(), 'update',
                         throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.FILE_NOT_FOUND, GAPI.PERMISSION_NOT_FOUND],
                         fileId=ofileId, permissionId=permissionId, transferOwnership=True, body=body, fields='')
                entityModifierNewValueItemValueListActionPerformed([Ent.USER, user, entityType, fileDesc], Act.MODIFIER_FROM, None, [Ent.USER, oldOwner], l, lcount)
                _processRetainedRole(user, i, count, oldOwner, entityType, ofileId, fileDesc, l, lcount)
              except GAPI.invalidSharingRequest as e:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), l, lcount)
              except GAPI.permissionNotFound:
                entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileDesc, Ent.PERMISSION_ID, permissionId], l, lcount)
              except GAPI.fileNotFound:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, l, lcount)
              except GAPI.forbidden as e:
                entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), l, lcount)
              except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
                userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
            except GAPI.fileNotFound:
              entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], Msg.DOES_NOT_EXIST, l, lcount)
            except GAPI.forbidden as e:
              entityActionFailedWarning([Ent.USER, user, entityType, fileDesc], str(e), l, lcount)
            except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
              userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
              break
          Ind.Decrement()
        else:
          entityPerformActionModifierNumItemsModifier([Ent.USER, user], 'Not Performed', kcount, Ent.DRIVE_FILE_OR_FOLDER,
                                                      f'{Act.MODIFIER_FROM} {Ent.Singular(Ent.USER)}: {oldOwner}', j, jcount)
          Ind.Increment()
          l = 0
          for ofileId, fileInfo in iter(filesToClaim[oldOwner].items()):
            l += 1
            entityActionNotPerformedWarning([Ent.USER, user, fileInfo['type'], f'{fileInfo["name"]} ({ofileId})'],
                                            Msg.USER_IN_OTHER_DOMAIN.format(Ent.Singular(Ent.USER), oldOwner), l, lcount)
          Ind.Decrement()
      Ind.Decrement()
      Ind.Decrement()
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Files to Claim Ownership')

# gam <UserTypeEntity> delete emptydrivefolders [<TeamDriveEntity>]
def deleteEmptyDriveFolders(users):
  Act.Set(Act.DELETE_EMPTY)
  if Cmd.ArgumentsRemaining():
    fileIdEntity = getTeamDriveEntity()
    query = ANY_FOLDERS
  else:
    fileIdEntity = {}
    query = MY_FOLDERS
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      printEntityKVList([Ent.USER, user],
                        [f'{Act.ToPerform()} {Ent.Plural(Ent.DRIVE_FILE_OR_FOLDER)}'],
                        i, count)
      Ind.Increment()
      deletedFolderIds = set()
      deleted_empty = True
      while deleted_empty:
        deleted_empty = False
        printGettingAllEntityItemsForWhom(Ent.DRIVE_FOLDER, user, i, count)
        if not fileIdEntity.get('teamdrive'):
          feed = callGAPIpages(drive.files(), 'list', 'files',
                               pageMessage=getPageMessageForWhom(),
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               q=query, fields='nextPageToken,files(id,name,ownedByMe)',
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS])
        else:
          feed = callGAPIpages(drive.files(), 'list', 'files',
                               pageMessage=getPageMessageForWhom(),
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                               retryReasons=[GAPI.UNKNOWN_ERROR],
                               q=query, fields='nextPageToken,files(id,name)',
                               pageSize=GC.Values[GC.DRIVE_MAX_RESULTS], **fileIdEntity['teamdrive'])
        jcount = len(feed)
        j = 0
        for folder in feed:
          j += 1
          if folder['id'] in deletedFolderIds:
            pass
          elif folder.get('ownedByMe', True):
            if not fileIdEntity.get('teamdrive'):
              children = callGAPIitems(drive.files(), 'list', 'files',
                                       throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                                       retryReasons=[GAPI.UNKNOWN_ERROR],
                                       q=WITH_PARENTS.format(folder['id']), fields='files(id,name)',
                                       pageSize=1)
            else:
              children = callGAPIitems(drive.files(), 'list', 'files',
                                       throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.TEAMDRIVE_MEMBERSHIP_REQUIRED],
                                       retryReasons=[GAPI.UNKNOWN_ERROR],
                                       q=WITH_PARENTS.format(folder['id']), fields='files(id,name)',
                                       pageSize=1, **fileIdEntity['teamdrive'])
            if not children:
              try:
                callGAPI(drive.files(), 'delete',
                         throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                         fileId=folder['id'], supportsAllDrives=True)
                entityActionPerformed([Ent.USER, user, Ent.DRIVE_FOLDER, folder['name']], j, jcount)
                deletedFolderIds.add(folder['id'])
                deleted_empty = True
                if fileIdEntity.get('teamdrive'):
                  time.sleep(1)
              except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
                entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder['name']], str(e), j, jcount)
            else:
              entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder['name']],
                                              f'{Msg.CONTAINS_AT_LEAST_1_ITEM} - {children[0]["name"]} ({children[0]["id"]})', j, jcount)
          else:
            entityActionNotPerformedWarning([Ent.USER, user, Ent.DRIVE_FOLDER, folder['name']],
                                            Msg.NOT_OWNED_BY.format(user), j, jcount)
    except (GAPI.notFound, GAPI.teamDriveMembershipRequired) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, fileIdEntity['teamdrive']['driveId']], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
    Ind.Decrement()

# gam <UserTypeEntity> empty drivetrash [<TeamDriveEntity>]
def emptyDriveTrash(users):
  if Cmd.ArgumentsRemaining():
    fileIdEntity = getTeamDriveEntity()
  else:
    fileIdEntity = {}
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  if not fileIdEntity:
    for user in users:
      i += 1
      user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not drive:
        continue
      try:
        callGAPI(drive.files(), 'emptyTrash',
                 throwReasons=GAPI.DRIVE_USER_THROW_REASONS)
        entityActionPerformed([Ent.USER, user, Ent.DRIVE_TRASH, None], i, count)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  else:
    Act.Set(Act.PURGE)
    fileIdEntity['teamdrivefilequery'] = 'trashed = true'
    for user in users:
      i += 1
      user, drive, jcount = _validateUserGetTeamDriveFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER)
      if jcount == 0:
        continue
      Ind.Increment()
      j = 0
      for fileId in fileIdEntity['list']:
        j += 1
        try:
          callGAPI(drive.files(), 'delete',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                   fileId=fileId, supportsAllDrives=True)
          fileName = fileId
          entityActionPerformed([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER, fileName], j, jcount)
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DRIVE_FILE_OR_FOLDER_ID, fileId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
          break
      Ind.Decrement()

def _getDriveFileACLPrintKeysTimeObjects():
  printKeys = ['id', 'type', 'emailAddress', 'domain', 'role', 'permissionDetails', 'expirationTime', 'photoLink', 'allowFileDiscovery', 'deleted']
  timeObjects = ['expirationTime']
  if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES]:
    _mapDrive3TitlesToDrive2(printKeys, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
    _mapDrive3TitlesToDrive2(timeObjects, API.DRIVE3_TO_DRIVE2_FILES_FIELDS_MAP)
  return (printKeys, set(timeObjects))

# DriveFileACL commands utilities
def _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects):
  _mapDrivePermissionNames(permission)
  row = {'Owner': user, 'id': fileId, 'permission': permission}
  if fileId != fileName:
    row['name'] = fileName
  printLine(json.dumps(cleanJSON(row, timeObjects=timeObjects), ensure_ascii=False, sort_keys=True))

def _showDriveFilePermissionsJSON(user, fileId, fileName, permissions, timeObjects):
  for permission in permissions:
    _mapDrivePermissionNames(permission)
  row = {'Owner': user, 'id': fileId, 'permissions': permissions}
  if fileId != fileName:
    row['name'] = fileName
  printLine(json.dumps(cleanJSON(row, timeObjects=timeObjects), ensure_ascii=False, sort_keys=True))

def _showDriveFilePermission(permission, printKeys, timeObjects, i=0, count=0):
  if permission.get('displayName'):
    name = permission['displayName']
  elif 'id' in permission:
    if permission['id'] == 'anyone':
      name = 'Anyone'
    elif permission['id'] == 'anyoneWithLink':
      name = 'Anyone with Link'
    else:
      name = permission['id']
  else:
    name = 'Permission'
  _mapDrivePermissionNames(permission)
  printKeyValueListWithCount([name], i, count)
  Ind.Increment()
  for key in printKeys:
    value = permission.get(key)
    if value is None:
      continue
    if key == 'permissionDetails':
      printKeyValueList([key, ''])
      Ind.Increment()
      for detail in value:
        printKeyValueList(['role', detail['role']])
        Ind.Increment()
        printKeyValueList(['type', detail['permissionType']])
        if 'additionalRoles' in detail:
          printKeyValueList(['additionalRoles', ','.join(detail['additionalRoles'])])
        printKeyValueList(['inherited', detail['inherited']])
        if detail['inherited']:
          printKeyValueList(['inheritedFrom', detail['inheritedFrom']])
        Ind.Decrement()
      Ind.Decrement()
    elif key not in timeObjects:
      printKeyValueList([key, value])
    else:
      printKeyValueList([key, formatLocalTime(value)])
  Ind.Decrement()

def _showDriveFilePermissions(entityType, fileName, permissions, printKeys, timeObjects, j, jcount):
  kcount = len(permissions)
  entityPerformActionNumItems([entityType, fileName], kcount, Ent.PERMITTEE, j, jcount)
  Ind.Increment()
  k = 0
  for permission in permissions:
    k += 1
    _showDriveFilePermission(permission, printKeys, timeObjects, k, kcount)
  Ind.Decrement()

# gam <UserTypeEntity> create|add drivefileacl <DriveFileEntity> [adminaccess|asadmin]
#	anyone|(user <UserItem>)|(group <GroupItem>)|(domain <DomainName>)
#	(role <DriveFileACLRole>) [withlink|(allowfilediscovery|discoverable [<Boolean>])]
#	[enforcesingleparent <Boolean>] [moveToNewOwnersRoot [<Boolean>]]
#	[expiration <Time>] [sendemail] [emailmessage <String>] [showtitles] [nodetails]
def createDriveFileACL(users, useDomainAdminAccess=False):
  enforceSingleParent = moveToNewOwnersRoot = False
  sendNotificationEmail = showTitles = _transferOwnership = False
  roleLocation = withLinkLocation = expirationLocation = None
  showDetails = True
  emailMessage = None
  fileIdEntity = getDriveFileEntity()
  body = {}
  ubody = {}
  body['type'] = getChoice(DRIVEFILE_ACL_PERMISSION_TYPES)
  if body['type'] != 'anyone':
    if body['type'] != 'domain':
      body['emailAddress'] = permissionId = getEmailAddress()
    else:
      body['domain'] = permissionId = getString(Cmd.OB_DOMAIN_NAME)
  else:
    permissionId = 'anyone'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'withlink':
      withLinkLocation = Cmd.Location()
      body['allowFileDiscovery'] = False
    elif myarg in {'allowfilediscovery', 'discoverable'}:
      withLinkLocation = Cmd.Location()
      body['allowFileDiscovery'] = getBoolean()
    elif myarg == 'role':
      roleLocation = Cmd.Location()
      body['role'] = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
      if body['role'] == 'owner':
        sendNotificationEmail = _transferOwnership = True
      ubody['role'] = body['role']
    elif myarg == 'enforcesingleparent':
      enforceSingleParent = getBoolean(defaultValue=None)
    elif myarg == 'movetonewownersroot':
      moveToNewOwnersRoot = getBoolean(defaultValue=None)
    elif myarg in {'expiration', 'expires'}:
      expirationLocation = Cmd.Location()
      ubody['expirationTime'] = getTimeOrDeltaFromNow()
    elif myarg == 'sendemail':
      sendNotificationEmail = True
    elif myarg == 'emailmessage':
      sendNotificationEmail = True
      emailMessage = getString(Cmd.OB_STRING)
    elif myarg == 'showtitles':
      showTitles = True
    elif myarg == 'nodetails':
      showDetails = False
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if 'role' not in body:
    missingArgumentExit(f'role {formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)}')
  _validatePermissionOwnerType(roleLocation, body)
  _validatePermissionAttributes('allowfilediscovery/withlink', withLinkLocation, body, 'allowFileDiscovery', ['anyone', 'domain'])
  _validatePermissionAttributes('expiration', expirationLocation, body, 'expirationTime', ['user', 'group'])
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        permission = callGAPI(drive.permissions(), 'create',
                              bailOnInternalError=True,
                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_CREATE_ACL_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                              enforceSingleParent=enforceSingleParent, moveToNewOwnersRoot=moveToNewOwnersRoot,
                              useDomainAdminAccess=useDomainAdminAccess,
                              fileId=fileId, sendNotificationEmail=sendNotificationEmail, emailMessage=emailMessage,
                              transferOwnership=_transferOwnership, body=body, fields='*', supportsAllDrives=True)
        if 'expirationTime' in ubody:
          permission = callGAPI(drive.permissions(), 'update',
                                bailOnInternalError=True,
                                throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_UPDATE_ACL_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                                useDomainAdminAccess=useDomainAdminAccess,
                                fileId=fileId, permissionId=permission['id'], removeExpiration=False,
                                body=ubody, fields='*', supportsAllDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
        if showDetails:
          _showDriveFilePermission(permission, printKeys, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.fileNeverWritable, GAPI.ownershipChangeAcrossDomainNotPermitted, GAPI.teamDriveDomainUsersOnlyRestriction,
              GAPI.insufficientAdministratorPrivileges, GAPI.sharingRateLimitExceeded,
              GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains, GAPI.ownerOnTeamDriveItemNotSupported,
              GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.fileOrganizerOnNonTeamDriveNotSupported, GAPI.fileOrganizerNotYetEnabledForThisTeamDrive,
              GAPI.teamDrivesFolderSharingNotSupported) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except (GAPI.invalid, GAPI.invalidSharingRequest) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], Ent.TypeNameMessage(Ent.PERMISSION_ID, permissionId, str(e)), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def doCreateDriveFileACL():
  createDriveFileACL([_getAdminEmail()], True)

# gam <UserTypeEntity> update drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [adminaccess|asadmin]
#	(role <DriveFileACLRole>) [expiration <Time>] [removeexpiration [<Boolean>]] [showtitles] [nodetails]
def updateDriveFileACLs(users, useDomainAdminAccess=False):
  fileIdEntity = getDriveFileEntity()
  body = {}
  isEmail, permissionId = getPermissionId()
  removeExpiration = showTitles = False
  showDetails = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'role':
      body['role'] = getChoice(DRIVEFILE_ACL_ROLES_MAP, mapChoice=True)
    elif myarg in {'expiration', 'expires'}:
      body['expirationTime'] = getTimeOrDeltaFromNow()
    elif myarg == 'removeexpiration':
      removeExpiration = getBoolean()
    elif myarg == 'showtitles':
      showTitles = True
    elif myarg == 'nodetails':
      showDetails = False
    elif myarg == 'transferownership':
      deprecatedArgument(myarg)
      getBoolean()
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if (removeExpiration or 'expirationTime' in body) and 'role' not in body:
    missingArgumentExit(f'role {formatChoiceList(DRIVEFILE_ACL_ROLES_MAP)}')
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    if isEmail:
      permissionId = getPermissionIdForEmail(user, i, count, permissionId)
      if not permissionId:
        return
      isEmail = False
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        result = callGAPI(drive.permissions(), 'update',
                          bailOnInternalError=True,
                          throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_UPDATE_ACL_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                          useDomainAdminAccess=useDomainAdminAccess,
                          fileId=fileId, permissionId=permissionId, removeExpiration=removeExpiration,
                          transferOwnership=body.get('role', '') == 'owner', body=body, fields='*', supportsAllDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
        if showDetails:
          _showDriveFilePermission(result, printKeys, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.invalidOwnershipTransfer, GAPI.cannotRemoveOwner,
              GAPI.fileNeverWritable, GAPI.ownershipChangeAcrossDomainNotPermitted, GAPI.sharingRateLimitExceeded,
              GAPI.insufficientAdministratorPrivileges,
              GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.fileOrganizerOnNonTeamDriveNotSupported,
              GAPI.cannotUpdatePermission, GAPI.cannotModifyInheritedTeamDrivePermission, GAPI.fieldNotWritable) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except (GAPI.notFound, GAPI.teamDriveDomainUsersOnlyRestriction,
              GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains, GAPI.ownerOnTeamDriveItemNotSupported,
              GAPI.fileOrganizerNotYetEnabledForThisTeamDrive) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def doUpdateDriveFileACLs():
  updateDriveFileACLs([_getAdminEmail()], True)

def getJSONPermissionSkips(myarg, skips):
  if myarg in {'jsonskiprole', 'jsonskiproles'}:
    roleList = getString(Cmd.OB_DRIVE_FILE_ACL_ROLE_LIST, minLen=0).lower().replace(',', ' ').split()
    if not roleList:
      skips['role'] = set()
    else:
      for role in roleList:
        if role == 'none':
          skips['role'] = set()
        elif role in DRIVEFILE_ACL_ROLES_MAP:
          skips['role'].add(DRIVEFILE_ACL_ROLES_MAP[role])
        else:
          invalidChoiceExit(role, DRIVEFILE_ACL_ROLES_MAP, True)
  elif myarg in {'jsonskiptype', 'jsonskiptypes'}:
    typeList = getString(Cmd.OB_DRIVE_FILE_ACL_TYPE_LIST, minLen=0).lower().replace(',', ' ').split()
    if not typeList:
      skips['type'] = set()
    else:
      for ptype in typeList:
        if ptype == 'none':
          skips['type'] = set()
        elif ptype in DRIVEFILE_ACL_PERMISSION_TYPES:
          skips['type'].add(ptype)
        else:
          invalidChoiceExit(ptype, DRIVEFILE_ACL_PERMISSION_TYPES, True)
  else:
    return False
  return True

# gam <UserTypeEntity> create|add permissions <DriveFileEntity> <DriveFilePermissionsEntity> [adminaccess|asadmin]
#	[expiration <Time>] [sendmail] [emailmessage <String>]
#	[enforcesingleparent <Boolean>] [moveToNewOwnersRoot <Boolean>]
#	<PermissionMatch>* [<PermissionMatchAction>]
def createDriveFilePermissions(users, useDomainAdminAccess=False):
  def convertJSONPermissions(jsonPermissions):
    permissions = []
    for permission in PM.GetMatchingPermissions(jsonPermissions):
      if permission.get('deleted', False):
        continue
      if permission['type'] in {'anyone', 'domain'}:
        permItem = permission['type'] if permission['allowFileDiscovery'] else permission['type']+'withlink'
        if permission['type'] == 'domain':
          permItem += ':'+permission['domain']
      else:
        permItem = permission['type']+':'+permission['emailAddress']
      permissions.append(permItem+';'+permission['role'].lower())
    return permissions

  def _makePermissionBody(permission):
    body = {}
    try:
      scope, role = permission.split(';', 1)
      scope = scope.lower()
      role = role.lower()
      if scope in {'anyone', 'anyonewithlink'}:
        body['type'] = 'anyone'
        body['allowFileDiscovery'] = scope != 'anyonewithlink'
      else:
        body['type'], value = scope.split(':', 1)
        if body['type'] == 'domainwithlink':
          body['allowFileDiscovery'] = False
          body['type'] = 'domain'
        if body['type'] not in DRIVEFILE_ACL_PERMISSION_TYPES[1:]:
          return None
        if body['type'] != 'domain':
          body['emailAddress'] = value
        else:
          body['domain'] = value
      body['role'] = DRIVEFILE_ACL_ROLES_MAP.get(role)
      if not body['role']:
        return None
      if expiration:
        body['expirationTime'] = expiration
      return body
    except ValueError:
      return None

  def _callbackCreatePermission(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Ent.PERMITTEE, int(ri[RI_I]), int(ri[RI_COUNT]))
      Ind.Increment()
    if exception is None:
      entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+[GAPI.SERVICE_LIMIT]:
        if reason in GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_CREATE_ACL_THROW_REASONS:
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], message, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
          Ind.Decrement()
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), 'create',
                 bailOnInternalError=True,
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_CREATE_ACL_THROW_REASONS, retryReasons=[GAPI.SERVICE_LIMIT],
                 useDomainAdminAccess=useDomainAdminAccess,
                 fileId=ri[RI_ENTITY], sendNotificationEmail=sendNotificationEmail, emailMessage=emailMessage,
                 body=_makePermissionBody(ri[RI_ITEM]), fields='', supportsAllDrives=True)
        entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.invalidSharingRequest, GAPI.ownershipChangeAcrossDomainNotPermitted, GAPI.teamDriveDomainUsersOnlyRestriction,
              GAPI.insufficientAdministratorPrivileges, GAPI.sharingRateLimitExceeded, GAPI.cannotShareTeamDriveTopFolderWithAnyoneOrDomains,
              GAPI.ownerOnTeamDriveItemNotSupported, GAPI.fileOrganizerNotYetEnabledForThisTeamDrive,
              GAPI.organizerOnNonTeamDriveItemNotSupported, GAPI.fileOrganizerOnNonTeamDriveNotSupported, GAPI.teamDrivesFolderSharingNotSupported,
              GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.TEAMDRIVE, ri[RI_ENTITY], Ent.PERMITTEE, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
    if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
      Ind.Decrement()

  enforceSingleParent = moveToNewOwnersRoot = False
  sendNotificationEmail = False
  emailMessage = expiration = None
  fileIdEntity = getDriveFileEntity()
  if not checkArgumentPresent('json'):
    permissions = getEntityList(Cmd.OB_DRIVE_FILE_PERMISSION_ENTITY)
    jsonData = None
    PM = None
  else:
    permissions = []
    jsonData = getJSON([])
    PM = PermissionMatch()
    PM.SetDefaultMatch(False, {'role': 'owner'})
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'enforcesingleparent':
      enforceSingleParent = getBoolean(defaultValue=None)
    elif myarg == 'movetonewownersroot':
      moveToNewOwnersRoot = getBoolean(defaultValue=None)
    elif myarg in {'expiration', 'expires'}:
      expiration = getTimeOrDeltaFromNow()
    elif myarg == 'sendemail':
      sendNotificationEmail = True
    elif myarg == 'emailmessage':
      sendNotificationEmail = True
      emailMessage = getString(Cmd.OB_STRING)
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    elif PM and PM.ProcessArgument(myarg):
      pass
    else:
      unknownArgumentExit()
  if jsonData:
    if 'permission' in jsonData:
      permissions = convertJSONPermissions([jsonData['permission']])
    elif 'permissions' in jsonData:
      permissions = convertJSONPermissions(jsonData['permissions'])
  permissionsLists = permissions if isinstance(permissions, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess)
    if not drive:
      continue
    entityPerformActionSubItemModifierNumItems([Ent.USER, user], Ent.DRIVE_FILE_OR_FOLDER_ACL, Act.MODIFIER_TO, jcount, Ent.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), 'get',
               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
               fields='kind')
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    Ind.Increment()
    svcargs = dict([('fileId', None), ('sendNotificationEmail', sendNotificationEmail), ('emailMessage', emailMessage),
                    ('useDomainAdminAccess', useDomainAdminAccess),
                    ('body', None), ('fields', ''), ('supportsAllDrives', True)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(drive.permissions(), 'create')
    dbatch = drive.new_batch_http_request(callback=_callbackCreatePermission)
    bcount = 0
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      if permissionsLists:
        if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
          permissions = permissionsLists[fileId]
        else:
          permissions = permissionsLists[origUser][fileId]
      kcount = len(permissions)
      if kcount == 0:
        continue
      k = 0
      for permission in permissions:
        k += 1
        svcparms = svcargs.copy()
        svcparms['fileId'] = fileId
        svcparms['body'] = _makePermissionBody(permission)
        if not svcparms['body']:
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, fileId, Ent.PERMITTEE, permission], Msg.INVALID, k, kcount)
          continue
        if svcparms['body']['role'] == 'owner':
          svcparms['enforceSingleParent'] = enforceSingleParent
          svcparms['moveToNewOwnersRoot'] = moveToNewOwnersRoot
          svcparms['transferOwnership'] = svcparms['sendNotificationEmail'] = True
        dbatch.add(method(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permission))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = drive.new_batch_http_request(callback=_callbackCreatePermission)
          bcount = 0
    if bcount > 0:
      dbatch.execute()
    Ind.Decrement()

def doCreatePermissions():
  createDriveFilePermissions([_getAdminEmail()], True)

# gam <UserTypeEntity> delete drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail> [adminaccess|asadmin] [showtitles]
def deleteDriveFileACLs(users, useDomainAdminAccess=False):
  fileIdEntity = getDriveFileEntity()
  isEmail, permissionId = getPermissionId()
  showTitles = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'showtitles':
      showTitles = getBoolean()
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.DRIVE_FILE_OR_FOLDER_ACL, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    if isEmail:
      permissionId = getPermissionIdForEmail(user, i, count, permissionId)
      if not permissionId:
        return
      isEmail = False
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId)
        callGAPI(drive.permissions(), 'delete',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_DELETE_ACL_THROW_REASONS+[GAPI.FILE_NEVER_WRITABLE],
                 useDomainAdminAccess=useDomainAdminAccess, fileId=fileId, permissionId=permissionId, supportsAllDrives=True)
        entityActionPerformed([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.fileNeverWritable, GAPI.badRequest, GAPI.cannotRemoveOwner, GAPI.cannotModifyInheritedTeamDrivePermission,
              GAPI.insufficientAdministratorPrivileges, GAPI.sharingRateLimitExceeded) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def doDeleteDriveFileACLs():
  deleteDriveFileACLs([_getAdminEmail()], True)

# gam <UserTypeEntity> delete permissions <DriveFileEntity> <DriveFilePermissionIDEntity> [adminaccess|asadmin]
#	<PermissionMatch>* [<PermissionMatchAction>]
def deletePermissions(users, useDomainAdminAccess=False):
  def convertJSONPermissions(jsonPermissions):
    permissionIds = []
    for permission in PM.GetMatchingPermissions(jsonPermissions):
      if permission.get('role', '') == 'owner':
        continue
      permissionIds.append(permission['id'])
    return permissionIds

  def _callbackDeletePermissionId(request_id, response, exception):
    ri = request_id.splitlines()
    if int(ri[RI_J]) == 1:
      entityPerformActionNumItems([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY]], int(ri[RI_JCOUNT]), Ent.PERMISSION_ID, int(ri[RI_I]), int(ri[RI_COUNT]))
      Ind.Increment()
    if exception is None:
      entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      http_status, reason, message = checkGAPIError(exception)
      if reason not in GAPI.DEFAULT_RETRY_REASONS+[GAPI.SERVICE_LIMIT]:
        if reason == GAPI.PERMISSION_NOT_FOUND:
          entityDoesNotHaveItemWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        elif reason in GAPI.DRIVE3_DELETE_ACL_THROW_REASONS:
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], message, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        else:
          errMsg = getHTTPError({}, http_status, reason, message)
          entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
        if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
          Ind.Decrement()
        return
      waitOnFailure(1, 10, reason, message)
      try:
        callGAPI(drive.permissions(), 'delete',
                 throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+GAPI.DRIVE3_DELETE_ACL_THROW_REASONS,
                 retryReasons=[GAPI.SERVICE_LIMIT],
                 useDomainAdminAccess=useDomainAdminAccess, fileId=ri[RI_ENTITY], permissionId=ri[RI_ITEM], supportsAllDrives=True)
        entityActionPerformed([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.cannotRemoveOwner, GAPI.cannotModifyInheritedTeamDrivePermission,
              GAPI.insufficientAdministratorPrivileges, GAPI.sharingRateLimitExceeded, GAPI.permissionNotFound,
              GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        entityActionFailedWarning([Ent.DRIVE_FILE_OR_FOLDER_ID, ri[RI_ENTITY], Ent.PERMISSION_ID, ri[RI_ITEM]], str(e), int(ri[RI_J]), int(ri[RI_JCOUNT]))
    if int(ri[RI_J]) == int(ri[RI_JCOUNT]):
      Ind.Decrement()

  fileIdEntity = getDriveFileEntity()
  if not checkArgumentPresent('json'):
    permissionIds = getEntityList(Cmd.OB_DRIVE_FILE_PERMISSION_ID_ENTITY)
    jsonData = None
    PM = None
  else:
    permissionIds = []
    jsonData = getJSON([])
    PM = PermissionMatch()
    PM.SetDefaultMatch(False, {'role': 'owner'})
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    elif PM and PM.ProcessArgument(myarg):
      pass
    else:
      unknownArgumentExit()
  if jsonData:
    if 'permission' in jsonData:
      permissionIds = convertJSONPermissions([jsonData['permission']])
    elif 'permissions' in jsonData:
      permissionIds = convertJSONPermissions(jsonData['permissions'])
  permissionIdsLists = permissionIds if isinstance(permissionIds, dict) else None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess)
    if not drive:
      continue
    entityPerformActionSubItemModifierNumItems([Ent.USER, user], Ent.DRIVE_FILE_OR_FOLDER_ACL, Act.MODIFIER_FROM, jcount, Ent.DRIVE_FILE_OR_FOLDER, i, count)
    if jcount == 0:
      continue
    try:
      callGAPI(drive.about(), 'get',
               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
               fields='kind')
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    Ind.Increment()
    svcargs = dict([('fileId', None), ('permissionId', None), ('useDomainAdminAccess', useDomainAdminAccess), ('supportsAllDrives', True)]+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(drive.permissions(), 'delete')
    dbatch = drive.new_batch_http_request(callback=_callbackDeletePermissionId)
    bcount = 0
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      if permissionIdsLists:
        if not GM.Globals[GM.CSV_SUBKEY_FIELD]:
          permissionIds = permissionIdsLists[fileId]
        else:
          permissionIds = permissionIdsLists[origUser][fileId]
      kcount = len(permissionIds)
      if kcount == 0:
        continue
      k = 0
      for permissionId in permissionIds:
        k += 1
        svcparms = svcargs.copy()
        svcparms['fileId'] = fileId
        svcparms['permissionId'] = permissionId
        dbatch.add(method(**svcparms), request_id=batchRequestID(fileId, j, jcount, k, kcount, permissionId))
        bcount += 1
        if bcount >= GC.Values[GC.BATCH_SIZE]:
          executeBatch(dbatch)
          dbatch = drive.new_batch_http_request(callback=_callbackDeletePermissionId)
          bcount = 0
    if bcount > 0:
      dbatch.execute()
    Ind.Decrement()

def doDeletePermissions():
  deletePermissions([_getAdminEmail()], True)

# gam <UserTypeEntity> info drivefileacl <DriveFileEntity> <DriveFilePermissionIDorEmail>
#	[showtitles] [formatjson] [adminaccess|asadmin]
def infoDriveFileACLs(users, useDomainAdminAccess=False):
  fileIdEntity = getDriveFileEntity()
  isEmail, permissionId = getPermissionId()
  showTitles = False
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'showtitles':
      showTitles = getBoolean()
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      FJQC.GetFormatJSON(myarg)
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=[Ent.DRIVE_FILE_OR_FOLDER_ACL, None][FJQC.formatJSON],
                                                  useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    if isEmail:
      permissionId = getPermissionIdForEmail(user, i, count, permissionId)
      if not permissionId:
        return
      isEmail = False
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      try:
        fileName = fileId
        entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
        if showTitles:
          fileName, entityType = _getDriveFileNameFromId(drive, fileId, not FJQC.formatJSON, useDomainAdminAccess)
        permission = callGAPI(drive.permissions(), 'get',
                              throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.PERMISSION_NOT_FOUND, GAPI.INSUFFICIENT_ADMINISTRATOR_PRIVILEGES],
                              useDomainAdminAccess=useDomainAdminAccess,
                              fileId=fileId, permissionId=permissionId, fields='*', supportsAllDrives=True)
        if not FJQC.formatJSON:
          entityPerformActionNumItems([entityType, fileName], jcount, Ent.PERMITTEE)
          Ind.Increment()
          _showDriveFilePermission(permission, printKeys, timeObjects, j, jcount)
          Ind.Decrement()
        else:
          _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError,
              GAPI.badRequest, GAPI.insufficientAdministratorPrivileges) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
      except GAPI.permissionNotFound:
        entityDoesNotHaveItemWarning([Ent.USER, user, entityType, fileName, Ent.PERMISSION_ID, permissionId], j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

def doInfoDriveFileACLs():
  infoDriveFileACLs([_getAdminEmail()], True)

DRIVEFILE_BASIC_PERMISSION_FIELDS = [
  'id', 'emailAddress', 'domain', 'role', 'type',
  'allowFileDiscovery', 'expirationTime', 'deleted'
  ]

def getDriveFilePermissionsFields(myarg, fieldsList):
  if myarg in DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP:
    fieldsList.append(DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP[myarg])
  elif myarg == 'basicpermissions':
    fieldsList.extend(DRIVEFILE_BASIC_PERMISSION_FIELDS)
  elif myarg == 'fields':
    for field in _getFieldsList():
      if field in DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP:
        fieldsList.append(DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP[field])
      elif field == 'basicpermissions':
        fieldsList.extend(DRIVEFILE_BASIC_PERMISSION_FIELDS)
      else:
        invalidChoiceExit(field, DRIVE_PERMISSIONS_SUBFIELDS_CHOICE_MAP, True)
  else:
    return False
  return True

# gam <UserTypeEntity> print drivefileacls <DriveFileEntity> [todrive <ToDriveAttribute>*]
#	[oneitemperrow] [showtitles] [<DrivePermissionsFieldName>*|(fields <DrivePermissionsFieldNameList>)]
#	<PermissionMatch>* [<PermissionMatchAction>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[formatjson [quotechar <Character>]] [adminaccess|asadmin]
# gam <UserTypeEntity> show drivefileacls <DriveFileEntity>
#	[oneitemperrow] [showtitles] [<DrivePermissionsFieldName>*|(fields <DrivePermissionsFieldNameList>)]
#	<PermissionMatch>* [<PermissionMatchAction>]
#	(orderby <DriveFileOrderByFieldName> [ascending|descending])*
#	[formatjson] [adminaccess|asadmin]
def printShowDriveFileACLs(users, useDomainAdminAccess=False):
  csvPF = CSVPrintFile(['Owner', 'id'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  fileIdEntity = getDriveFileEntity()
  oneItemPerRow = showTitles = False
  fieldsList = []
  OBY = OrderBy(DRIVEFILE_ORDERBY_CHOICE_MAP)
  PM = PermissionMatch()
  fileNameTitle = 'title' if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES] else 'name'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'oneitemperrow':
      oneItemPerRow = True
    elif myarg == 'orderby':
      OBY.GetChoice()
    elif myarg == 'showtitles':
      showTitles = True
      if csvPF:
        csvPF.AddTitles(fileNameTitle)
        csvPF.SetSortAllTitles()
    elif getDriveFilePermissionsFields(myarg, fieldsList):
      pass
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    elif PM.ProcessArgument(myarg):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  fields = getItemFieldsFromFieldsList('permissions', fieldsList, True)
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity,
                                                  entityType=[Ent.DRIVE_FILE_OR_FOLDER, None][csvPF is not None or FJQC.formatJSON],
                                                  orderBy=OBY.orderBy, useDomainAdminAccess=useDomainAdminAccess)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for fileId in fileIdEntity['list']:
      j += 1
      fileName = fileId
      entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
      if showTitles:
        fileName, entityType = _getDriveFileNameFromId(drive, fileId, not (csvPF or FJQC.formatJSON), useDomainAdminAccess)
      try:
        results = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INSUFFICIENT_ADMINISTRATOR_PRIVILEGES],
                                useDomainAdminAccess=useDomainAdminAccess,
                                fileId=fileId, fields=fields, supportsAllDrives=True)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions,
              GAPI.unknownError, GAPI.insufficientAdministratorPrivileges) as e:
        entityActionFailedWarning([Ent.USER, user, entityType, fileName], str(e), j, jcount)
        continue
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, fileName], str(e), j, jcount)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      permissions = PM.GetMatchingPermissions(results)
      if not csvPF:
        if not FJQC.formatJSON:
          _showDriveFilePermissions(entityType, fileName, permissions, printKeys, timeObjects, j, jcount)
        else:
          if oneItemPerRow:
            for permission in permissions:
              _showDriveFilePermissionJSON(user, fileId, fileName, permission, timeObjects)
          else:
            _showDriveFilePermissionsJSON(user, fileId, fileName, permissions, timeObjects)
      else:
        baserow = {'Owner': user, 'id': fileId}
        if showTitles:
          baserow[fileNameTitle] = fileName
        if oneItemPerRow:
          for permission in permissions:
            row = baserow.copy()
            _mapDrivePermissionNames(permission)
            flattenJSON({'permission': permission}, flattened=row, timeObjects=timeObjects)
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(row)
            elif csvPF.CheckRowTitles(row):
              row = baserow.copy()
              row['JSON'] = json.dumps(cleanJSON({'permission': permission}, timeObjects=timeObjects),
                                       ensure_ascii=False, sort_keys=True)
              csvPF.WriteRowNoFilter(row)
        else:
          row = baserow.copy()
          for permission in permissions:
            _mapDrivePermissionNames(permission)
          flattenJSON({'permissions': permissions}, flattened=row, timeObjects=timeObjects)
          if not FJQC.formatJSON:
            csvPF.WriteRowTitles(row)
          elif csvPF.CheckRowTitles(row):
            baserow['JSON'] = json.dumps(cleanJSON({'permissions': permissions}, timeObjects=timeObjects),
                                         ensure_ascii=False, sort_keys=True)
            csvPF.WriteRowNoFilter(baserow)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Drive File ACLs')

def doPrintShowDriveFileACLs():
  printShowDriveFileACLs([_getAdminEmail()], True)

# gam print ownership <DriveFileID>|(drivefilename <DriveFileName>) [todrive <ToDriveAttribute>*] [formatjson [quotechar <Character>]]
# gam show ownership <DriveFileID>|(drivefilename <DriveFileName>) [formatjson]
def doPrintShowOwnership():
  rep = buildGAPIObject(API.REPORTS)
  customerId = GC.Values[GC.CUSTOMER_ID]
  if customerId == GC.MY_CUSTOMER:
    customerId = None
  fileNameTitle = 'title' if not GC.Values[GC.DRIVE_V3_NATIVE_NAMES] else 'name'
  csvPF = CSVPrintFile('Owner') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  showComplete = False
  entityType = Ent.DRIVE_FILE_OR_FOLDER_ID
  myarg = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  mycmd = myarg.lower().replace('_', '').replace('-', '')
  if mycmd == 'id':
    fileId = getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True)
  elif mycmd == 'drivefilename':
    entityType = Ent.DRIVE_FILE_OR_FOLDER
    fileId = getString(Cmd.OB_DRIVE_FILE_NAME, checkBlank=True)
  elif mycmd.find(':') != -1:
    kw, fileId = myarg.split(':', 1)
    kw = kw.lower().replace('_', '').replace('-', '')
    if fileId.isspace():
      Cmd.Backup()
      blankArgumentExit(Cmd.OB_DRIVE_FILE_ID)
    if kw == 'id':
      pass
    elif kw == 'drivefilename':
      entityType = Ent.DRIVE_FILE_OR_FOLDER
    else:
      Cmd.Backup()
      invalidArgumentExit(Cmd.OB_DRIVE_FILE_ID)
  else:
    fileId = myarg
  if not fileId:
    Cmd.Backup()
    invalidArgumentExit(Cmd.OB_DRIVE_FILE_ID)
  if entityType == Ent.DRIVE_FILE_OR_FOLDER_ID:
    filters = f'doc_id=={fileId}'
  else:
    filters = f'doc_title=={fileId}'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if csvPF and not FJQC.formatJSON:
    csvPF.AddTitles(['id', fileNameTitle, 'type', 'ownerIsTeamDrive', 'driveId'])
    csvPF.SetSortAllTitles()
  foundIds = {}
  try:
    feed = callGAPIpages(rep.activities(), 'list', 'items',
                         throwReasons=[GAPI.BAD_REQUEST, GAPI.INVALID, GAPI.AUTH_ERROR],
                         applicationName='drive', userKey='all', customerId=customerId,
                         filters=filters, fields='nextPageToken,items(events(parameters))')
  except GAPI.badRequest:
    systemErrorExit(BAD_REQUEST_RC, Msg.BAD_REQUEST)
  except GAPI.invalid as e:
    systemErrorExit(GOOGLE_API_ERROR_RC, str(e))
  except GAPI.authError:
    accessErrorExit(None)
  for activity in feed:
    events = activity.pop('events')
    for event in events:
      fileInfo = {}
      for item in event.get('parameters', []):
        if item['name'] == 'primary_event':
          if not item['boolValue']:
            break
        elif item['name'] == 'doc_id':
          if item['value'] in foundIds:
            break
          fileInfo['id'] = item['value']
        elif item['name'] == 'owner':
          fileInfo['Owner'] = item['value']
        elif item['name'] == 'doc_title':
          fileInfo[fileNameTitle] = item['value']
        elif item['name'] == 'doc_type':
          fileInfo['type'] = item['value']
        elif item['name'] == 'owner_is_shared_drive':
          fileInfo['ownerIsSharedDrive'] = item['boolValue']
        elif item['name'] == 'shared_drive_id':
          fileInfo['driveId'] = item['value']
      else:
        if 'Owner' in fileInfo and 'id' in fileInfo:
          foundIds[fileInfo['id']] = True
          if not csvPF:
            if not FJQC.formatJSON:
              printEntityKVList([Ent.OWNER, fileInfo['Owner']],
                                ['id', fileInfo['id'], fileNameTitle, fileInfo.get('title', ''),
                                 'type', fileInfo.get('type', ''), 'ownerIsSharedDrive', fileInfo.get('ownerIsSharedDrive', False), 'driveId', fileInfo.get('driveId', '')])
            else:
              printLine(json.dumps(cleanJSON(fileInfo), ensure_ascii=False, sort_keys=True))
          else:
            row = flattenJSON(fileInfo)
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(row)
            elif csvPF.CheckRowTitles(row):
              csvPF.WriteRowNoFilter({'JSON': json.dumps(cleanJSON(fileInfo), ensure_ascii=False, sort_keys=True)})
          if entityType == Ent.DRIVE_FILE_OR_FOLDER_ID:
            showComplete = True
            break
      if showComplete:
        break
    if showComplete:
      break
  if not foundIds:
    entityActionFailedWarning([entityType, fileId], Msg.NOT_FOUND)
  if csvPF:
    csvPF.writeCSVfile('Drive File Ownership')

def _getTeamDriveTheme(myarg, body):
  if myarg in {'theme', 'themeid'}:
    body.pop('backgroundImageFile', None)
    body.pop('colorRgb', None)
    body['themeId'] = getString(Cmd.OB_STRING, checkBlank=True)
  elif myarg == 'customtheme':
    body.pop('themeId', None)
    body['backgroundImageFile'] = {
      'id': getString(Cmd.OB_DRIVE_FILE_ID, checkBlank=True),
      'xCoordinate': getFloat(minVal=0.0, maxVal=1.0),
      'yCoordinate': getFloat(minVal=0.0, maxVal=1.0),
      'width': getFloat(minVal=0.0, maxVal=1.0)
      }
  elif myarg == 'color':
    body.pop('themeId', None)
    body['colorRgb'] = getColor()
  else:
    return False
  return True

TEAMDRIVE_RESTRICTIONS_MAP = {
  'adminmanagedrestrictions': 'adminManagedRestrictions',
  'copyrequireswriterpermission': 'copyRequiresWriterPermission',
  'domainusersonly': 'domainUsersOnly',
  'drivemembersonly': 'driveMembersOnly',
  'teammembersonly': 'driveMembersOnly',
  }

def _getTeamDriveRestrictions(myarg, body):
  def _setRestriction(restriction):
    body.setdefault('restrictions', {})
    body['restrictions'][TEAMDRIVE_RESTRICTIONS_MAP[restriction]] = getBoolean()

  if myarg.startswith('restrictions.'):
    _, subField = myarg.split('.', 1)
    if subField in TEAMDRIVE_RESTRICTIONS_MAP:
      _setRestriction(subField)
      return True
    invalidChoiceExit(subField, TEAMDRIVE_RESTRICTIONS_MAP, True)
  if myarg in TEAMDRIVE_RESTRICTIONS_MAP:
    _setRestriction(myarg)
    return True
  return False

# gam <UserTypeEntity> create|add teamdrive <Name> [adminaccess|asadmin]
#	[(theme|themeid <String>) | ([customtheme <DriveFileID> <Float> <Float> <Float>] [color <ColorValue>])]
#	(<TeamDriveRestrictionsFieldName> <Boolean>)*
#	[hide <Boolean>]
#	[csv [todrive <ToDriveAttribute>*]] [returnidonly]
def createTeamDrive(users, useDomainAdminAccess=False):
  requestId = str(uuid.uuid4())
  body = {'name': getString(Cmd.OB_NAME, checkBlank=True)}
  updateBody = {}
  csvPF = None
  hide = returnIdOnly = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getTeamDriveTheme(myarg, body):
      pass
    elif _getTeamDriveRestrictions(myarg, updateBody):
      pass
    elif myarg == 'hide':
      hide = getBoolean()
    elif myarg == 'returnidonly':
      returnIdOnly = True
    elif myarg == 'csv':
      csvPF = CSVPrintFile()
    elif csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  if csvPF:
    csvPF.SetTitles(['User', 'name', 'id'])
  for field in ['backgroundImageFile', 'colorRgb']:
    if field in body:
      updateBody[field] = body.pop(field)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    doUpdate = False
    Act.Set(Act.CREATE)
    retry = 0
    while True:
      try:
        teamdrive = callGAPI(drive.drives(), 'create',
                             bailOnTransientError=True,
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.TRANSIENT_ERROR, GAPI.TEAMDRIVE_ALREADY_EXISTS,
                                                                         GAPI.DUPLICATE, GAPI.BAD_REQUEST],
                             requestId=requestId, body=body, fields='id')
        teamDriveId = teamdrive['id']
        if returnIdOnly:
          writeStdout(f'{teamDriveId}\n')
        elif not csvPF:
          entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
        else:
          csvPF.WriteRow({'User': user, 'name': body['name'], 'id': teamDriveId})
        doUpdate = True
        break
      except (GAPI.transientError, GAPI.teamDriveAlreadyExists) as e:
        retry += 1
        if retry > 3:
          entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], str(e), i, count)
          break
        requestId = str(uuid.uuid4())
      except GAPI.duplicate:
        entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], Msg.DUPLICATE, i, count)
        break
      except (GAPI.badRequest) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], str(e), i, count)
        break
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    if doUpdate and (updateBody or hide):
      try:
        if updateBody:
          Act.Set(Act.UPDATE)
          retry = 0
          while True:
            try:
              callGAPI(drive.drives(), 'update',
                       throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST,
                                                                   GAPI.NO_MANAGE_TEAMDRIVE_ADMINISTRATOR_PRIVILEGE],
                       useDomainAdminAccess=useDomainAdminAccess, driveId=teamDriveId, body=updateBody)
              if not returnIdOnly and not csvPF:
                entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
              break
            except GAPI.notFound as e:
              retry += 1
              if retry > 3:
                entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], str(e), i, count)
                break
              time.sleep(retry*retry)
            except GAPI.badRequest as e:
              entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
              break
        if hide:
          Act.Set(Act.HIDE)
          retry = 0
          while True:
            try:
              callGAPI(drive.drives(), 'hide',
                       throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
                       driveId=teamDriveId)
              if not returnIdOnly and not csvPF:
                entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
              break
            except GAPI.notFound as e:
              retry += 1
              if retry > 3:
                entityActionFailedWarning([Ent.USER, user, Ent.REQUEST_ID, requestId], str(e), i, count)
                break
              time.sleep(retry*retry)
      except (GAPI.forbidden, GAPI.badRequest, GAPI.noManageTeamDriveAdministratorPrivilege) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
  if csvPF:
    csvPF.writeCSVfile('SharedDrives')

# gam create|add teamdrive <Name>
#	[(theme|themeid <String>) | ([customtheme <DriveFileID> <Float> <Float> <Float>] [color <ColorValue>])]
#	(<TeamDriveRestrictionsFieldName> <Boolean>)*
#	[hide <Boolean>]
#	[csv [todrive <ToDriveAttribute>*]] [returnidonly]
def doCreateTeamDrive():
  createTeamDrive([_getAdminEmail()], True)

# gam <UserTypeEntity> update teamdrive <TeamDriveEntity> [adminaccess|asadmin] [name <Name>]
#	[(theme|themeid <String>) | ([customtheme <DriveFileID> <Float> <Float> <Float>] [color <ColorValue>])]
#	(<TeamDriveRestrictionsFieldName> <Boolean>)*
def updateTeamDrive(users, useDomainAdminAccess=False):
  fileIdEntity = getTeamDriveEntity()
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'name':
      body['name'] = getString(Cmd.OB_NAME, checkBlank=True)
    elif _getTeamDriveTheme(myarg, body):
      pass
    elif _getTeamDriveRestrictions(myarg, body):
      pass
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity['teamdrive']['driveId']
      callGAPI(drive.drives(), 'update',
               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN, GAPI.BAD_REQUEST,
                                                           GAPI.NO_MANAGE_TEAMDRIVE_ADMINISTRATOR_PRIVILEGE],
               useDomainAdminAccess=useDomainAdminAccess, driveId=teamDriveId, body=body)
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
    except (GAPI.notFound, GAPI.forbidden, GAPI.badRequest, GAPI.noManageTeamDriveAdministratorPrivilege) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

def doUpdateTeamDrive():
  updateTeamDrive([_getAdminEmail()], True)

# gam <UserTypeEntity> delete teamdrive <TeamDriveEntity>
def deleteTeamDrive(users):
  fileIdEntity = getTeamDriveEntity()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity['teamdrive']['driveId']
      callGAPI(drive.drives(), 'delete',
               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN,
                                                           GAPI.CANNOT_DELETE_RESOURCE_WITH_CHILDREN, GAPI.INSUFFICIENT_FILE_PERMISSIONS],
               driveId=teamDriveId)
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
    except (GAPI.notFound, GAPI.forbidden,
            GAPI.cannotDeleteResourceWithChildren, GAPI.insufficientFilePermissions) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam delete teamdrive <TeamDriveEntity>
def doDeleteTeamDrive():
  deleteTeamDrive([_getAdminEmail()])

# gam <UserTypeEntity> hide/unhide teamdrive <TeamDriveEntity>
def hideUnhideTeamDrive(users):
  fileIdEntity = getTeamDriveEntity()
  checkForExtraneousArguments()
  function = 'hide' if Act.Get() == Act.HIDE else 'unhide'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity['teamdrive']['driveId']
      callGAPI(drive.drives(), function,
               throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.FORBIDDEN],
               driveId=teamDriveId)
      entityActionPerformed([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], i, count)
    except (GAPI.notFound, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

# gam hide/unhide teamdrive <TeamDriveEntity>
def doHideUnhideTeamDrive():
  hideUnhideTeamDrive([_getAdminEmail()])

TEAMDRIVE_FIELDS_CHOICE_MAP = {
  'backgroundimagefile': 'backgroundImageFile',
  'backgroundimagelink': 'backgroundImageLink',
  'capabilities': 'capabilities',
  'colorrgb': 'colorRgb',
  'createddate': 'createdTime',
  'createdtime': 'createdTime',
  'id': 'id',
  'hidden': 'hidden',
  'name': 'name',
  'restrictions': 'restrictions',
  'themeid': 'themeId',
  }
TEAMDRIVE_TIME_OBJECTS = {'createdTime'}

def _showTeamDrive(user, teamdrive, j, jcount, FJQC):
  def _showCapabilitiesRestrictions(field):
    if field in teamdrive:
      printKeyValueList([field, ''])
      Ind.Increment()
      for capability in sorted(teamdrive[field]):
        printKeyValueList([capability, teamdrive[field][capability]])
      Ind.Decrement()

  if FJQC.formatJSON:
    printLine(json.dumps(cleanJSON(teamdrive, timeObjects=TEAMDRIVE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True))
    return
  printEntity([Ent.USER, user, Ent.TEAMDRIVE, f'{teamdrive["name"]} ({teamdrive["id"]})'], j, jcount)
  Ind.Increment()
  printEntity([Ent.TEAMDRIVE_ID, teamdrive['id']])
  printEntity([Ent.TEAMDRIVE_NAME, teamdrive['name']])
  if 'hidden' in teamdrive:
    printKeyValueList(['hidden', teamdrive['hidden']])
  if 'createdTime' in teamdrive:
    printKeyValueList(['createdTime', formatLocalTime(teamdrive['createdTime'])])
  for setting in ['backgroundImageLink', 'colorRgb', 'themeId']:
    if setting in teamdrive:
      printKeyValueList([setting, teamdrive[setting]])
  if 'role' in teamdrive:
    printKeyValueList(['role', teamdrive['role']])
  _showCapabilitiesRestrictions('capabilities')
  _showCapabilitiesRestrictions('restrictions')
  Ind.Decrement()

# gam <UserTypeEntity> info teamdrive <TeamDriveEntity> [adminaccess|asadmin] [fields <TeamDriveFieldNameList>] [formatjson]
def infoTeamDrive(users, useDomainAdminAccess=False):
  fileIdEntity = getTeamDriveEntity()
  fieldsList = []
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    elif getFieldsList(myarg, TEAMDRIVE_FIELDS_CHOICE_MAP, fieldsList, initialField=['id', 'name']):
      pass
    else:
      FJQC.GetFormatJSON(myarg)
  fields = ','.join(set(fieldsList)) if fieldsList else '*'
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = _validateUserTeamDrive(user, i, count, fileIdEntity, useDomainAdminAccess=useDomainAdminAccess)
    if not drive:
      continue
    try:
      teamDriveId = fileIdEntity['teamdrive']['driveId']
      teamdrive = callGAPI(drive.drives(), 'get',
                           throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.NOT_FOUND],
                           useDomainAdminAccess=useDomainAdminAccess,
                           driveId=teamDriveId, fields=fields)
      _showTeamDrive(user, teamdrive, i, count, FJQC)
    except GAPI.notFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE_ID, teamDriveId], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

def doInfoTeamDrive():
  infoTeamDrive([_getAdminEmail()], True)

TEAMDRIVE_ACL_ROLES_MAP = {
  'commenter': 'commenter',
  'contentmanager': 'fileOrganizer',
  'contributor': 'writer',
  'editor': 'writer',
  'fileorganizer': 'fileOrganizer',
  'manager': 'organizer',
  'organizer': 'organizer',
  'owner': 'organizer',
  'read': 'reader',
  'reader': 'reader',
  'viewer': 'reader',
  'writer': 'writer',
  }

TEAMDRIVE_ROLES_CAPABILITIES_MAP = {
  'commenter': {'canComment': True, 'canEdit': False},
  'fileOrganizer': {'canAddChildren': True, 'canManageMembers': False},
  'organizer': {'canManageMembers': True},
  'reader': {'canCopy': True, 'canComment': False},
  'writer': {'canEdit': True, 'canManageMembers': False},
  }

# gam <UserTypeEntity> print teamdrives [todrive <ToDriveAttribute>*]
#	[adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]]
#	[matchname <RegularExpression>] (role|roles <TeamDriveACLRoleList>)*
#	[fields <TeamDriveFieldNameList>] [formatjson [quotechar <Character>]]
# gam <UserTypeEntity> show teamdrives
#	[adminaccess|asadmin [teamdriveadminquery|query <QueryTeamDrive>]]
#	[matchname <RegularExpression>] (role|roles <TeamDriveACLRoleLIst>)*
#	[fields <TeamDriveFieldNameList>] [formatjson [quotechar <Character>]]
def printShowTeamDrives(users, useDomainAdminAccess=False):
  def stripNonShowFields(teamdrive):
    if not showFields:
      return teamdrive
    steamdrive = {}
    for field in showFields:
      if field in teamdrive:
        steamdrive[field] = teamdrive[field]
    return steamdrive

  csvPF = CSVPrintFile(['User', 'id', 'name'], ['User', 'id', 'name', 'role']) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  roles = set()
  query = matchPattern = None
  showFields = set()
  fieldsList = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'teamdriveadminquery', 'shareddriveadminquery', 'query'}:
      queryLocation = Cmd.Location()
      query = getString(Cmd.OB_QUERY, minLen=0) or None
    elif myarg == 'matchname':
      matchPattern = getREPattern(re.IGNORECASE)
    elif myarg in {'role', 'roles'}:
      roles |= getACLRoles(TEAMDRIVE_ACL_ROLES_MAP)
    elif myarg == 'checkgroups':
      pass
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    elif getFieldsList(myarg, TEAMDRIVE_FIELDS_CHOICE_MAP, fieldsList, initialField=['id', 'name']):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if query and not useDomainAdminAccess:
    Cmd.SetLocation(queryLocation-1)
    usageErrorExit(Msg.ONLY_ADMINISTRATORS_CAN_PERFORM_SHARED_DRIVE_QUERIES)
  if fieldsList:
    showFields = set(fieldsList)
  if csvPF and not useDomainAdminAccess:
    if fieldsList:
      showFields.add('role')
    csvPF.AddTitle('role')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    try:
      if useDomainAdminAccess:
        printGettingAllAccountEntities(Ent.TEAMDRIVE, query)
      else:
        printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query)
      feed = callGAPIpages(drive.drives(), 'list', 'drives',
                           pageMessage=getPageMessage(),
                           throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID,
                                                                       GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS,
                                                                       GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                           q=query, useDomainAdminAccess=useDomainAdminAccess,
                           fields='*', pageSize=100)
    except (GAPI.invalidQuery, GAPI.invalid, GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
      continue
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
      continue
    matchedFeed = []
    if not useDomainAdminAccess:
      for teamdrive in feed:
        if matchPattern is not None and matchPattern.match(teamdrive['name']) is None:
          continue
        for role, capabilities in iter(TEAMDRIVE_ROLES_CAPABILITIES_MAP.items()):
          match = True
          for capability in capabilities:
            if capabilities[capability] != teamdrive['capabilities'][capability]:
              match = False
              break
          if match:
            break
        else:
          role = 'unknown'
        if not roles or role in roles:
          teamdrive['role'] = role
          matchedFeed.append(teamdrive)
    elif matchPattern is not None:
      for teamdrive in feed:
        if matchPattern.match(teamdrive['name']) is not None:
          matchedFeed.append(teamdrive)
    else:
      matchedFeed = feed
    jcount = len(matchedFeed)
    if not csvPF:
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE, i, count)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    else:
      if not csvPF:
        Ind.Increment()
        j = 0
        for teamdrive in matchedFeed:
          j += 1
          teamdrive = stripNonShowFields(teamdrive)
          _showTeamDrive(user, teamdrive, j, jcount, FJQC)
        Ind.Decrement()
      else:
        for teamdrive in matchedFeed:
          teamdrive = stripNonShowFields(teamdrive)
          if FJQC.formatJSON:
            row = {'User': user, 'id': teamdrive['id'], 'name': teamdrive['name']}
            if not useDomainAdminAccess:
              row['role'] = teamdrive['role']
            row['JSON'] = json.dumps(cleanJSON(teamdrive, timeObjects=TEAMDRIVE_TIME_OBJECTS), ensure_ascii=False, sort_keys=True)
            csvPF.WriteRow(row)
          else:
            csvPF.WriteRowTitles(flattenJSON(teamdrive, flattened={'User': user}, timeObjects=TEAMDRIVE_TIME_OBJECTS))
  if csvPF:
    csvPF.writeCSVfile('SharedDrives')

def doPrintShowTeamDrives():
  printShowTeamDrives([_getAdminEmail()], True)

TEAMDRIVE_INDEXED_TITLES = ['permissions']

# gam <UserTypeEntity> print teamdriveacls [todrive <ToDriveAttribute>*]
#	[teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>]
#	[user|group <EmailAddress> [checkgroups]] (role|roles <TeamDriveACLRoleList>)*
#	[oneitemperrow] [<DrivePermissionsFieldName>*|(fields <DrivePermissionsFieldNameList>)]
#	[formatjson [quotechar <Character>]]
#	asadmin
# gam <UserTypeEntity> show teamdriveacls
#	[teamdriveadminquery|query <QueryTeamDrive>] [matchname <RegularExpression>]
#	[user|group <EmailAddress> [checkgroups]] (role|roles <TeamDriveACLRoleList>)*
#	[oneitemperrow] [<DrivePermissionsFieldName>*|(fields <DrivePermissionsFieldNameList>)]
#	asadmin
def printShowTeamDriveACLs(users, useDomainAdminAccess=False):
  csvPF = CSVPrintFile(['User', 'id', 'name'], 'sortall', TEAMDRIVE_INDEXED_TITLES) if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  roles = set()
  checkGroups = oneItemPerRow = False
  fieldsList = []
  emailAddress = query = matchPattern = permtype = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'teamdriveadminquery', 'shareddriveadminquery', 'query'}:
      queryLocation = Cmd.Location()
      query = getString(Cmd.OB_QUERY, minLen=0) or None
    elif myarg == 'matchname':
      matchPattern = getREPattern(re.IGNORECASE)
    elif myarg in {'user', 'group'}:
      permtype = myarg
      emailAddress = getEmailAddress(noUid=True)
    elif myarg in {'role', 'roles'}:
      roles |= getACLRoles(TEAMDRIVE_ACL_ROLES_MAP)
    elif myarg == 'checkgroups':
      checkGroups = True
    elif myarg == 'oneitemperrow':
      oneItemPerRow = True
    elif getDriveFilePermissionsFields(myarg, fieldsList):
      pass
    elif myarg in ADMIN_ACCESS_OPTIONS:
      useDomainAdminAccess = True
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if query and not useDomainAdminAccess:
    Cmd.SetLocation(queryLocation-1)
    usageErrorExit(Msg.ONLY_ADMINISTRATORS_CAN_PERFORM_SHARED_DRIVE_QUERIES)
  if fieldsList:
    if permtype is not None:
      fieldsList.extend(['type', 'emailAddress'])
    if roles:
      fieldsList.append('role')
  fields = getItemFieldsFromFieldsList('permissions', fieldsList, True)
  printKeys, timeObjects = _getDriveFileACLPrintKeysTimeObjects()
  if checkGroups:
    if emailAddress:
      cd = buildGAPIObject(API.DIRECTORY)
      try:
        groups = callGAPIpages(cd.groups(), 'list', 'groups',
                               throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                               userKey=emailAddress, orderBy='email', fields='nextPageToken,groups(email)')
      except (GAPI.invalidMember, GAPI.invalidInput):
        badRequestWarning(Ent.GROUP, Ent.MEMBER, emailAddress)
        return
      except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
        accessErrorExit(cd)
      groupsSet = {group['email'] for group in groups}
    else:
      checkGroups = False
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
    if not drive:
      continue
    feed = None
    if permtype == 'user':
      _, userdrive = buildGAPIServiceObject(API.DRIVE3, emailAddress, displayError=False)
      if userdrive is not None:
        try:
          feed = callGAPIpages(userdrive.drives(), 'list', 'drives',
                               throwReasons=GAPI.DRIVE_USER_THROW_REASONS,
                               fields='nextPageToken,drives(id,name)', pageSize=100)
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy):
          pass
    if feed is None:
      try:
        if useDomainAdminAccess:
          printGettingAllAccountEntities(Ent.TEAMDRIVE, query)
        else:
          printGettingAllEntityItemsForWhom(Ent.TEAMDRIVE, user, i, count, query)
        feed = callGAPIpages(drive.drives(), 'list', 'drives',
                             pageMessage=getPageMessage(),
                             throwReasons=GAPI.DRIVE_USER_THROW_REASONS+[GAPI.INVALID_QUERY, GAPI.INVALID,
                                                                         GAPI.QUERY_REQUIRES_ADMIN_CREDENTIALS,
                                                                         GAPI.NO_LIST_TEAMDRIVES_ADMINISTRATOR_PRIVILEGE],
                             q=query, useDomainAdminAccess=useDomainAdminAccess,
                             fields='nextPageToken,drives(id,name)', pageSize=100)
      except (GAPI.invalidQuery, GAPI.invalid, GAPI.queryRequiresAdminCredentials, GAPI.noListTeamDrivesAdministratorPrivilege) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.TEAMDRIVE, None], str(e), i, count)
        continue
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        continue
    matchFeed = []
    jcount = len(feed)
    j = 0
    for teamdrive in feed:
      j += 1
      if matchPattern is not None and matchPattern.match(teamdrive['name']) is None:
        continue
      printGettingAllEntityItemsForWhom(Ent.PERMISSION, teamdrive['name'], j, jcount)
      teamdrive['permissions'] = []
      try:
        results = callGAPIpages(drive.permissions(), 'list', 'permissions',
                                throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS,
                                useDomainAdminAccess=useDomainAdminAccess,
                                fileId=teamdrive['id'], fields=fields, supportsAllDrives=True)
        for permission in results:
          if roles and permission['role'] not in roles:
            continue
          if permtype is None:
            teamdrive['permissions'].append(permission)
          elif permission['type'] == permtype and permission['emailAddress'] == emailAddress:
            teamdrive['permissions'].append(permission)
          elif checkGroups and permission['emailAddress'] in groupsSet:
            teamdrive['permissions'].append(permission)
        if teamdrive['permissions']:
          matchFeed.append(teamdrive)
      except (GAPI.fileNotFound, GAPI.forbidden, GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.unknownError):
        pass
    jcount = len(matchFeed)
    if jcount == 0:
      setSysExitRC(NO_ENTITIES_FOUND)
    if not csvPF:
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.TEAMDRIVE, i, count)
      Ind.Increment()
      j = 0
      for teamdrive in matchFeed:
        j += 1
        if not FJQC.formatJSON:
          _showDriveFilePermissions(Ent.TEAMDRIVE, f'{teamdrive["name"]} ({teamdrive["id"]})',
                                    teamdrive['permissions'], printKeys, timeObjects, j, jcount)
        else:
          if oneItemPerRow:
            for permission in teamdrive['permissions']:
              _showDriveFilePermissionJSON(user, teamdrive['id'], teamdrive['name'], permission, timeObjects)
          else:
            _showDriveFilePermissionsJSON(user, teamdrive['id'], teamdrive['name'], teamdrive['permissions'], timeObjects)
      Ind.Decrement()
    elif matchFeed:
      if oneItemPerRow:
        for teamdrive in matchFeed:
          baserow = {'User': user, 'id': teamdrive['id'], 'name': teamdrive['name']}
          for permission in teamdrive['permissions']:
            row = baserow.copy()
            _mapDrivePermissionNames(permission)
            flattenJSON({'permission': permission}, flattened=row, timeObjects=timeObjects)
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(row)
            elif csvPF.CheckRowTitles(row):
              row = baserow.copy()
              row['JSON'] = json.dumps(cleanJSON({'permission': permission}, timeObjects=timeObjects),
                                       ensure_ascii=False, sort_keys=True)
              csvPF.WriteRowNoFilter(row)
      else:
        for teamdrive in matchFeed:
          baserow = {'User': user, 'id': teamdrive['id'], 'name': teamdrive['name']}
          row = baserow.copy()
          for permission in teamdrive['permissions']:
            _mapDrivePermissionNames(permission)
          flattenJSON({'permissions': teamdrive['permissions']}, flattened=row, timeObjects=timeObjects)
          if not FJQC.formatJSON:
            csvPF.WriteRowTitles(row)
          elif csvPF.CheckRowTitles(row):
            baserow['JSON'] = json.dumps(cleanJSON({'permissions': teamdrive['permissions']}, timeObjects=timeObjects),
                                         ensure_ascii=False, sort_keys=True)
            csvPF.WriteRowNoFilter(baserow)
  if csvPF:
    csvPF.writeCSVfile('SharedDrive ACLs')

def doPrintShowTeamDriveACLs():
  printShowTeamDriveACLs([_getAdminEmail()], True)

# gam <UserTypeEntity> delete alias|aliases
def deleteUsersAliases(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      user_aliases = callGAPI(cd.users(), 'get',
                              throwReasons=GAPI.USER_GET_THROW_REASONS,
                              userKey=user, fields='id,primaryEmail,aliases')
      user_id = user_aliases['id']
      user_primary = user_aliases['primaryEmail']
      jcount = len(user_aliases['aliases']) if ('aliases' in user_aliases) else 0
      entityPerformActionNumItems([Ent.USER, user_primary], jcount, Ent.ALIAS, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      Ind.Increment()
      j = 0
      for an_alias in user_aliases['aliases']:
        j += 1
        try:
          callGAPI(cd.users().aliases(), 'delete',
                   throwReasons=[GAPI.RESOURCE_ID_NOT_FOUND],
                   userKey=user_id, alias=an_alias)
          entityActionPerformed([Ent.USER, user_primary, Ent.ALIAS, an_alias], j, jcount)
        except GAPI.resourceIdNotFound:
          entityActionFailedWarning([Ent.USER, user_primary, Ent.ALIAS, an_alias], Msg.DOES_NOT_EXIST, j, jcount)
      Ind.Decrement()
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      entityUnknownWarning(Ent.USER, user, i, count)

def _validateSubkeyRoleGetGroups(user, role, origUser, userGroupLists, i, count):
  roleLower = role.lower()
  if roleLower in GROUP_ROLES_MAP:
    return (GROUP_ROLES_MAP[roleLower], userGroupLists[origUser][role])
  entityActionNotPerformedWarning([Ent.USER, user, Ent.ROLE, role], Msg.INVALID_ROLE.format(','.join(sorted(GROUP_ROLES_MAP))), i, count)
  return (None, None)

def _addUserToGroups(cd, user, addGroupsSet, addGroups, i, count):
  jcount = len(addGroupsSet)
  entityPerformActionModifierNumItems([Ent.USER, user], Act.MODIFIER_TO, jcount, Ent.GROUP, i, count)
  Ind.Increment()
  j = 0
  for group in sorted(addGroupsSet):
    j += 1
    role = addGroups[group]['role']
    body = {'email': user, 'role': role}
    if addGroups[group]['delivery_settings'] != DELIVERY_SETTINGS_UNDEFINED:
      body['delivery_settings'] = addGroups[group]['delivery_settings']
    try:
      callGAPI(cd.members(), 'insert',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.DUPLICATE, GAPI.MEMBER_NOT_FOUND, GAPI.RESOURCE_NOT_FOUND,
                                                        GAPI.INVALID_MEMBER, GAPI.CYCLIC_MEMBERSHIPS_NOT_ALLOWED,
                                                        GAPI.CONDITION_NOT_MET, GAPI.CONFLICT],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, body=body, fields='')
      entityActionPerformed([Ent.GROUP, group, role, user], j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, j, jcount)
    except (GAPI.duplicate, GAPI.cyclicMembershipsNotAllowed, GAPI.conditionNotMet) as e:
      entityActionFailedWarning([Ent.GROUP, group, role, user], str(e), j, jcount)
    except GAPI.conflict:
      entityActionPerformedMessage([Ent.GROUP, group, role, user], Msg.ACTION_MAY_BE_DELAYED, j, jcount)
    except (GAPI.memberNotFound, GAPI.resourceNotFound, GAPI.invalidMember) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
  Ind.Decrement()

# gam <UserTypeEntity> add group|groups ([<GroupRole>] [[delivery] <DeliverySetting>] <GroupEntity>)+
def addUserToGroups(users):
  cd = buildGAPIObject(API.DIRECTORY)
  baseRole = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
  delivery_settings = getDeliverySettings()
  groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
  subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
  if not isinstance(groupKeys, dict):
    userGroupLists = None
    addGroups = {}
    for group in groupKeys:
      addGroups[normalizeEmailAddressOrUID(group)] = {'role': baseRole, 'delivery_settings': delivery_settings}
    while Cmd.ArgumentsRemaining():
      role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
      delivery_settings = getDeliverySettings()
      for group in getEntityList(Cmd.OB_GROUP_ENTITY):
        addGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': delivery_settings}
  else:
    userGroupLists = groupKeys
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user = normalizeEmailAddressOrUID(user)
    if userGroupLists:
      roleList = [baseRole]
      if not subkeyRoleField:
        groupKeys = userGroupLists[origUser]
      else:
        roleList = userGroupLists[origUser]
      addGroups = {}
      for role in roleList:
        if subkeyRoleField:
          role, groupKeys = _validateSubkeyRoleGetGroups(user, role, origUser, userGroupLists, i, count)
          if role is None:
            continue
        for group in groupKeys:
          addGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': DELIVERY_SETTINGS_UNDEFINED}
    _addUserToGroups(cd, user, set(addGroups), addGroups, i, count)

def _deleteUserFromGroups(cd, user, deleteGroupsSet, deleteGroups, i, count):
  jcount = len(deleteGroupsSet)
  entityPerformActionModifierNumItems([Ent.USER, user], Act.MODIFIER_FROM, jcount, Ent.GROUP, i, count)
  Ind.Increment()
  j = 0
  for group in sorted(deleteGroupsSet):
    j += 1
    role = deleteGroups[group]['role']
    try:
      callGAPI(cd.members(), 'delete',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER,
                                                        GAPI.CONDITION_NOT_MET, GAPI.CONFLICT],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, memberKey=user)
      entityActionPerformed([Ent.GROUP, group, role, user], j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, j, jcount)
    except (GAPI.memberNotFound, GAPI.invalidMember, GAPI.conditionNotMet) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.GROUP, group], str(e), j, jcount)
    except GAPI.conflict:
      entityActionPerformedMessage([Ent.GROUP, group, role, user], Msg.ACTION_MAY_BE_DELAYED, j, jcount)
  Ind.Decrement()

# gam <UserTypeEntity> delete group|groups [<GroupEntity>]
def deleteUserFromGroups(users):
  cd = buildGAPIObject(API.DIRECTORY)
  deleteGroups = {}
  if Cmd.ArgumentsRemaining():
    groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
    userGroupLists = groupKeys if isinstance(groupKeys, dict) else None
    for group in groupKeys:
      deleteGroups[normalizeEmailAddressOrUID(group)] = {'role': Ent.MEMBER}
    checkForExtraneousArguments()
  else:
    groupKeys = None
  role = Ent.MEMBER
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user = normalizeEmailAddressOrUID(user)
    if groupKeys is None:
      try:
        result = callGAPIpages(cd.groups(), 'list', 'groups',
                               throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                               userKey=user, orderBy='email', fields='nextPageToken,groups(email)')
      except (GAPI.invalidMember, GAPI.invalidInput):
        badRequestWarning(Ent.GROUP, Ent.MEMBER, user)
        continue
      except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
        accessErrorExit(cd)
      deleteGroups = {}
      for group in result:
        deleteGroups[group['email']] = {'role': role}
    elif userGroupLists:
      userGroupKeys = userGroupLists[origUser]
      deleteGroups = {}
      for group in userGroupKeys:
        deleteGroups[normalizeEmailAddressOrUID(group)] = {'role': role}
    _deleteUserFromGroups(cd, user, set(deleteGroups), deleteGroups, i, count)

def _updateUserGroups(cd, user, updateGroupsSet, updateGroups, i, count):
  jcount = len(updateGroupsSet)
  entityPerformActionModifierNumItems([Ent.USER, user], Act.MODIFIER_TO, jcount, Ent.GROUP, i, count)
  Ind.Increment()
  j = 0
  for group in sorted(updateGroupsSet):
    j += 1
    role = updateGroups[group]['role']
    body = {'email': user, 'role': role}
    if updateGroups[group]['delivery_settings'] != DELIVERY_SETTINGS_UNDEFINED:
      body['delivery_settings'] = updateGroups[group]['delivery_settings']
    try:
      callGAPI(cd.members(), 'patch',
               throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER, GAPI.CONDITION_NOT_MET],
               retryReasons=GAPI.MEMBERS_RETRY_REASONS,
               groupKey=group, memberKey=user, body=body, fields='')
      entityActionPerformed([Ent.GROUP, group, role, user], j, jcount)
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
      entityUnknownWarning(Ent.GROUP, group, j, jcount)
    except (GAPI.memberNotFound, GAPI.invalidMember, GAPI.conditionNotMet) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.GROUP, group], str(e), j, jcount)
  Ind.Decrement()

# gam <UserTypeEntity> update group|groups ([<GroupRole>] [[delivery] <DeliverySetting>] <GroupEntity>)+
def updateUserGroups(users):
  cd = buildGAPIObject(API.DIRECTORY)
  baseRole = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
  delivery_settings = getDeliverySettings()
  groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
  subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
  if not isinstance(groupKeys, dict):
    userGroupLists = None
    updateGroups = {}
    for group in groupKeys:
      updateGroups[normalizeEmailAddressOrUID(group)] = {'role': baseRole, 'delivery_settings': delivery_settings}
    while Cmd.ArgumentsRemaining():
      role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
      delivery_settings = getDeliverySettings()
      for group in getEntityList(Cmd.OB_GROUP_ENTITY):
        updateGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': delivery_settings}
  else:
    userGroupLists = groupKeys
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user = normalizeEmailAddressOrUID(user)
    if userGroupLists:
      roleList = [baseRole]
      if not subkeyRoleField:
        groupKeys = userGroupLists[origUser]
      else:
        roleList = userGroupLists[origUser]
      updateGroups = {}
      for role in roleList:
        if subkeyRoleField:
          role, groupKeys = _validateSubkeyRoleGetGroups(user, role, origUser, userGroupLists, i, count)
          if role is None:
            continue
        for group in groupKeys:
          updateGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': DELIVERY_SETTINGS_UNDEFINED}
    _updateUserGroups(cd, user, set(updateGroups), updateGroups, i, count)

# gam <UserTypeEntity> sync group|groups [[delivery] <DeliverySetting>] ([<GroupRole>] <GroupEntity>)*
def syncUserWithGroups(users):
  cd = buildGAPIObject(API.DIRECTORY)
  baseRole = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
  delivery_settings = getDeliverySettings()
  groupKeys = getEntityList(Cmd.OB_GROUP_ENTITY)
  subkeyRoleField = GM.Globals[GM.CSV_SUBKEY_FIELD]
  if not isinstance(groupKeys, dict):
    userGroupLists = None
    syncGroups = {}
    for group in groupKeys:
      syncGroups[normalizeEmailAddressOrUID(group)] = {'role': baseRole, 'delivery_settings': delivery_settings}
    while Cmd.ArgumentsRemaining():
      role = getChoice(GROUP_ROLES_MAP, defaultChoice=Ent.ROLE_MEMBER, mapChoice=True)
      delivery_settings = getDeliverySettings()
      for group in getEntityList(Cmd.OB_GROUP_ENTITY):
        syncGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': delivery_settings}
  else:
    userGroupLists = groupKeys
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    origUser = user
    user = normalizeEmailAddressOrUID(user)
    if userGroupLists:
      roleList = [baseRole]
      if not subkeyRoleField:
        groupKeys = userGroupLists[origUser]
      else:
        roleList = userGroupLists[origUser]
      syncGroups = {}
      for role in roleList:
        if subkeyRoleField:
          role, groupKeys = _validateSubkeyRoleGetGroups(user, role, origUser, userGroupLists, i, count)
          if role is None:
            continue
        for group in groupKeys:
          syncGroups[normalizeEmailAddressOrUID(group)] = {'role': role, 'delivery_settings': DELIVERY_SETTINGS_UNDEFINED}
    currGroups = {}
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=user, orderBy='email', fields='nextPageToken,groups(email)')
    except (GAPI.invalidMember, GAPI.invalidInput):
      badRequestWarning(Ent.GROUP, Ent.MEMBER, user)
      continue
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      accessErrorExit(cd)
    for groupEntity in entityList:
      groupEmail = groupEntity['email']
      try:
        result = callGAPI(cd.members(), 'get',
                          throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER, GAPI.CONDITION_NOT_MET],
                          retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                          groupKey=groupEmail, memberKey=user, fields='role,delivery_settings')
        currGroups[groupEmail] = {'role': result.get('role', Ent.MEMBER),
                                  'delivery_settings': result.get('delivery_settings', DELIVERY_SETTINGS_UNDEFINED)}
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
        entityUnknownWarning(Ent.GROUP, groupEmail, i, count)
      except (GAPI.memberNotFound, GAPI.invalidMember, GAPI.conditionNotMet) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.GROUP, groupEmail], str(e), i, count)
    currGroupsSet = set(currGroups)
    syncGroupsSet = set(syncGroups)
    removeGroupsSet = currGroupsSet-syncGroupsSet
    addGroupsSet = syncGroupsSet-currGroupsSet
    updateGroupsSet = set()
    for group in currGroupsSet.intersection(syncGroupsSet):
      if (syncGroups[group]['role'] != currGroups[group]['role'] or
          (syncGroups[group]['delivery_settings'] != currGroups[group]['delivery_settings'] and
           syncGroups[group]['delivery_settings'] != DELIVERY_SETTINGS_UNDEFINED)):
        updateGroupsSet.add(group)
    if removeGroupsSet or addGroupsSet or updateGroupsSet:
      if removeGroupsSet:
        Act.Set(Act.REMOVE)
        _deleteUserFromGroups(cd, user, removeGroupsSet, currGroups, i, count)
      if addGroupsSet:
        Act.Set(Act.ADD)
        _addUserToGroups(cd, user, addGroupsSet, syncGroups, i, count)
      if updateGroupsSet:
        Act.Set(Act.UPDATE)
        _updateUserGroups(cd, user, updateGroupsSet, syncGroups, i, count)
    else:
      printEntityKVList([Ent.USER, user], [Msg.NO_CHANGES], i, count)

# gam <UserTypeEntity> print groups [roles <GroupRoleList>] [domain <DomainName>] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show groups [roles <GroupRoleList>] [domain <DomainName>]
def printShowUserGroups(users):
  cd = buildGAPIObject(API.DIRECTORY)
  kwargs = {}
  csvPF = CSVPrintFile(['User', 'Group', 'Role', 'Status', 'Delivery'], 'sortall') if Act.csvFormat() else None
  rolesSet = set()
  allRoles = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'domain':
      kwargs['domain'] = getString(Cmd.OB_DOMAIN_NAME).lower()
    elif myarg in {'role', 'roles'}:
      for role in getString(Cmd.OB_GROUP_ROLE_LIST).lower().replace(',', ' ').split():
        if role in GROUP_ROLES_MAP:
          rolesSet.add(GROUP_ROLES_MAP[role])
        else:
          invalidChoiceExit(role, GROUP_ROLES_MAP, True)
    else:
      unknownArgumentExit()
  if not rolesSet:
    rolesSet = ALL_GROUP_ROLES
  else:
    allRoles = rolesSet - ALL_GROUP_ROLES
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    if csvPF:
      printGettingAllEntityItemsForWhom(Ent.GROUP, user, i, count)
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=user, orderBy='email', fields='nextPageToken,groups(email)', **kwargs)
    except (GAPI.invalidMember, GAPI.invalidInput):
      badRequestWarning(Ent.GROUP, Ent.MEMBER, user)
      continue
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get('domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs['domain'])
        return
      accessErrorExit(cd)
    jcount = len(entityList)
    if not csvPF:
      if allRoles:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.GROUP, i, count)
      else:
        entityPerformActionModifierNumItems([Ent.USER, user], Msg.MAXIMUM_OF, jcount, Ent.GROUP, i, count)
    Ind.Increment()
    j = 0
    for groupEntity in entityList:
      j += 1
      groupEmail = groupEntity['email']
      try:
        result = callGAPI(cd.members(), 'get',
                          throwReasons=GAPI.MEMBERS_THROW_REASONS+[GAPI.MEMBER_NOT_FOUND, GAPI.INVALID_MEMBER, GAPI.CONDITION_NOT_MET],
                          retryReasons=GAPI.MEMBERS_RETRY_REASONS,
                          groupKey=groupEmail, memberKey=user, fields='role,status,delivery_settings')
        role = result.get('role', Ent.MEMBER)
        status = result.get('status', 'UNKNOWN')
        delivery_settings = result.get('delivery_settings', '')
        if role in rolesSet:
          if not csvPF:
            printEntity([Ent.GROUP, groupEmail, Ent.ROLE, role, Ent.STATUS, status, Ent.DELIVERY, delivery_settings], j, jcount)
          else:
            csvPF.WriteRow({'User': user, 'Group': groupEmail, 'Role': role, 'Status': status, 'Delivery': delivery_settings})
      except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.invalid, GAPI.forbidden):
        entityUnknownWarning(Ent.GROUP, groupEmail, j, jcount)
      except (GAPI.memberNotFound, GAPI.invalidMember, GAPI.conditionNotMet) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.GROUP, groupEmail], str(e), j, jcount)
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('User Groups')

# gam <UserTypeEntity> print groupslist [domain <DomainName>] [todrive <ToDriveAttribute>*]
#	[delimiter <Character>] [quotechar <Character>]

def printUserGroupsList(users):
  cd = buildGAPIObject(API.DIRECTORY)
  kwargs = {}
  csvPF = CSVPrintFile(['User', 'Groups', 'GroupsList'])
  FJQC = FormatJSONQuoteChar(csvPF)
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'domain':
      kwargs['domain'] = getString(Cmd.OB_DOMAIN_NAME).lower()
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    else:
      FJQC.GetQuoteChar(myarg)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    printGettingAllEntityItemsForWhom(Ent.GROUP, user, i, count)
    try:
      entityList = callGAPIpages(cd.groups(), 'list', 'groups',
                                 throwReasons=GAPI.GROUP_LIST_USERKEY_THROW_REASONS,
                                 userKey=user, orderBy='email', fields='nextPageToken,groups(email)', **kwargs)
    except (GAPI.invalidMember, GAPI.invalidInput):
      badRequestWarning(Ent.GROUP, Ent.MEMBER, user)
      continue
    except (GAPI.resourceNotFound, GAPI.domainNotFound, GAPI.forbidden, GAPI.badRequest):
      if kwargs.get('domain'):
        badRequestWarning(Ent.GROUP, Ent.DOMAIN, kwargs['domain'])
        return
      accessErrorExit(cd)
    csvPF.WriteRow({'User': user, 'Groups': len(entityList), 'GroupsList': delimiter.join([group['email'] for group in entityList])})
  csvPF.writeCSVfile('User GroupsList')

# License command utilities
LICENSE_SKUID = 'skuId'
LICENSE_PRODUCTID = 'productId'
LICENSE_OLDSKUID = 'oldSkuId'

def getLicenseParameters(operation):
  lic = buildGAPIObject(API.LICENSING)
  parameters = {}
  parameters[LICENSE_PRODUCTID], parameters[LICENSE_SKUID] = getGoogleSKU()
  if checkArgumentPresent(['product', 'productid']):
    parameters[LICENSE_PRODUCTID] = getGoogleProduct()
  if operation == 'patch':
    checkArgumentPresent('from')
    _, parameters[LICENSE_OLDSKUID] = getGoogleSKU()
  checkForExtraneousArguments()
  return (lic, parameters)

# gam <UserTypeEntity> create|add license <SKUID>
def createLicense(users):
  lic, parameters = getLicenseParameters('insert')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), 'insert',
               throwReasons=[GAPI.DUPLICATE, GAPI.CONDITION_NOT_MET, GAPI.INVALID, GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], body={'userId': user}, fields='')
      entityActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except (GAPI.duplicate, GAPI.conditionNotMet, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> update license <SKUID> [from] <SKUID>
def updateLicense(users):
  lic, parameters = getLicenseParameters('patch')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), 'patch',
               bailOnInternalError=True,
               throwReasons=[GAPI.INTERNAL_ERROR, GAPI.NOT_FOUND, GAPI.CONDITION_NOT_MET, GAPI.INVALID,
                             GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_OLDSKUID], userId=user, body={'skuId': parameters[LICENSE_SKUID]}, fields='')
      entityModifierNewValueActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.skuIdToDisplayName(parameters[LICENSE_SKUID])],
                                            Act.MODIFIER_FROM, SKU.skuIdToDisplayName(parameters[LICENSE_OLDSKUID]), i, count)
    except (GAPI.internalError, GAPI.notFound, GAPI.conditionNotMet, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_OLDSKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete license <SKUID>
def deleteLicense(users):
  lic, parameters = getLicenseParameters('delete')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(lic.licenseAssignments(), 'delete',
               throwReasons=[GAPI.NOT_FOUND, GAPI.CONDITION_NOT_MET, GAPI.INVALID, GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.BACKEND_ERROR],
               productId=parameters[LICENSE_PRODUCTID], skuId=parameters[LICENSE_SKUID], userId=user)
      entityActionPerformed([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], i, count)
    except (GAPI.notFound, GAPI.conditionNotMet, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LICENSE, SKU.formatSKUIdDisplayName(parameters[LICENSE_SKUID])], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden, GAPI.backendError):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> update photo [<FileNamePattern>]
# gam <UserTypeEntity> update photo [drivedir|(sourcefolder <FilePath>)] [filename <FileNamePattern>]
#	#  #user# and #email" will be replaced with user email address #username# will be replaced by portion of email address in front of @
def updatePhoto(users):
  cd = buildGAPIObject(API.DIRECTORY)
  if Cmd.NumArgumentsRemaining() == 1 and not Cmd.PeekArgumentPresent(['drivedir', 'sourcefolder', 'filename']):
    sourceFolder = None
    filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
  else:
    sourceFolder = os.getcwd()
    filenamePattern = '#email#.jpg'
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg == 'drivedir':
        sourceFolder = GC.Values[GC.DRIVE_DIR]
      elif myarg == 'sourcefolder':
        sourceFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
        if not os.path.isdir(sourceFolder):
          entityDoesNotExistExit(Ent.DIRECTORY, sourceFolder)
      elif myarg == 'filename':
        filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
      else:
        unknownArgumentExit()
  p = re.compile('^(ht|f)tps?://.*$')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, userName, _ = splitEmailAddressOrUID(user)
    filename = _substituteForUser(filenamePattern, user, userName)
    if p.match(filename):
      try:
        status, image_data = getHttpObj().request(filename, 'GET')
        if status['status'] != '200':
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], Msg.NOT_ALLOWED, i, count)
          continue
        if status['content-location'] != filename:
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], Msg.NOT_FOUND, i, count)
          continue
      except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
        continue
    else:
      if sourceFolder is not None:
        filename = os.path.join(sourceFolder, filename)
      try:
        with open(os.path.expanduser(filename), 'rb') as f:
          image_data = f.read()
      except (OSError, IOError) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
        continue
    body = {'photoData': base64.urlsafe_b64encode(image_data).decode(UTF8)}
    try:
      callGAPI(cd.users().photos(), 'update',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.INVALID_INPUT],
               userKey=user, body=body, fields='')
      entityActionPerformed([Ent.USER, user, Ent.PHOTO, filename], i, count)
    except GAPI.invalidInput as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete photo
def deletePhoto(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.users().photos(), 'delete',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.PHOTO_NOT_FOUND],
               userKey=user)
      entityActionPerformed([Ent.USER, user, Ent.PHOTO, ''], i, count)
    except GAPI.photoNotFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, ''], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

def getPhoto(users, profileMode):
  cd = buildGAPIObject(API.DIRECTORY)
  if profileMode:
    people = buildGAPIObject(API.PEOPLE)
  targetFolder = os.getcwd()
  filenamePattern = '#email#.jpg'
  returnURLonly = False
  showPhotoData = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'drivedir':
      targetFolder = GC.Values[GC.DRIVE_DIR]
    elif myarg == 'targetfolder':
      targetFolder = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    elif myarg == 'filename':
      filenamePattern = getString(Cmd.OB_PHOTO_FILENAME_PATTERN)
    elif myarg == 'noshow':
      showPhotoData = False
    elif profileMode and myarg == 'returnurlonly':
      returnURLonly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    _, userName, _ = splitEmailAddressOrUID(user)
    filename = os.path.join(targetFolder, _substituteForUser(filenamePattern, user, userName))
    try:
      if not showPhotoData:
        entityPerformActionNumItems([Ent.USER, user], 1, Ent.PHOTO, i, count)
      if not profileMode:
        photo = callGAPI(cd.users().photos(), 'get',
                         throwReasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN, GAPI.PHOTO_NOT_FOUND],
                         userKey=user)
        if showPhotoData:
          writeStdout(photo['photoData']+'\n')
        photo_data = base64.urlsafe_b64decode(photo['photoData'])
      else:
        memberId = getUserPeopleId(cd, user, i, count)
        if not memberId:
          continue
        result = callGAPI(people.people(), 'get',
                          throwReasons=[GAPI.NOT_FOUND],
                          resourceName=f'people/{memberId}', personFields='photos')
        url = None
        for photo in result.get('photos', []):
          if photo['metadata']['source']['type'] == 'PROFILE':
            url = photo['url']
            break
        if not url:
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, None], Msg.PROFILE_PHOTO_NOT_FOUND, i, count)
          continue
        if returnURLonly:
          writeStdout(f'{url}\n')
          continue
        try:
          status, photo_data = getHttpObj().request(url, 'GET')
          if status['status'] != '200':
            entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], Msg.NOT_ALLOWED, i, count)
            continue
          if showPhotoData:
            writeStdout(base64.urlsafe_b64encode(photo_data).decode(UTF8)+'\n')
        except (httplib2.HttpLib2Error, google.auth.exceptions.TransportError, RuntimeError) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
          continue
      status, e = writeFileReturnError(filename, photo_data, mode='wb')
      if status:
        if not showPhotoData:
          entityActionPerformed([Ent.USER, user, Ent.PHOTO, filename], i, count)
      else:
        entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, filename], str(e), i, count)
    except (GAPI.notFound, GAPI.photoNotFound) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.PHOTO, None], str(e), i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> get photo [drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]]
#	[noshow]
def getUserPhoto(users):
  getPhoto(users, False)

# gam <UserTypeEntity> get profilephoto [drivedir|(targetfolder <FilePath>)] [filename <FileNamePattern>]
#	[noshow] [returnurlonly]
def getProfilePhoto(users):
  getPhoto(users, True)

PROFILE_SHARING_CHOICE_MAP = {
  'share': True,
  'shared': True,
  'unshare': False,
  'unshared': False,
  }

def _setShowProfile(users, function, **kwargs):
  cd = buildGAPIObject(API.DIRECTORY)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      result = callGAPI(cd.users(), function,
                        throwReasons=[GAPI.USER_NOT_FOUND, GAPI.FORBIDDEN],
                        userKey=user, fields='includeInGlobalAddressList', **kwargs)
      printEntity([Ent.USER, user, Ent.PROFILE_SHARING_ENABLED, result.get('includeInGlobalAddressList', 'Unknown')], i, count)
    except (GAPI.userNotFound, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> profile share|shared|unshare|unshared
def setProfile(users):
  body = {'includeInGlobalAddressList': getChoice(PROFILE_SHARING_CHOICE_MAP, mapChoice=True)}
  _setShowProfile(users, 'update', body=body)

# gam <UserTypeEntity> show profile
def showProfile(users):
  _setShowProfile(users, 'get')

# gam <UserTypeEntity> create sheet
#	((json [charset <Charset>] <SpreadsheetJSONCreateRequest>) |
#	 (json file <FileName> [charset <Charset>]))
#	[<DriveFileParentAttribute>]
#	[formatjson] [returnidonly]
def createSheet(users):
  parameters = initDriveFileAttributes()
  parentBody = {}
  changeParents = returnIdOnly = False
  addParents = ''
  removeParents = ROOT
  body = {}
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'json':
      body = getJSON([])
    elif getDriveFileParentAttribute(myarg, parameters):
      changeParents = True
    elif myarg == 'returnidonly':
      returnIdOnly = True
    else:
      FJQC.GetFormatJSON(myarg)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet = buildGAPIServiceObject(API.SHEETS, user, i, count)
    if not sheet:
      continue
    if changeParents:
      user, drive = buildGAPIServiceObject(API.DRIVE3, user, i, count)
      if not drive:
        continue
      if not _getDriveFileParentInfo(drive, user, i, count, parentBody, parameters):
        continue
      addParents = ','.join(parentBody['parents'])
    try:
      result = callGAPI(sheet.spreadsheets(), 'create',
                        throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                        body=body)
      spreadsheetId = result['spreadsheetId']
      if not returnIdOnly and not FJQC.formatJSON:
        entityActionPerformed([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], i, count)
      parentId = ROOT
      parentMsg = 'Success'
      if changeParents:
        try:
          callGAPI(drive.files(), 'update',
                   throwReasons=GAPI.DRIVE_ACCESS_THROW_REASONS+[GAPI.CANNOT_ADD_PARENT],
                   fileId=result['spreadsheetId'],
                   addParents=addParents, removeParents=removeParents, fields='', supportsAllDrives=True)
          parentId = addParents
        except (GAPI.fileNotFound, GAPI.forbidden, GAPI.permissionDenied,
                GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument,
                GAPI.cannotAddParent) as e:
          parentMsg = f'{ERROR_PREFIX}{addParents}: {str(e)}'
        except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
          parentMsg = f'{ERROR_PREFIX}{addParents}: {str(e)}'
      if returnIdOnly:
        writeStdout(f'{spreadsheetId}\n')
        continue
      if FJQC.formatJSON:
        printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "parentId": "{parentId}", '\
                    '"parentAssignment": "{parentMsg}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
        continue
      Ind.Increment()
      for field in ['spreadsheetId', 'spreadsheetUrl']:
        printKeyValueList([field, result[field]])
      printKeyValueList(['parentId', parentId])
      printKeyValueList(['parentAssignment', parentMsg])
      for field in ['properties', 'sheets', 'namedRanges', 'developerMetadata']:
        if field in result:
          showJSON(field, result[field])
      Ind.Decrement()
    except (GAPI.notFound, GAPI.forbidden, GAPI.internalError,
            GAPI.insufficientFilePermissions, GAPI.unknownError, GAPI.badRequest, GAPI.invalid) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, ''], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
      userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)

def _validateUserGetSpreadsheetIDs(user, i, count, fileIdEntity, showEntityType):
  user, _, jcount = _validateUserGetFileIDs(user, i, count, fileIdEntity, entityType=Ent.SPREADSHEET if showEntityType else None)
  if jcount == 0:
    return (user, None, 0)
  user, sheet = buildGAPIServiceObject(API.SHEETS, user, i, count)
  if not sheet:
    return (user, None, 0)
  return (user, sheet, jcount)

# gam <UserTypeEntity> update sheet
#	((json [charset <Charset>] <SpreadsheetJSONUpdateRequest>) |
#	 (json file <FileName> [charset <Charset>]))
#	[formatjson]
def updateSheets(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body = {}
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'json':
      body = getJSON([])
    else:
      FJQC.GetFormatJSON(myarg)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      try:
        result = callGAPI(sheet.spreadsheets(), 'batchUpdate',
                          throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, body=body)
        if FJQC.formatJSON:
          printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
          continue
        entityActionPerformed([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], j, jcount)
        Ind.Increment()
        for field in ['replies', 'updatedSpreadsheet']:
          if field in result:
            showJSON(field, result[field])
        Ind.Decrement()
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()

SPREADSHEET_FIELDS_CHOICE_MAP = {
  'developermetadata': 'developerMetadata',
  'namedranges': 'namedRanges',
  'properties': 'properties',
  'sheets': 'sheets',
  'spreadcheetid': 'spreadsheetId',
  'spreadcheeturl': 'spreadsheetUrl',
  }

# gam <UserTypeEntity> info|show sheet <DriveFileEntity>
#	[fields <SpreadsheetFieldList>]
#	(range <SpreadsheetRange>)* (rangelist <SpreadsheetRangeList>)*
#	[includegriddata [<Boolean>]]
#	[formatjson]
# gam <UserTypeEntity> print sheet <DriveFileEntity> [todrive <ToDriveAttribute>*]
#	[fields <SpreadsheetFieldList>]
#	(range <SpreadsheetRange>)* (rangelist <SpreadsheetRangeList>)*
#	[includegriddata [<Boolean>]]
#	[formatjson [quotechar <Character>]]
def infoPrintShowSheets(users):
  csvPF = CSVPrintFile(['User', 'spreadsheetId'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  spreadsheetIdEntity = getDriveFileEntity()
  fieldsList = []
  ranges = []
  includeGridData = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'range':
      ranges.append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg == 'rangelist':
      ranges.extend(convertEntityToList(getString(Cmd.OB_SPREADSHEET_RANGE_LIST), shlexSplit=True))
    elif myarg == 'includegriddata':
      includeGridData = getBoolean()
    elif getFieldsList(myarg, SPREADSHEET_FIELDS_CHOICE_MAP, fieldsList, initialField='spreadsheetId'):
      pass
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  fields = getFieldsFromFieldsList(fieldsList)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      try:
        result = callGAPI(sheet.spreadsheets(), 'get',
                          throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, ranges=ranges, includeGridData=includeGridData, fields=fields)
        if not includeGridData and 'sheets' in result:
          for usheet in result['sheets']:
            usheet.pop('data', None)
        if not csvPF:
          if FJQC.formatJSON:
            printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
            continue
          printEntity([Ent.SPREADSHEET, spreadsheetId], j, jcount)
          Ind.Increment()
          if 'spreadsheetUrl' in result:
            printKeyValueList(['spreadsheetUrl', result['spreadsheetUrl']])
          for field in ['properties', 'sheets', 'namedRanges', 'developerMetadata']:
            if field in result:
              showJSON(field, result[field])
          Ind.Decrement()
        else:
          row = flattenJSON(result, flattened={'User': user, 'spreadsheetId': spreadsheetId})
          if not FJQC.formatJSON:
            csvPF.WriteRowTitles(row)
          elif csvPF.CheckRowTitles(row):
            csvPF.WriteRowNoFilter({'User': user, 'spreadsheetId': spreadsheetId,
                                    'JSON': json.dumps(result, ensure_ascii=False, sort_keys=False)})
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Spreadsheet')

SHEET_VALUE_INPUT_OPTIONS_MAP = {
  'raw': 'RAW',
  'userentered': 'USER_ENTERED',
  }
SHEET_DIMENSIONS_MAP = {
  'rows': 'ROWS',
  'columns': 'COLUMNS',
  }
SHEET_VALUE_RENDER_OPTIONS_MAP = {
  'formula': 'FORMULA',
  'formattedvalue': 'FORMATTED_VALUE',
  'unformattedvalue': 'UNFORMATTED_VALUE',
  }
SHEET_DATETIME_RENDER_OPTIONS_MAP = {
  'serialnumber': 'SERIAL_NUMBER',
  'formattedstring': 'FORMATTED_STRING',
  }
SHEET_INSERT_DATA_OPTIONS_MAP = {
  'overwrite': 'OVERWRITE',
  'insertrows': 'INSERT_ROWS',
  }

def _getSpreadsheetRangesValues(append):
  spreadsheetRangesValues = []
  kwargs = {
    'valueInputOption': 'USER_ENTERED',
    'includeValuesInResponse': False,
    'responseValueRenderOption': 'FORMATTED_VALUE',
    'responseDateTimeRenderOption': 'FORMATTED_STRING',
    }
  if append:
    kwargs['insertDataOption'] = 'INSERT_ROWS'
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'json':
      if append and spreadsheetRangesValues:
        usageErrorExit(Msg.ONLY_ONE_JSON_RANGE_ALLOWED)
      spreadsheetRangeValue = getJSON([])
      if isinstance(spreadsheetRangeValue, dict) and 'valueRanges' in spreadsheetRangeValue:
        spreadsheetRangesValues.extend(spreadsheetRangeValue['valueRanges'])
      elif isinstance(spreadsheetRangeValue, list):
        spreadsheetRangesValues.extend(spreadsheetRangeValue)
      else:
        spreadsheetRangesValues.append(spreadsheetRangeValue)
      if append and len(spreadsheetRangesValues) > 1:
        Cmd.Backup()
        usageErrorExit(Msg.ONLY_ONE_JSON_RANGE_ALLOWED)
    elif myarg in SHEET_VALUE_INPUT_OPTIONS_MAP:
      kwargs['valueInputOption'] = SHEET_VALUE_INPUT_OPTIONS_MAP[myarg]
    elif myarg == 'includevaluesinresponse':
      kwargs['includeValuesInResponse'] = getBoolean()
    elif myarg in SHEET_VALUE_RENDER_OPTIONS_MAP:
      kwargs['responseValueRenderOption'] = SHEET_VALUE_RENDER_OPTIONS_MAP[myarg]
    elif myarg in SHEET_DATETIME_RENDER_OPTIONS_MAP:
      kwargs['responseDateTimeRenderOption'] = SHEET_DATETIME_RENDER_OPTIONS_MAP[myarg]
    elif append and myarg in SHEET_INSERT_DATA_OPTIONS_MAP:
      kwargs['insertDataOption'] = SHEET_INSERT_DATA_OPTIONS_MAP[myarg]
    else:
      FJQC.GetFormatJSON(myarg)
  return (kwargs, spreadsheetRangesValues, FJQC)

def _showValueRange(valueRange):
  Ind.Increment()
  printKeyValueList(['majorDimension', valueRange['majorDimension']])
  printKeyValueList(['range', valueRange['range']])
  printKeyValueList(['value', '{'+f'"values": {json.dumps(valueRange.get("values", []), ensure_ascii=False, sort_keys=False)}'+'}'])
  Ind.Decrement()

def _showUpdateValuesResponse(result, k, kcount):
  printKeyValueListWithCount(['updatedRange', result['updatedRange']], k, kcount)
  Ind.Increment()
  for field in ['updatedRows', 'updatedColumns', 'updatedCells']:
    printKeyValueList([field, result[field]])
  if 'updatedData' in result:
    printKeyValueList(['updatedData', ''])
    _showValueRange(result['updatedData'])
  Ind.Decrement()

# gam <UserTypeEntity> append sheetrange <DriveFileEntity>
#	((json [charset <Charset>] <SpreadsheetJSONRangeValues>|<SpreadsheetJSONRangeValuesList>) |
#	 (json file <FileName> [charset <Charset>]))
#	[overwrite|insertrows]
#	[raw|userentered] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[includevaluesinresponse [<Boolean>]] [formatjson]
def appendSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  kwargs, spreadsheetRangesValues, FJQC = _getSpreadsheetRangesValues(True)
  kcount = len(spreadsheetRangesValues)
  body = spreadsheetRangesValues[0] if kcount > 0 else {}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      k = 1
      try:
        result = callGAPI(sheet.spreadsheets().values(), 'append',
                          throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, range=body['range'], body=body, **kwargs)
        if FJQC.formatJSON:
          printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
          continue
        for field in ['tableRange']:
          printKeyValueList([field, result[field]])
        _showUpdateValuesResponse(result['updates'], k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> update sheetrange <DriveFileEntity>
#	((json [charset <Charset>] <SpreadsheetJSONRangeValues>|<SpreadsheetJSONRangeValuesList>)+
#	 (json file <FileName> [charset <Charset>]))+
#	[raw|userentered] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[includevaluesinresponse [<Boolean>]] [formatjson]
def updateSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body, spreadsheetRangesValues, FJQC = _getSpreadsheetRangesValues(False)
  body['data'] = spreadsheetRangesValues
  kcount = len(spreadsheetRangesValues)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      try:
        result = callGAPI(sheet.spreadsheets().values(), 'batchUpdate',
                          throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, body=body)
        if FJQC.formatJSON:
          printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
          continue
        for field in ['totalUpdatedRows', 'totalUpdatedColumns', 'totalUpdatedCells', 'totalUpdatedSheets']:
          printKeyValueList([field, result[field]])
        k = 0
        for response in result.get('responses', []):
          k += 1
          _showUpdateValuesResponse(response, k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> clear sheetrange <DriveFileEntity>
#	(range <SpreadsheetRange>)* (rangelist <SpreadsheetRangeList>)*
#	[formatjson]
def clearSheetRanges(users):
  spreadsheetIdEntity = getDriveFileEntity()
  body = {'ranges': []}
  FJQC = FormatJSONQuoteChar()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'range':
      body['ranges'].append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg == 'rangelist':
      body['ranges'].extend(convertEntityToList(getString(Cmd.OB_SPREADSHEET_RANGE_LIST), shlexSplit=True))
    else:
      FJQC.GetFormatJSON(myarg)
  kcount = len(body['ranges'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      if not FJQC.formatJSON:
        entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
      Ind.Increment()
      try:
        result = callGAPIitems(sheet.spreadsheets().values(), 'batchClear', 'clearedRanges',
                               throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                               spreadsheetId=spreadsheetId, body=body)
        if FJQC.formatJSON:
          printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps({"clearedRanges": result}, ensure_ascii=False, sort_keys=False)}'+'}')
          continue
        k = 0
        for clearedRange in result:
          k += 1
          printKeyValueListWithCount(['range', clearedRange], k, kcount)
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
      Ind.Decrement()
    Ind.Decrement()

# gam <UserTypeEntity> print sheetrange <DriveFileEntity> [todrive <ToDriveAttribute>*]
#	(range <SpreadsheetRange>)* (rangelist <SpreadsheetRangeList>)*
#	[rows|columns] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[formatjson [quotechar <Character>] [valuerangesonly [<Boolean>]]]
# gam <UserTypeEntity> show sheetrange <DriveFileEntity>
#	(range <SpreadsheetRange>)* (rangelist <SpreadsheetRangeList>)*
#	[rows|columns] [serialnumber|formattedstring] [formula|formattedvalue|unformattedvalue]
#	[formatjson [valuerangesonly [<Boolean>]]]
def printShowSheetRanges(users):
  csvPF = CSVPrintFile(['User', 'spreadsheetId'], 'sortall') if Act.csvFormat() else None
  FJQC = FormatJSONQuoteChar(csvPF)
  spreadsheetIdEntity = getDriveFileEntity()
  spreadsheetRanges = []
  kwargs = {
    'majorDimension': 'ROWS',
    'valueRenderOption': 'FORMATTED_VALUE',
    'dateTimeRenderOption': 'FORMATTED_STRING',
    }
  valueRangesOnly = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'range':
      spreadsheetRanges.append(getString(Cmd.OB_SPREADSHEET_RANGE))
    elif myarg == 'rangelist':
      spreadsheetRanges.extend(convertEntityToList(getString(Cmd.OB_SPREADSHEET_RANGE_LIST), shlexSplit=True))
    elif myarg == 'valuerangesonly':
      valueRangesOnly = getBoolean()
    elif myarg in SHEET_DIMENSIONS_MAP:
      kwargs['majorDimension'] = SHEET_DIMENSIONS_MAP[myarg]
    elif myarg in SHEET_VALUE_RENDER_OPTIONS_MAP:
      kwargs['valueRenderOption'] = SHEET_VALUE_RENDER_OPTIONS_MAP[myarg]
    elif myarg in SHEET_DATETIME_RENDER_OPTIONS_MAP:
      kwargs['dateTimeRenderOption'] = SHEET_DATETIME_RENDER_OPTIONS_MAP[myarg]
    else:
      FJQC.GetFormatJSONQuoteChar(myarg, True)
  if csvPF and FJQC.formatJSON and valueRangesOnly:
    csvPF.SetJSONTitles(['JSON'])
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, sheet, jcount = _validateUserGetSpreadsheetIDs(user, i, count, spreadsheetIdEntity, not csvPF and not FJQC.formatJSON)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for spreadsheetId in spreadsheetIdEntity['list']:
      j += 1
      try:
        result = callGAPI(sheet.spreadsheets().values(), 'batchGet',
                          throwReasons=GAPI.SHEETS_ACCESS_THROW_REASONS,
                          spreadsheetId=spreadsheetId, ranges=spreadsheetRanges, fields='valueRanges', **kwargs)
        valueRanges = result.get('valueRanges', [])
        kcount = len(valueRanges)
        if not csvPF:
          if FJQC.formatJSON:
            if not valueRangesOnly:
              printLine('{'+f'"User": "{user}", "spreadsheetId": "{spreadsheetId}", "JSON": {json.dumps(result, ensure_ascii=False, sort_keys=False)}'+'}')
            else:
              printLine(json.dumps(result.get('valueRanges', []), ensure_ascii=False, sort_keys=False))
            continue
          entityPerformActionNumItems([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], kcount, Ent.SPREADSHEET_RANGE, j, jcount)
          Ind.Increment()
          k = 0
          for valueRange in valueRanges:
            k += 1
            printKeyValueListWithCount(['range', valueRange['range']], k, kcount)
            _showValueRange(valueRange)
          Ind.Decrement()
        else:
          if kcount:
            row = flattenJSON(result, flattened={'User': user, 'spreadsheetId': spreadsheetId})
            if not FJQC.formatJSON:
              csvPF.WriteRowTitles(row)
            elif csvPF.CheckRowTitles(row):
              if not valueRangesOnly:
                csvPF.WriteRowNoFilter({'User': user, 'spreadsheetId': spreadsheetId,
                                        'JSON': json.dumps(result, ensure_ascii=False, sort_keys=False)})
              else:
                csvPF.WriteRowNoFilter({'JSON': json.dumps(result.get('valueRanges', []), ensure_ascii=False, sort_keys=False)})
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvPF.WriteRowNoFilter({'User': user})
      except (GAPI.notFound, GAPI.forbidden, GAPI.permissionDenied,
              GAPI.internalError, GAPI.insufficientFilePermissions, GAPI.badRequest, GAPI.invalid, GAPI.invalidArgument) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.SPREADSHEET, spreadsheetId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.authError, GAPI.domainPolicy) as e:
        userSvcNotApplicableOrDriveDisabled(user, str(e), i, count)
        break
    Ind.Decrement()
  if csvPF:
    csvPF.writeCSVfile('Spreadsheet')

# Token commands utilities
def commonClientIds(clientId):
  if clientId == 'gasmo':
    return '1095133494869.apps.googleusercontent.com'
  return clientId

# gam <UserTypeEntity> delete token|tokens|3lo|oauth clientid <ClientID>
def deleteTokens(users):
  cd = buildGAPIObject(API.DIRECTORY)
  checkArgumentPresent('clientid', required=True)
  clientId = commonClientIds(getString(Cmd.OB_CLIENT_ID))
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      callGAPI(cd.tokens(), 'get',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                             GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN,
                             GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               userKey=user, clientId=clientId, fields='')
      callGAPI(cd.tokens(), 'delete',
               throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                             GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN,
                             GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
               userKey=user, clientId=clientId)
      entityActionPerformed([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], i, count)
    except (GAPI.notFound, GAPI.resourceNotFound) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)

TOKENS_FIELDS_TITLES = ['clientId', 'displayText', 'anonymous', 'nativeApp', 'userKey', 'scopes']
TOKENS_ORDERBY_CHOICE_MAP = {
  'clientid': 'clientId',
  'displaytext': 'displayText',
  }

def _printShowTokens(entityType, users):
  def _showToken(token, j, jcount):
    printKeyValueListWithCount(['Client ID', token['clientId']], j, jcount)
    Ind.Increment()
    for item in sorted(token):
      if item not in {'clientId', 'scopes'}:
        printKeyValueList([item, token.get(item, '')])
    item = 'scopes'
    printKeyValueList([item, None])
    Ind.Increment()
    for it in sorted(token.get(item, [])):
      printKeyValueList([it])
    Ind.Decrement()
    Ind.Decrement()

  cd = buildGAPIObject(API.DIRECTORY)
  csvPF = CSVPrintFile(['user']+TOKENS_FIELDS_TITLES) if Act.csvFormat() else None
  clientId = None
  orderBy = 'clientId'
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'clientid':
      clientId = commonClientIds(getString(Cmd.OB_CLIENT_ID))
    elif myarg == 'orderby':
      orderBy = getChoice(TOKENS_ORDERBY_CHOICE_MAP, mapChoice=True)
    elif myarg == 'delimiter':
      delimiter = getCharacter()
    elif not entityType:
      Cmd.Backup()
      entityType, users = getEntityToModify(defaultEntityType=Cmd.ENTITY_USERS)
    else:
      unknownArgumentExit()
  if not entityType:
    users = getUsersToModify(Cmd.ENTITY_ALL_USERS_NS, None)
  fields = ','.join(TOKENS_FIELDS_TITLES)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      if csvPF:
        printGettingEntityItemForWhom(Ent.ACCESS_TOKEN, user, i, count)
      if clientId:
        results = [callGAPI(cd.tokens(), 'get',
                            throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                                          GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN,
                                          GAPI.NOT_FOUND, GAPI.RESOURCE_NOT_FOUND],
                            userKey=user, clientId=clientId, fields=fields)]
      else:
        results = callGAPIitems(cd.tokens(), 'list', 'items',
                                throwReasons=[GAPI.USER_NOT_FOUND, GAPI.DOMAIN_NOT_FOUND,
                                              GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
                                userKey=user, fields=f'items({fields})')
      jcount = len(results)
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.ACCESS_TOKEN, i, count)
        Ind.Increment()
        j = 0
        for token in sorted(results, key=lambda k: k[orderBy]):
          j += 1
          _showToken(token, j, jcount)
        Ind.Decrement()
      else:
        if results:
          for token in sorted(results, key=lambda k: k[orderBy]):
            row = {'user': user, 'scopes': delimiter.join(token.get('scopes', []))}
            for item in token:
              if item != 'scopes':
                row[item] = token.get(item, '')
            csvPF.WriteRow(row)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvPF.WriteRowNoFilter({'user': user})
    except (GAPI.notFound, GAPI.resourceNotFound) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), i, count)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden):
      entityUnknownWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('OAuth Tokens')

# gam <UserTypeEntity> print tokens|token [todrive <ToDriveAttribute>*] [clientid <ClientID>]
#	[orderby clientid|displaytext] [delimiter <Character>]
# gam <UserTypeEntity> show tokens|token|3lo|oauth [clientid <ClientID>]
#	[orderby clientid|displaytext]
def printShowTokens(users):
  _printShowTokens(Cmd.ENTITY_USERS, users)

# gam print tokens|token [todrive <ToDriveAttribute>*] [clientid <ClientID>]
#	[orderby clientid|displaytext] [delimiter <Character>]
#	[<UserTypeEntity>]
def doPrintTokens():
  _printShowTokens(None, None)

# gam <UserTypeEntity> deprovision|deprov [popimap] [signout] [turnoff2sv]
def deprovisionUser(users):
  cd = buildGAPIObject(API.DIRECTORY)
  disablePopImap = signout = turnoff2sv = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'popimap':
      disablePopImap = True
    elif myarg == 'signout':
      signout = True
    elif myarg == 'turnoff2sv':
      turnoff2sv = True
    else:
      unknownArgumentExit()
  if disablePopImap:
    imapBody = _imapDefaults(False)
    popBody = _popDefaults(False)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user = normalizeEmailAddressOrUID(user)
    try:
      printGettingEntityItemForWhom(Ent.APPLICATION_SPECIFIC_PASSWORD, user, i, count)
      asps = callGAPIitems(cd.asps(), 'list', 'items',
                           throwReasons=[GAPI.USER_NOT_FOUND],
                           userKey=user, fields='items(codeId)')
      codeIds = [asp['codeId'] for asp in asps]
      jcount = len(codeIds)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.APPLICATION_SPECIFIC_PASSWORD, i, count)
      if jcount > 0:
        Ind.Increment()
        j = 0
        for codeId in codeIds:
          j += 1
          try:
            callGAPI(cd.asps(), 'delete',
                     throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_PARAMETER, GAPI.FORBIDDEN],
                     userKey=user, codeId=codeId)
            entityActionPerformed([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], j, jcount)
          except (GAPI.invalid, GAPI.invalidParameter, GAPI.forbidden) as e:
            entityActionFailedWarning([Ent.USER, user, Ent.APPLICATION_SPECIFIC_PASSWORD, codeId], str(e), j, jcount)
        Ind.Decrement()
#
      printGettingEntityItemForWhom(Ent.BACKUP_VERIFICATION_CODES, user, i, count)
      try:
        codes = callGAPIitems(cd.verificationCodes(), 'list', 'items',
                              throwReasons=[GAPI.USER_NOT_FOUND],
                              userKey=user, fields='items(verificationCode)')
        jcount = len(codes)
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.BACKUP_VERIFICATION_CODES, i, count)
        if jcount > 0:
          callGAPI(cd.verificationCodes(), 'invalidate',
                   throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.INVALID_INPUT],
                   userKey=user)
          entityActionPerformed([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], i, count)
      except (GAPI.invalid, GAPI.invalidInput) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.BACKUP_VERIFICATION_CODES, None], str(e), i, count)
#
      printGettingEntityItemForWhom(Ent.ACCESS_TOKEN, user, i, count)
      tokens = callGAPIitems(cd.tokens(), 'list', 'items',
                             throwReasons=[GAPI.USER_NOT_FOUND],
                             userKey=user, fields='items(clientId)')
      jcount = len(tokens)
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.ACCESS_TOKEN, i, count)
      if jcount > 0:
        Ind.Increment()
        j = 0
        for token in tokens:
          j += 1
          clientId = token['clientId']
          try:
            callGAPI(cd.tokens(), 'delete',
                     throwReasons=[GAPI.USER_NOT_FOUND, GAPI.NOT_FOUND],
                     userKey=user, clientId=clientId)
            entityActionPerformed([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], j, jcount)
          except GAPI.notFound as e:
            entityActionFailedWarning([Ent.USER, user, Ent.ACCESS_TOKEN, clientId], str(e), j, jcount)
        Ind.Decrement()
#
      if turnoff2sv:
        Act.Set(Act.TURNOFF2SV)
        try:
          callGAPI(cd.twoStepVerification(), 'turnOff',
                   throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.DOMAIN_NOT_FOUND,
                                 GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
                   userKey=user)
          entityActionPerformed([Ent.USER, user], i, count)
        except GAPI.invalid as e:
          entityActionFailedWarning([Ent.USER, user], str(e), i, count)
#
      if signout:
        Act.Set(Act.SIGNOUT)
        callGAPI(cd.users(), 'signOut',
                 throwReasons=[GAPI.USER_NOT_FOUND, GAPI.INVALID, GAPI.DOMAIN_NOT_FOUND,
                               GAPI.DOMAIN_CANNOT_USE_APIS, GAPI.FORBIDDEN],
                 userKey=user)
        entityActionPerformed([Ent.USER, user], i, count)
#
      Act.Set(Act.DEPROVISION)
      if disablePopImap:
        _setImap(user, imapBody, i, count)
        _setPop(user, popBody, i, count)
#
      entityActionPerformed([Ent.USER, user], i, count)
    except GAPI.userNotFound:
      entityUnknownWarning(Ent.USER, user, i, count)
    except (GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam <UserTypeEntity> watch gmail [maxmessages <Integer>]
def watchGmail(users):
  maxMessages = 100
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'maxmessages':
      maxMessages = getInteger(minVal=1)
    else:
      unknownArgumentExit()
  project = f'projects/{_getCurrentProjectId()}'
  gamTopics = project+'/topics/gam-pubsub-gmail-'
  gamSubscriptions = project+'/subscriptions/gam-pubsub-gmail-'
  pubsub = buildGAPIObject(API.PUBSUB)
  topics = callGAPIpages(pubsub.projects().topics(), 'list', items='topics',
                         project=project)
  for atopic in topics:
    if atopic['name'].startswith(gamTopics):
      topic = atopic['name']
      break
  else:
    topic = gamTopics+str(uuid.uuid4())
    callGAPI(pubsub.projects().topics(), 'create',
             name=topic)
    body = {'policy': {'bindings': [{'members': ['serviceAccount:gmail-api-push@system.gserviceaccount.com'], 'role': 'roles/pubsub.editor'}]}}
    callGAPI(pubsub.projects().topics(), 'setIamPolicy',
             resource=topic, body=body)
  subscriptions = callGAPIpages(pubsub.projects().topics().subscriptions(), 'list', items='subscriptions',
                                topic=topic)
  for asubscription in subscriptions:
    if asubscription.startswith(gamSubscriptions):
      subscription = asubscription
      break
  else:
    subscription = gamSubscriptions+str(uuid.uuid4())
    callGAPI(pubsub.projects().subscriptions(), 'create',
             name=subscription, body={'topic': topic})
  gmails = {}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    gmails[user] = {'g': gmail}
    callGAPI(gmails[user]['g'].users(), 'watch',
             userId='me', body={'topicName': topic})
    gmails[user]['seen_historyId'] = callGAPI(gmails[user]['g'].users(), 'getProfile',
                                              userId='me', fields='historyId')['historyId']
  entityPerformActionNumItems([Ent.EVENT, u'gmail'], count, Ent.USER)
  while True:
    results = callGAPI(pubsub.projects().subscriptions(), 'pull',
                       subscription=subscription, body={'maxMessages': maxMessages})
    if 'receivedMessages' in results:
      ackIds = []
      update_history = []
      for message in results['receivedMessages']:
        if 'data' in message['message']:
          try:
            decoded_message = json.loads(base64.b64decode(message['message']['data']))
            if 'historyId' in decoded_message:
              update_history.append(decoded_message['emailAddress'])
          except (IndexError, KeyError, SyntaxError, TypeError, ValueError):
            pass
        if 'ackId' in message:
          ackIds.append(message['ackId'])
      if ackIds:
        callGAPI(pubsub.projects().subscriptions(), 'acknowledge',
                 subscription=subscription, body={'ackIds': ackIds})
      if update_history:
        for a_user in update_history:
          results = callGAPI(gmails[a_user]['g'].users().history(), 'list',
                             userId='me', startHistoryId=gmails[a_user]['seen_historyId'])
          if 'history' in results:
            for history in results['history']:
              if list(history) == ['messages', 'id']:
                continue
              if 'labelsAdded' in history:
                Act.Set(Act.ADD)
                for labelling in history['labelsAdded']:
                  entityActionPerformed([Ent.USER, a_user, Ent.MESSAGE, labelling['message']['id'],
                                         Ent.LABEL, ', '.join(labelling['labelIds'])])
              if 'labelsRemoved' in history:
                Act.Set(Act.REMOVE)
                for labelling in history['labelsRemoved']:
                  entityActionPerformed([Ent.USER, a_user, Ent.MESSAGE, labelling['message']['id'],
                                         Ent.LABEL, ', '.join(labelling['labelIds'])])
              if 'messagesAdded' in history:
                Act.Set(Act.CREATE)
                for adding in history['messagesAdded']:
                  entityActionPerformed([Ent.USER, a_user, Ent.MESSAGE, adding['message']['id'],
                                         Ent.LABEL, ', '.join(adding['message']['labelIds'])])
              if 'messagesDeleted' in history:
                Act.Set(Act.DELETE)
                for deleting in history['messagesDeleted']:
                  entityActionPerformed([Ent.USER, a_user, Ent.MESSAGE, deleting['message']['id']])
          gmails[a_user]['seen_historyId'] = results['historyId']

# gam <UserTypeEntity> print gmailprofile [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show gmailprofile
def printShowGmailProfile(users):
  csvPF = CSVPrintFile(['emailAddress'], 'sortall') if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if csvPF:
      printGettingEntityItemForWhom(Ent.GMAIL_PROFILE, user, i, count)
    try:
      results = callGAPI(gmail.users(), 'getProfile',
                         throwReasons=GAPI.GMAIL_THROW_REASONS,
                         userId='me')
      if not csvPF:
        kvList = []
        for item in ['historyId', 'messagesTotal', 'threadsTotal']:
          kvList += [item, results[item]]
        printEntityKVList([Ent.USER, user], kvList, i, count)
      else:
        csvPF.WriteRowTitles(results)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Gmail Profiles')

def _getUserGmailLabels(gmail, user, i, count, **kwargs):
  try:
    labels = callGAPI(gmail.users().labels(), 'list',
                      throwReasons=GAPI.GMAIL_THROW_REASONS,
                      userId='me', **kwargs)
    if not labels:
      labels = {'labels': []}
    return labels
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    return None

def _getLabelId(labels, labelName):
  for label in labels['labels']:
    if labelName in (label['id'], label['name']):
      return label['id']
  return None

def _getLabelName(labels, labelId):
  for label in labels['labels']:
    if label['id'] == labelId:
      return label['name']
  return labelId

LABEL_LABEL_LIST_VISIBILITY_CHOICE_MAP = {
  'hide': 'labelHide',
  'show': 'labelShow',
  'showifunread': 'labelShowIfUnread',
  }
LABEL_MESSAGE_LIST_VISIBILITY_CHOICES = ['hide', 'show']
LABEL_TYPE_SYSTEM = 'system'
LABEL_TYPE_USER = 'user'

def getLabelAttributes(myarg, body):
  if myarg == 'labellistvisibility':
    body['labelListVisibility'] = getChoice(LABEL_LABEL_LIST_VISIBILITY_CHOICE_MAP, mapChoice=True)
  elif myarg == 'messagelistvisibility':
    body['messageListVisibility'] = getChoice(LABEL_MESSAGE_LIST_VISIBILITY_CHOICES)
  elif myarg == 'backgroundcolor':
    body.setdefault('color', {})
    body['color']['backgroundColor'] = getLabelColor()
  elif myarg == 'textcolor':
    body.setdefault('color', {})
    body['color']['textColor'] = getLabelColor()
  else:
    unknownArgumentExit()

def checkLabelColor(body):
  if 'color' not in body:
    return
  if 'backgroundColor' in body['color']:
    if 'textColor' in body['color']:
      return
    missingArgumentExit('textcolor <LabelColorHex>')
  missingArgumentExit('backgroundcolor <LabelColorHex>')

# gam <UserTypeEntity> [create|add] label|labels <String> [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread] [buildpath [<Boolean>]]
#	[backgroundcolor <LabelColorHex>] [textcolor <LabelColorHex>]
def createLabel(users):
  label = getString(Cmd.OB_LABEL_NAME)
  body = {'name': label}
  buildPath = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'buildpath':
      buildPath = getBoolean()
      label = label.strip('/')
    else:
      getLabelAttributes(myarg, body)
  checkLabelColor(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if not buildPath:
      entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
      Ind.Increment()
      try:
        callGAPI(gmail.users().labels(), 'create',
                 throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.DUPLICATE],
                 userId='me', body=body, fields='')
        entityActionPerformed([Ent.USER, user, Ent.LABEL, label], i, count)
      except GAPI.duplicate:
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.DUPLICATE, i, count)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
      Ind.Decrement()
    else:
      labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
      if not labels:
        continue
      labelParts = label.split('/')
      invalid = False
      for j, labelPart in enumerate(labelParts):
        labelParts[j] = labelPart.strip()
        if not labelParts[j]:
          entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
          Ind.Increment()
          entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.INVALID, i, count)
          Ind.Decrement()
          invalid = True
          break
      if invalid:
        continue
      labelSet = {ulabel['name'] for ulabel in labels['labels'] if ulabel['type'] != LABEL_TYPE_SYSTEM}
      duplicate = True
      labelPath = ''
      j = 0
      for k, labelPart in enumerate(labelParts):
        if labelPath != '':
          labelPath += '/'
        labelPath += labelPart
        if labelPath not in labelSet:
          if duplicate:
            jcount = len(labelParts)-k
            entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
            Ind.Increment()
            duplicate = False
          j += 1
          body['name'] = labelPath
          try:
            callGAPI(gmail.users().labels(), 'create',
                     throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.DUPLICATE],
                     userId='me', body=body, fields='')
            entityActionPerformed([Ent.USER, user, Ent.LABEL, labelPath], j, jcount)
          except GAPI.duplicate:
            entityActionFailedWarning([Ent.USER, user, Ent.LABEL, labelPath], Msg.DUPLICATE, j, jcount)
            break
          except (GAPI.serviceNotAvailable, GAPI.badRequest):
            entityServiceNotApplicableWarning(Ent.USER, user, i, count)
            break
      if duplicate:
        entityPerformActionNumItems([Ent.USER, user], 1, Ent.LABEL, i, count)
        Ind.Increment()
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, labelPath], Msg.DUPLICATE, i, count)
      Ind.Decrement()

# gam <UserTypeEntity> update labelsettings <LabelName> [name <String>] [messagelistvisibility hide|show] [labellistvisibility hide|show|showifunread]
#	[backgroundcolor <LabelColorHex>] [textcolor <LabelColorHex>]
def updateLabelSettings(users):
  label_name = getString(Cmd.OB_LABEL_NAME)
  label_name_lower = label_name.lower()
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'name':
      body['name'] = getString(Cmd.OB_STRING)
    else:
      getLabelAttributes(myarg, body)
  checkLabelColor(body)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name)')
    if not labels:
      continue
    try:
      for label in labels['labels']:
        if label['name'].lower() == label_name_lower:
          callGAPI(gmail.users().labels(), 'patch',
                   throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT],
                   userId='me', id=label['id'], body=body, fields='')
          entityActionPerformed([Ent.USER, user, Ent.LABEL, label_name], i, count)
          break
      else:
        entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label_name], Msg.DOES_NOT_EXIST, i, count)
    except (GAPI.notFound, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label_name], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
#
def cleanLabelQuery(labelQuery):
  for ch in '/ (){}':
    labelQuery = labelQuery.replace(ch, '-')
  return labelQuery.lower()

# gam <UserTypeEntity> update label|labels [search <RegularExpression>] [replace <LabelReplacement>] [merge [keepoldlabel]]
#	search defaults to '^Inbox/(.*)$' which will find all labels in the Inbox
#	replace defaults to '%s'
def updateLabels(users):
  search = '^Inbox/(.*)$'
  pattern = re.compile(search, re.IGNORECASE)
  replace = '%s'
  keepOldLabel = merge = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'search':
      search = getString(Cmd.OB_RE_PATTERN)
      pattern = validateREPattern(search, re.IGNORECASE)
    elif myarg == 'replace':
      replaceLocation = Cmd.Location()
      replace = getString(Cmd.OB_LABEL_REPLACEMENT)
    elif myarg == 'merge':
      merge = True
    elif myarg == 'keepoldlabel':
      keepOldLabel = True
    else:
      unknownArgumentExit()
# Validate that number of substitions in replace matches the number of groups in pattern
  useRegexSub = replace.find('%s') == -1
  if useRegexSub:
    patternGroups = pattern.groups
    replSubs = REPLACE_GROUP_PATTERN.findall(replace)
    for replSub in replSubs:
      if int(replSub) > patternGroups:
        Cmd.SetLocation(replaceLocation)
        usageErrorExit(Msg.MISMATCH_RE_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, int(replSub), replace))
  else:
    if pattern.groups != replace.count('%s'):
      Cmd.SetLocation(replaceLocation)
      usageErrorExit(Msg.MISMATCH_SEARCH_REPLACE_SUBFIELDS.format(pattern.groups, search, replace.count('%s'), replace))
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
    if not labels:
      continue
    try:
      labelMatches = 0
      for label in sorted(labels['labels'], key=lambda k: k['name'], reverse=True):
        if label['type'] == LABEL_TYPE_SYSTEM:
          continue
        match_result = pattern.match(label['name'])
        if match_result is not None:
          labelMatches += 1
          newLabelName = pattern.sub(replace, label['name']) if useRegexSub else replace % match_result.groups()
          newLabelNameLower = newLabelName.lower()
          try:
            Act.Set(Act.RENAME)
            callGAPI(gmail.users().labels(), 'patch',
                     throwReasons=[GAPI.ABORTED, GAPI.DUPLICATE],
                     userId='me', id=label['id'], body={'name': newLabelName}, fields='')
            entityModifierNewValueActionPerformed([Ent.USER, user, Ent.LABEL, label['name']], Act.MODIFIER_TO, newLabelName, i, count)
          except (GAPI.aborted, GAPI.duplicate):
            if merge:
              Act.Set(Act.MERGE)
              entityPerformActionModifierNewValue([Ent.USER, user, Ent.LABEL, label['name']], Act.MODIFIER_WITH, newLabelName, i, count)
              messagesToRelabel = callGAPIpages(gmail.users().messages(), 'list', 'messages',
                                                userId='me', q=f'label:{cleanLabelQuery(label["name"])}')
              Act.Set(Act.RELABEL)
              jcount = len(messagesToRelabel)
              Ind.Increment()
              if jcount > 0:
                for new_label in labels['labels']:
                  if new_label['name'].lower() == newLabelNameLower:
                    body = {'addLabelIds': [new_label['id']]}
                    break
                j = 0
                for message in messagesToRelabel:
                  j += 1
                  callGAPI(gmail.users().messages(), 'modify',
                           userId='me', id=message['id'], body=body, fields='')
                  entityActionPerformed([Ent.USER, user, Ent.MESSAGE, message['id']], j, jcount)
              else:
                printEntityKVList([Ent.USER, user],
                                  [Msg.NO_MESSAGES_WITH_LABEL, label['name']],
                                  i, count)
              Ind.Decrement()
              if not keepOldLabel:
                callGAPI(gmail.users().labels(), 'delete',
                         userId='me', id=label['id'])
                Act.Set(Act.DELETE)
                entityActionPerformed([Ent.USER, user, Ent.LABEL, label['name']], i, count)
            else:
              entityActionNotPerformedWarning([Ent.USER, user, Ent.LABEL, newLabelName], Msg.ALREADY_EXISTS_USE_MERGE_ARGUMENT, i, count)
      if labels and (labelMatches == 0):
        printEntityKVList([Ent.USER, user],
                          [Msg.NO_LABELS_MATCH, search],
                          i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete label|labels <LabelName>|regex:<RegularExpression>
def deleteLabel(users):
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], Ent.LABEL, labelIdToNameMap[ri[RI_ITEM]]], formatHTTPError(http_status, reason, message), int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackDeleteLabel(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.USER, ri[RI_ENTITY], Ent.LABEL, labelIdToNameMap[ri[RI_ITEM]]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  label = getString(Cmd.OB_LABEL_NAME)
  if label[:6].lower() == 'regex:':
    labelPattern = validateREPattern(label[6:])
  else:
    labelPattern = None
  label_name_lower = label.lower()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      printGettingAllEntityItemsForWhom(Ent.LABEL, user, i, count)
      labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
      if not labels:
        continue
      del_labels = []
      if label == '--ALL_LABELS--':
        count = len(labels['labels'])
        for del_label in sorted(labels['labels'], key=lambda k: k['name'], reverse=True):
          if del_label['type'] != LABEL_TYPE_SYSTEM:
            del_labels.append(del_label)
      elif labelPattern:
        for del_label in sorted(labels['labels'], key=lambda k: k['name'], reverse=True):
          if del_label['type'] != LABEL_TYPE_SYSTEM and labelPattern.match(del_label['name']):
            del_labels.append(del_label)
      else:
        for del_label in sorted(labels['labels'], key=lambda k: k['name'], reverse=True):
          if label_name_lower == del_label['name'].lower():
            del_labels.append(del_label)
            break
        else:
          entityActionFailedWarning([Ent.USER, user, Ent.LABEL, label], Msg.DOES_NOT_EXIST, i, count)
          continue
      jcount = len(del_labels)
      labelIdToNameMap = {}
      entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
      Ind.Increment()
      svcargs = dict([('userId', 'me'), ('id', None), ('fields', '')]+GM.Globals[GM.EXTRA_ARGS_LIST])
      method = getattr(gmail.users().labels(), 'delete')
      dbatch = gmail.new_batch_http_request(callback=_callbackDeleteLabel)
      bcount = 0
      j = 0
      for del_me in del_labels:
        j += 1
        svcparms = svcargs.copy()
        svcparms['id'] = del_me['id']
        labelIdToNameMap[del_me['id']] = del_me['name']
        dbatch.add(method(**svcparms), request_id=batchRequestID(user, i, count, j, jcount, del_me['id']))
        bcount += 1
        if bcount == 10:
          executeBatch(dbatch)
          dbatch = gmail.new_batch_http_request(callback=_callbackDeleteLabel)
          bcount = 0
      if bcount > 0:
        dbatch.execute()
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

PRINT_LABELS_TITLES = ['User', 'type', 'name', 'id']
SHOW_LABELS_DISPLAY_CHOICES = ['allfields', 'basename', 'fullname']
LABEL_DISPLAY_FIELDS_LIST = ['type', 'id', 'labelListVisibility', 'messageListVisibility', 'color']
LABEL_COUNTS_FIELDS_LIST = ['messagesTotal', 'messagesUnread', 'threadsTotal', 'threadsUnread']
LABEL_COUNTS_FIELDS = ','.join(LABEL_COUNTS_FIELDS_LIST)

# gam <UserTypeEntity> print labels|label [onlyuser|useronly [<Boolean>]] [showcounts [<Boolean>]] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show labels|label [onlyuser|useronly [<Boolean>]] [showcounts [<Boolean>]] [nested [<Boolean>]] [display allfields|basename|fullname]
def printShowLabels(users):
  def _buildLabelTree(labels):
    def _checkChildLabel(label):
      if label.find('/') != -1:
        (parent, base) = label.rsplit('/', 1)
        if parent in labelTree:
          if label in labelTree:
            labelTree[label]['info']['base'] = base
            labelTree[parent]['children'].append(labelTree.pop(label))
          _checkChildLabel(parent)

    labelTree = {}
    for label in labels['labels']:
      if not onlyUser or (label['type'] != LABEL_TYPE_SYSTEM):
        label['base'] = label['name']
        labelTree[label['name']] = {'info': label, 'children': []}
    labelList = sorted(list(labelTree), reverse=True)
    for label in labelList:
      _checkChildLabel(label)
    return labelTree

  def _printLabel(label):
    if not displayAllFields:
      if not showCounts:
        printKeyValueList([label[nameField]])
      else:
        counts = callGAPI(gmail.users().labels(), 'get',
                          throwReasons=GAPI.GMAIL_THROW_REASONS,
                          userId='me', id=label['id'],
                          fields=LABEL_COUNTS_FIELDS)
        kvlist = [label[nameField], 'Counts']
        for a_key in LABEL_COUNTS_FIELDS_LIST:
          kvlist.extend([a_key, counts[a_key]])
        printKeyValueList(kvlist)
    else:
      printKeyValueList([label[nameField]])
      Ind.Increment()
      for a_key in LABEL_DISPLAY_FIELDS_LIST:
        if a_key in label:
          if a_key != 'color':
            printKeyValueList([a_key, label[a_key]])
          else:
            printKeyValueList(['backgroundColor', label[a_key]['backgroundColor']])
            printKeyValueList(['textColor', label[a_key]['textColor']])
      if showCounts:
        counts = callGAPI(gmail.users().labels(), 'get',
                          throwReasons=GAPI.GMAIL_THROW_REASONS,
                          userId='me', id=label['id'],
                          fields=LABEL_COUNTS_FIELDS)
        for a_key in LABEL_COUNTS_FIELDS_LIST:
          printKeyValueList([a_key, counts[a_key]])
      Ind.Decrement()

  def _printFlatLabel(label):
    _printLabel(label['info'])
    if label['children']:
      for child in sorted(label['children'], key=lambda k: k['info']['name']):
        _printFlatLabel(child)

  def _printNestedLabel(label):
    _printLabel(label['info'])
    if label['children']:
      Ind.Increment()
      if displayAllFields:
        printKeyValueList(['nested', len(label['children'])])
        Ind.Increment()
        for child in sorted(label['children'], key=lambda k: k['info']['name']):
          _printNestedLabel(child)
        Ind.Decrement()
      else:
        for child in sorted(label['children'], key=lambda k: k['info']['name']):
          _printNestedLabel(child)
      Ind.Decrement()

  csvPF = CSVPrintFile(PRINT_LABELS_TITLES, 'sortall') if Act.csvFormat() else None
  onlyUser = showCounts = showNested = False
  displayAllFields = True
  nameField = 'name'
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'onlyuser', 'useronly'}:
      onlyUser = getBoolean()
    elif myarg == 'showcounts':
      showCounts = getBoolean()
    elif not csvPF and myarg == 'nested':
      showNested = getBoolean()
    elif not csvPF and myarg == 'display':
      fields = getChoice(SHOW_LABELS_DISPLAY_CHOICES)
      nameField = 'name' if fields != 'basename' else 'base'
      displayAllFields = fields == 'allfields'
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if csvPF:
      printGettingEntityItemForWhom(Ent.LABEL, user, i, count)
    labels = _getUserGmailLabels(gmail, user, i, count)
    if not labels:
      continue
    try:
      jcount = len(labels['labels'])
      if (jcount > 0) and onlyUser:
        for label in labels['labels']:
          if label['type'] == LABEL_TYPE_SYSTEM:
            jcount -= 1
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if not csvPF:
        labelTree = _buildLabelTree(labels)
        Ind.Increment()
        if not showNested:
          for label, _ in sorted(iter(labelTree.items()), key=lambda k: (k[1]['info']['type'], k[1]['info']['name'])):
            _printFlatLabel(labelTree[label])
        else:
          for label, _ in sorted(iter(labelTree.items()), key=lambda k: (k[1]['info']['type'], k[1]['info']['name'])):
            _printNestedLabel(labelTree[label])
        Ind.Decrement()
      else:
        for label in sorted(labels['labels'], key=lambda k: (k['type'], k['name'])):
          if not onlyUser or label['type'] != LABEL_TYPE_SYSTEM:
            if showCounts:
              counts = callGAPI(gmail.users().labels(), 'get',
                                throwReasons=GAPI.GMAIL_THROW_REASONS,
                                userId='me', id=label['id'],
                                fields=LABEL_COUNTS_FIELDS)
              for a_key in LABEL_COUNTS_FIELDS_LIST:
                label[a_key] = counts[a_key]
            csvPF.WriteRowTitles(flattenJSON(label, flattened={'User': user}))
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Labels')

def _initLabelNameMap(userGmailLabels):
  baseLabelNameMap = {
    'INBOX': 'INBOX', 'SPAM': 'SPAM', 'TRASH': 'TRASH',
    'UNREAD': 'UNREAD', 'STARRED': 'STARRED', 'IMPORTANT': 'IMPORTANT',
    'SENT': 'SENT', 'DRAFT': 'DRAFT',
    'CATEGORY_PERSONAL': 'CATEGORY_PERSONAL',
    'CATEGORY_SOCIAL': 'CATEGORY_SOCIAL',
    'CATEGORY_PROMOTIONS': 'CATEGORY_PROMOTIONS',
    'CATEGORY_UPDATES': 'CATEGORY_UPDATES',
    'CATEGORY_FORUMS': 'CATEGORY_FORUMS',
    }

  labelNameMap = baseLabelNameMap.copy()
  for label in userGmailLabels['labels']:
    if label['type'] == 'system':
      labelNameMap[label['id']] = label['id']
    else:
      labelNameMap[label['name']] = label['id']
  return labelNameMap

def _convertLabelNamesToIds(gmail, bodyLabels, labelNameMap, addLabelIfMissing):
  labelIds = []
  for label in bodyLabels:
    if label.upper() in labelNameMap:
      label = label.upper()
    if label not in labelNameMap:
      results = callGAPI(gmail.users().labels(), 'create',
                         userId='me', body={'labelListVisibility': 'labelShow', 'messageListVisibility': 'show', 'name': label}, fields='id')
      labelNameMap[label] = results['id']
    try:
      labelIds.append(labelNameMap[label])
    except KeyError:
      pass
    if addLabelIfMissing:
      if label.find('/') != -1:
        # make sure to create parent labels for proper nesting
        parent_label = label[:label.rfind('/')]
        while True:
          if not parent_label in labelNameMap:
            result = callGAPI(gmail.users().labels(), 'create',
                              userId='me', body={'name': parent_label}, fields='id')
            labelNameMap[parent_label] = result['id']
          if parent_label.find('/') == -1:
            break
          parent_label = parent_label[:parent_label.rfind('/')]
  return labelIds

MESSAGES_MAX_TO_KEYWORDS = {
  Act.ARCHIVE: 'maxtoarchive',
  Act.DELETE: 'maxtodelete',
  Act.MODIFY: 'maxtomodify',
  Act.PRINT: 'maxtoprint',
  Act.SHOW: 'maxtoshow',
  Act.SPAM: 'maxtospam',
  Act.TRASH: 'maxtotrash',
  Act.UNTRASH: 'maxtountrash',
  }

def _initMessageThreadParameters(entityType, doIt, maxToProcess):
  listType = 'messages' if entityType == Ent.MESSAGE else 'threads'
  return {'currLabelOp': 'and', 'prevLabelOp': 'and', 'labelGroupOpen':  False, 'query': '',
          'entityType': entityType, 'messageEntity': None, 'doIt': doIt, 'quick': True,
          'maxToProcess': maxToProcess, 'maxItems': 0,
          'maxToKeywords': [MESSAGES_MAX_TO_KEYWORDS[Act.Get()], 'maxtoprocess'],
          'listType': listType, 'fields': f'nextPageToken,{listType}(id)'}

def _getMessageSelectParameters(myarg, parameters):
  if myarg == 'query':
    parameters['query'] += f' ({getString(Cmd.OB_QUERY)})'
  elif myarg == 'matchlabel':
    labelName = getString(Cmd.OB_LABEL_NAME).lower().replace(' ', '-').replace('/', '-')
    if not parameters['labelGroupOpen']:
      parameters['query'] += '('
      parameters['labelGroupOpen'] = True
    parameters['query'] += f' label:{labelName}'
  elif myarg in {'or', 'and'}:
    parameters['prevLabelOp'] = parameters['currLabelOp']
    parameters['currLabelOp'] = myarg
    if parameters['labelGroupOpen'] and parameters['currLabelOp'] != parameters['prevLabelOp']:
      parameters['query'] += ')'
      parameters['labelGroupOpen'] = False
    if parameters['currLabelOp'] == 'or':
      parameters['query'] += ' OR '
  elif myarg == 'ids':
    parameters['messageEntity'] = getUserObjectEntity(Cmd.OB_MESSAGE_ID, parameters['entityType'])
  elif myarg == 'quick':
    parameters['quick'] = True
  elif myarg == 'notquick':
    parameters['quick'] = False
  elif myarg == 'doit':
    parameters['doIt'] = True
  elif myarg in parameters['maxToKeywords']:
    parameters['maxToProcess'] = getInteger(minVal=0)
  else:
    return False
  return True

def _finalizeMessageSelectParameters(parameters, queryOrIdsRequired):
  if parameters['query']:
    if parameters['labelGroupOpen']:
      parameters['query'] += ')'
  elif queryOrIdsRequired and parameters['messageEntity'] is None:
    missingArgumentExit('query|matchlabel|ids')
  else:
    parameters['query'] = None
  parameters['maxItems'] = parameters['maxToProcess'] if parameters['quick'] else 0

# gam <UserTypeEntity> archive messages <GroupItem> (((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_archive <Number>])|(ids <MessageIDEntity>)
def archiveMessages(users):
  entityType = Ent.MESSAGE
  parameters = _initMessageThreadParameters(entityType, False, 0)
  group = getEmailAddress()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getMessageSelectParameters(myarg, parameters):
      pass
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, False)
  if not GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
    gm = buildGAPIObject(API.GROUPSMIGRATION)
    cd = buildGAPIObject(API.DIRECTORY)
    try:
      group = callGAPI(cd.groups(), 'get',
                       throwReasons=GAPI.GROUP_GET_THROW_REASONS,
                       groupKey=group, fields='email')['email']
    except (GAPI.groupNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest):
      entityDoesNotExistExit(Ent.GROUP, group)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters['messageEntity'])
    if not gmail:
      continue
    if GC.Values[GC.USER_SERVICE_ACCOUNT_ACCESS_ONLY]:
      _, gm = buildGAPIServiceObject(API.GROUPSMIGRATION, user, i, count)
      if not gm:
        continue
    service = gmail.users().messages()
    try:
      if parameters['messageEntity'] is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        listResult = callGAPIpages(service, 'list', parameters['listType'],
                                   pageMessage=getPageMessage(), maxItems=parameters['maxItems'],
                                   throwReasons=GAPI.GMAIL_THROW_REASONS,
                                   userId='me', q=parameters['query'], fields=parameters['fields'],
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message['id'] for message in listResult]
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if parameters['messageEntity'] is None:
        if parameters['maxToProcess'] and jcount > parameters['maxToProcess']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Act.ToPerform(), parameters['maxToProcess']), i, count)
          continue
        if not parameters['doIt']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
      Ind.Increment()
      j = 0
      for messageId in messageIds:
        j += 1
        try:
          message = callGAPI(service, 'get',
                             throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT],
                             userId='me', id=messageId, format='raw')
          stream = StringIOobject()
          stream.write(base64.urlsafe_b64decode(str(message['raw'])))
          try:
            callGAPI(gm.archive(), 'insert',
                     throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.BAD_REQUEST, GAPI.INVALID],
                     groupId=group, media_body=googleapiclient.http.MediaIoBaseUpload(stream, mimetype='message/rfc822', resumable=True))
            entityActionPerformed([Ent.USER, user, entityType, messageId], j, jcount)
          except GAPI.serviceNotAvailable:
            entityServiceNotApplicableWarning(Ent.USER, user, i, count)
            break
          except (GAPI.badRequest, GAPI.invalid) as e:
            entityActionFailedWarning([Ent.USER, user, entityType, messageId], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.badRequest):
          entityServiceNotApplicableWarning(Ent.USER, user, i, count)
          break
        except (GAPI.notFound, GAPI.invalidArgument) as e:
          entityActionFailedWarning([Ent.USER, user, entityType, messageId], str(e), j, jcount)
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _processMessagesThreads(users, entityType):
  def _batchDeleteModifyMessages(gmail, function, user, jcount, messageIds, body):
    mcount = 0
    bcount = min(jcount-mcount, GC.Values[GC.MESSAGE_BATCH_SIZE])
    while bcount > 0:
      body['ids'] = messageIds[mcount:mcount+bcount]
      try:
        callGAPI(gmail.users().messages(), function,
                 throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_MESSAGE_ID],
                 userId='me', body=body)
        for messageId in body['ids']:
          mcount += 1
          entityActionPerformed([Ent.USER, user, entityType, messageId], mcount, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        mcount += bcount
      except GAPI.invalidMessageId:
        entityActionFailedWarning([Ent.USER, user, entityType, Msg.BATCH], f'{Msg.INVALID_MESSAGE_ID} ({mcount+1}-{mcount+bcount}/{jcount})')
        mcount += bcount
      bcount = min(jcount-mcount, GC.Values[GC.MESSAGE_BATCH_SIZE])

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.INVALID_MESSAGE_ID: Msg.INVALID_MESSAGE_ID}
  def _handleProcessGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))

  def _callbackProcessMessage(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      entityActionPerformed([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleProcessGmailError(exception, ri)

  def _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs):
    svcargs = dict([('userId', 'me'), ('id', None), ('fields', '')]+list(kwargs.items())+GM.Globals[GM.EXTRA_ARGS_LIST])
    method = getattr(service, function)
    dbatch = gmail.new_batch_http_request(callback=_callbackProcessMessage)
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms['id'] = messageId
      dbatch.add(method(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms['id']))
      bcount += 1
      if bcount == GC.Values[GC.EMAIL_BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = gmail.new_batch_http_request(callback=_callbackProcessMessage)
        bcount = 0
    if bcount > 0:
      dbatch.execute()

  parameters = _initMessageThreadParameters(entityType, False, 1)
  includeSpamTrash = False
  function = {Act.DELETE: 'delete', Act.MODIFY: 'modify', Act.SPAM: 'spam', Act.TRASH: 'trash', Act.UNTRASH: 'untrash'}[Act.Get()]
  labelNameMap = {}
  addLabelNames = []
  addLabelIds = []
  removeLabelNames = []
  removeLabelIds = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if _getMessageSelectParameters(myarg, parameters):
      pass
    elif (function == 'modify') and (myarg == 'addlabel'):
      addLabelNames.append(getString(Cmd.OB_LABEL_NAME))
    elif (function == 'modify') and (myarg == 'removelabel'):
      removeLabelNames.append(getString(Cmd.OB_LABEL_NAME))
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, True)
  includeSpamTrash = Act.Get() in [Act.DELETE, Act.MODIFY, Act.UNTRASH]
  if function == 'spam':
    function = 'modify'
    addLabelIds = ['SPAM']
    removeLabelIds = ['INBOX']
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters['messageEntity'])
    if not gmail:
      continue
    service = gmail.users().messages() if entityType == Ent.MESSAGE else gmail.users().threads()
    try:
      if addLabelNames or removeLabelNames:
        userGmailLabels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
        if not userGmailLabels:
          continue
        labelNameMap = _initLabelNameMap(userGmailLabels)
        addLabelIds = _convertLabelNamesToIds(gmail, addLabelNames, labelNameMap, True)
        removeLabelIds = _convertLabelNamesToIds(gmail, removeLabelNames, labelNameMap, False)
      if parameters['messageEntity'] is None:
        printGettingAllEntityItemsForWhom(Ent.MESSAGE, user, i, count)
        listResult = callGAPIpages(service, 'list', parameters['listType'],
                                   pageMessage=getPageMessage(), maxItems=parameters['maxItems'],
                                   throwReasons=GAPI.GMAIL_THROW_REASONS,
                                   userId='me', q=parameters['query'], fields=parameters['fields'], includeSpamTrash=includeSpamTrash,
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message['id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), 'getProfile',
                 throwReasons=GAPI.GMAIL_THROW_REASONS,
                 userId='me', fields='')
      jcount = len(messageIds)
      if jcount == 0:
        entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        setSysExitRC(NO_ENTITIES_FOUND)
        continue
      if parameters['messageEntity'] is None:
        if parameters['maxToProcess'] and jcount > parameters['maxToProcess']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.COUNT_N_EXCEEDS_MAX_TO_PROCESS_M.format(jcount, Act.ToPerform(), parameters['maxToProcess']), i, count)
          continue
        if not parameters['doIt']:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.USE_DOIT_ARGUMENT_TO_PERFORM_ACTION, i, count)
          continue
      entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
      Ind.Increment()
      if function == 'delete' and entityType == Ent.MESSAGE:
        _batchDeleteModifyMessages(gmail, 'batchDelete', user, jcount, messageIds, {'ids': []})
      elif function == 'modify' and entityType == Ent.MESSAGE:
        _batchDeleteModifyMessages(gmail, 'batchModify', user, jcount, messageIds, {'ids': [], 'addLabelIds': addLabelIds, 'removeLabelIds': removeLabelIds})
      else:
        if addLabelIds or removeLabelIds:
          kwargs = {'body': {'addLabelIds': addLabelIds, 'removeLabelIds': removeLabelIds}}
        else:
          kwargs = {}
        _batchProcessMessagesThreads(service, function, user, jcount, messageIds, **kwargs)
      Ind.Decrement()
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> modify message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <MessageIDEntity>)
#	(addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> trash message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <MessageIDEntity>)
def processMessages(users):
  _processMessagesThreads(users, Ent.MESSAGE)

# gam <UserTypeEntity> delete thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_delete <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> modify thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_modify <Number>])|(ids <ThreadIDEntity>)
#	(addlabel <LabelName>)* (removelabel <LabelName>)*
# gam <UserTypeEntity> spam thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_spam <Number>])|(ids <ThreadIDEntity>)
# gam <UserTypeEntity> trash thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_trash <Number>])|(ids <MessageIDEntity>)
# gam <UserTypeEntity> untrash thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])+ [quick|notquick] [doit] [max_to_untrash <Number>])|(ids <ThreadIDEntity>)
def processThreads(users):
  _processMessagesThreads(users, Ent.THREAD)

SMTP_HEADERS_MAP = {
  'accept-language': 'Accept-Language',
  'alternate-recipient': 'Alternate-Recipient',
  'autoforwarded': 'Autoforwarded',
  'autosubmitted': 'Autosubmitted',
  'bcc': 'Bcc',
  'cc': 'Cc',
  'comments': 'Comments',
  'content-alternative': 'Content-Alternative',
  'content-base': 'Content-Base',
  'content-description': 'Content-Description',
  'content-disposition': 'Content-Disposition',
  'content-duration': 'Content-Duration',
  'content-id': 'Content-ID',
  'content-identifier': 'Content-Identifier',
  'content-language': 'Content-Language',
  'content-location': 'Content-Location',
  'content-md5': 'Content-MD5',
  'content-return': 'Content-Return',
  'content-transfer-encoding': 'Content-Transfer-Encoding',
  'content-type': 'Content-Type',
  'content-features': 'Content-features',
  'conversion': 'Conversion',
  'conversion-with-loss': 'Conversion-With-Loss',
  'dl-expansion-history': 'DL-Expansion-History',
  'date': 'Date',
  'deferred-delivery': 'Deferred-Delivery',
  'delivered-to': 'Delivered-To',
  'delivery-date': 'Delivery-Date',
  'discarded-x400-ipms-extensions': 'Discarded-X400-IPMS-Extensions',
  'discarded-x400-mts-extensions': 'Discarded-X400-MTS-Extensions',
  'disclose-recipients': 'Disclose-Recipients',
  'disposition-notification-options': 'Disposition-Notification-Options',
  'disposition-notification-to': 'Disposition-Notification-To',
  'encoding': 'Encoding',
  'encrypted': 'Encrypted',
  'expires': 'Expires',
  'expiry-date': 'Expiry-Date',
  'from': 'From',
  'generate-delivery-report': 'Generate-Delivery-Report',
  'importance': 'Importance',
  'in-reply-to': 'In-Reply-To',
  'incomplete-copy': 'Incomplete-Copy',
  'keywords': 'Keywords',
  'language': 'Language',
  'latest-delivery-time': 'Latest-Delivery-Time',
  'list-archive': 'List-Archive',
  'list-help': 'List-Help',
  'list-id': 'List-ID',
  'list-owner': 'List-Owner',
  'list-post': 'List-Post',
  'list-subscribe': 'List-Subscribe',
  'list-unsubscribe': 'List-Unsubscribe',
  'mime-version': 'MIME-Version',
  'message-context': 'Message-Context',
  'message-id': 'Message-ID',
  'message-type': 'Message-Type',
  'obsoletes': 'Obsoletes',
  'original-encoded-information-types': 'Original-Encoded-Information-Types',
  'original-message-id': 'Original-Message-ID',
  'originator-return-address': 'Originator-Return-Address',
  'pics-label': 'PICS-Label',
  'prevent-nondelivery-report': 'Prevent-NonDelivery-Report',
  'priority': 'Priority',
  'received': 'Received',
  'recipient': 'To',
  'references': 'References',
  'reply-by': 'Reply-By',
  'reply-to': 'Reply-To',
  'resent-bcc': 'Resent-Bcc',
  'resent-cc': 'Resent-Cc',
  'resent-date': 'Resent-Date',
  'resent-from': 'Resent-From',
  'resent-message-id': 'Resent-Message-ID',
  'resent-reply-to': 'Resent-Reply-To',
  'resent-sender': 'Resent-Sender',
  'resent-to': 'Resent-To',
  'return-path': 'Return-Path',
  'sender': 'Sender',
  'sensitivity': 'Sensitivity',
  'subject': 'Subject',
  'supersedes': 'Supersedes',
  'to': 'To',
  'x400-content-identifier': 'X400-Content-Identifier',
  'x400-content-return': 'X400-Content-Return',
  'x400-content-type': 'X400-Content-Type',
  'x400-mts-identifier': 'X400-MTS-Identifier',
  'x400-originator': 'X400-Originator',
  'x400-received': 'X400-Received',
  'x400-recipients': 'X400-Recipients',
  'x400-trace': 'X400-Trace',
  }

SMTP_ADDRESS_HEADERS = [
  'Bcc',
  'Cc',
  'Delivered-To',
  'From',
  'Reply-To',
  'Resent-Bcc',
  'Resent-Cc',
  'Resent-Reply-To',
  'Resent-Sender',
  'Resent-To',
  'Sender',
  'To',
  ]

SMTP_DATE_HEADERS = [
  'date',
  'delivery-date',
  'expires',
  'expiry-date',
  'latest-delivery-time',
  'reply-by',
  'resent-date',
  ]

SMTP_NAME_ADDRESS_PATTERN = re.compile(r'^(.+?)\s*<(.+)>$')

IMPORT_INSERT = {'import', 'insert'}

def _draftImportInsertMessage(users, operation):
  def _appendToHeader(header, value):
    try:
      header.append(value)
    except UnicodeDecodeError:
      header.append(value, UTF8)

  labelNameMap = {}
  addLabelNames = []
  msgHTML = msgText = ''
  msgHeaders = {}
  tagReplacements = _initTagReplacements()
  attachments = []
  internalDateSource = 'receivedTime'
  deleted = processForCalendar = substituteForUserInHeaders = False
  neverMarkSpam = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in SMTP_HEADERS_MAP:
      if myarg in SMTP_DATE_HEADERS:
        msgDate, _, _ = getTimeOrDeltaFromNow(True)
        msgHeaders[SMTP_HEADERS_MAP[myarg]] = formatdate(time.mktime(msgDate.timetuple()) + msgDate.microsecond/1E6, True)
        if myarg == 'date':
          internalDateSource = 'dateHeader'
      else:
        value = getString(Cmd.OB_STRING)
        if (value.find('#user#') >= 0) or (value.find('#email#') >= 0) or (value.find('#username#') >= 0):
          substituteForUserInHeaders = True
        msgHeaders[SMTP_HEADERS_MAP[myarg]] = value
    elif myarg == 'header':
      header = getString(Cmd.OB_STRING, minLen=1).lower()
      value = getString(Cmd.OB_STRING)
      if (value.find('#user#') >= 0) or (value.find('#email#') >= 0) or (value.find('#username#') >= 0):
        substituteForUserInHeaders = True
      msgHeaders[SMTP_HEADERS_MAP.get(header, header)] = value
    elif myarg in SORF_MSG_FILE_ARGUMENTS:
      if 'html' in myarg:
        msgHTML, _, _ = getStringOrFile(myarg)
      else:
        msgText, _, _ = getStringOrFile(myarg)
    elif myarg == 'replace':
      _getTagReplacement(tagReplacements, False)
    elif operation in IMPORT_INSERT and myarg == 'addlabel':
      addLabelNames.append(getString(Cmd.OB_LABEL_NAME, minLen=1))
    elif operation in IMPORT_INSERT and myarg == 'labels':
      addLabelNames.extend(shlexSplitList(getString(Cmd.OB_LABEL_NAME_LIST)))
    elif operation in IMPORT_INSERT and myarg == 'deleted':
      deleted = getBoolean()
    elif myarg == 'attach':
      attachments.append((getFilename(), getCharSet()))
    elif operation == 'import' and myarg == 'nevermarkspam':
      neverMarkSpam = getBoolean()
    elif operation == 'import' and myarg == 'checkspam':
      neverMarkSpam = not getBoolean()
    elif operation == 'import' and myarg == 'processforcalendar':
      processForCalendar = getBoolean()
    else:
      unknownArgumentExit()
  if not msgText and not msgHTML:
    missingArgumentExit('textmessage|textfile|htmlmessage|htmlfile')
  msgText = msgText.replace('\r', '').replace('\\n', '\n')
  msgHTML = msgHTML.replace('\r', '').replace('\\n', '<br/>')
  if not tagReplacements['tags']:
    tmpText = msgText
    tmpHTML = msgHTML
  if operation != 'draft':
    if 'To' not in msgHeaders:
      msgHeaders['To'] = '#user#'
      substituteForUserInHeaders = True
    if 'From' not in msgHeaders:
      msgHeaders['From'] = _getAdminEmail()
    kwargs = {'internalDateSource': internalDateSource, 'deleted': deleted}
    if operation == 'import':
      function = 'import_'
      kwargs.update({'neverMarkSpam': neverMarkSpam, 'processForCalendar': processForCalendar})
    else: #'insert':
      function = 'insert'
  else:
    function = 'create'
  add_charset(UTF8, QP, QP, UTF8)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    userName, _ = splitEmailAddress(user)
    if tagReplacements['tags']:
      if tagReplacements['subs']:
        _getTagReplacementFieldValues(user, i, count, tagReplacements)
      tmpText = _processTagReplacements(tagReplacements, msgText)
      tmpHTML = _processTagReplacements(tagReplacements, msgHTML)
    if attachments:
      if tmpText and tmpHTML:
        message = MIMEMultipart('alternative')
        textpart = MIMEText(tmpText, 'plain', UTF8)
        message.attach(textpart)
        htmlpart = MIMEText(tmpHTML, 'html', UTF8)
        message.attach(htmlpart)
      elif tmpHTML:
        message = MIMEMultipart()
        htmlpart = MIMEText(tmpHTML, 'html', UTF8)
        message.attach(htmlpart)
      else:
        message = MIMEMultipart()
        textpart = MIMEText(tmpText, 'plain', UTF8)
        message.attach(textpart)
      _addAttachmentsToMessage(message, attachments)
    else:
      if tmpText and tmpHTML:
        message = MIMEMultipart('alternative')
        textpart = MIMEText(tmpText, 'plain', UTF8)
        message.attach(textpart)
        htmlpart = MIMEText(tmpHTML, 'html', UTF8)
        message.attach(htmlpart)
      elif tmpHTML:
        message = MIMEText(tmpHTML, 'html', UTF8)
      else:
        message = MIMEText(tmpText, 'plain', UTF8)
    for header, value in iter(msgHeaders.items()):
      if substituteForUserInHeaders:
        value = _substituteForUser(value, user, userName)
      message[header] = Header()
      if header in SMTP_ADDRESS_HEADERS:
        match = SMTP_NAME_ADDRESS_PATTERN.match(value.strip())
        if match:
          _appendToHeader(message[header], match.group(1))
          _appendToHeader(message[header], match.group(2))
        else:
          _appendToHeader(message[header], value)
      else:
        _appendToHeader(message[header], value)
    tmpFile = TemporaryFile(mode='w+', encoding=UTF8)
    g = Generator(tmpFile, False)
    g.flatten(message)
    tmpFile.seek(0)
    body = {'raw': base64.urlsafe_b64encode(bytes(tmpFile.read(), UTF8)).decode()}
    tmpFile.close()
    try:
      if operation != 'draft':
        if addLabelNames:
          userGmailLabels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
          if not userGmailLabels:
            continue
          labelNameMap = _initLabelNameMap(userGmailLabels)
          body['labelIds'] = _convertLabelNamesToIds(gmail, addLabelNames, labelNameMap, True)
        else:
          body['labelIds'] = ['INBOX']
        result = callGAPI(gmail.users().messages(), function,
                          throwReasons=GAPI.GMAIL_THROW_REASONS,
                          userId='me', body=body, fields='id', **kwargs)
      else:
        result = callGAPI(gmail.users().drafts(), function,
                          throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_ARGUMENT],
                          userId='me', body={'message': body}, fields='id')
      entityActionPerformed([Ent.USER, user, Ent.MESSAGE, result['id']], i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    except GAPI.invalidArgument as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)

# gam <UserTypeEntity> draft message (<SMTPDateHeader> <Time>)* (<SMTPHeader> <String>)* (header <String> <String>)*
#	(textmessage|message <String>)|(textfile|file <FileName> [charset <CharSet>])|(gdoc <UserGoogleDoc>)
#	(htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])|(ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)* (attach <FileName> [charset <CharSet>])*
def draftMessage(users):
  _draftImportInsertMessage(users, u'draft')

# gam <UserTypeEntity> import message (<SMTPDateHeader> <Time>)* (<SMTPHeader> <String>)* (header <String> <String>)* (addlabel <LabelName>)*
#	(textmessage|message <String>)|(textfile|file <FileName> [charset <CharSet>])|(gdoc <UserGoogleDoc>)
#	(htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])|(ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)* (attach <FileName> [charset <CharSet>])*
#	[deleted [<Boolean>]] [nevermarkspam [<Boolean>]] [processforcalendar [<Boolean>]]
def importMessage(users):
  _draftImportInsertMessage(users, u'import')

# gam <UserTypeEntity> insert message (<SMTPDateHeader> <Time>)* (<SMTPHeader> <String>)* (header <String> <String>)* (addlabel <LabelName>)*
#	(textmessage|message <String>)|(textfile|file <FileName> [charset <CharSet>])|(gdoc <UserGoogleDoc>)
#	(htmlmessage <String>)|(htmlfile <FileName> [charset <CharSet>])|(ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)* (attach <FileName> [charset <CharSet>])*
#	[deleted [<Boolean>]]
def insertMessage(users):
  _draftImportInsertMessage(users, u'insert')

def printShowMessagesThreads(users, entityType):

  HEADER_ENCODE_PATTERN = re.compile(r'=\?([^?]*?)\?[qQbB]\?(.*?)\?=', re.VERBOSE | re.MULTILINE)

  def _decodeHeader(header):
    header = header.encode(UTF8, 'replace').decode(UTF8)
    while True:
      mg = HEADER_ENCODE_PATTERN.search(header)
      if not mg:
        return header
      try:
        header = header[:mg.start()]+decode_header(mg.group())[0][0].decode(mg.group(1))+header[mg.end():]
      except LookupError:
        stderrWarningMsg(Msg.INVALID_CHARSET.format(mg.group(1)))
        return header

  def _getBodyData(payload, getOrigMsg):
    data = headers = ''
    for part in payload.get('parts', []):
      if getOrigMsg:
        if show_all_headers:
          if not headers:
            headers = '---------- Original message ----------\n'
          for header in part['headers']:
            headers += header['name']+': '+_decodeHeader(header['value'])+'\n'
        else:
          for name in headersToShow:
            for header in part['headers']:
              if name == header['name'].lower():
                if not headers:
                  headers = '---------- Original message ----------\n'
                headers += SMTP_HEADERS_MAP.get(name, header['name'])+': '+_decodeHeader(header['value'])+'\n'
        if headers:
          headers += 'Body:\n'
          data = Ind.INDENT_SPACES_PER_LEVEL
      if part['mimeType'] == 'text/plain':
        if 'data' in part['body']:
          data += base64.urlsafe_b64decode(str(part['body']['data'])).decode(UTF8)+'\n'
      elif part['mimeType'] == 'text/rfc822-headers':
        if 'data' in part['body']:
          data += _decodeHeader(base64.urlsafe_b64decode(str(part['body']['data'])).decode(UTF8)+'\n')
      else:
        data += _getBodyData(part, part['mimeType'] == 'message/rfc822')
    if getOrigMsg:
      data = data.replace('\n', f'\n{Ind.INDENT_SPACES_PER_LEVEL}').rstrip()
    return headers+data

  def _getMessageBody(payload):
    if 'attachmentId' not in payload.get('body', {}) and 'data' in payload.get('body', {}):
      return base64.urlsafe_b64decode(str(payload['body']['data'])).decode(UTF8)
    data = _getBodyData(payload, False)
    if data:
      return data
    return 'Body not available'

  ATTACHMENT_NAME_PATTERN = re.compile(r'^.*name="(.*?)".*$')

  def _showSaveAttachments(messageId, payload, attachmentNamePattern):
    for part in payload.get('parts', []):
      if 'attachmentId' in part['body']:
        for header in part['headers']:
          if header['name'] in {'Content-Type', 'Content-Disposition'}:
            mg = ATTACHMENT_NAME_PATTERN.match(header['value'])
            if not mg:
              continue
            attachmentName = mg.group(1)
            if (not attachmentNamePattern) or attachmentNamePattern.match(attachmentName):
              if part['mimeType'] == 'text/plain' or save_attachments:
                try:
                  result = callGAPI(gmail.users().messages().attachments(), 'get',
                                    throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                                    messageId=messageId, id=part['body']['attachmentId'], userId='me')
                  if 'data' in result:
                    if show_attachments:
                      printKeyValueList(['Attachment', attachmentName])
                      Ind.Increment()
                      if part['mimeType'] == 'text/plain':
                        printKeyValueList([Ind.MultiLineText(base64.urlsafe_b64decode(str(result['data'])).decode(UTF8)+'\n')])
                      else:
                        printKeyValueList(['mimeType', part['mimeType']])
                      Ind.Decrement()
                    if save_attachments:
                      safe_file_title = attachmentName
                      filename = os.path.join(targetFolder, safe_file_title)
                      y = 0
                      while True:
                        if overwrite or not os.path.isfile(filename):
                          break
                        y += 1
                        filename = os.path.join(targetFolder, f'({y})-{safe_file_title}')
                      action = Act.Get()
                      Act.Set(Act.DOWNLOAD)
                      status, e = writeFileReturnError(filename, base64.urlsafe_b64decode(str(result['data'])), mode='wb')
                      if status:
                        entityActionPerformed([Ent.ATTACHMENT, filename])
                      else:
                        entityActionFailedWarning([Ent.ATTACHMENT, filename], str(e))
                      Act.Set(action)
                except (GAPI.serviceNotAvailable, GAPI.badRequest, GAPI.notFound):
                  pass
              elif show_attachments:
                printKeyValueList(['Attachment', attachmentName])
                Ind.Increment()
                printKeyValueList(['mimeType', part['mimeType']])
                Ind.Decrement()
            break
      else:
        _showSaveAttachments(messageId, part, attachmentNamePattern)

  def _getMessageLabels(result):
    messageLabels = []
    for labelId in result.get('labelIds', []):
      if labelId in labelsMap:
        if not onlyUser or labelsMap[labelId]['type'] != LABEL_TYPE_SYSTEM:
          messageLabels.append(labelsMap[labelId]['name'])
      else:
        messageLabels.append(labelId)
    return messageLabels

  def _showMessage(result, j, jcount):
    printEntity([Ent.MESSAGE, result['id']], j, jcount)
    Ind.Increment()
    if show_snippet:
      printKeyValueList(['Snippet', dehtml(result['snippet']).replace('\n', ' ')])
    if show_all_headers:
      for header in result['payload'].get('headers', []):
        printKeyValueList([header['name'], _decodeHeader(header['value'])])
    else:
      for name in headersToShow:
        for header in result['payload'].get('headers', []):
          if name == header['name'].lower():
            printKeyValueList([SMTP_HEADERS_MAP.get(name, header['name']), _decodeHeader(header['value'])])
    if show_size:
      printKeyValueList(['SizeEstimate', result['sizeEstimate']])
    if show_labels:
      printKeyValueList(['Labels', ','.join(_getMessageLabels(result))])
    if show_body:
      printKeyValueList(['Body', None])
      Ind.Increment()
      printKeyValueList([Ind.MultiLineText(_getMessageBody(result['payload']))])
      Ind.Decrement()
    if show_attachments or save_attachments:
      _showSaveAttachments(result['id'], result['payload'], attachmentNamePattern)
    Ind.Decrement()

  def _printMessage(user, result):
    row = {'User': user, 'threadId': result['threadId'], 'id': result['id']}
    if show_snippet:
      row['Snippet'] = dehtml(result['snippet']).replace('\n', ' ')
    if show_all_headers:
      headerCounts = {}
      for header in result['payload'].get('headers', []):
        headerCounts.setdefault(header['name'], 0)
        if headerCounts[header['name']] == 0:
          row[header['name']] = _decodeHeader(header['value'])
        else:
          row[f'{header["name"]} {headerCounts[header["name"]]}'] = _decodeHeader(header['value'])
        headerCounts[header['name']] += 1
    else:
      for name in headersToShow:
        j = 0
        for header in result['payload'].get('headers', []):
          if name == header['name'].lower():
            if j == 0:
              row[SMTP_HEADERS_MAP.get(name, header['name'])] = _decodeHeader(header['value'])
            else:
              row[f'{SMTP_HEADERS_MAP.get(name, header["name"])} {j}'] = _decodeHeader(header['value'])
            j += 1
    if show_size:
      row['SizeEstimate'] = result['sizeEstimate']
    if show_labels:
      row['Labels'] = delimiter.join(_getMessageLabels(result))
    if show_body:
      if not convertCRNL:
        row['Body'] = _getMessageBody(result['payload'])
      else:
        row['Body'] = escapeCRsNLs(_getMessageBody(result['payload']))
    csvPF.WriteRowTitles(row)

  def _countMessageLabels(result):
    labelIds = result.get('labelIds', [])
    if labelIds:
      for labelId in labelIds:
        if labelId in labelsMap:
          labelsMap[labelId]['count'] += 1
        else:
          labelsMap[labelId] = {'name': labelId, 'count': 1, 'type': LABEL_TYPE_USER}
    else:
      labelsMap['*None*']['count'] += 1

  def _showThread(result, j, jcount):
    printEntity([Ent.THREAD, result['id']], j, jcount)
    Ind.Increment()
    if show_snippet and 'snippet' in result:
      printKeyValueList(['Snippet', dehtml(result['snippet']).replace('\n', ' ')])
    kcount = len(result['messages'])
    k = 0
    for message in result['messages']:
      k += 1
      _showMessage(message, k, kcount)
    Ind.Decrement()

  def _printThread(user, result):
    for message in result['messages']:
      _printMessage(user, message)

  def _countThreadLabels(result):
    for message in result['messages']:
      _countMessageLabels(message)

  _GMAIL_ERROR_REASON_TO_MESSAGE_MAP = {GAPI.NOT_FOUND: Msg.DOES_NOT_EXIST, GAPI.INVALID_MESSAGE_ID: Msg.INVALID_MESSAGE_ID}

  def _handleGmailError(exception, ri):
    http_status, reason, message = checkGAPIError(exception)
    errMsg = getHTTPError(_GMAIL_ERROR_REASON_TO_MESSAGE_MAP, http_status, reason, message)
    if reason not in GAPI.DEFAULT_RETRY_REASONS:
      if not csvPF:
        printKeyValueListWithCount([Ent.Singular(entityType), ri[RI_ITEM], errMsg], int(ri[RI_J]), int(ri[RI_JCOUNT]))
        setSysExitRC(ACTION_FAILED_RC)
      else:
        entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], errMsg, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      return
    try:
      response = callGAPI(service, 'get',
                          throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_MESSAGE_ID],
                          userId='me', id=ri[RI_ITEM], format=['metadata', 'full'][show_body or show_attachments or save_attachments])
      if not csvPF:
        _callbacks['process'](response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
      else:
        _callbacks['process'](ri[RI_ENTITY], response)
    except GAPI.notFound:
      entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], Msg.DOES_NOT_EXIST, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    except GAPI.invalidMessageId:
      entityActionFailedWarning([Ent.USER, ri[RI_ENTITY], entityType, ri[RI_ITEM]], Msg.INVALID_MESSAGE_ID, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, ri[RI_ENTITY], int(ri[RI_I]), int(ri[RI_COUNT]))

  def _callbackShow(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _callbacks['process'](response, int(ri[RI_J]), int(ri[RI_JCOUNT]))
    else:
      _handleGmailError(exception, ri)

  def _callbackPrint(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _callbacks['process'](ri[RI_ENTITY], response)
    else:
      _handleGmailError(exception, ri)

  def _callbackCountLabels(request_id, response, exception):
    ri = request_id.splitlines()
    if exception is None:
      _callbacks['process'](response)
    else:
      _handleGmailError(exception, ri)

  def _batchPrintShowMessagesThreads(service, user, jcount, messageIds):
    svcargs = dict([('userId', 'me'), ('id', None), ('format', ['metadata', 'full'][show_body or show_attachments or save_attachments])]+GM.Globals[GM.EXTRA_ARGS_LIST])
    if countsOnly: #show_labels is True
      svcargs['fields'] = 'labelIds' if entityType == Ent.MESSAGE else 'messages(labelIds)'
    method = getattr(service, 'get')
    dbatch = gmail.new_batch_http_request(callback=_callbacks['batch'])
    bcount = 0
    j = 0
    for messageId in messageIds:
      j += 1
      svcparms = svcargs.copy()
      svcparms['id'] = messageId
      dbatch.add(method(**svcparms), request_id=batchRequestID(user, 0, 0, j, jcount, svcparms['id']))
      bcount += 1
      if parameters['maxToProcess'] and j == parameters['maxToProcess']:
        break
      if bcount == GC.Values[GC.EMAIL_BATCH_SIZE]:
        executeBatch(dbatch)
        dbatch = gmail.new_batch_http_request(callback=_callbacks['batch'])
        bcount = 0
    if bcount > 0:
      dbatch.execute()

  parameters = _initMessageThreadParameters(entityType, True, 0)
  convertCRNL = GC.Values[GC.CSV_OUTPUT_CONVERT_CR_NL]
  delimiter = GC.Values[GC.CSV_OUTPUT_FIELD_DELIMITER]
  countsOnly = positiveCountsOnly = includeSpamTrash = onlyUser = overwrite = save_attachments = False
  show_all_headers = show_attachments = show_body = show_labels = show_size = show_snippet = False
  attachmentNamePattern = None
  targetFolderPattern = GC.Values[GC.DRIVE_DIR]
  defaultHeaders = ['Date', 'Subject', 'From', 'Reply-To', 'To', 'Delivered-To', 'Content-Type', 'Message-ID']
  headersToShow = [header.lower() for header in defaultHeaders]
  csvPF = CSVPrintFile() if Act.csvFormat() else None
  showMode = Act.Get() == Act.SHOW
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif _getMessageSelectParameters(myarg, parameters):
      pass
    elif myarg == 'headers':
      headersToShow = getString(Cmd.OB_STRING, minLen=0).lower().replace(',', ' ').split()
      show_all_headers = headersToShow and headersToShow[0] == 'all'
    elif not showMode and myarg in {'convertcrnl', 'converttextnl', 'convertbodynl'}:
      convertCRNL = True
    elif not showMode and myarg == 'delimiter':
      delimiter = getCharacter()
    elif myarg == 'showbody':
      show_body = True
    elif myarg == 'showlabels':
      show_labels = True
    elif myarg == 'showsize':
      show_size = True
    elif myarg == 'showsnippet':
      show_snippet = True
    elif showMode and myarg == 'showattachments':
      show_attachments = True
    elif showMode and myarg == 'attachmentnamepattern':
      attachmentNamePattern = getREPattern(re.IGNORECASE)
    elif showMode and myarg == 'saveattachments':
      save_attachments = True
    elif showMode and myarg == 'targetfolder':
      targetFolderPattern = os.path.expanduser(getString(Cmd.OB_FILE_PATH))
    elif showMode and myarg == 'overwrite':
      overwrite = getBoolean()
    elif myarg == 'includespamtrash':
      includeSpamTrash = True
    elif myarg == 'countsonly':
      countsOnly = True
    elif myarg == 'positivecountsonly':
      countsOnly = positiveCountsOnly = True
    elif myarg in {'onlyuser', 'useronly'}:
      onlyUser = getBoolean()
    else:
      unknownArgumentExit()
  _finalizeMessageSelectParameters(parameters, False)
  if csvPF:
    if countsOnly:
      if show_labels:
        sortTitles = ['User']
        csvPF.SetIndexedTitles(['Labels'])
        _callbacks = {'batch': _callbackCountLabels, 'process': _countMessageLabels if entityType == Ent.MESSAGE else _countThreadLabels}
      else:
        sortTitles = ['User', parameters['listType']]
      csvPF.SetTitles(sortTitles)
    else:
      sortTitles = ['User', 'threadId', 'id']
      csvPF.SetTitles(sortTitles)
      sortTitles.extend(defaultHeaders)
      _callbacks = {'batch': _callbackPrint, 'process': _printMessage if entityType == Ent.MESSAGE else _printThread}
    csvPF.SetSortTitles(sortTitles)
  else:
    if countsOnly:
      if show_labels:
        _callbacks = {'batch': _callbackCountLabels, 'process': _countMessageLabels if entityType == Ent.MESSAGE else _countThreadLabels}
    else:
      _callbacks = {'batch': _callbackShow, 'process': _showMessage if entityType == Ent.MESSAGE else _showThread}
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, messageIds = _validateUserGetMessageIds(user, i, count, parameters['messageEntity'])
    if not gmail:
      continue
    service = gmail.users().messages() if entityType == Ent.MESSAGE else gmail.users().threads()
    if show_labels:
      labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name,type)')
      if not labels:
        continue
      labelsMap = {'*None*': {'name': '*None*', 'count': 0, 'type': LABEL_TYPE_USER}}
      for label in labels['labels']:
        labelsMap[label['id']] = {'name': label['name'], 'count': 0, 'type': label['type']}
    if save_attachments:
      _, userName, _ = splitEmailAddressOrUID(user)
      targetFolder = _substituteForUser(targetFolderPattern, user, userName)
      if not os.path.isdir(targetFolder):
        os.makedirs(targetFolder)
    try:
      if parameters['messageEntity'] is None:
        printGettingAllEntityItemsForWhom(entityType, user, i, count)
        listResult = callGAPIpages(service, 'list', parameters['listType'],
                                   pageMessage=getPageMessage(), maxItems=parameters['maxItems'],
                                   throwReasons=GAPI.GMAIL_THROW_REASONS,
                                   userId='me', q=parameters['query'], fields=parameters['fields'], includeSpamTrash=includeSpamTrash,
                                   maxResults=GC.Values[GC.MESSAGE_MAX_RESULTS])
        messageIds = [message['id'] for message in listResult]
      else:
        # Need to get authorization set up for batch
        callGAPI(gmail.users(), 'getProfile',
                 throwReasons=GAPI.GMAIL_THROW_REASONS,
                 userId='me', fields='')
      jcount = len(messageIds)
      if jcount == 0:
        setSysExitRC(NO_ENTITIES_FOUND)
      if countsOnly and not show_labels:
        if not csvPF:
          printEntityKVList([Ent.USER, user], [parameters['listType'], jcount], i, count)
        else:
          csvPF.WriteRow({'User': user, parameters['listType']: jcount})
        continue
      if jcount == 0:
        if not csvPF:
          entityNumEntitiesActionNotPerformedWarning([Ent.USER, user], entityType, jcount, Msg.NO_ENTITIES_MATCHED.format(Ent.Plural(entityType)), i, count)
        continue
      if not csvPF and not countsOnly: #show_labels is True
        if parameters['messageEntity'] is not None or parameters['maxToProcess'] == 0 or jcount <= parameters['maxToProcess']:
          entityPerformActionNumItems([Ent.USER, user], jcount, entityType, i, count)
        else:
          entityPerformActionNumItemsModifier([Ent.USER, user], parameters['maxToProcess'], entityType, f'of {jcount} Total {Ent.Plural(entityType)}', i, count)
      if parameters['messageEntity'] is None and parameters['maxToProcess'] and (jcount > parameters['maxToProcess']):
        jcount = parameters['maxToProcess']
      if not csvPF:
        Ind.Increment()
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds)
        Ind.Decrement()
      else:
        _batchPrintShowMessagesThreads(service, user, jcount, messageIds)
      if countsOnly: #show_labels is True
        if onlyUser or positiveCountsOnly:
          userLabelsMap = {}
          for labelId, label in iter(labelsMap.items()):
            if ((not onlyUser or label['type'] != LABEL_TYPE_SYSTEM) and
                (not positiveCountsOnly or label['count'] > 0)):
              userLabelsMap[labelId] = label
          labelsMap = userLabelsMap
        if not csvPF:
          jcount = len(labelsMap)
          entityPerformActionNumItems([Ent.USER, user], jcount, Ent.LABEL, i, count)
          Ind.Increment()
          j = 0
          for label in sorted(iter(labelsMap.values()), key=lambda k: k['name']):
            j += 1
            printEntityKVList([Ent.LABEL, label['name']], ['Count', label['count'], 'Type', label['type']], j, jcount)
          Ind.Decrement()
        else:
          csvPF.WriteRowTitles(flattenJSON({'Labels': sorted(iter(labelsMap.values()), key=lambda k: k['name'])}, flattened={'User': user}))
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    if not countsOnly:
      csvPF.RemoveTitles(['Snippet', 'SizeEstimate', 'Labels', 'Body'])
      if show_snippet:
        csvPF.AddTitle('Snippet')
      if show_size:
        csvPF.AddTitle('SizeEstimate')
      if show_labels:
        csvPF.AddTitle('Labels')
      if show_body:
        csvPF.AddTitle('Body')
    csvPF.writeCSVfile('Messages' if not (countsOnly and show_labels) else 'Message Label Counts')

# gam <UserTypeEntity> print message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_print <Number>] [includespamtrash])|(ids <MessageIDEntity>)
#	[headers all|<SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <Character>] [todrive <ToDriveAttribute>*]
#	[countsonly|positivecountsonly] [useronly]
# gam <UserTypeEntity> show message|messages
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <MessageIDEntity>)
#	[headers all|<SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [showattachments [attachmentnamepattern <RegularExpression>]]
#	[countsonly|positivecountsonly] [useronly]
#       [saveattachments [attachmentnamepattern <RegularExpression>]] [targetfolder <FilePath>] [overwrite [<Boolean>]]
def printShowMessages(users):
  printShowMessagesThreads(users, Ent.MESSAGE)

# gam <UserTypeEntity> print thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_print <Number>] [includespamtrash])|(ids <ThreadIDEntity>)
#	[headers all|<SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [convertcrnl] [delimiter <Character>] [todrive <ToDriveAttribute>*]
#	[countsonly|positivecountsonly] [useronly]
# gam <UserTypeEntity> show thread|threads
#	(((query <QueryGmail>) (matchlabel <LabelName>) [or|and])* [quick|notquick] [max_to_show <Number>] [includespamtrash])|(ids <ThreadIDEntity>)
#	[headers all|<SMTPHeaderList>] [showlabels] [showbody] [showsize] [showsnippet] [showattachments [attachmentnamepattern <RegularExpression>]]
#	[countsonly|positivecountsonly] [useronly]
#       [saveattachments [attachmentnamepattern <RegularExpression>]] [targetfolder <FilePath>] [overwrite [<Boolean>]]
def printShowThreads(users):
  printShowMessagesThreads(users, Ent.THREAD)

# gam <UserTypeEntity> delegate to <UserEntity>
def delegateTo(users, checkForTo=True):
  cd = buildGAPIObject(API.DIRECTORY)
  if checkForTo:
    checkArgumentPresent('to', required=True)
  delegateEntity = getUserObjectEntity(Cmd.OB_USER_ENTITY, Ent.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, delegates, jcount = _validateUserGetObjectList(user, i, count, delegateEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = convertUIDtoEmailAddress(delegate, cd=cd)
      try:
        callGAPI(gmail.users().settings().delegates(), 'create',
                 throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.ALREADY_EXISTS, GAPI.FAILED_PRECONDITION,
                                                        GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.PERMISSION_DENIED],
                 userId='me', body={'delegateEmail': delegateEmail})
        entityActionPerformed([Ent.USER, user, Ent.DELEGATE, delegateEmail], j, jcount)
      except (GAPI.alreadyExists, GAPI.failedPrecondition, GAPI.notFound, GAPI.invalidArgument, GAPI.permissionDenied) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DELEGATE, delegateEmail], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    Ind.Decrement()

# gam <UserTypeEntity> create|add delegate|delegates <UserEntity>
def createDelegate(users):
  delegateTo(users, checkForTo=False)

# gam <UserTypeEntity> delete delegate|delegates <UserEntity>
def deleteDelegate(users):
  cd = buildGAPIObject(API.DIRECTORY)
  delegateEntity = getUserObjectEntity(Cmd.OB_USER_ENTITY, Ent.DELEGATE)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, delegates, jcount = _validateUserGetObjectList(user, i, count, delegateEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      delegateEmail = convertUIDtoEmailAddress(delegate, cd=cd)
      try:
        callGAPI(gmail.users().settings().delegates(), 'delete',
                 throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.INVALID_INPUT, GAPI.PERMISSION_DENIED],
                 userId='me', delegateEmail=delegateEmail)
        entityActionPerformed([Ent.USER, user, Ent.DELEGATE, delegateEmail], j, jcount)
      except (GAPI.notFound, GAPI.invalidInput, GAPI.permissionDenied) as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DELEGATE, delegateEmail], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    Ind.Decrement()

# gam <UserTypeEntity> update delegate|delegates [<UserEntity>]
def updateDelegates(users):
  if Cmd.ArgumentsRemaining():
    cd = buildGAPIObject(API.DIRECTORY)
    delegateEntity = getUserObjectEntity(Cmd.OB_USER_ENTITY, Ent.DELEGATE)
    checkForExtraneousArguments()
  else:
    delegateEntity = None
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    if delegateEntity is None:
      user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
      if not gmail:
        continue
      try:
        result = callGAPI(gmail.users().settings().delegates(), 'list',
                          throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.PERMISSION_DENIED],
                          userId='me')
      except GAPI.permissionDenied as e:
        entityActionFailedWarning([Ent.USER, user, Ent.DELEGATE, None], str(e), i, count)
        continue
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        continue
      delegates = result.get('delegates', []) if result is not None else []
      jcount = len(delegates)
      entityPerformActionModifierNumItems([Ent.USER, user], Msg.MAXIMUM_OF, jcount, Ent.DELEGATE, i, count)
    else:
      user, gmail, delegates, jcount = _validateUserGetObjectList(user, i, count, delegateEntity)
      if jcount == 0:
        continue
    Ind.Increment()
    j = 0
    for delegate in delegates:
      j += 1
      if delegateEntity is not None or delegate['verificationStatus'] == 'accepted':
        delegateEmail = delegate['delegateEmail'] if delegateEntity is None else convertUIDtoEmailAddress(delegate, cd=cd)
        try:
          callGAPI(gmail.users().settings().delegates(), 'create',
                   throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.ALREADY_EXISTS, GAPI.FAILED_PRECONDITION,
                                                          GAPI.NOT_FOUND, GAPI.INVALID_ARGUMENT, GAPI.PERMISSION_DENIED],
                   userId='me', body={'delegateEmail': delegateEmail, 'verificationStatus': 'accepted'})
          entityActionPerformed([Ent.USER, user, Ent.DELEGATE, delegateEmail], j, jcount)
        except GAPI.alreadyExists:
          entityActionPerformed([Ent.USER, user, Ent.DELEGATE, delegateEmail], j, jcount)
        except (GAPI.failedPrecondition, GAPI.notFound, GAPI.invalidArgument, GAPI.permissionDenied) as e:
          entityActionFailedWarning([Ent.USER, user, Ent.DELEGATE, delegateEmail], str(e), j, jcount)
        except (GAPI.serviceNotAvailable, GAPI.badRequest):
          entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    Ind.Decrement()

# gam <UserTypeEntity> print delegates|delegate [todrive <ToDriveAttribute>*] [shownames]
# gam <UserTypeEntity> show delegates|delegate [shownames] [csv]
def printShowDelegates(users):
  def _getDelegateName(delegateEmail):
    if delegateEmail in delegateNames:
      return delegateNames[delegateEmail]
    try:
      result = callGAPI(cd.users(), 'get',
                        throwReasons=GAPI.USER_GET_THROW_REASONS,
                        userKey=delegateEmail, fields='name(fullName)')
      delegateName = result.get('name', {'fullName': delegateEmail}).get('fullName', delegateEmail)
    except (GAPI.userNotFound, GAPI.domainNotFound, GAPI.domainCannotUseApis, GAPI.forbidden, GAPI.badRequest, GAPI.backendError, GAPI.systemError):
      delegateName = delegateEmail
    delegateNames[delegateEmail] = delegateName
    return delegateName

  titlesList = ['User', 'delegateAddress', 'delegationStatus']
  csvPF = CSVPrintFile() if Act.csvFormat() else None
  cd = None
  csvStyle = False
  delegateNames = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif not csvPF and myarg == 'csv':
      csvStyle = True
    elif myarg == 'shownames':
      cd = buildGAPIObject(API.DIRECTORY)
      titlesList = ['User', 'delegateName', 'delegateAddress', 'delegationStatus']
    else:
      unknownArgumentExit()
  if csvPF:
    csvPF.AddTitles(titlesList)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if csvPF:
      printGettingAllEntityItemsForWhom(Ent.DELEGATE, user, i, count)
    try:
      result = callGAPI(gmail.users().settings().delegates(), 'list',
                        throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.PERMISSION_DENIED],
                        userId='me')
      delegates = result.get('delegates', []) if result is not None else []
      jcount = len(delegates)
      if not csvPF:
        if not csvStyle:
          entityPerformActionNumItems([Ent.USER, user], jcount, Ent.DELEGATE, i, count)
          Ind.Increment()
          j = 0
          for delegate in delegates:
            j += 1
            status = delegate['verificationStatus']
            delegateEmail = delegate['delegateEmail']
            if cd:
              printEntity([Ent.DELEGATE, _getDelegateName(delegateEmail)], j, jcount)
              Ind.Increment()
              printKeyValueList(['Status', status])
              printKeyValueList(['Delegate Email', delegateEmail])
              Ind.Decrement()
            else:
              printEntity([Ent.DELEGATE, delegateEmail], j, jcount)
              Ind.Increment()
              printKeyValueList(['Status', status])
              Ind.Decrement()
          Ind.Decrement()
        else:
          j = 0
          for delegate in delegates:
            j += 1
            status = delegate['verificationStatus']
            delegateEmail = delegate['delegateEmail']
            if cd:
              writeStdout(f'{user},{_getDelegateName(delegateEmail)},{status},{delegateEmail}\n')
            else:
              writeStdout(f'{user},{status},{delegateEmail}\n')
      else:
        if delegates:
          if cd:
            for delegate in delegates:
              csvPF.WriteRow({'User': user, 'delegateName': _getDelegateName(delegate['delegateEmail']),
                              'delegateAddress': delegate['delegateEmail'], 'delegationStatus': delegate['verificationStatus']})
          else:
            for delegate in delegates:
              csvPF.WriteRow({'User': user, 'delegateAddress': delegate['delegateEmail'],
                              'delegationStatus': delegate['verificationStatus']})
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvPF.WriteRowNoFilter({'User': user})
    except GAPI.permissionDenied as e:
      entityActionFailedWarning([Ent.USER, user, Ent.DELEGATE, None], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Delegates')

FILTER_ADD_LABEL_TO_ARGUMENT_MAP = {
  'IMPORTANT': 'important',
  'STARRED': 'star',
  'TRASH': 'trash',
  }

FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP = {
  'IMPORTANT': 'notimportant',
  'INBOX': 'archive',
  'SPAM': 'neverspam',
  'UNREAD': 'markread',
  }

def _printFilter(user, userFilter, labels):
  row = {'User': user, 'id': userFilter['id']}
  if 'criteria' in userFilter:
    for item in userFilter['criteria']:
      if item in {'hasAttachment', 'excludeChats'}:
        row[item] = item
      elif item == 'size':
        row[item] = f'size {userFilter["criteria"]["sizeComparison"]} {formatMaxMessageBytes(userFilter["criteria"][item], ONE_KILO_10_BYTES, ONE_MEGA_10_BYTES)}'
      elif item == 'sizeComparison':
        pass
      else:
        row[item] = f'{item} {userFilter["criteria"][item]}'
  else:
    row['error'] = 'NoCriteria'
  if 'action' in userFilter:
    for labelId in userFilter['action'].get('addLabelIds', []):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]
      else:
        row['label'] = f'label {_getLabelName(labels, labelId)}'
    for labelId in userFilter['action'].get('removeLabelIds', []):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        row[FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]] = FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]
    if userFilter['action'].get('forward'):
      row['forward'] = f'forward {userFilter["action"]["forward"]}'
  else:
    row['error'] = 'NoActions'
  return row

def _showFilter(userFilter, j, jcount, labels):
  printEntity([Ent.FILTER, userFilter['id']], j, jcount)
  Ind.Increment()
  printEntitiesCount(Ent.CRITERIA, None)
  Ind.Increment()
  if 'criteria' in userFilter:
    for item in sorted(userFilter['criteria']):
      if item in {'hasAttachment', 'excludeChats'}:
        printKeyValueList([item])
      elif item == 'size':
        printKeyValueList([f'{item} {userFilter["criteria"]["sizeComparison"]} {formatMaxMessageBytes(userFilter["criteria"][item], ONE_KILO_10_BYTES, ONE_MEGA_10_BYTES)}'])
      elif item == 'sizeComparison':
        pass
      else:
        printKeyValueList([f'{item} "{userFilter["criteria"][item]}"'])
  else:
    printKeyValueList([ERROR, Msg.NO_FILTER_CRITERIA.format(Ent.Singular(Ent.FILTER))])
  Ind.Decrement()
  printEntitiesCount(Ent.ACTION, None)
  Ind.Increment()
  if 'action' in userFilter:
    for labelId in sorted(userFilter['action'].get('addLabelIds', [])):
      if labelId in FILTER_ADD_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_ADD_LABEL_TO_ARGUMENT_MAP[labelId]])
      else:
        printKeyValueList([f'label "{_getLabelName(labels, labelId)}"'])
    for labelId in sorted(userFilter['action'].get('removeLabelIds', [])):
      if labelId in FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP:
        printKeyValueList([FILTER_REMOVE_LABEL_TO_ARGUMENT_MAP[labelId]])
    Ind.Decrement()
    if userFilter['action'].get('forward'):
      printEntity([Ent.FORWARDING_ADDRESS, userFilter['action']['forward']])
  else:
    printKeyValueList([ERROR, Msg.NO_FILTER_ACTIONS.format(Ent.Singular(Ent.FILTER))])
    Ind.Decrement()
  Ind.Decrement()
#
FILTER_CRITERIA_CHOICE_MAP = {
  'excludechats': 'excludeChats',
  'from': 'from',
  'hasattachment': 'hasAttachment',
  'haswords': 'query',
  'musthaveattachment': 'hasAttachment',
  'negatedquery': 'negatedQuery',
  'nowords': 'negatedQuery',
  'query': 'query',
  'size': 'size',
  'subject': 'subject',
  'to': 'to',
  }
FILTER_ADD_LABEL_ACTIONS = ['important', 'star', 'trash']
FILTER_REMOVE_LABEL_ACTIONS = ['markread', 'notimportant', 'archive', 'neverspam']
FILTER_ACTION_CHOICES = FILTER_ADD_LABEL_ACTIONS+FILTER_REMOVE_LABEL_ACTIONS+['forward', 'label']
FILTER_ACTION_LABEL_MAP = {
  'archive': 'INBOX',
  'important': 'IMPORTANT',
  'markread': 'UNREAD',
  'neverspam': 'SPAM',
  'notimportant': 'IMPORTANT',
  'star': 'STARRED',
  'trash': 'TRASH',
  }

# gam <UserTypeEntity> [create|add] filter <FilterCriteria>+ <FilterAction>+
def createFilter(users):
  body = {}
  addLabelName = None
  addLabelIds = []
  removeLabelIds = []
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in FILTER_CRITERIA_CHOICE_MAP:
      myarg = FILTER_CRITERIA_CHOICE_MAP[myarg]
      body.setdefault('criteria', {})
      if myarg in {'from', 'to', 'subject', 'query', 'negatedQuery'}:
        body['criteria'][myarg] = getString(Cmd.OB_STRING)
      elif myarg in {'hasAttachment', 'excludeChats'}:
        body['criteria'][myarg] = True
      elif myarg == 'size':
        body['criteria']['sizeComparison'] = getChoice(['larger', 'smaller'])
        body['criteria'][myarg] = getMaxMessageBytes(ONE_KILO_10_BYTES, ONE_MEGA_10_BYTES)
    elif myarg in FILTER_ACTION_CHOICES:
      body.setdefault('action', {})
      if myarg in FILTER_ADD_LABEL_ACTIONS:
        addLabelIds.append(myarg)
        if (myarg == 'important') and ('notimportant' in removeLabelIds):
          removeLabelIds.remove('notimportant')
      elif myarg in FILTER_REMOVE_LABEL_ACTIONS:
        removeLabelIds.append(myarg)
        if (myarg == 'notimportant') and ('important' in addLabelIds):
          addLabelIds.remove('important')
      elif myarg == 'forward':
        body['action']['forward'] = getEmailAddress(noUid=True)
      else: #elif myarg == 'label':
        addLabelName = getString(Cmd.OB_LABEL_NAME)
    else:
      unknownArgumentExit()
  if 'criteria' not in body:
    missingChoiceExit(FILTER_CRITERIA_CHOICE_MAP)
  if 'action' not in body:
    missingChoiceExit(FILTER_ACTION_CHOICES)
  if removeLabelIds:
    body['action']['removeLabelIds'] = [FILTER_ACTION_LABEL_MAP[action] for action in FILTER_REMOVE_LABEL_ACTIONS if action in removeLabelIds]
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name)')
    if not labels:
      continue
    try:
      if addLabelIds:
        body['action']['addLabelIds'] = [FILTER_ACTION_LABEL_MAP[action] for action in FILTER_ADD_LABEL_ACTIONS if action in addLabelIds]
      if addLabelName:
        if not addLabelIds:
          body['action']['addLabelIds'] = []
        addLabelId = _getLabelId(labels, addLabelName)
        if not addLabelId:
          result = callGAPI(gmail.users().labels(), 'create',
                            throwReasons=GAPI.GMAIL_THROW_REASONS,
                            userId='me', body={'name': addLabelName}, fields='id')
          addLabelId = result['id']
        body['action']['addLabelIds'].append(addLabelId)
      result = callGAPI(gmail.users().settings().filters(), 'create',
                        throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_ARGUMENT, GAPI.FAILED_PRECONDITION],
                        userId='me', body=body, fields='id')
      if result:
        entityActionPerformed([Ent.USER, user, Ent.FILTER, result['id']], i, count)
    except (GAPI.invalidArgument, GAPI.failedPrecondition) as e:
      entityActionFailedWarning([Ent.USER, user, Ent.FILTER, ''], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete filter <FilterIDEntity>
def deleteFilters(users):
  filterIdEntity = getUserObjectEntity(Cmd.OB_FILTER_ID_ENTITY, Ent.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        callGAPI(gmail.users().settings().filters(), 'delete',
                 throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                 userId='me', id=filterId)
        entityActionPerformed([Ent.USER, user, Ent.FILTER, filterId], j, jcount)
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.FILTER, filterId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> info filters <FilterIDEntity>
def infoFilters(users):
  filterIdEntity = getUserObjectEntity(Cmd.OB_FILTER_ID_ENTITY, Ent.FILTER)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, filterIds, jcount = _validateUserGetObjectList(user, i, count, filterIdEntity)
    if jcount == 0:
      continue
    labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name)')
    if not labels:
      continue
    Ind.Increment()
    j = 0
    for filterId in filterIds:
      j += 1
      try:
        result = callGAPI(gmail.users().settings().filters(), 'get',
                          throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND],
                          userId='me', id=filterId)
        printEntityKVList([Ent.USER, user],
                          [Ent.Singular(Ent.FILTER), result['id']],
                          i, count)
        Ind.Increment()
        _showFilter(result, j, jcount, labels)
        Ind.Decrement()
      except GAPI.notFound as e:
        entityActionFailedWarning([Ent.USER, user, Ent.FILTER, filterId], str(e), j, jcount)
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
        break
    Ind.Decrement()

# gam <UserTypeEntity> print filters [labelidsonly] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show filters [labelidsonly]
def printShowFilters(users):
  labelIdsOnly = False
  csvPF = CSVPrintFile(['User', 'id'], 'sortall') if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg == 'labelidsonly':
      labelIdsOnly = True
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if not labelIdsOnly:
      labels = _getUserGmailLabels(gmail, user, i, count, fields='labels(id,name)')
      if not labels:
        continue
    else:
      labels = {'labels': []}
    try:
      results = callGAPIitems(gmail.users().settings().filters(), 'list', 'filter',
                              throwReasons=GAPI.GMAIL_THROW_REASONS,
                              userId='me')
      jcount = len(results)
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.FILTER, i, count)
        Ind.Increment()
        j = 0
        for userFilter in results:
          j += 1
          _showFilter(userFilter, j, jcount, labels)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.FILTER, user, i, count)
        if results:
          for userFilter in results:
            csvPF.WriteRowTitles(_printFilter(user, userFilter, labels))
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvPF.WriteRowNoFilter({'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Filters')

EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP = {
  'ARCHIVE': 'archive',
  'DELETE': 'trash',
  'KEEP': 'leaveInInBox',
  'MARK_READ': 'markRead',
  }

def _showForward(user, i, count, result):
  if 'enabled' in result:
    enabled = result['enabled']
    kvList = [Ent.Singular(Ent.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Ent.Singular(Ent.FORWARDING_ADDRESS), result['emailAddress']]
      kvList += [Ent.Singular(Ent.ACTION), result['disposition']]
  else:
    enabled = result['enable'] == 'true'
    kvList = [Ent.Singular(Ent.FORWARD_ENABLED), enabled]
    if enabled:
      kvList += [Ent.Singular(Ent.FORWARDING_ADDRESS), result['forwardTo']]
      kvList += [Ent.Singular(Ent.ACTION), EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result['action']]]
  printEntityKVList([Ent.USER, user], kvList, i, count)

EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP = {
  'archive': 'archive',
  'delete': 'trash',
  'keep': 'leaveInInbox',
  'leaveininbox': 'leaveInInbox',
  'markread': 'markRead',
  'trash': 'trash',
  }

# gam <UserTypeEntity> forward <FalseValues>
# gam <UserTypeEntity> forward <TrueValues> keep|leaveininbox|archive|delete|trash|markread <EmailAddress>
def setForward(users):
  enable = getBoolean(None)
  body = {'enabled': enable}
  if enable:
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP:
        body['disposition'] = EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP[myarg]
      elif myarg == 'confirm':
        pass
      elif myarg.find('@') != -1 or (not Cmd.ArgumentsRemaining() and 'emailAddress' not in body):
        body['emailAddress'] = normalizeEmailAddressOrUID(Cmd.Previous())
      else:
        unknownArgumentExit()
    if not body.get('disposition'):
      missingChoiceExit(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP)
    if not body.get('emailAddress'):
      missingArgumentExit(Cmd.OB_EMAIL_ADDRESS)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'updateAutoForwarding',
                        throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.FAILED_PRECONDITION],
                        userId='me', body=body)
      _showForward(user, i, count, result)
    except GAPI.failedPrecondition as e:
      entityActionFailedWarning([Ent.USER, user, Ent.FORWARDING_ADDRESS, body['emailAddress']], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> print forward [enabledonly] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show forward
def printShowForward(users):
  def _printForward(user, result, showDisabled):
    if 'enabled' in result:
      enabled = result['enabled']
      if not enabled and not showDisabled:
        return
      row = {'User': user, 'forwardEnabled': enabled}
      if enabled:
        row['forwardTo'] = result['emailAddress']
        row['disposition'] = result['disposition']
    else:
      enabled = result['enable'] == 'true'
      if not enabled and not showDisabled:
        return
      row = {'User': user, 'forwardEnabled': enabled}
      if enabled:
        row['forwardTo'] = result['forwardTo']
        row['disposition'] = EMAILSETTINGS_OLD_NEW_OLD_FORWARD_ACTION_MAP[result['action']]
    csvPF.WriteRow(row)

  csvPF = CSVPrintFile(['User', 'forwardEnabled', 'forwardTo', 'disposition']) if Act.csvFormat() else None
  showDisabled = True
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif csvPF and myarg == 'enabledonly':
      showDisabled = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'getAutoForwarding',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me')
      if not csvPF:
        _showForward(user, i, count, result)
      else:
        printGettingEntityItemForWhom(Ent.FORWARD_ENABLED, user, i, count)
        _printForward(user, result, showDisabled)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Forward')

# Process ForwardingAddresses functions
def _showForwardingAddress(j, jcount, result):
  printEntityKVList([Ent.FORWARDING_ADDRESS, result['forwardingEmail']], ['Verification Status', result['verificationStatus']], j, jcount)

def _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().forwardingAddresses(), function,
                      throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS, GAPI.DUPLICATE, GAPI.INVALID_ARGUMENT],
                      userId='me', **kwargs)
    if function == 'get':
      _showForwardingAddress(j, count, result)
    else:
      entityActionPerformed([Ent.USER, user, Ent.FORWARDING_ADDRESS, emailAddress], j, jcount)
  except (GAPI.notFound, GAPI.alreadyExists, GAPI.duplicate, GAPI.invalidArgument) as e:
    entityActionFailedWarning([Ent.USER, user, Ent.FORWARDING_ADDRESS, emailAddress], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    userDefined = False
  return userDefined

# gam <UserTypeEntity> create|add forwardingaddresses <EmailAddressEntity>
def createForwardingAddresses(users):
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      body = {'forwardingEmail': emailAddress}
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, 'create', body=body, fields=''):
        break
    Ind.Decrement()

def _deleteInfoForwardingAddreses(users, function):
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.FORWARDING_ADDRESS)
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processForwardingAddress(user, i, count, emailAddress, j, jcount, gmail, function, forwardingEmail=emailAddress):
        break
    Ind.Decrement()

# gam <UserTypeEntity> delete forwardingaddresses <EmailAddressEntity>
def deleteForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, 'delete')

# gam <UserTypeEntity> info forwardingaddresses <EmailAddressEntity>
def infoForwardingAddresses(users):
  _deleteInfoForwardingAddreses(users, 'get')

# gam <UserTypeEntity> print forwardingaddresses [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show forwardingaddresses
def printShowForwardingAddresses(users):
  csvPF = CSVPrintFile(['User', 'forwardingEmail', 'verificationStatus']) if Act.csvFormat() else None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      results = callGAPIitems(gmail.users().settings().forwardingAddresses(), 'list', 'forwardingAddresses',
                              throwReasons=GAPI.GMAIL_THROW_REASONS,
                              userId='me')
      jcount = len(results)
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.FORWARDING_ADDRESS, i, count)
        Ind.Increment()
        j = 0
        for forward in results:
          j += 1
          _showForwardingAddress(j, jcount, forward)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.FORWARDING_ADDRESS, user, i, count)
        if results:
          for forward in results:
            csvPF.WriteRow({'User': user, 'forwardingEmail': forward['forwardingEmail'], 'verificationStatus': forward['verificationStatus']})
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvPF.WriteRowNoFilter({'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Forwarding Addresses')

def _showImap(user, i, count, result):
  enabled = result['enabled']
  kvList = [Ent.Singular(Ent.IMAP_ENABLED), enabled]
  if enabled:
    for item in result:
      if item != 'enabled':
        kvList += [item, result[item]]
  printEntityKVList([Ent.USER, user], kvList, i, count)
#
EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICE_MAP = {
  'archive': 'archive',
  'deleteforever': 'deleteForever',
  'trash': 'trash',
  }

EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES = ['0', '1000', '2000', '5000', '10000']

def _imapDefaults(enable):
  return {'enabled': enable, 'autoExpunge': True, 'expungeBehavior': 'archive', 'maxFolderSize': 0}

def _setImap(user, body, i, count):
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if gmail:
    try:
      result = callGAPI(gmail.users().settings(), 'updateImap',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me', body=body)
      _showImap(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> imap|imap4 <Boolean> [noautoexpunge] [expungebehavior archive|deleteforever|trash] [maxfoldersize 0|1000|2000|5000|10000]
def setImap(users):
  body = _imapDefaults(getBoolean(None))
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'noautoexpunge':
      body['autoExpunge'] = False
    elif myarg == 'expungebehavior':
      body['expungeBehavior'] = getChoice(EMAILSETTINGS_IMAP_EXPUNGE_BEHAVIOR_CHOICE_MAP, mapChoice=True)
    elif myarg == 'maxfoldersize':
      body['maxFolderSize'] = int(getChoice(EMAILSETTINGS_IMAP_MAX_FOLDER_SIZE_CHOICES))
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    _setImap(user, body, i, count)

# gam <UserTypeEntity> show imap|imap4
def showImap(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'getImap',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me')
      _showImap(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _showPop(user, i, count, result):
  enabled = result['accessWindow'] != 'disabled'
  kvList = [Ent.Singular(Ent.POP_ENABLED), enabled]
  if enabled:
    kvList += ['For', result['accessWindow'], Ent.Singular(Ent.ACTION), result['disposition']]
  printEntityKVList([Ent.USER, user], kvList, i, count)
#
EMAILSETTINGS_POP_ENABLE_FOR_CHOICE_MAP = {
  'allmail': 'allMail',
  'fromnowon': 'fromNowOn',
  'mailfromnowon': 'fromNowOn',
  'newmail': 'fromNowOn',
  }

def _popDefaults(enable):
  return {'accessWindow': ['disabled', 'allMail'][enable], 'disposition': 'leaveInInbox'}

def _setPop(user, body, i, count):
  user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
  if gmail:
    try:
      result = callGAPI(gmail.users().settings(), 'updatePop',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me', body=body)
      _showPop(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> pop|pop3 <Boolean> [for allmail|newmail|mailfromnowon|fromnowown] [action keep|leaveininbox|archive|delete|trash|markread]
def setPop(users):
  body = _popDefaults(getBoolean(None))
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'for':
      body['accessWindow'] = getChoice(EMAILSETTINGS_POP_ENABLE_FOR_CHOICE_MAP, mapChoice=True)
    elif myarg == 'action':
      body['disposition'] = getChoice(EMAILSETTINGS_FORWARD_POP_ACTION_CHOICE_MAP, mapChoice=True)
    elif myarg == 'confirm':
      pass
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    _setPop(user, body, i, count)

# gam <UserTypeEntity> show pop|pop3
def showPop(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'getPop',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me')
      _showPop(user, i, count, result)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> language <Language>
def setLanguage(users):
  language = getLanguageCode()
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'updateLanguage',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me', body={'displayLanguage': language})
      entityActionPerformed([Ent.USER, user, Ent.LANGUAGE, result['displayLanguage']], i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> show language
def showLanguage(users):
  checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'getLanguage',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me')
      printEntity([Ent.USER, user, Ent.LANGUAGE, result['displayLanguage']], i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

SIG_REPLY_HTML = 0
SIG_REPLY_COMPACT = 1
SIG_REPLY_FORMAT = 2
SIG_REPLY_OPTIONS_MAP = {'html': SIG_REPLY_HTML, 'compact': SIG_REPLY_COMPACT, 'format': SIG_REPLY_FORMAT}
SMTPMSA_DISPLAY_FIELDS = ['host', 'port', 'securityMode']

def _showSendAs(result, j, jcount, sigReplyFormat):
  if result['displayName']:
    printEntity([Ent.SENDAS_ADDRESS, f'{result["displayName"]} <{result["sendAsEmail"]}>'], j, jcount)
  else:
    printEntity([Ent.SENDAS_ADDRESS, f'<{result["sendAsEmail"]}>'], j, jcount)
  Ind.Increment()
  if result.get('replyToAddress'):
    printKeyValueList(['ReplyTo', result['replyToAddress']])
  printKeyValueList(['IsPrimary', result.get('isPrimary', False)])
  printKeyValueList(['Default', result.get('isDefault', False)])
  if not result.get('isPrimary', False):
    printKeyValueList(['TreatAsAlias', result.get('treatAsAlias', False)])
  if 'smtpMsa' in result:
    for field in SMTPMSA_DISPLAY_FIELDS:
      if field in result['smtpMsa']:
        printKeyValueList([f'smtpMsa.{field}', result['smtpMsa'][field]])
  if 'verificationStatus' in result:
    printKeyValueList(['Verification Status', result['verificationStatus']])
  signature = result.get('signature')
  if not signature:
    signature = 'None'
  if sigReplyFormat == SIG_REPLY_HTML:
    printKeyValueList(['Signature', None])
    Ind.Increment()
    printKeyValueList([Ind.MultiLineText(signature)])
    Ind.Decrement()
  elif sigReplyFormat == SIG_REPLY_FORMAT:
    printKeyValueList(['Signature', None])
    Ind.Increment()
    printKeyValueList([Ind.MultiLineText(dehtml(signature))])
    Ind.Decrement()
  else: # SIG_REPLY_COMPACT
    printKeyValueList(['Signature', escapeCRsNLs(signature)])
  Ind.Decrement()

def _processSignature(tagReplacements, signature, html):
  if signature:
    signature = signature.replace('\r', '').replace('\\n', '<br/>')
    if tagReplacements['tags']:
      signature = _processTagReplacements(tagReplacements, signature)
    if not html:
      signature = signature.replace('\n', '<br/>')
  return signature

# Process SendAs functions
def _processSendAs(user, i, count, entityType, emailAddress, j, jcount, gmail, function, sigReplyFormat, **kwargs):
  userDefined = True
  try:
    result = callGAPI(gmail.users().settings().sendAs(), function,
                      throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.NOT_FOUND, GAPI.ALREADY_EXISTS, GAPI.DUPLICATE,
                                                             GAPI.CANNOT_DELETE_PRIMARY_SENDAS, GAPI.INVALID_ARGUMENT,
                                                             GAPI.FAILED_PRECONDITION],
                      userId='me', **kwargs)
    if function == 'get':
      _showSendAs(result, j, jcount, sigReplyFormat)
    else:
      entityActionPerformed([Ent.USER, user, entityType, emailAddress], j, jcount)
  except (GAPI.notFound, GAPI.alreadyExists, GAPI.duplicate,
          GAPI.cannotDeletePrimarySendAs, GAPI.invalidArgument, GAPI.failedPrecondition) as e:
    entityActionFailedWarning([Ent.USER, user, entityType, emailAddress], str(e), j, jcount)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    userDefined = False
  return userDefined

def getSendAsAttributes(myarg, body, tagReplacements):
  if myarg == 'replace':
    _getTagReplacement(tagReplacements, True)
  elif myarg == 'name':
    body['displayName'] = getString(Cmd.OB_NAME, minLen=0)
  elif myarg == 'replyto':
    body['replyToAddress'] = getEmailAddress(noUid=True, minLen=0)
  elif myarg == 'default':
    body['isDefault'] = True
  elif myarg == 'treatasalias':
    body['treatAsAlias'] = getBoolean()
  else:
    unknownArgumentExit()

SMTPMSA_PORTS = ['25', '465', '587']
SMTPMSA_SECURITY_MODES = ['none', 'ssl', 'starttls']
SMTPMSA_REQUIRED_FIELDS = ['host', 'port', 'username', 'password']

# gam <UserTypeEntity> [create|add] sendas <EmailAddress> <String>
#	[signature|sig|htmlsig <String>|(file|htmlfile <FileName> [charset <CharSet>])|(gdoc|ghtml <UserGoogleDoc>)
#	    (replace <Tag> <String>)*]
#	[html [<Boolean>]] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
#	[smtpmsa.host <SMTPHostName> smtpmsa.port 25|465|587
#	 smtpmsa.username <UserName> smtpmsa.password <Password>
#	 [smtpmsa.securitymode none|ssl|starttls]]
# gam <UserTypeEntity> update sendas <EmailAddress> [name <String>]
#	[signature|sig|htmlsig <String>|(file|htmlfile <FileName> [charset <CharSet>])|(gdoc|ghtml <UserGoogleDoc>)
#	    (replace <Tag> <String>)*]
#	[html [<Boolean>]] [replyto <EmailAddress>] [default] [treatasalias <Boolean>]
def createUpdateSendAs(users):
  updateCmd = Act.Get() == Act.UPDATE
  emailAddress = getEmailAddress(noUid=True)
  if not updateCmd:
    body = {'sendAsEmail': emailAddress, 'displayName': getString(Cmd.OB_NAME)}
  else:
    body = {}
  signature = None
  smtpMsa = {}
  tagReplacements = _initTagReplacements()
  html = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg in SORF_SIG_FILE_ARGUMENTS:
      signature, _, html = getStringOrFile(myarg)
    elif myarg == 'html':
      html = getBoolean()
    elif not updateCmd and myarg.startswith('smtpmsa.'):
      if myarg == 'smtpmsa.host':
        smtpMsa['host'] = getString(Cmd.OB_SMTP_HOST_NAME)
      elif myarg == 'smtpmsa.port':
        smtpMsa['port'] = int(getChoice(SMTPMSA_PORTS))
      elif myarg == 'smtpmsa.username':
        smtpMsa['username'] = getString(Cmd.OB_USER_NAME)
      elif myarg == 'smtpmsa.password':
        smtpMsa['password'] = getString(Cmd.OB_PASSWORD)
      elif myarg == 'smtpmsa.securitymode':
        smtpMsa['securityMode'] = getChoice(SMTPMSA_SECURITY_MODES)
      else:
        unknownArgumentExit()
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  if signature is not None and not tagReplacements['subs']:
    body['signature'] = _processSignature(tagReplacements, signature, html)
  if smtpMsa:
    for field in SMTPMSA_REQUIRED_FIELDS:
      if field not in smtpMsa:
        missingArgumentExit(f'smtpmsa.{field}')
    body['smtpMsa'] = smtpMsa
  kwargs = {'body': body, 'fields': ''}
  if updateCmd:
    kwargs['sendAsEmail'] = emailAddress
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if signature is not None and tagReplacements['subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      kwargs['body']['signature'] = _processSignature(tagReplacements, signature, html)
    _processSendAs(user, i, count, Ent.SENDAS_ADDRESS, emailAddress, i, count, gmail, ['create', 'patch'][updateCmd], False, **kwargs)

# gam <UserTypeEntity> delete sendas <EmailAddressEntity>
# gam <UserTypeEntity> info sendas <EmailAddressEntity> [compact|format|html]
def deleteInfoSendAs(users):
  function = 'delete' if Act.Get() == Act.DELETE else 'get'
  emailAddressEntity = getUserObjectEntity(Cmd.OB_EMAIL_ADDRESS_ENTITY, Ent.SENDAS_ADDRESS)
  sigReplyFormat = SIG_REPLY_HTML
  if function == 'get':
    while Cmd.ArgumentsRemaining():
      myarg = getArgument()
      if myarg in SIG_REPLY_OPTIONS_MAP:
        sigReplyFormat = SIG_REPLY_OPTIONS_MAP[myarg]
      else:
        unknownArgumentExit()
  else:
    checkForExtraneousArguments()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail, emailAddresses, jcount = _validateUserGetObjectList(user, i, count, emailAddressEntity)
    if jcount == 0:
      continue
    Ind.Increment()
    j = 0
    for emailAddress in emailAddresses:
      j += 1
      emailAddress = normalizeEmailAddressOrUID(emailAddress, noUid=True)
      if not _processSendAs(user, i, count, Ent.SENDAS_ADDRESS, emailAddress, j, jcount, gmail, function, sigReplyFormat, sendAsEmail=emailAddress):
        break
    Ind.Decrement()

# gam <UserTypeEntity> print sendas [compact] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show sendas [compact|format|html]
def printShowSendAs(users):
  csvPF = CSVPrintFile(['User', 'displayName', 'sendAsEmail', 'replyToAddress',
                        'isPrimary', 'isDefault', 'treatAsAlias', 'verificationStatus'],
                       'sortall') if Act.csvFormat() else None
  sigReplyFormat = SIG_REPLY_HTML
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif (not csvPF and myarg in SIG_REPLY_OPTIONS_MAP) or (csvPF and myarg == 'compact'):
      sigReplyFormat = SIG_REPLY_OPTIONS_MAP[myarg]
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      results = callGAPIitems(gmail.users().settings().sendAs(), 'list', 'sendAs',
                              throwReasons=GAPI.GMAIL_THROW_REASONS,
                              userId='me')
      jcount = len(results)
      if not csvPF:
        entityPerformActionNumItems([Ent.USER, user], jcount, Ent.SENDAS_ADDRESS, i, count)
        Ind.Increment()
        j = 0
        for sendas in results:
          j += 1
          _showSendAs(sendas, j, jcount, sigReplyFormat)
        Ind.Decrement()
      else:
        printGettingEntityItemForWhom(Ent.SENDAS_ADDRESS, user, i, count)
        if results:
          for sendas in results:
            row = {'User': user, 'isPrimary': False}
            for item in sendas:
              if item != 'smtpMsa':
                if item != 'signature' or sigReplyFormat != SIG_REPLY_COMPACT:
                  row[item] = sendas[item]
                else:
                  row[item] = sendas[item].replace('\r', '').replace('\n', '')
              else:
                for field in SMTPMSA_DISPLAY_FIELDS:
                  if field in sendas[item]:
                    row[f'smtpMsa.{field}'] = sendas[item][field]
            csvPF.WriteRowTitles(row)
        elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
          csvPF.WriteRowNoFilter({'User': user})
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('SendAs')

# gam <UserTypeEntity> create|add smime file <FileName> [password <Password>]
#	[sendas|sendasemail <EmailAddress>] [default]
def createSmime(users):
  sendAsEmailBase = None
  setDefault = False
  body = {}
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'file':
      smimefile = getString(Cmd.OB_FILE_NAME)
      smimeData = readFile(smimefile, mode='rb')
      body['pkcs12'] = base64.urlsafe_b64encode(smimeData).decode(UTF8)
    elif myarg == 'password':
      body['encryptedKeyPassword'] = getString(Cmd.OB_PASSWORD)
    elif myarg == 'default':
      setDefault = True
    elif myarg in {'sendas', 'sendasemail'}:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  if 'pkcs12' not in body:
    missingArgumentExit('file')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    try:
      Act.Set(Act.CREATE)
      result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), 'insert',
                        throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                        userId='me', sendAsEmail=sendAsEmail, body=body, fields='id,issuerCn')
      entityModifierNewValueActionPerformed([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, result['id']],
                                            Act.MODIFIER_FROM, f'{Ent.Singular(Ent.ISSUER_CN)}: {result["issuerCn"]}', i, count)
      if setDefault:
        Act.Set(Act.UPDATE)
        smimeId = result['id']
        callGAPI(gmail.users().settings().sendAs().smimeInfo(), 'setDefault',
                 throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                 userId='me', sendAsEmail=sendAsEmail, id=smimeId)
        entityActionPerformedMessage([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, smimeId], Msg.DEFAULT_SMIME, i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

def _getSmimeIds(gmail, user, i, count, sendAsEmail, function):
  try:
    result = callGAPI(gmail.users().settings().sendAs().smimeInfo(), 'list',
                      throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                      userId='me', sendAsEmail=sendAsEmail, fields='smimeInfo(id)')
    smimes = result.get('smimeInfo', [])
    jcount = len(smimes)
    if jcount == 0:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, None],
                                      Msg.NO_ENTITIES_FOUND.format(Ent.Plural(Ent.SMIME_ID)), i, count)
      setSysExitRC(NO_ENTITIES_FOUND)
    elif jcount > 1:
      entityActionNotPerformedWarning([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, None],
                                      Msg.PLEASE_SELECT_ENTITY_TO_PROCESS.format(jcount, Ent.Plural(Ent.SMIME_ID), function, 'id <S/MIMEID>'),
                                      i, count)
      Ind.Increment()
      j = 0
      for smime in smimes:
        j += 1
        printEntityKVList([Ent.SMIME_ID, smime['id'], Ent.ISSUER_CN, smime['issuerCn']], ['Default', smime.get('isDefault', False)], j, jcount)
      Ind.Decrement()
    else:
      return smimes[0]['id']
  except GAPI.forbidden as e:
    entityActionFailedWarning([Ent.USER, user], str(e), i, count)
  except (GAPI.serviceNotAvailable, GAPI.badRequest):
    entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  return None

# gam <UserTypeEntity> update smime default
#	[id <SmimeID>] [sendas|sendasemail <EmailAddress>]
def updateSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  setDefault = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'id':
      smimeIdBase = getString(Cmd.OB_SMIME_ID)
    elif myarg in {'sendas', 'sendasemail'}:
      sendAsEmailBase = getEmailAddress(noUid=True)
    elif myarg == 'default':
      setDefault = True
    else:
      unknownArgumentExit()
  if not setDefault:
    missingArgumentExit('default')
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, 'update')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), 'setDefault',
               throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
               userId='me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformedMessage([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, smimeId], Msg.DEFAULT_SMIME, i, count)
    except GAPI.notFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.SMIME_ID, smimeId], str(e), i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> delete smime
#	[id <SmimeID>] [sendas|sendasemail <EmailAddress>]
def deleteSmime(users):
  smimeIdBase = None
  sendAsEmailBase = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'id':
      smimeIdBase = getString(Cmd.OB_SMIME_ID)
    elif myarg in {'sendas', 'sendasemail'}:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    sendAsEmail = sendAsEmailBase if sendAsEmailBase else user
    if not smimeIdBase:
      smimeId = _getSmimeIds(gmail, user, i, count, sendAsEmail, 'delete')
      if not smimeId:
        continue
    else:
      smimeId = smimeIdBase
    try:
      callGAPI(gmail.users().settings().sendAs().smimeInfo(), 'delete',
               throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
               userId='me', sendAsEmail=sendAsEmail, id=smimeId)
      entityActionPerformed([Ent.USER, user, Ent.SENDAS_ADDRESS, sendAsEmail, Ent.SMIME_ID, smimeId], i, count)
    except GAPI.notFound as e:
      entityActionFailedWarning([Ent.USER, user, Ent.SMIME_ID, smimeId], str(e), i, count)
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> print smimes [todrive <ToDriveAttribute>*]
#	[primary|default|(sendas|sendasemail <EmailAddress>)]
# gam <UserTypeEntity> show smimes
#	[primary|default|(sendas|sendasemail <EmailAddress>)]
def printShowSmimes(users):
  csvPF = CSVPrintFile(['User', 'id', 'isDefault', 'issuerCn', 'expiration', 'encryptedKeyPassword', 'pem']) if Act.csvFormat() else None
  selectField = 'sendAsEmail'
  sendAsEmailBase = None
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif myarg in {'default', 'defaultonly'}:
      selectField = 'isDefault'
    elif myarg in {'primary', 'primaryonly'}:
      selectField = 'isPrimary'
    elif myarg in {'sendas', 'sendasemail'}:
      sendAsEmailBase = getEmailAddress(noUid=True)
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      if sendAsEmailBase:
        sendAsEmails = [sendAsEmailBase]
      else:
        results = callGAPIitems(gmail.users().settings().sendAs(), 'list', 'sendAs',
                                throwReasons=GAPI.GMAIL_THROW_REASONS,
                                userId='me', fields='sendAs(isDefault,isPrimary,sendAsEmail)')
        sendAsEmails = [sendAs['sendAsEmail'] for sendAs in results if sendAs.get(selectField, False)]
      jcount = len(sendAsEmails)
      if not csvPF:
        entityPerformActionSubItemModifierNumItems([Ent.USER, user], Ent.SMIME_ID, Act.MODIFIER_FROM, jcount, Ent.SENDAS_ADDRESS, i, count)
      else:
        printGettingEntityItemForWhom(Ent.SENDAS_ADDRESS, user, i, count)
      if sendAsEmails:
        j = 0
        for sendAsEmail in sendAsEmails:
          j += 1
          smimes = callGAPIitems(gmail.users().settings().sendAs().smimeInfo(), 'list', 'smimeInfo',
                                 throwReasons=GAPI.GMAIL_SMIME_THROW_REASONS,
                                 userId='me', sendAsEmail=sendAsEmail)
          kcount = len(smimes)
          if not csvPF:
            Ind.Increment()
            printEntity([Ent.SENDAS_ADDRESS, sendAsEmail], j, jcount)
            Ind.Increment()
            k = 0
            for smime in smimes:
              k += 1
              printEntity([Ent.SMIME_ID, smime['id']], k, kcount)
              Ind.Increment()
              printKeyValueList(['Default', smime.get('isDefault', False)])
              printKeyValueList(['Issuer CN', smime['issuerCn']])
              printKeyValueList(['Expiration', formatLocalTimestamp(smime['expiration'])])
              printKeyValueList(['Password', smime.get('encryptedKeyPassword', '')])
              printKeyValueList(['PEM', None])
              Ind.Increment()
              printKeyValueList([Ind.MultiLineText(smime['pem'])])
              Ind.Decrement()
              Ind.Decrement()
            Ind.Decrement()
            Ind.Decrement()
          elif smimes:
            for smime in smimes:
              smime['expiration'] = formatLocalTimestamp(smime['expiration'])
              csvPF.WriteRowTitles(flattenJSON(smime, flattened={'User': user}))
          elif GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
            csvPF.WriteRowNoFilter({'User': user})
      elif csvPF and GC.Values[GC.CSV_OUTPUT_USERS_AUDIT]:
        csvPF.WriteRowNoFilter({'User': user})
    except (GAPI.forbidden, GAPI.invalidArgument) as e:
      entityActionFailedWarning([Ent.USER, user], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('S/MIME')

# gam <UserTypeEntity> signature|sig
#	<String>|(file|htmlfile <FileName> [charset <CharSet>])|(gdoc|ghtml <UserGoogleDoc>)
#	(replace <Tag> <String>)*
#	[html [<Boolean>]] [name <String>] [replyto <EmailAddress>]
#	[default] [primary] [treatasalias <Boolean>]
def setSignature(users):
  tagReplacements = _initTagReplacements()
  signature, _, html = getStringOrFile('sig')
  body = {}
  primary = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'primary':
      primary = True
    elif myarg == 'html':
      html = getBoolean()
    else:
      getSendAsAttributes(myarg, body, tagReplacements)
  if not tagReplacements['subs']:
    body['signature'] = _processSignature(tagReplacements, signature, html)
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if tagReplacements['subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      body['signature'] = _processSignature(tagReplacements, signature, html)
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), 'list',
                          throwReasons=GAPI.GMAIL_THROW_REASONS,
                          userId='me')
        for sendas in result['sendAs']:
          if sendas.get('isPrimary', False):
            emailAddress = sendas['sendAsEmail']
            _processSendAs(user, i, count, Ent.SIGNATURE, emailAddress, i, count, gmail, 'patch', False, body=body, sendAsEmail=emailAddress, fields='')
            break
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Ent.SIGNATURE, user, i, count, gmail, 'patch', False, body=body, sendAsEmail=user, fields='')

# gam <UserTypeEntity> show signature|sig [compact|format|html] [primary]
def showSignature(users):
  sigReplyFormat = SIG_REPLY_HTML
  primary = False
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'primary':
      primary = True
    elif myarg in SIG_REPLY_OPTIONS_MAP:
      sigReplyFormat = SIG_REPLY_OPTIONS_MAP[myarg]
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if primary:
      try:
        result = callGAPI(gmail.users().settings().sendAs(), 'list',
                          throwReasons=GAPI.GMAIL_THROW_REASONS,
                          userId='me')
        printEntity([Ent.USER, user, Ent.SIGNATURE, ''], i, count)
        Ind.Increment()
        for sendas in result['sendAs']:
          if sendas.get('isPrimary', False):
            _showSendAs(sendas, 0, 0, sigReplyFormat)
            break
        Ind.Decrement()
      except (GAPI.serviceNotAvailable, GAPI.badRequest):
        entityServiceNotApplicableWarning(Ent.USER, user, i, count)
    else:
      _processSendAs(user, i, count, Ent.SIGNATURE, user, i, count, gmail, 'get', sigReplyFormat, sendAsEmail=user)

VACATION_START_STARTED = 'Started'
VACATION_END_NOT_SPECIFIED = 'NotSpecified'

def _showVacation(user, i, count, result, showDisabled, sigReplyFormat):
  enabled = result['enableAutoReply']
  if not enabled and not showDisabled:
    return
  printEntity([Ent.USER, user, Ent.VACATION, None], i, count)
  Ind.Increment()
  printKeyValueList(['Enabled', enabled])
  printKeyValueList(['Contacts Only', result['restrictToContacts']])
  printKeyValueList(['Domain Only', result['restrictToDomain']])
  if 'startTime' in result:
    printKeyValueList(['Start Date', formatLocalDatestamp(result['startTime'])])
  elif enabled:
    printKeyValueList(['Start Date', VACATION_START_STARTED])
  if 'endTime' in result:
    printKeyValueList(['End Date', formatLocalDatestamp(result['endTime'])])
  elif enabled:
    printKeyValueList(['End Date', VACATION_END_NOT_SPECIFIED])
  printKeyValueList(['Subject', result.get('responseSubject', 'None')])
  if sigReplyFormat == SIG_REPLY_HTML:
    printKeyValueList(['Message', None])
    Ind.Increment()
    if result.get('responseBodyPlainText'):
      printKeyValueList([Ind.MultiLineText(result['responseBodyPlainText'])])
    elif result.get('responseBodyHtml'):
      printKeyValueList([Ind.MultiLineText(result['responseBodyHtml'])])
    else:
      printKeyValueList(['None'])
    Ind.Decrement()
  elif sigReplyFormat == SIG_REPLY_FORMAT:
    printKeyValueList(['Message', None])
    Ind.Increment()
    if result.get('responseBodyPlainText'):
      printKeyValueList([Ind.MultiLineText(result['responseBodyPlainText'])])
    elif result.get('responseBodyHtml'):
      printKeyValueList([Ind.MultiLineText(dehtml(result['responseBodyHtml']))])
    else:
      printKeyValueList(['None'])
    Ind.Decrement()
  else: # SIG_REPLY_COMPACT
    if result.get('responseBodyPlainText'):
      printKeyValueList(['Message', escapeCRsNLs(result['responseBodyPlainText'])])
    elif result.get('responseBodyHtml'):
      printKeyValueList(['Message', escapeCRsNLs(result['responseBodyHtml'])])
    else:
      printKeyValueList(['Message', 'None'])
  Ind.Decrement()

# gam <UserTypeEntity> vacation <Boolean> subject <String>
#	[message|htmlmessage <String>|(file|htmlfile <FileName> [charset <CharSet>])|(gdoc|ghtml <UserGoogleDoc>)]
#	(replace <Tag> <String>)*
#	[html [<Boolean>]] [contactsonly [<Boolean>]] [domainonly [<Boolean>]]
#	[start|startdate <Date>|Started] [end|enddate <Date>|NotSpecified]
def setVacation(users):
  enable = getBoolean(None)
  body = {'enableAutoReply': enable}
  responseBodyType = 'responseBodyPlainText'
  message = None
  tagReplacements = _initTagReplacements()
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if myarg == 'subject':
      body['responseSubject'] = getString(Cmd.OB_STRING, minLen=0)
    elif myarg in SORF_MSG_FILE_ARGUMENTS:
      message, _, html = getStringOrFile(myarg)
      if html:
        responseBodyType = 'responseBodyHtml'
    elif myarg == 'replace':
      _getTagReplacement(tagReplacements, True)
    elif myarg == 'html':
      if getBoolean():
        responseBodyType = 'responseBodyHtml'
    elif myarg == 'contactsonly':
      body['restrictToContacts'] = getBoolean()
    elif myarg == 'domainonly':
      body['restrictToDomain'] = getBoolean()
    elif myarg in {'start', 'startdate'}:
      body['startTime'] = getYYYYMMDD(returnTimeStamp=True, alternateValue=VACATION_START_STARTED)
    elif myarg in {'end', 'enddate'}:
      body['endTime'] = getYYYYMMDD(returnTimeStamp=True, alternateValue=VACATION_END_NOT_SPECIFIED)
    else:
      unknownArgumentExit()
  if message:
    if responseBodyType == 'responseBodyHtml':
      message = message.replace('\r', '').replace('\\n', '<br/>')
    else:
      message = message.replace('\r', '').replace('\\n', '\n')
    if tagReplacements['tags'] and not tagReplacements['subs']:
      message = _processTagReplacements(tagReplacements, message)
    body[responseBodyType] = message
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    if message and tagReplacements['subs']:
      _getTagReplacementFieldValues(user, i, count, tagReplacements)
      body[responseBodyType] = _processTagReplacements(tagReplacements, message)
    try:
      oldBody = callGAPI(gmail.users().settings(), 'getVacation',
                         throwReasons=GAPI.GMAIL_THROW_REASONS,
                         userId='me')
      if body.get(responseBodyType):
        oldBody.pop('responseBodyPlainText', None)
        oldBody.pop('responseBodyHtml', None)
      oldBody.update(body)
      result = callGAPI(gmail.users().settings(), 'updateVacation',
                        throwReasons=GAPI.GMAIL_THROW_REASONS+[GAPI.INVALID_ARGUMENT],
                        userId='me', body=oldBody)
      printEntity([Ent.USER, user, Ent.VACATION_ENABLED, result['enableAutoReply']], i, count)
    except GAPI.invalidArgument as e:
      entityActionFailedWarning([Ent.USER, user, Ent.VACATION_ENABLED, enable], str(e), i, count)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)

# gam <UserTypeEntity> print vacation [compact] [enabledonly] [todrive <ToDriveAttribute>*]
# gam <UserTypeEntity> show vacation [compact|format|html] [enabledonly]
def printShowVacation(users):
  def _printVacation(user, result, showDisabled):
    enabled = result['enableAutoReply']
    if not enabled and not showDisabled:
      return
    row = {'User': user, 'enabled': enabled}
    row['contactsonly'] = result['restrictToContacts']
    row['domainonly'] = result['restrictToDomain']
    if 'startTime' in result:
      row['startdate'] = formatLocalDatestamp(result['startTime'])
    elif enabled:
      row['startdate'] = VACATION_START_STARTED
    if 'endTime' in result:
      row['enddate'] = formatLocalDatestamp(result['endTime'])
    elif enabled:
      row['enddate'] = VACATION_END_NOT_SPECIFIED
    row['subject'] = result.get('responseSubject', 'None')
    if result.get('responseBodyPlainText'):
      row['html'] = False
      row['message'] = escapeCRsNLs(result['responseBodyPlainText'])
    elif result.get('responseBodyHtml'):
      row['html'] = True
      if sigReplyFormat == SIG_REPLY_HTML:
        row['message'] = escapeCRsNLs(result['responseBodyHtml'])
      else:
        row['message'] = result['responseBodyHtml'].replace('\r', '').replace('\n', '')
    else:
      row['html'] = False
      row['message'] = 'None'
    csvPF.WriteRow(row)

  csvPF = CSVPrintFile(['User', 'enabled', 'contactsonly', 'domainonly',
                        'startdate', 'enddate', 'subject', 'html', 'message']) if Act.csvFormat() else None
  showDisabled = True
  sigReplyFormat = SIG_REPLY_HTML
  while Cmd.ArgumentsRemaining():
    myarg = getArgument()
    if csvPF and myarg == 'todrive':
      csvPF.GetTodriveParameters()
    elif (not csvPF and myarg in SIG_REPLY_OPTIONS_MAP) or (csvPF and myarg == 'compact'):
      sigReplyFormat = SIG_REPLY_OPTIONS_MAP[myarg]
    elif myarg == 'enabledonly':
      showDisabled = False
    else:
      unknownArgumentExit()
  i, count, users = getEntityArgument(users)
  for user in users:
    i += 1
    user, gmail = buildGAPIServiceObject(API.GMAIL, user, i, count)
    if not gmail:
      continue
    try:
      result = callGAPI(gmail.users().settings(), 'getVacation',
                        throwReasons=GAPI.GMAIL_THROW_REASONS,
                        userId='me')
      if not csvPF:
        _showVacation(user, i, count, result, showDisabled, sigReplyFormat)
      else:
        printGettingEntityItemForWhom(Ent.VACATION, user, i, count)
        _printVacation(user, result, showDisabled)
    except (GAPI.serviceNotAvailable, GAPI.badRequest):
      entityServiceNotApplicableWarning(Ent.USER, user, i, count)
  if csvPF:
    csvPF.writeCSVfile('Vacation')

# Command line processing

CMD_ACTION = 0
CMD_FUNCTION = 1

# Main commands
BATCH_CSV_COMMANDS = {
  Cmd.BATCH_CMD: (Act.PERFORM, doBatch),
  Cmd.CSV_CMD: (Act.PERFORM, doCSV),
  Cmd.CSVTEST_CMD: (Act.PERFORM, doCSVTest),
  Cmd.TBATCH_CMD: (Act.PERFORM, doThreadBatch),
  }
MAIN_COMMANDS = {
  'help': (Act.PERFORM, doUsage),
  'list': (Act.LIST, doListType),
  'report': (Act.REPORT, doReport),
  'sendemail': (Act.SENDEMAIL, doSendEmail),
  'version': (Act.PERFORM, doVersion),
  'whatis': (Act.INFO, doWhatIs),
  }

# Main commands with objects
MAIN_ADD_CREATE_FUNCTIONS = {
  Cmd.ARG_ADMIN:	doCreateAdmin,
  Cmd.ARG_ADMINROLE:	doCreateUpdateAdminRoles,
  Cmd.ARG_ALERTFEEDBACK:	doCreateAlertFeedback,
  Cmd.ARG_ALIAS:	doCreateUpdateAliases,
  Cmd.ARG_BUILDING:	doCreateBuilding,
  Cmd.ARG_CONTACT:	doCreateDomainContact,
  Cmd.ARG_COURSE:	doCreateCourse,
  Cmd.ARG_DATATRANSFER:	doCreateDataTransfer,
  Cmd.ARG_DOMAIN:	doCreateDomain,
  Cmd.ARG_DOMAINALIAS:	doCreateDomainAlias,
  Cmd.ARG_DRIVEFILEACL:	doCreateDriveFileACL,
  Cmd.ARG_FEATURE:	doCreateFeature,
  Cmd.ARG_GROUP:	doCreateGroup,
  Cmd.ARG_GUARDIAN: 	doInviteGuardian,
  Cmd.ARG_GUARDIANINVITATION: 	doInviteGuardian,
  Cmd.ARG_ORG:		doCreateOrg,
  Cmd.ARG_PERMISSION:	doCreatePermissions,
  Cmd.ARG_PROJECT:	doCreateProject,
  Cmd.ARG_RESOLDCUSTOMER:	doCreateResoldCustomer,
  Cmd.ARG_RESOLDSUBSCRIPTION:	doCreateResoldSubscription,
  Cmd.ARG_RESOURCE:	doCreateResourceCalendar,
  Cmd.ARG_SCHEMA:	doCreateUpdateUserSchemas,
  Cmd.ARG_SAKEY:	doCreateSvcAcctKeys,
  Cmd.ARG_SITE:		doCreateDomainSite,
  Cmd.ARG_SITEACL:	doProcessDomainSiteACLs,
  Cmd.ARG_SVCACCT:	doCreateSvcAcct,
  Cmd.ARG_TEAMDRIVE:	doCreateTeamDrive,
  Cmd.ARG_USER:		doCreateUser,
  Cmd.ARG_VAULTEXPORT:	doCreateVaultExport,
  Cmd.ARG_VAULTHOLD:	doCreateVaultHold,
  Cmd.ARG_VAULTMATTER:	doCreateVaultMatter,
  Cmd.ARG_VERIFY:	doCreateSiteVerification,
  }

MAIN_COMMANDS_WITH_OBJECTS = {
  'add': (Act.ADD, MAIN_ADD_CREATE_FUNCTIONS),
  'cancel': (Act.CANCEL, {Cmd.ARG_GUARDIANINVITATION: doCancelGuardianInvitation}),
  'check': (Act.CHECK, {Cmd.ARG_SVCACCT: doCheckUpdateSvcAcct}),
  'clear': (Act.CLEAR, {Cmd.ARG_CONTACT: doClearDomainContacts}),
  'close': (Act.CLOSE, {Cmd.ARG_VAULTMATTER: doCloseVaultMatter}),
  'create': (Act.CREATE, MAIN_ADD_CREATE_FUNCTIONS),
  'dedup': (Act.DEDUP, {Cmd.ARG_CONTACT: doDedupDomainContacts}),
  'delete':
    (Act.DELETE,
     {Cmd.ARG_ADMIN:		doDeleteAdmin,
      Cmd.ARG_ADMINROLE:	doDeleteAdminRole,
      Cmd.ARG_ALIAS:		doDeleteAliases,
      Cmd.ARG_ALERT:		doDeleteOrUndeleteAlert,
      Cmd.ARG_BUILDING:		doDeleteBuilding,
      Cmd.ARG_CONTACT:		doDeleteDomainContacts,
      Cmd.ARG_CONTACTPHOTO:	doDeleteDomainContactPhoto,
      Cmd.ARG_COURSE:		doDeleteCourse,
      Cmd.ARG_COURSES:		doDeleteCourses,
      Cmd.ARG_DOMAIN:		doDeleteDomain,
      Cmd.ARG_DOMAINALIAS:	doDeleteDomainAlias,
      Cmd.ARG_DRIVEFILEACL:	doDeleteDriveFileACLs,
      Cmd.ARG_FEATURE:		doDeleteFeature,
      Cmd.ARG_GROUP:		doDeleteGroups,
      Cmd.ARG_GUARDIAN: 	doDeleteGuardian,
      Cmd.ARG_MOBILE:		doDeleteMobileDevices,
      Cmd.ARG_ORG:		doDeleteOrg,
      Cmd.ARG_ORGS:		doDeleteOrgs,
      Cmd.ARG_PERMISSION:	doDeletePermissions,
      Cmd.ARG_PRINTER:		doDeletePrinters,
      Cmd.ARG_PROJECT:		doDeleteProject,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doDeleteResoldSubscription,
      Cmd.ARG_RESOURCE:		doDeleteResourceCalendar,
      Cmd.ARG_RESOURCES:	doDeleteResourceCalendars,
      Cmd.ARG_SAKEY:		doDeleteSvcAcctKeys,
      Cmd.ARG_SCHEMA:		doDeleteUserSchemas,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_SVCACCT:		doDeleteSvcAcct,
      Cmd.ARG_TEAMDRIVE:	doDeleteTeamDrive,
      Cmd.ARG_USER:		doDeleteUser,
      Cmd.ARG_USERS:		doDeleteUsers,
      Cmd.ARG_VAULTEXPORT:	doDeleteVaultExport,
      Cmd.ARG_VAULTHOLD:	doDeleteVaultHold,
      Cmd.ARG_VAULTMATTER:	doDeleteVaultMatter,
     }
    ),
  'download': (Act.DOWNLOAD, {Cmd.ARG_STORAGEBUCKET: doDownloadCloudStorageBucket, Cmd.ARG_VAULTEXPORT: doDownloadVaultExport}),
  'get': (Act.DOWNLOAD, {Cmd.ARG_CONTACTPHOTO: doGetDomainContactPhoto, Cmd.ARG_DEVICEFILE: doGetCrOSDeviceFiles}),
  'hide': (Act.HIDE, {Cmd.ARG_TEAMDRIVE: doHideUnhideTeamDrive}),
  'info':
    (Act.INFO,
     {Cmd.ARG_ALERT:		doInfoAlert,
      Cmd.ARG_ALIAS:		doInfoAliases,
      Cmd.ARG_BUILDING:		doInfoBuilding,
      Cmd.ARG_CONTACT:		doInfoDomainContacts,
      Cmd.ARG_COURSE:		doInfoCourse,
      Cmd.ARG_COURSES:		doInfoCourses,
      Cmd.ARG_CROS:		doInfoCrOSDevices,
      Cmd.ARG_CUSTOMER:		doInfoCustomer,
      Cmd.ARG_DATATRANSFER:	doInfoDataTransfer,
      Cmd.ARG_DOMAIN:		doInfoDomain,
      Cmd.ARG_DOMAINALIAS:	doInfoDomainAlias,
      Cmd.ARG_DRIVEFILEACL:	doInfoDriveFileACLs,
      Cmd.ARG_INSTANCE:		doInfoInstance,
      Cmd.ARG_GAL:		doInfoGAL,
      Cmd.ARG_GROUP:		doInfoGroups,
      Cmd.ARG_GROUPMEMBERS:	doInfoGroupMembers,
      Cmd.ARG_MOBILE:		doInfoMobileDevices,
      Cmd.ARG_ORG:		doInfoOrg,
      Cmd.ARG_ORGS:		doInfoOrgs,
      Cmd.ARG_PRINTER:		doInfoPrinters,
      Cmd.ARG_RESOLDCUSTOMER:	doInfoResoldCustomer,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doInfoResoldSubscription,
      Cmd.ARG_RESOURCE:		doInfoResourceCalendar,
      Cmd.ARG_RESOURCES:	doInfoResourceCalendars,
      Cmd.ARG_SCHEMA:		doInfoUserSchemas,
      Cmd.ARG_SITE:		doInfoDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_TEAMDRIVE:	doInfoTeamDrive,
      Cmd.ARG_USER:		doInfoUser,
      Cmd.ARG_USERS:		doInfoUsers,
      Cmd.ARG_VAULTEXPORT:	doInfoVaultExport,
      Cmd.ARG_VAULTHOLD:	doInfoVaultHold,
      Cmd.ARG_VAULTMATTER:	doInfoVaultMatter,
      Cmd.ARG_VERIFY:		doInfoSiteVerification,
     }
    ),
  'print':
    (Act.PRINT,
     {Cmd.ARG_ADMINROLE:	doPrintShowAdminRoles,
      Cmd.ARG_ADMIN:		doPrintShowAdmins,
      Cmd.ARG_ALERT:		doPrintShowAlerts,
      Cmd.ARG_ALERTFEEDBACK:	doPrintShowAlertFeedback,
      Cmd.ARG_ALIAS:		doPrintAliases,
      Cmd.ARG_BUILDING:		doPrintShowBuildings,
      Cmd.ARG_CLASSROOMINVITATION:	doPrintShowClassroomInvitations,
      Cmd.ARG_CONTACT:		doPrintShowDomainContacts,
      Cmd.ARG_COURSE:		doPrintCourses,
      Cmd.ARG_COURSES:		doPrintCourses,
      Cmd.ARG_COURSEANNOUNCEMENTS:	doPrintCourseAnnouncements,
      Cmd.ARG_COURSEPARTICIPANTS:	doPrintCourseParticipants,
      Cmd.ARG_COURSESUBMISSIONS:	doPrintCourseSubmissions,
      Cmd.ARG_COURSETOPICS:	doPrintCourseTopics,
      Cmd.ARG_COURSEWORK:	doPrintCourseWork,
      Cmd.ARG_CROS:		doPrintCrOSDevices,
      Cmd.ARG_CROSACTIVITY:	doPrintCrOSActivity,
      Cmd.ARG_DATATRANSFER:	doPrintShowDataTransfers,
      Cmd.ARG_DOMAIN:		doPrintShowDomains,
      Cmd.ARG_DOMAINALIAS:	doPrintShowDomainAliases,
      Cmd.ARG_DRIVEFILEACL:	doPrintShowDriveFileACLs,
      Cmd.ARG_FEATURE:		doPrintShowFeatures,
      Cmd.ARG_GAL:		doPrintShowGAL,
      Cmd.ARG_GROUP:		doPrintGroups,
      Cmd.ARG_GROUPMEMBERS:	doPrintGroupMembers,
      Cmd.ARG_GROUPTREE:	doPrintShowGroupTree,
      Cmd.ARG_GUARDIAN: 	doPrintShowGuardians,
      Cmd.ARG_LICENSE:		doPrintLicenses,
      Cmd.ARG_MOBILE:		doPrintMobileDevices,
      Cmd.ARG_ORG:		doPrintOrgs,
      Cmd.ARG_ORGS:		doPrintOrgs,
      Cmd.ARG_OWNERSHIP:	doPrintShowOwnership,
      Cmd.ARG_PRINTER:		doPrintShowPrinters,
      Cmd.ARG_PRINTJOBS:	doPrintPrintJobs,
      Cmd.ARG_PRIVILEGES:	doPrintShowPrivileges,
      Cmd.ARG_PROJECT:		doPrintShowProjects,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doPrintShowResoldSubscriptions,
      Cmd.ARG_RESOURCE:		doPrintShowResourceCalendars,
      Cmd.ARG_RESOURCES:	doPrintShowResourceCalendars,
      Cmd.ARG_SCHEMA:		doPrintShowUserSchemas,
      Cmd.ARG_SITE:		doPrintShowDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_SITEACTIVITY:	doPrintDomainSiteActivity,
      Cmd.ARG_SVCACCT:		doPrintShowSvcAccts,
      Cmd.ARG_TEAMDRIVE:	doPrintShowTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	doPrintShowTeamDriveACLs,
      Cmd.ARG_TOKEN:		doPrintTokens,
      Cmd.ARG_TRANSFERAPPS:	doShowTransferApps,
      Cmd.ARG_USER:		doPrintUsers,
      Cmd.ARG_USERS:		doPrintUsers,
      Cmd.ARG_VAULTEXPORT:	doPrintShowVaultExports,
      Cmd.ARG_VAULTHOLD:	doPrintShowVaultHolds,
      Cmd.ARG_VAULTMATTER:	doPrintShowVaultMatters,
     }
    ),
  'register': (Act.REGISTER, {Cmd.ARG_PRINTER: doRegisterPrinter}),
  'reopen': (Act.REOPEN, {Cmd.ARG_VAULTMATTER: doReopenVaultMatter}),
  'replace': (Act.UPDATE, {Cmd.ARG_SAKEY: doReplaceSvcAcctKeys}),
  'rotate': (Act.UPDATE, {Cmd.ARG_SAKEY: doProcessSvcAcctKeys}),
  'show':
    (Act.SHOW,
     {Cmd.ARG_ADMINROLE:	doPrintShowAdminRoles,
      Cmd.ARG_ADMIN:		doPrintShowAdmins,
      Cmd.ARG_ALERT:		doPrintShowAlerts,
      Cmd.ARG_ALERTFEEDBACK:	doPrintShowAlertFeedback,
      Cmd.ARG_BUILDING:		doPrintShowBuildings,
      Cmd.ARG_CLASSROOMINVITATION:	doPrintShowClassroomInvitations,
      Cmd.ARG_CONTACT:		doPrintShowDomainContacts,
      Cmd.ARG_DATATRANSFER:	doPrintShowDataTransfers,
      Cmd.ARG_DOMAIN:		doPrintShowDomains,
      Cmd.ARG_DOMAINALIAS:	doPrintShowDomainAliases,
      Cmd.ARG_DRIVEFILEACL:	doPrintShowDriveFileACLs,
      Cmd.ARG_FEATURE:		doPrintShowFeatures,
      Cmd.ARG_GAL:		doPrintShowGAL,
      Cmd.ARG_GROUPMEMBERS:	doShowGroupMembers,
      Cmd.ARG_GROUPTREE:	doPrintShowGroupTree,
      Cmd.ARG_GUARDIAN: 	doPrintShowGuardians,
      Cmd.ARG_LICENSE:		doShowLicenses,
      Cmd.ARG_ORGTREE:		doShowOrgTree,
      Cmd.ARG_OWNERSHIP:	doPrintShowOwnership,
      Cmd.ARG_PRINTER:		doPrintShowPrinters,
      Cmd.ARG_PRIVILEGES:	doPrintShowPrivileges,
      Cmd.ARG_PROJECT:		doPrintShowProjects,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doPrintShowResoldSubscriptions,
      Cmd.ARG_RESOURCE:		doPrintShowResourceCalendars,
      Cmd.ARG_RESOURCES:	doPrintShowResourceCalendars,
      Cmd.ARG_SAKEY:		doShowSvcAcctKeys,
      Cmd.ARG_SCHEMA:		doPrintShowUserSchemas,
      Cmd.ARG_SITE:		doPrintShowDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_SVCACCT:		doPrintShowSvcAccts,
      Cmd.ARG_TEAMDRIVE:	doPrintShowTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	doPrintShowTeamDriveACLs,
      Cmd.ARG_TEAMDRIVEINFO:	doInfoTeamDrive,
      Cmd.ARG_TEAMDRIVETHEMES:	doShowTeamDriveThemes,
      Cmd.ARG_TRANSFERAPPS:	doShowTransferApps,
      Cmd.ARG_VAULTEXPORT:	doPrintShowVaultExports,
      Cmd.ARG_VAULTHOLD:	doPrintShowVaultHolds,
      Cmd.ARG_VAULTMATTER:	doPrintShowVaultMatters,
     }
    ),
  'suspend': (Act.SUSPEND, {Cmd.ARG_USER: doSuspendUser, Cmd.ARG_USERS: doSuspendUsers}),
  'unhide': (Act.UNHIDE, {Cmd.ARG_TEAMDRIVE: doHideUnhideTeamDrive}),
  'update':
    (Act.UPDATE,
     {Cmd.ARG_ADMINROLE:	doCreateUpdateAdminRoles,
      Cmd.ARG_ALIAS:		doCreateUpdateAliases,
      Cmd.ARG_BUILDING:		doUpdateBuilding,
      Cmd.ARG_CONTACT:		doUpdateDomainContacts,
      Cmd.ARG_CONTACTPHOTO:	doUpdateDomainContactPhoto,
      Cmd.ARG_COURSE:		doUpdateCourse,
      Cmd.ARG_COURSES:		doUpdateCourses,
      Cmd.ARG_CROS:		doUpdateCrOSDevices,
      Cmd.ARG_CUSTOMER:		doUpdateCustomer,
      Cmd.ARG_DOMAIN:		doUpdateDomain,
      Cmd.ARG_DRIVEFILEACL:	doUpdateDriveFileACLs,
      Cmd.ARG_FEATURE:		doUpdateFeature,
      Cmd.ARG_GROUP:		doUpdateGroups,
      Cmd.ARG_MOBILE:		doUpdateMobileDevices,
      Cmd.ARG_ORG:		doUpdateOrg,
      Cmd.ARG_ORGS:		doUpdateOrgs,
      Cmd.ARG_PRINTER:		doUpdatePrinters,
      Cmd.ARG_PROJECT:		doUpdateProject,
      Cmd.ARG_RESOLDCUSTOMER:	doUpdateResoldCustomer,
      Cmd.ARG_RESOLDSUBSCRIPTION:	doUpdateResoldSubscription,
      Cmd.ARG_RESOURCE:		doUpdateResourceCalendar,
      Cmd.ARG_RESOURCES:	doUpdateResourceCalendars,
      Cmd.ARG_SCHEMA:		doCreateUpdateUserSchemas,
      Cmd.ARG_SAKEY:		doUpdateSvcAcctKeys,
      Cmd.ARG_SITE:		doUpdateDomainSites,
      Cmd.ARG_SITEACL:		doProcessDomainSiteACLs,
      Cmd.ARG_SVCACCT:		doCheckUpdateSvcAcct,
      Cmd.ARG_TEAMDRIVE:	doUpdateTeamDrive,
      Cmd.ARG_USER:		doUpdateUser,
      Cmd.ARG_USERS:		doUpdateUsers,
      Cmd.ARG_VAULTHOLD:	doUpdateVaultHold,
      Cmd.ARG_VAULTMATTER:	doUpdateVaultMatter,
      Cmd.ARG_VERIFY:		doUpdateSiteVerification,
     }
    ),
  'undelete':
    (Act.UNDELETE,
     {Cmd.ARG_ALERT: doDeleteOrUndeleteAlert,
      Cmd.ARG_USER: doUndeleteUser,
      Cmd.ARG_USERS: doUndeleteUsers,
      Cmd.ARG_VAULTMATTER: doUndeleteVaultMatter,
     }
    ),
  'unsuspend': (Act.UNSUSPEND, {Cmd.ARG_USER: doUnsuspendUser, Cmd.ARG_USERS: doUnsuspendUsers}),
  'use': (Act.USE, {Cmd.ARG_PROJECT: doUseProject}),
  }

MAIN_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_ADMINS:	Cmd.ARG_ADMIN,
  Cmd.ARG_ADMINROLES:	Cmd.ARG_ADMINROLE,
  Cmd.ARG_ALERTFEEDBACKS:	Cmd.ARG_ALERTFEEDBACK,
  Cmd.ARG_ALERTS:	Cmd.ARG_ALERT,
  Cmd.ARG_ALERTSFEEDBACK:	Cmd.ARG_ALERTFEEDBACK,
  Cmd.ARG_ALIASDOMAIN:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_ALIASDOMAINS:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_ALIASES:	Cmd.ARG_ALIAS,
  Cmd.ARG_APIPROJECT:	Cmd.ARG_PROJECT,
  Cmd.ARG_BUILDINGS:	Cmd.ARG_BUILDING,
  Cmd.ARG_CLASS:	Cmd.ARG_COURSE,
  Cmd.ARG_CLASSES:	Cmd.ARG_COURSES,
  Cmd.ARG_CLASSPARTICIPANTS:	Cmd.ARG_COURSEPARTICIPANTS,
  Cmd.ARG_CLASSROOMINVITATIONS:	Cmd.ARG_CLASSROOMINVITATION,
  Cmd.ARG_CONTACTS:	Cmd.ARG_CONTACT,
  Cmd.ARG_CONTACTPHOTOS:	Cmd.ARG_CONTACTPHOTO,
  Cmd.ARG_CROSES:	Cmd.ARG_CROS,
  Cmd.ARG_DATATRANSFERS:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_DEVICEFILES:	Cmd.ARG_DEVICEFILE,
  Cmd.ARG_DOMAINS:	Cmd.ARG_DOMAIN,
  Cmd.ARG_DOMAINALIASES:	Cmd.ARG_DOMAINALIAS,
  Cmd.ARG_DRIVEFILEACLS:	Cmd.ARG_DRIVEFILEACL,
  Cmd.ARG_EXPORT:	Cmd.ARG_VAULTEXPORT,
  Cmd.ARG_EXPORTS:	Cmd.ARG_VAULTEXPORT,
  Cmd.ARG_FEATURES:	Cmd.ARG_FEATURE,
  Cmd.ARG_GROUPS:	Cmd.ARG_GROUP,
  Cmd.ARG_GROUPSMEMBERS:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_GUARDIANINVITATIONS:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_GUARDIANINVITE:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_GUARDIANS:	Cmd.ARG_GUARDIAN,
  Cmd.ARG_HOLD:		Cmd.ARG_VAULTHOLD,
  Cmd.ARG_HOLDS:	Cmd.ARG_VAULTHOLD,
  Cmd.ARG_INVITEGUARDIAN:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_LICENCE:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENCES:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENSES:	Cmd.ARG_LICENSE,
  Cmd.ARG_MATTER:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_MATTERS:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_MEMBER:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_MEMBERS:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_MOBILES:	Cmd.ARG_MOBILE,
  Cmd.ARG_NICKNAME:	Cmd.ARG_ALIAS,
  Cmd.ARG_NICKNAMES:	Cmd.ARG_ALIAS,
  Cmd.ARG_OU:		Cmd.ARG_ORG,
  Cmd.ARG_OUS:		Cmd.ARG_ORGS,
  Cmd.ARG_OUTREE:	Cmd.ARG_ORGTREE,
  Cmd.ARG_PARTICIPANTS:	Cmd.ARG_COURSEPARTICIPANTS,
  Cmd.ARG_PERMISSIONS:	Cmd.ARG_PERMISSION,
  Cmd.ARG_PRINT:	Cmd.ARG_PRINTER,
  Cmd.ARG_PRINTERS:	Cmd.ARG_PRINTER,
  Cmd.ARG_PROJECTS:	Cmd.ARG_PROJECT,
  Cmd.ARG_RESELLERCUSTOMERS:	Cmd.ARG_RESOLDCUSTOMER,
  Cmd.ARG_RESELLERSUBSCRIPTIONS:	Cmd.ARG_RESOLDSUBSCRIPTION,
  Cmd.ARG_RESOLDCUSTOMERS:	Cmd.ARG_RESOLDCUSTOMER,
  Cmd.ARG_RESOLDSUBSCRIPTIONS:	Cmd.ARG_RESOLDSUBSCRIPTION,
  Cmd.ARG_ROLE:		Cmd.ARG_ADMINROLE,
  Cmd.ARG_ROLES:	Cmd.ARG_ADMINROLE,
  Cmd.ARG_SAKEYS:	Cmd.ARG_SAKEY,
  Cmd.ARG_SCHEMAS:	Cmd.ARG_SCHEMA,
  Cmd.ARG_SHAREDDRIVE:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_SHAREDDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_SHAREDDRIVEACLS:	Cmd.ARG_TEAMDRIVEACLS,
  Cmd.ARG_SHAREDDRIVEINFO:	Cmd.ARG_TEAMDRIVEINFO,
  Cmd.ARG_SHAREDDRIVETHEMES:	Cmd.ARG_TEAMDRIVETHEMES,
  Cmd.ARG_SITEACLS:	Cmd.ARG_SITEACL,
  Cmd.ARG_SITES:	Cmd.ARG_SITE,
  Cmd.ARG_SVCACCTS:	Cmd.ARG_SVCACCT,
  Cmd.ARG_TEAMDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_TOKENS:	Cmd.ARG_TOKEN,
  Cmd.ARG_TRANSFER:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_TRANSFERS:	Cmd.ARG_DATATRANSFER,
  Cmd.ARG_VAULTEXPORTS:	Cmd.ARG_VAULTEXPORT,
  Cmd.ARG_VAULTHOLDS:	Cmd.ARG_VAULTHOLD,
  Cmd.ARG_VAULTMATTERS:	Cmd.ARG_VAULTMATTER,
  Cmd.ARG_VERIFICATION:	Cmd.ARG_VERIFY,
  }

# Oauth command sub-commands
OAUTH2_SUBCOMMANDS = {
  'create': (Act.CREATE, doOAuthCreate),
  'delete': (Act.DELETE, doOAuthDelete),
  'export': (Act.EXPORT, doOAuthExport),
  'info': (Act.INFO, doOAuthInfo),
  'refresh': (Act.REFRESH, doOAuthRefresh),
  'update': (Act.UPDATE, doOAuthUpdate),
  }

# Oauth sub-command aliases
OAUTH2_SUBCOMMAND_ALIASES = {
  'request':	'create',
  'revoke':	'delete',
  'verify':	'info',
  }

def processOauthCommands():
  CL_subCommand = getChoice(OAUTH2_SUBCOMMANDS, choiceAliases=OAUTH2_SUBCOMMAND_ALIASES)
  Act.Set(OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  OAUTH2_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()

# Audit command sub-commands
AUDIT_SUBCOMMANDS = {
  'uploadkey': (Act.UPLOAD, doUploadAuditKey),
  }

# Audit command sub-commands with objects
AUDIT_SUBCOMMANDS_WITH_OBJECTS = {
  'export':
    {'request': (Act.SUBMIT, doSubmitExportRequest),
     'delete': (Act.DELETE, doDeleteExportRequest),
     'download': (Act.DOWNLOAD, doDownloadExportRequest),
     'status': (Act.LIST, doStatusExportRequests),
     'watch': (Act.WATCH, doWatchExportRequest),
    },
  'monitor':
    {'create': (Act.CREATE, doCreateMonitor),
     'delete': (Act.DELETE, doDeleteMonitor),
     'list': (Act.LIST, doShowMonitors),
    },
  }

def processAuditCommands():
  CL_subCommand = getChoice(list(AUDIT_SUBCOMMANDS)+list(AUDIT_SUBCOMMANDS_WITH_OBJECTS))
  if CL_subCommand in AUDIT_SUBCOMMANDS:
    Act.Set(AUDIT_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    AUDIT_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION]()
  else:
    CL_objectName = getChoice(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand])
    Act.Set(AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_ACTION])
    AUDIT_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CL_objectName][CMD_FUNCTION]()

# Calendar command sub-commands
CALENDAR_SUBCOMMANDS = {
  'showacl': (Act.SHOW, doCalendarsPrintShowACLs),
  'printacl': (Act.PRINT, doCalendarsPrintShowACLs),
  'addevent': (Act.ADD, doCalendarsCreateEvent),
  'deleteevent': (Act.DELETE, doCalendarsDeleteEventsOld),
  'moveevent': (Act.MOVE, doCalendarsMoveEventsOld),
  'updateevent': (Act.UPDATE, doCalendarsUpdateEventsOld),
  'printevents': (Act.PRINT, doCalendarsPrintShowEvents),
  'wipe': (Act.WIPE, doCalendarsWipeEvents),
  'modify': (Act.MODIFY, doCalendarsModifySettings),
  }

CALENDAR_OLDACL_SUBCOMMANDS = {
  'add': (Act.ADD, doCalendarsCreateACL),
  'create': (Act.CREATE, doCalendarsCreateACL),
  'delete': (Act.DELETE, doCalendarsDeleteACL),
  'update': (Act.UPDATE, doCalendarsUpdateACL),
  }

# Calendar sub-command aliases
CALENDAR_OLDACL_SUBCOMMAND_ALIASES = {
  'del':	'delete',
  }

# Calendars command sub-commands with objects
CALENDARS_SUBCOMMANDS_WITH_OBJECTS = {
  'add': (Act.ADD, {Cmd.ARG_CALENDARACL: doCalendarsCreateACLs, Cmd.ARG_EVENT: doCalendarsCreateEvent}),
  'create': (Act.CREATE, {Cmd.ARG_CALENDARACL: doCalendarsCreateACLs, Cmd.ARG_EVENT: doCalendarsCreateEvent}),
  'delete': (Act.DELETE, {Cmd.ARG_CALENDARACL: doCalendarsDeleteACLs, Cmd.ARG_EVENT: doCalendarsDeleteEvents}),
  'empty': (Act.EMPTY, {Cmd.ARG_CALENDARTRASH: doCalendarsEmptyTrash}),
  'import': (Act.IMPORT, {Cmd.ARG_EVENT: doCalendarsImportEvent}),
  'info': (Act.INFO, {Cmd.ARG_CALENDARACL: doCalendarsInfoACLs, Cmd.ARG_EVENT: doCalendarsInfoEvents}),
  'move': (Act.MOVE, {Cmd.ARG_EVENT: doCalendarsMoveEvents}),
  'print': (Act.PRINT, {Cmd.ARG_CALENDARACL: doCalendarsPrintShowACLs, Cmd.ARG_EVENT: doCalendarsPrintShowEvents, Cmd.ARG_SETTINGS: doCalendarsPrintShowSettings}),
  'purge': (Act.PURGE, {Cmd.ARG_EVENT: doCalendarsPurgeEvents}),
  'show': (Act.SHOW, {Cmd.ARG_CALENDARACL: doCalendarsPrintShowACLs, Cmd.ARG_EVENT: doCalendarsPrintShowEvents, Cmd.ARG_SETTINGS: doCalendarsPrintShowSettings}),
  'update': (Act.UPDATE, {Cmd.ARG_CALENDARACL: doCalendarsUpdateACLs, Cmd.ARG_EVENT: doCalendarsUpdateEvents}),
  'wipe': (Act.WIPE, {Cmd.ARG_EVENT: doCalendarsWipeEvents}),
  }

CALENDARS_SUBCOMMANDS_OBJECT_ALIASES = {
  Cmd.ARG_ACL:		Cmd.ARG_CALENDARACL,
  Cmd.ARG_ACLS:		Cmd.ARG_CALENDARACL,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_EVENTS:	Cmd.ARG_EVENT,
  }

def processCalendarsCommands():
  calendarList = getEntityList(Cmd.OB_EMAIL_ADDRESS_ENTITY)
  CL_subCommand = getChoice(CALENDAR_SUBCOMMANDS, defaultChoice=None)
  if CL_subCommand:
    Act.Set(CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CALENDAR_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](calendarList)
    return
  CL_subCommand = getChoice(CALENDAR_OLDACL_SUBCOMMANDS, choiceAliases=CALENDAR_OLDACL_SUBCOMMAND_ALIASES, defaultChoice=None)
  if CL_subCommand:
    Act.Set(CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
    CL_objectName = getChoice([Cmd.ARG_CALENDARACL, Cmd.ARG_EVENT], choiceAliases=CALENDARS_SUBCOMMANDS_OBJECT_ALIASES, defaultChoice=None)
    if not CL_objectName:
      CALENDAR_OLDACL_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](calendarList)
    else:
      CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](calendarList)
    return
  CL_subCommand = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS)
  Act.Set(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=CALENDARS_SUBCOMMANDS_OBJECT_ALIASES)
  CALENDARS_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](calendarList)

# Course command sub-commands
COURSE_SUBCOMMANDS = {
  'add': (Act.ADD, doCourseAddItems),
  'clear': (Act.REMOVE, doCourseClearParticipants),
  'remove': (Act.REMOVE, doCourseRemoveItems),
  'sync': (Act.SYNC, doCourseSyncParticipants),
  }

# Course sub-command aliases
COURSE_SUBCOMMAND_ALIASES = {
  'create':	'add',
  'del':	'remove',
  'delete':	'remove',
  }

def executeCourseCommands(courseIdList, getEntityListArg):
  CL_subCommand = getChoice(COURSE_SUBCOMMANDS, choiceAliases=COURSE_SUBCOMMAND_ALIASES)
  Act.Set(COURSE_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  COURSE_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](courseIdList, getEntityListArg)

def processCourseCommands():
  executeCourseCommands(getStringReturnInList(Cmd.OB_COURSE_ID), False)

def processCoursesCommands():
  executeCourseCommands(getEntityList(Cmd.OB_COURSE_ENTITY, shlexSplit=True), True)

# Printer command sub-commands
PRINTER_SUBCOMMANDS = {
  'add': (Act.ADD, printerCreateACL),
  'delete': (Act.DELETE, printerDeleteACLs),
  'printacls': (Act.PRINT, printerPrintShowACLs),
  'showacls': (Act.SHOW, printerPrintShowACLs),
  'sync': (Act.SYNC, printerSyncACLs),
  'wipe': (Act.DELETE, printerWipeACLs),
  }

# Printer sub-command aliases
PRINTER_SUBCOMMAND_ALIASES = {
  'create':	'add',
  'del':	'delete',
  'printacl':	'printacls',
  'showacl':	'showacls',
  'remove':	'delete',
  }

def processPrintersCommands(users=None):
  if users is None:
    users = [None]
  printerIdList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  if printerIdList[0] == 'register':
    Act.Set(Act.REGISTER)
    registerPrinter(users)
    return
  CL_subCommand = getChoice(PRINTER_SUBCOMMANDS, choiceAliases=PRINTER_SUBCOMMAND_ALIASES)
  Act.Set(PRINTER_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTER_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](users, printerIdList)

# Printjob command sub-commands
PRINTJOB_SUBCOMMANDS = {
  'cancel': (Act.CANCEL, doPrintJobCancel),
  'delete': (Act.DELETE, doPrintJobDelete),
  'fetch': (Act.DOWNLOAD, doPrintJobFetch),
  'resubmit': (Act.RESUBMIT, doPrintJobResubmit),
  'submit': (Act.SUBMIT, doPrintJobSubmit),
  }

def processPrintjobsCommands(users=None):
  if users is None:
    users = [None]
  jobPrinterIdList = getEntityList(Cmd.OB_PRINTER_ID_ENTITY)
  CL_subCommand = getChoice(PRINTJOB_SUBCOMMANDS)
  Act.Set(PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_ACTION])
  PRINTJOB_SUBCOMMANDS[CL_subCommand][CMD_FUNCTION](users, jobPrinterIdList)

# Resource command sub-commands
RESOURCE_SUBCOMMANDS_WITH_OBJECTS = {
  'add': (Act.ADD, {Cmd.ARG_CALENDARACL: doResourceCreateCalendarACLs}),
  'create': (Act.CREATE, {Cmd.ARG_CALENDARACL: doResourceCreateCalendarACLs}),
  'update': (Act.UPDATE, {Cmd.ARG_CALENDARACL: doResourceUpdateCalendarACLs}),
  'delete': (Act.DELETE, {Cmd.ARG_CALENDARACL: doResourceDeleteCalendarACLs}),
  'info': (Act.INFO, {Cmd.ARG_CALENDARACL: doResourceInfoCalendarACLs}),
  'print': (Act.PRINT, {Cmd.ARG_CALENDARACL: doResourcePrintShowCalendarACLs}),
  'show': (Act.SHOW, {Cmd.ARG_CALENDARACL: doResourcePrintShowCalendarACLs}),
  }

# Resource sub-command aliases
RESOURCE_SUBCOMMAND_ALIASES = {
  'del':	'delete',
  }

RESOURCE_SUBCOMMANDS_OBJECT_ALIASES = {
  Cmd.ARG_ACL:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_ACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  }

def executeResourceCommands(resourceEntity):
  CL_subCommand = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS, choiceAliases=RESOURCE_SUBCOMMAND_ALIASES)
  Act.Set(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_ACTION])
  CL_objectName = getChoice(RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION], choiceAliases=RESOURCE_SUBCOMMANDS_OBJECT_ALIASES)
  RESOURCE_SUBCOMMANDS_WITH_OBJECTS[CL_subCommand][CMD_FUNCTION][CL_objectName](resourceEntity)

def processResourceCommands():
  executeResourceCommands(getStringReturnInList(Cmd.OB_RESOURCE_ID))

def processResourcesCommands():
  executeResourceCommands(getEntityList(Cmd.OB_RESOURCE_ENTITY))

# Commands
COMMANDS_MAP = {
  'oauth':	processOauthCommands,
  'audit':	processAuditCommands,
  'calendars':	processCalendarsCommands,
  'course':	processCourseCommands,
  'courses':	processCoursesCommands,
  'printers':	processPrintersCommands,
  'printjobs':	processPrintjobsCommands,
  'resource':	processResourceCommands,
  'resources':	processResourcesCommands,
  }

# Commands aliases
COMMANDS_ALIASES = {
  'oauth2':	'oauth',
  'calendar':	'calendars',
  'printer':	'printers',
  'printjob':	'printjobs',
  }

# <CrOSTypeEntity> commands
CROS_COMMANDS = {
  'info': (Act.INFO, infoCrOSDevices),
  'list': (Act.LIST, doListCrOS),
  'print': (Act.PRINT, doPrintCrOSEntity),
  'update': (Act.UPDATE, updateCrOSDevices),
  }

CROS_COMMANDS_WITH_OBJECTS = {
  'get': (Act.DOWNLOAD, {Cmd.ARG_DEVICEFILE: getCrOSDeviceFiles}),
  }

CROS_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_DEVICEFILES:	Cmd.ARG_DEVICEFILE,
  }

# <UserTypeEntity> commands
USER_COMMANDS = {
  'delegate': (Act.ADD, delegateTo),
  'deprovision':(Act.DEPROVISION, deprovisionUser),
  'draftemail': (Act.DRAFT, draftMessage),
  'filter': (Act.ADD, createFilter),
  'forward': (Act.SET, setForward),
  'imap': (Act.SET, setImap),
  'importemail': (Act.IMPORT, importMessage),
  'insertemail': (Act.INSERT, insertMessage),
  'label': (Act.ADD, createLabel),
  'list': (Act.LIST, doListUser),
  'language': (Act.SET, setLanguage),
  'pop': (Act.SET, setPop),
  'printers': (Act.PROCESS, processPrintersCommands),
  'printjobs': (Act.PROCESS, processPrintjobsCommands),
  'profile': (Act.SET, setProfile),
  'sendas': (Act.ADD, createUpdateSendAs),
  'sendemail': (Act.SENDEMAIL, doSendEmail),
  'signature': (Act.SET, setSignature),
  'signout': (Act.SIGNOUT, signoutTurnoff2SVUsers),
  'turnoff2sv': (Act.TURNOFF2SV, signoutTurnoff2SVUsers),
  'vacation': (Act.SET, setVacation),
  }

# User commands with objects
#
USER_ADD_CREATE_FUNCTIONS = {
  Cmd.ARG_CALENDAR:	addCreateCalendars,
  Cmd.ARG_GROUP:	addUserToGroups,
  Cmd.ARG_CALENDARACL:	createCalendarACLs,
  Cmd.ARG_CLASSROOMINVITATION:	createClassroomInvitations,
  Cmd.ARG_CONTACT:	createUserContact,
  Cmd.ARG_CONTACTGROUP:	createUserContactGroup,
  Cmd.ARG_DELEGATE:	createDelegate,
  Cmd.ARG_DRIVEFILE:	createDriveFile,
  Cmd.ARG_DRIVEFILEACL:	createDriveFileACL,
  Cmd.ARG_DRIVEFILESHORTCUT:	createDriveFileShortcut,
  Cmd.ARG_EVENT:	createCalendarEvent,
  Cmd.ARG_FILTER:	createFilter,
  Cmd.ARG_FORWARDINGADDRESS:	createForwardingAddresses,
  Cmd.ARG_GUARDIAN: 	inviteGuardians,
  Cmd.ARG_GUARDIANINVITATION: 	inviteGuardians,
  Cmd.ARG_LABEL:	createLabel,
  Cmd.ARG_LICENSE:	createLicense,
  Cmd.ARG_PERMISSION:	createDriveFilePermissions,
  Cmd.ARG_SENDAS:	createUpdateSendAs,
  Cmd.ARG_SHEET:	createSheet,
  Cmd.ARG_SITE:		createUserSite,
  Cmd.ARG_SITEACL:	processUserSiteACLs,
  Cmd.ARG_SMIME:	createSmime,
  Cmd.ARG_TEAMDRIVE:	createTeamDrive,
  }

USER_COMMANDS_WITH_OBJECTS = {
  'accept': (Act.ACCEPT, {Cmd.ARG_CLASSROOMINVITATION:	acceptClassroomInvitations}),
  'add': (Act.ADD, USER_ADD_CREATE_FUNCTIONS),
  'append': (Act.APPEND, {Cmd.ARG_SHEETRANGE: appendSheetRanges}),
  'archive': (Act.ARCHIVE, {Cmd.ARG_MESSAGE: archiveMessages}),
  'cancel': (Act.CANCEL, {Cmd.ARG_GUARDIANINVITATION: cancelGuardianInvitations}),
  'check': (Act.CHECK, {Cmd.ARG_DRIVEFILESHORTCUT: checkDriveFileShortcut, Cmd.ARG_SERVICEACCOUNT: checkServiceAccount}),
  'claim': (Act.CLAIM, {Cmd.ARG_OWNERSHIP: claimOwnership}),
  'clear': (Act.CLEAR, {Cmd.ARG_CONTACT: clearUserContacts, Cmd.ARG_GUARDIAN: clearGuardians, Cmd.ARG_SHEETRANGE: clearSheetRanges}),
  'collect': (Act.COLLECT, {Cmd.ARG_ORPHANS: collectOrphans}),
  'copy': (Act.COPY, {Cmd.ARG_DRIVEFILE: copyDriveFile}),
  'create': (Act.CREATE, USER_ADD_CREATE_FUNCTIONS),
  'dedup': (Act.DEDUP, {Cmd.ARG_CONTACT: dedupUserContacts}),
  'delete':
    (Act.DELETE,
     {Cmd.ARG_ALIAS:		deleteUsersAliases,
      Cmd.ARG_ASP:		deleteASP,
      Cmd.ARG_BACKUPCODE:	deleteBackupCodes,
      Cmd.ARG_CALENDAR:		deleteCalendars,
      Cmd.ARG_CALENDARACL:	deleteCalendarACLs,
      Cmd.ARG_CLASSROOMINVITATION:	deleteClassroomInvitations,
      Cmd.ARG_CONTACT:		deleteUserContacts,
      Cmd.ARG_CONTACTGROUP:	deleteUserContactGroups,
      Cmd.ARG_CONTACTPHOTO:	deleteUserContactPhoto,
      Cmd.ARG_DELEGATE:		deleteDelegate,
      Cmd.ARG_DRIVEFILE:	deleteDriveFile,
      Cmd.ARG_DRIVEFILEACL:	deleteDriveFileACLs,
      Cmd.ARG_EMPTYDRIVEFOLDERS:	deleteEmptyDriveFolders,
      Cmd.ARG_EVENT:		deleteCalendarEvents,
      Cmd.ARG_FILEREVISION:	deleteFileRevisions,
      Cmd.ARG_FILTER:		deleteFilters,
      Cmd.ARG_FORWARDINGADDRESS:	deleteForwardingAddresses,
      Cmd.ARG_GROUP:		deleteUserFromGroups,
      Cmd.ARG_GUARDIAN: 	deleteGuardians,
      Cmd.ARG_LABEL:		deleteLabel,
      Cmd.ARG_LICENSE:		deleteLicense,
      Cmd.ARG_MESSAGE:		processMessages,
      Cmd.ARG_PERMISSION:	deletePermissions,
      Cmd.ARG_PHOTO:		deletePhoto,
      Cmd.ARG_PRINTER:		deletePrinters,
      Cmd.ARG_SENDAS:		deleteInfoSendAs,
      Cmd.ARG_SMIME:		deleteSmime,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	deleteTeamDrive,
      Cmd.ARG_THREAD:		processThreads,
      Cmd.ARG_TOKEN:		deleteTokens,
      Cmd.ARG_USER:		deleteUsers,
     }
    ),
  'draft': (Act.DRAFT, {Cmd.ARG_MESSAGE: draftMessage}),
  'empty': (Act.EMPTY, {Cmd.ARG_CALENDARTRASH: emptyCalendarTrash, Cmd.ARG_DRIVETRASH: emptyDriveTrash}),
  'get':
    (Act.DOWNLOAD,
     {Cmd.ARG_CONTACTPHOTO: getUserContactPhoto,
      Cmd.ARG_DRIVEFILE: getDriveFile,
      Cmd.ARG_PHOTO: getUserPhoto,
      Cmd.ARG_PROFILE_PHOTO: getProfilePhoto
     }
    ),
  'hide': (Act.HIDE, {Cmd.ARG_TEAMDRIVE: hideUnhideTeamDrive}),
  'import': (Act.IMPORT, {Cmd.ARG_EVENT: importCalendarEvent, Cmd.ARG_MESSAGE: importMessage}),
  'info':
    (Act.INFO,
     {Cmd.ARG_CALENDAR:		infoCalendars,
      Cmd.ARG_CALENDARACL:	infoCalendarACLs,
      Cmd.ARG_CONTACT:		infoUserContacts,
      Cmd.ARG_CONTACTGROUP:	infoUserContactGroups,
      Cmd.ARG_DRIVEFILE:	showFileInfo,
      Cmd.ARG_DRIVEFILEACL:	infoDriveFileACLs,
      Cmd.ARG_EVENT:		infoCalendarEvents,
      Cmd.ARG_FILTER:		infoFilters,
      Cmd.ARG_FORWARDINGADDRESS:	infoForwardingAddresses,
      Cmd.ARG_GROUPMEMBERS:	infoGroupMembers,
      Cmd.ARG_PRINTER:		infoPrinters,
      Cmd.ARG_SENDAS:		deleteInfoSendAs,
      Cmd.ARG_SHEET:		infoPrintShowSheets,
      Cmd.ARG_SITE:		infoUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	infoTeamDrive,
      Cmd.ARG_USER:		infoUsers,
     }
    ),
  'insert': (Act.INSERT, {Cmd.ARG_MESSAGE: insertMessage}),
  'modify': (Act.MODIFY, {Cmd.ARG_CALENDAR: modifyCalendars, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  'move': (Act.MOVE, {Cmd.ARG_DRIVEFILE: moveDriveFile, Cmd.ARG_EVENT: moveCalendarEvents}),
  'purge': (Act.PURGE, {Cmd.ARG_DRIVEFILE: purgeDriveFile, Cmd.ARG_EVENT: purgeCalendarEvents}),
  'print':
    (Act.PRINT,
     {Cmd.ARG_ASP:		printShowASPs,
      Cmd.ARG_BACKUPCODE:	printShowBackupCodes,
      Cmd.ARG_CALENDAR:		printShowCalendars,
      Cmd.ARG_CALENDARACL:	printShowCalendarACLs,
      Cmd.ARG_CALSETTINGS:	printShowCalSettings,
      Cmd.ARG_CLASSROOMINVITATION:	printShowClassroomInvitations,
      Cmd.ARG_CLASSROOMPROFILE:	printShowClassroomProfile,
      Cmd.ARG_CONTACT:		printShowUserContacts,
      Cmd.ARG_CONTACTGROUP:	printShowUserContactGroups,
      Cmd.ARG_DELEGATE:		printShowDelegates,
      Cmd.ARG_DRIVEACTIVITY:	printDriveActivity,
      Cmd.ARG_DRIVEFILEACL:	printShowDriveFileACLs,
      Cmd.ARG_DRIVESETTINGS:	printShowDriveSettings,
      Cmd.ARG_EVENT:		printShowCalendarEvents,
      Cmd.ARG_FILECOUNT:	printShowFileCounts,
      Cmd.ARG_FILEINFO:		showFileInfo,
      Cmd.ARG_FILELIST:		printFileList,
      Cmd.ARG_FILEPATH:		printShowFilePaths,
      Cmd.ARG_FILEREVISION:	printShowFileRevisions,
      Cmd.ARG_FILETREE:		printShowFileTree,
      Cmd.ARG_FILTER:		printShowFilters,
      Cmd.ARG_FORWARD:		printShowForward,
      Cmd.ARG_FORWARDINGADDRESS:	printShowForwardingAddresses,
      Cmd.ARG_GMAILPROFILE:	printShowGmailProfile,
      Cmd.ARG_GROUP:		printShowUserGroups,
      Cmd.ARG_GROUPSLIST:	printUserGroupsList,
      Cmd.ARG_GUARDIAN: 	printShowGuardians,
      Cmd.ARG_LABEL:		printShowLabels,
      Cmd.ARG_MESSAGE:		printShowMessages,
      Cmd.ARG_PEOPLEPROFILE:	printShowPeopleProfile,
      Cmd.ARG_PRINTER:		printShowPrinters,
      Cmd.ARG_PRINTJOBS:	printPrintJobs,
      Cmd.ARG_SENDAS:		printShowSendAs,
      Cmd.ARG_SHEET:		infoPrintShowSheets,
      Cmd.ARG_SHEETRANGE:	printShowSheetRanges,
      Cmd.ARG_SIGNATURE:	printShowSendAs,
      Cmd.ARG_SMIME:		printShowSmimes,
      Cmd.ARG_SITE:		printShowUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_SITEACTIVITY:	printUserSiteActivity,
      Cmd.ARG_TEAMDRIVE:	printShowTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	printShowTeamDriveACLs,
      Cmd.ARG_THREAD:		printShowThreads,
      Cmd.ARG_TOKEN:		printShowTokens,
      Cmd.ARG_USER:		doPrintUserEntity,
      Cmd.ARG_VACATION:		printShowVacation,
     }
    ),
  'register': (Act.REGISTER, {Cmd.ARG_PRINTER: registerPrinter}),
  'remove': (Act.REMOVE, {Cmd.ARG_CALENDAR: removeCalendars}),
  'show':
    (Act.SHOW,
     {Cmd.ARG_ASP:		printShowASPs,
      Cmd.ARG_BACKUPCODE:	printShowBackupCodes,
      Cmd.ARG_CALENDAR:		printShowCalendars,
      Cmd.ARG_CALENDARACL:	printShowCalendarACLs,
      Cmd.ARG_CALSETTINGS:	printShowCalSettings,
      Cmd.ARG_CLASSROOMINVITATION:	printShowClassroomInvitations,
      Cmd.ARG_CLASSROOMPROFILE:	printShowClassroomProfile,
      Cmd.ARG_CONTACT:		printShowUserContacts,
      Cmd.ARG_CONTACTGROUP:	printShowUserContactGroups,
      Cmd.ARG_DELEGATE:		printShowDelegates,
      Cmd.ARG_DRIVEACTIVITY:	printDriveActivity,
      Cmd.ARG_DRIVEFILEACL:	printShowDriveFileACLs,
      Cmd.ARG_DRIVESETTINGS:	printShowDriveSettings,
      Cmd.ARG_EVENT:		printShowCalendarEvents,
      Cmd.ARG_FILECOUNT:	printShowFileCounts,
      Cmd.ARG_FILEINFO:		showFileInfo,
      Cmd.ARG_FILELIST:		printFileList,
      Cmd.ARG_FILEPATH:		printShowFilePaths,
      Cmd.ARG_FILEREVISION:	printShowFileRevisions,
      Cmd.ARG_FILETREE:		printShowFileTree,
      Cmd.ARG_FILTER:		printShowFilters,
      Cmd.ARG_FORWARD:		printShowForward,
      Cmd.ARG_FORWARDINGADDRESS:	printShowForwardingAddresses,
      Cmd.ARG_GMAILPROFILE:	printShowGmailProfile,
      Cmd.ARG_GROUP:		printShowUserGroups,
      Cmd.ARG_GUARDIAN: 	printShowGuardians,
      Cmd.ARG_IMAP:		showImap,
      Cmd.ARG_LABEL:		printShowLabels,
      Cmd.ARG_LANGUAGE:		showLanguage,
      Cmd.ARG_MESSAGE:		printShowMessages,
      Cmd.ARG_PEOPLEPROFILE:	printShowPeopleProfile,
      Cmd.ARG_POP:		showPop,
      Cmd.ARG_PRINTER:		printShowPrinters,
      Cmd.ARG_PROFILE:		showProfile,
      Cmd.ARG_SENDAS:		printShowSendAs,
      Cmd.ARG_SHEET:		infoPrintShowSheets,
      Cmd.ARG_SHEETRANGE:	printShowSheetRanges,
      Cmd.ARG_SIGNATURE:	showSignature,
      Cmd.ARG_SITE:		printShowUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_SMIME:		printShowSmimes,
      Cmd.ARG_TEAMDRIVE:	printShowTeamDrives,
      Cmd.ARG_TEAMDRIVEACLS:	printShowTeamDriveACLs,
      Cmd.ARG_TEAMDRIVEINFO:	infoTeamDrive,
      Cmd.ARG_TEAMDRIVETHEMES:	showTeamDriveThemes,
      Cmd.ARG_THREAD:		printShowThreads,
      Cmd.ARG_TOKEN:		printShowTokens,
      Cmd.ARG_VACATION:		printShowVacation,
     }
    ),
  'spam': (Act.SPAM, {Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  'suspend': (Act.SUSPEND, {Cmd.ARG_USER: suspendUsers}),
  'sync': (Act.SYNC, {Cmd.ARG_GROUP: syncUserWithGroups, Cmd.ARG_GUARDIAN: syncGuardians}),
  'transfer': (Act.TRANSFER, {Cmd.ARG_DRIVE: transferDrive, Cmd.ARG_CALENDAR: transferCalendars, Cmd.ARG_OWNERSHIP: transferOwnership}),
  'trash': (Act.TRASH, {Cmd.ARG_DRIVEFILE: trashDriveFile, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  'undelete': (Act.UNDELETE, {Cmd.ARG_USER: undeleteUsers}),
  'unhide': (Act.UNHIDE, {Cmd.ARG_TEAMDRIVE: hideUnhideTeamDrive}),
  'unsuspend': (Act.UNSUSPEND, {Cmd.ARG_USER: unsuspendUsers}),
  'untrash': (Act.UNTRASH, {Cmd.ARG_DRIVEFILE: untrashDriveFile, Cmd.ARG_MESSAGE: processMessages, Cmd.ARG_THREAD: processThreads}),
  'update':
    (Act.UPDATE,
     {Cmd.ARG_BACKUPCODE:	updateBackupCodes,
      Cmd.ARG_CALATTENDEES:	updateCalendarAttendees,
      Cmd.ARG_CALENDAR:		updateCalendars,
      Cmd.ARG_CALENDARACL:	updateCalendarACLs,
      Cmd.ARG_CONTACT:		updateUserContacts,
      Cmd.ARG_CONTACTGROUP:	updateUserContactGroup,
      Cmd.ARG_CONTACTPHOTO:	updateUserContactPhoto,
      Cmd.ARG_DELEGATE:		updateDelegates,
      Cmd.ARG_DRIVEFILE:	updateDriveFile,
      Cmd.ARG_DRIVEFILEACL:	updateDriveFileACLs,
      Cmd.ARG_EVENT:		updateCalendarEvents,
      Cmd.ARG_GROUP:		updateUserGroups,
      Cmd.ARG_LABEL:		updateLabels,
      Cmd.ARG_LABELSETTINGS:	updateLabelSettings,
      Cmd.ARG_LICENSE:		updateLicense,
      Cmd.ARG_PHOTO:		updatePhoto,
      Cmd.ARG_PRINTER:		updatePrinters,
      Cmd.ARG_SENDAS:		createUpdateSendAs,
      Cmd.ARG_SERVICEACCOUNT:	checkServiceAccount,
      Cmd.ARG_SHEET:		updateSheets,
      Cmd.ARG_SHEETRANGE:	updateSheetRanges,
      Cmd.ARG_SMIME:		updateSmime,
      Cmd.ARG_SITE:		updateUserSites,
      Cmd.ARG_SITEACL:		processUserSiteACLs,
      Cmd.ARG_TEAMDRIVE:	updateTeamDrive,
      Cmd.ARG_USER:		updateUsers,
     }
    ),
  'watch': (Act.WATCH, {Cmd.ARG_GMAIL: watchGmail}),
  'wipe': (Act.WIPE, {Cmd.ARG_EVENT: wipeCalendarEvents}),
  }

# User commands aliases
USER_COMMANDS_ALIASES = {
  'del':	'delete',
  'delegates':	'delegate',
  'deprov':	'deprovision',
  'imap4':	'imap',
  'pop3':	'pop',
  'printer':	'printers',
  'printjob':	'printjobs',
  'sig':	'signature',
  'utf':	'unicode',
  'utf-8':	'unicode',
  'utf8':	'unicode',
  }

USER_COMMANDS_OBJ_ALIASES = {
  Cmd.ARG_3LO:		Cmd.ARG_TOKEN,
  Cmd.ARG_ALIASES:	Cmd.ARG_ALIAS,
  Cmd.ARG_APPLICATIONSPECIFICPASSWORDS:	Cmd.ARG_ASP,
  Cmd.ARG_ASPS:		Cmd.ARG_ASP,
  Cmd.ARG_BACKUPCODES:	Cmd.ARG_BACKUPCODE,
  Cmd.ARG_CALENDARS:	Cmd.ARG_CALENDAR,
  Cmd.ARG_CALENDARACLS:	Cmd.ARG_CALENDARACL,
  Cmd.ARG_CLASSROOMINVITATIONS:	Cmd.ARG_CLASSROOMINVITATION,
  Cmd.ARG_CONTACTS:	Cmd.ARG_CONTACT,
  Cmd.ARG_CONTACTGROUPS:	Cmd.ARG_CONTACTGROUP,
  Cmd.ARG_CONTACTPHOTOS:	Cmd.ARG_CONTACTPHOTO,
  Cmd.ARG_DELEGATES:	Cmd.ARG_DELEGATE,
  Cmd.ARG_DRIVEFILEACLS:	Cmd.ARG_DRIVEFILEACL,
  Cmd.ARG_DRIVEFILESHORTCUTS:	Cmd.ARG_DRIVEFILESHORTCUT,
  Cmd.ARG_EVENTS:	Cmd.ARG_EVENT,
  Cmd.ARG_FILECOUNTS:	Cmd.ARG_FILECOUNT,
  Cmd.ARG_FILEPATHS:	Cmd.ARG_FILEPATH,
  Cmd.ARG_FILEREVISIONS:	Cmd.ARG_FILEREVISION,
  Cmd.ARG_FILTERS:	Cmd.ARG_FILTER,
  Cmd.ARG_FORWARDS:	Cmd.ARG_FORWARD,
  Cmd.ARG_FORWARDINGADDRESSES:	Cmd.ARG_FORWARDINGADDRESS,
  Cmd.ARG_GROUPS:	Cmd.ARG_GROUP,
  Cmd.ARG_GROUPLIST:	Cmd.ARG_GROUPSLIST,
  Cmd.ARG_GROUPSMEMBERS:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_GUARDIANINVITATIONS:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_GUARDIANINVITE:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_GUARDIANS:	Cmd.ARG_GUARDIAN,
  Cmd.ARG_IMAP4:	Cmd.ARG_IMAP,
  Cmd.ARG_INVITEGUARDIAN:	Cmd.ARG_GUARDIANINVITATION,
  Cmd.ARG_LABELS:	Cmd.ARG_LABEL,
  Cmd.ARG_LICENCE:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENCES:	Cmd.ARG_LICENSE,
  Cmd.ARG_LICENSES:	Cmd.ARG_LICENSE,
  Cmd.ARG_MEMBER:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_MEMBERS:	Cmd.ARG_GROUPMEMBERS,
  Cmd.ARG_MESSAGES:	Cmd.ARG_MESSAGE,
  Cmd.ARG_OAUTH:	Cmd.ARG_TOKEN,
  Cmd.ARG_PERMISSIONS:	Cmd.ARG_PERMISSION,
  Cmd.ARG_POP3:		Cmd.ARG_POP,
  Cmd.ARG_PRINTERS:	Cmd.ARG_PRINTER,
  Cmd.ARG_SECCALS:	Cmd.ARG_CALENDAR,
  Cmd.ARG_SHAREDDRIVE:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_SHAREDDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_SHAREDDRIVEACLS:	Cmd.ARG_TEAMDRIVEACLS,
  Cmd.ARG_SHAREDDRIVEINFO:	Cmd.ARG_TEAMDRIVEINFO,
  Cmd.ARG_SHAREDDRIVETHEMES:	Cmd.ARG_TEAMDRIVETHEMES,
  Cmd.ARG_SHEETS:	Cmd.ARG_SHEET,
  Cmd.ARG_SHEETRANGES:	Cmd.ARG_SHEETRANGE,
  Cmd.ARG_SIG:		Cmd.ARG_SIGNATURE,
  Cmd.ARG_SITES:	Cmd.ARG_SITE,
  Cmd.ARG_SITEACLS:	Cmd.ARG_SITEACL,
  Cmd.ARG_SMIMES:	Cmd.ARG_SMIME,
  Cmd.ARG_TEAMDRIVES:	Cmd.ARG_TEAMDRIVE,
  Cmd.ARG_THREADS:	Cmd.ARG_THREAD,
  Cmd.ARG_TOKENS:	Cmd.ARG_TOKEN,
  Cmd.ARG_USERS:	Cmd.ARG_USER,
  Cmd.ARG_VERIFICATIONCODES:	Cmd.ARG_BACKUPCODE,
  }

def showAPICallsRetryData():
  if GC.Values.get(GC.SHOW_API_CALLS_RETRY_DATA) and GM.Globals[GM.API_CALLS_RETRY_DATA]:
    Ind.Reset()
    writeStderr(Msg.API_CALLS_RETRY_DATA)
    Ind.Increment()
    for k, v in sorted(iter(GM.Globals[GM.API_CALLS_RETRY_DATA].items())):
      m, s = divmod(int(v[1]), 60)
      h, m = divmod(m, 60)
      writeStderr(formatKeyValueList(Ind.Spaces(), [k, f'{v[0]}/{h}:{m:02d}:{s:02d}'], '\n'))
    Ind.Decrement()

def adjustRedirectedSTDFilesIfNotMultiprocessing():
  def adjustRedirectedSTDFile(stdtype):
    rdFd = GM.Globals[stdtype].get(GM.REDIRECT_FD)
    rdMultiFd = GM.Globals[stdtype].get(GM.REDIRECT_MULTI_FD)
    if rdFd and rdMultiFd and rdFd != rdMultiFd:
      try:
        rdFd.write(rdMultiFd.getvalue())
        rdMultiFd.close()
        GM.Globals[stdtype][GM.REDIRECT_MULTI_FD] = rdFd
        if (stdtype == GM.STDOUT) and (GM.Globals.get(GM.SAVED_STDOUT) is not None):
          sys.stdout = rdFd
      except IOError as e:
        systemErrorExit(FILE_ERROR_RC, e)

  adjustRedirectedSTDFile(GM.STDOUT)
  if GM.Globals[GM.STDERR].get(GM.REDIRECT_NAME) != 'stdout':
    adjustRedirectedSTDFile(GM.STDERR)
  else:
    GM.Globals[GM.STDERR][GM.REDIRECT_MULTI_FD] = GM.Globals[GM.STDOUT][GM.REDIRECT_MULTI_FD]

def closeSTDFilesIfNotMultiprocessing():
  def closeSTDFile(stdtype, stdfile):
    rdFd = GM.Globals[stdtype].get(GM.REDIRECT_FD)
    rdMultiFd = GM.Globals[stdtype].get(GM.REDIRECT_MULTI_FD)
    if rdFd and rdMultiFd and (rdFd == rdMultiFd) and (rdFd != stdfile):
      rdFd.flush()
      rdFd.close()

  closeSTDFile(GM.STDOUT, sys.stdout)
  if GM.Globals[GM.STDERR].get(GM.REDIRECT_NAME) != 'stdout':
    closeSTDFile(GM.STDERR, sys.stderr)

# Process GAM command
def ProcessGAMCommand(args, processGamCfg=True, inLoop=False):
  setSysExitRC(0)
  Cmd.InitializeArguments(args)
  Ind.Reset()
  try:
    if checkArgumentPresent(Cmd.LOOP_CMD):
      if processGamCfg and (not SetGlobalVariables()):
        sys.exit(GM.Globals[GM.SYSEXITRC])
      doLoop()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if processGamCfg and (not SetGlobalVariables()):
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if checkArgumentPresent(Cmd.LOOP_CMD):
      doLoop()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    if not Cmd.ArgumentsRemaining():
      doUsage()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(BATCH_CSV_COMMANDS, defaultChoice=None)
    if CL_command:
      Act.Set(BATCH_CSV_COMMANDS[CL_command][CMD_ACTION])
      BATCH_CSV_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Act.Set(MAIN_COMMANDS[CL_command][CMD_ACTION])
      MAIN_COMMANDS[CL_command][CMD_FUNCTION]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(MAIN_COMMANDS_WITH_OBJECTS, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      Act.Set(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
      CL_objectName = getChoice(MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=MAIN_COMMANDS_OBJ_ALIASES)
      MAIN_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    CL_command = getChoice(COMMANDS_MAP, choiceAliases=COMMANDS_ALIASES, defaultChoice=None)
    if CL_command:
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      COMMANDS_MAP[CL_command]()
      sys.exit(GM.Globals[GM.SYSEXITRC])
    GM.Globals[GM.ENTITY_CL_START] = Cmd.Location()
    entityType, entityList = getEntityToModify(crosAllowed=True, delayGet=True)
    if entityType == Cmd.ENTITY_USERS:
      CL_command = getChoice(list(USER_COMMANDS)+list(USER_COMMANDS_WITH_OBJECTS), choiceAliases=USER_COMMANDS_ALIASES)
      if (CL_command != 'list') and (GC.Values[GC.AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC.Values[GC.AUTO_BATCH_MIN]:
          doAutoBatch(Cmd.ENTITY_USER, entityList, CL_command)
          sys.exit(GM.Globals[GM.SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      if CL_command in USER_COMMANDS:
        Act.Set(USER_COMMANDS[CL_command][CMD_ACTION])
        USER_COMMANDS[CL_command][CMD_FUNCTION](entityList)
      else:
        Act.Set(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
        CL_objectName = getChoice(USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=USER_COMMANDS_OBJ_ALIASES,
                                  defaultChoice=[Cmd.ARG_USER, NO_DEFAULT][CL_command != 'print'])
        USER_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName](entityList)
    else:
      CL_command = getChoice(list(CROS_COMMANDS)+list(CROS_COMMANDS_WITH_OBJECTS))
      if (CL_command != 'list') and (GC.Values[GC.AUTO_BATCH_MIN] > 0):
        _, count, entityList = getEntityArgument(entityList)
        if count > GC.Values[GC.AUTO_BATCH_MIN]:
          doAutoBatch(Cmd.ENTITY_CROS, entityList, CL_command)
          sys.exit(GM.Globals[GM.SYSEXITRC])
      adjustRedirectedSTDFilesIfNotMultiprocessing()
      if CL_command in CROS_COMMANDS:
        Act.Set(CROS_COMMANDS[CL_command][CMD_ACTION])
        CROS_COMMANDS[CL_command][CMD_FUNCTION](entityList)
      else:
        Act.Set(CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_ACTION])
        CL_objectName = getChoice(CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION], choiceAliases=CROS_COMMANDS_OBJ_ALIASES,
                                  defaultChoice=NO_DEFAULT)
        CROS_COMMANDS_WITH_OBJECTS[CL_command][CMD_FUNCTION][CL_objectName](entityList)
    sys.exit(GM.Globals[GM.SYSEXITRC])
  except KeyboardInterrupt:
    setSysExitRC(KEYBOARD_INTERRUPT_RC)
    showAPICallsRetryData()
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except OSError as e:
    printErrorMessage(SOCKET_ERROR_RC, str(e))
    showAPICallsRetryData()
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except MemoryError:
    printErrorMessage(MEMORY_ERROR_RC, Msg.GAM_OUT_OF_MEMORY)
    showAPICallsRetryData()
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  except SystemExit as e:
    GM.Globals[GM.SYSEXITRC] = e.code
    if not inLoop:
      showAPICallsRetryData()
      try:
        adjustRedirectedSTDFilesIfNotMultiprocessing()
      except SystemExit:
        pass
  except Exception:
    print_exc(file=sys.stderr)
    setSysExitRC(UNKNOWN_ERROR_RC)
    showAPICallsRetryData()
    adjustRedirectedSTDFilesIfNotMultiprocessing()
  if processGamCfg:
    if not inLoop:
      if GM.Globals.get(GM.SAVED_STDOUT) is not None:
        sys.stdout = GM.Globals[GM.SAVED_STDOUT]
      closeSTDFilesIfNotMultiprocessing()
  return GM.Globals[GM.SYSEXITRC]

# gam loop <FileName>|-|(gsheet <UserGoogleSheet>) [charset <String>] [warnifnodata]
#	[columndelimiter <Character>] [quotechar <Character>] [fields <FieldNameList>]
#	(matchfield|skipfield <FieldName> <RegularExpression>)* gam <GAM argument list>
def doLoop():
  filename = getString(Cmd.OB_FILE_NAME)
  if (filename == '-') and (GC.Values[GC.DEBUG_LEVEL] > 0):
    Cmd.Backup()
    usageErrorExit(Msg.BATCH_CSV_LOOP_DASH_DEBUG_INCOMPATIBLE.format(Cmd.LOOP_CMD))
  f, csvFile, fieldnames = openCSVFileReader(filename)
  matchFields, skipFields = getMatchSkipFields(fieldnames)
  checkArgumentPresent(Cmd.GAM_CMD, required=True)
  if not Cmd.ArgumentsRemaining():
    missingArgumentExit(Cmd.OB_GAM_ARGUMENT_LIST)
  choice = Cmd.Current().strip().lower()
  if choice == Cmd.LOOP_CMD:
    usageErrorExit(Msg.NESTED_LOOP_CMD_NOT_ALLOWED)
# gam loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam redirect|select|config ... loop ... gam redirect|select|config ... process gam.cfg on each iteration
# gam loop ... gam !redirect|select|config ... no further processing of gam.cfg
# gam redirect|select|config ... loop ... gam !redirect|select|config ... no further processing of gam.cfg
  processGamCfg = choice in Cmd.GAM_META_COMMANDS
  GAM_argv, subFields = getSubFields([Cmd.GAM_CMD], fieldnames)
  multi = GM.Globals[GM.CSVFILE][GM.REDIRECT_MULTIPROCESS]
  if multi:
    mpQueue, mpQueueHandler = initializeCSVFileQueueHandler(None, None)
  else:
    mpQueue = None
  GM.Globals[GM.CSVFILE][GM.REDIRECT_QUEUE] = mpQueue
  for row in csvFile:
    if checkMatchSkipFields(row, matchFields, skipFields):
      ProcessGAMCommand(processSubFields(GAM_argv, row, subFields), processGamCfg=processGamCfg, inLoop=True)
      if (GM.Globals[GM.SYSEXITRC] > 0) and (GM.Globals[GM.SYSEXITRC] <= HARD_ERROR_RC):
        break
  closeFile(f)
  if multi:
    terminateCSVFileQueueHandler(mpQueue, mpQueueHandler)

# Run from command line
if __name__ == "__main__":
  if sys.platform.startswith('win'):
    multiprocessing.freeze_support()
  if sys.platform == 'darwin':
    # https://bugs.python.org/issue33725 in Python 3.8.0 seems
    # to break parallel operations with errors about extra -b
    # command line arguments
    multiprocessing.set_start_method('fork')
  initializeLogging()
  rc = ProcessGAMCommand(sys.argv)
  try:
    sys.stdout.flush()
  except (IOError, ValueError):
    pass
  sys.exit(rc)
